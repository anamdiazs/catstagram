/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/page";
exports.ids = ["app/page"];
exports.modules = {

/***/ "next/dist/compiled/anser":
/*!*******************************************!*\
  !*** external "next/dist/compiled/anser" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/anser");

/***/ }),

/***/ "next/dist/compiled/css.escape":
/*!************************************************!*\
  !*** external "next/dist/compiled/css.escape" ***!
  \************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/css.escape");

/***/ }),

/***/ "next/dist/compiled/platform":
/*!**********************************************!*\
  !*** external "next/dist/compiled/platform" ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/platform");

/***/ }),

/***/ "react":
/*!*******************************************!*\
  !*** external "next/dist/compiled/react" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react");

/***/ }),

/***/ "react-dom":
/*!*********************************************************************!*\
  !*** external "next/dist/compiled/react-dom/server-rendering-stub" ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-dom/server-rendering-stub");

/***/ }),

/***/ "next/dist/compiled/react-server-dom-webpack/client":
/*!*********************************************************************!*\
  !*** external "next/dist/compiled/react-server-dom-webpack/client" ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-server-dom-webpack/client");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!***********************************************************!*\
  !*** external "next/dist/compiled/react/jsx-dev-runtime" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react/jsx-dev-runtime");

/***/ }),

/***/ "next/dist/compiled/stacktrace-parser":
/*!*******************************************************!*\
  !*** external "next/dist/compiled/stacktrace-parser" ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/stacktrace-parser");

/***/ }),

/***/ "next/dist/compiled/strip-ansi":
/*!************************************************!*\
  !*** external "next/dist/compiled/strip-ansi" ***!
  \************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/strip-ansi");

/***/ }),

/***/ "./amp-context":
/*!******************************************************!*\
  !*** external "next/dist/shared/lib/amp-context.js" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/amp-context.js");

/***/ }),

/***/ "./amp-mode":
/*!***************************************************!*\
  !*** external "next/dist/shared/lib/amp-mode.js" ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/amp-mode.js");

/***/ }),

/***/ "../../shared/lib/app-router-context":
/*!*************************************************************!*\
  !*** external "next/dist/shared/lib/app-router-context.js" ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context.js");

/***/ }),

/***/ "./head-manager-context":
/*!***************************************************************!*\
  !*** external "next/dist/shared/lib/head-manager-context.js" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/head-manager-context.js");

/***/ }),

/***/ "../../shared/lib/hooks-client-context":
/*!***************************************************************!*\
  !*** external "next/dist/shared/lib/hooks-client-context.js" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hooks-client-context.js");

/***/ }),

/***/ "../shared/lib/image-blur-svg":
/*!*********************************************************!*\
  !*** external "next/dist/shared/lib/image-blur-svg.js" ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-blur-svg.js");

/***/ }),

/***/ "../shared/lib/image-config-context":
/*!***************************************************************!*\
  !*** external "next/dist/shared/lib/image-config-context.js" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config-context.js");

/***/ }),

/***/ "../shared/lib/image-config":
/*!*******************************************************!*\
  !*** external "next/dist/shared/lib/image-config.js" ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config.js");

/***/ }),

/***/ "next/dist/shared/lib/image-loader":
/*!****************************************************!*\
  !*** external "next/dist/shared/lib/image-loader" ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-loader");

/***/ }),

/***/ "../shared/lib/router/utils/add-path-prefix":
/*!***********************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/add-path-prefix.js" ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix.js");

/***/ }),

/***/ "../../shared/lib/router/utils/handle-smooth-scroll":
/*!****************************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/handle-smooth-scroll.js" ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/handle-smooth-scroll.js");

/***/ }),

/***/ "../../shared/lib/router/utils/is-bot":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/is-bot.js" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot.js");

/***/ }),

/***/ "../shared/lib/router/utils/parse-path":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/parse-path.js" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path.js");

/***/ }),

/***/ "../shared/lib/router/utils/remove-trailing-slash":
/*!*****************************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/remove-trailing-slash.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash.js");

/***/ }),

/***/ "../../shared/lib/server-inserted-html":
/*!***************************************************************!*\
  !*** external "next/dist/shared/lib/server-inserted-html.js" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/server-inserted-html.js");

/***/ }),

/***/ "./side-effect":
/*!******************************************************!*\
  !*** external "next/dist/shared/lib/side-effect.js" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/side-effect.js");

/***/ }),

/***/ "./utils/warn-once":
/*!**********************************************************!*\
  !*** external "next/dist/shared/lib/utils/warn-once.js" ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils/warn-once.js");

/***/ }),

/***/ "(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js":
/*!**************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_async_to_generator.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _asyncToGenerator;\n    }\n}));\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzPzQyYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/@swc/helpers/lib/_extends.js":
/*!***************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_extends.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _extends;\n    }\n}));\nfunction extends_() {\n    extends_ = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return extends_.apply(this, arguments);\n}\nfunction _extends() {\n    return extends_.apply(this, arguments);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanM/OTE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZXh0ZW5kc18oKSB7XG4gICAgZXh0ZW5kc18gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kc18uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIHJldHVybiBleHRlbmRzXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_interop_require_default.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _interopRequireDefault;\n    }\n}));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qcz82ZjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js":
/*!********************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_interop_require_wildcard.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _interopRequireWildcard;\n    }\n}));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzP2FkMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgICAgICByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7XG4gICAgfSkobm9kZUludGVyb3ApO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkge1xuICAgIGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApO1xuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gICAgfVxuICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@swc/helpers/lib/_object_without_properties_loose.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _objectWithoutPropertiesLoose;\n    }\n}));\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9saWIvX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuanM/MmYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fpage&appPaths=%2Fpage&pagePath=private-next-app-dir%2Fpage.jsx&appDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram&isDev=true&tsconfigPath=tsconfig.json&assetPrefix=!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fpage&appPaths=%2Fpage&pagePath=private-next-app-dir%2Fpage.jsx&appDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram&isDev=true&tsconfigPath=tsconfig.json&assetPrefix=! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppRouter\": () => (/* reexport default from dynamic */ next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0___default.a),\n/* harmony export */   \"GlobalError\": () => (/* reexport default from dynamic */ next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3___default.a),\n/* harmony export */   \"LayoutRouter\": () => (/* reexport default from dynamic */ next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1___default.a),\n/* harmony export */   \"RenderFromTemplateContext\": () => (/* reexport default from dynamic */ next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2___default.a),\n/* harmony export */   \"__next_app_webpack_require__\": () => (/* binding */ __next_app_webpack_require__),\n/* harmony export */   \"pages\": () => (/* binding */ pages),\n/* harmony export */   \"renderToReadableStream\": () => (/* reexport safe */ next_dist_compiled_react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_7__.renderToReadableStream),\n/* harmony export */   \"requestAsyncStorage\": () => (/* reexport safe */ next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__.requestAsyncStorage),\n/* harmony export */   \"serverHooks\": () => (/* reexport module object */ next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   \"staticGenerationAsyncStorage\": () => (/* reexport safe */ next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__.staticGenerationAsyncStorage),\n/* harmony export */   \"tree\": () => (/* binding */ tree)\n/* harmony export */ });\n/* harmony import */ var next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/client/components/app-router */ \"(sc_server)/./node_modules/next/dist/client/components/app-router.js\");\n/* harmony import */ var next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_app_router__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/client/components/layout-router */ \"(sc_server)/./node_modules/next/dist/client/components/layout-router.js\");\n/* harmony import */ var next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_layout_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/client/components/render-from-template-context */ \"(sc_server)/./node_modules/next/dist/client/components/render-from-template-context.js\");\n/* harmony import */ var next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_render_from_template_context__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/client/components/error-boundary */ \"(sc_server)/./node_modules/next/dist/client/components/error-boundary.js\");\n/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/client/components/static-generation-async-storage */ \"(sc_shared)/./node_modules/next/dist/client/components/static-generation-async-storage.js\");\n/* harmony import */ var next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_static_generation_async_storage__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/client/components/request-async-storage */ \"(sc_server)/./node_modules/next/dist/client/components/request-async-storage.js\");\n/* harmony import */ var next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_request_async_storage__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/client/components/hooks-server-context */ \"(sc_server)/./node_modules/next/dist/client/components/hooks-server-context.js\");\n/* harmony import */ var next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_compiled_react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/server.edge */ \"(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js\");\n\n    const tree = {\n        children: [\n        '',\n        {\n        children: ['', {}, {\n          page: [() => Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.jsx */ \"(sc_server)/./app/page.jsx\")), \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\"],\n          \n        }]\n      },\n        {\n          'layout': [() => Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/layout.js */ \"(sc_server)/./app/layout.js\")), \"/Users/anamdiazs/Documents/GitHub/catstagram/app/layout.js\"],\n          \n        }\n      ]\n      }.children;\n    const pages = [\"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\"];\n\n    \n    \n    \n    \n\n    \n    \n    \n\n    \n\n    \n    const __next_app_webpack_require__ = __webpack_require__\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZwYWdlJmFwcFBhdGhzPSUyRnBhZ2UmcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZwYWdlLmpzeCZhcHBEaXI9JTJGVXNlcnMlMkZhbmFtZGlhenMlMkZEb2N1bWVudHMlMkZHaXRIdWIlMkZjYXRzdGFncmFtJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRmFuYW1kaWF6cyUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRmNhdHN0YWdyYW0maXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZhc3NldFByZWZpeD0hLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLElBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCLDhJQUE4RjtBQUNySDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSwyQkFBMkIsZ0pBQStGO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFXOztBQUVYLElBQWlGO0FBQ2pGLElBQXVGO0FBQ3ZGLElBQW1IO0FBQ25ILElBQXVGOztBQUV2RixJQUE4RztBQUM5RztBQUNBLElBQTJGOztBQUUzRixJQUFtRjs7QUFFbkYsSUFBb0c7QUFDcEcsSUFBVyxxQ0FBcUMsbUJBQW1CO0FBQ25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8/YmZhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBleHBvcnQgY29uc3QgdHJlZSA9IHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgJycsXG4gICAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFsnJywge30sIHtcbiAgICAgICAgICBwYWdlOiBbKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5hbWRpYXpzL0RvY3VtZW50cy9HaXRIdWIvY2F0c3RhZ3JhbS9hcHAvcGFnZS5qc3hcIiksIFwiL1VzZXJzL2FuYW1kaWF6cy9Eb2N1bWVudHMvR2l0SHViL2NhdHN0YWdyYW0vYXBwL3BhZ2UuanN4XCJdLFxuICAgICAgICAgIFxuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICdsYXlvdXQnOiBbKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5hbWRpYXpzL0RvY3VtZW50cy9HaXRIdWIvY2F0c3RhZ3JhbS9hcHAvbGF5b3V0LmpzXCIpLCBcIi9Vc2Vycy9hbmFtZGlhenMvRG9jdW1lbnRzL0dpdEh1Yi9jYXRzdGFncmFtL2FwcC9sYXlvdXQuanNcIl0sXG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICAgIH0uY2hpbGRyZW47XG4gICAgZXhwb3J0IGNvbnN0IHBhZ2VzID0gW1wiL1VzZXJzL2FuYW1kaWF6cy9Eb2N1bWVudHMvR2l0SHViL2NhdHN0YWdyYW0vYXBwL3BhZ2UuanN4XCJdO1xuXG4gICAgZXhwb3J0IHsgZGVmYXVsdCBhcyBBcHBSb3V0ZXIgfSBmcm9tICduZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlcidcbiAgICBleHBvcnQgeyBkZWZhdWx0IGFzIExheW91dFJvdXRlciB9IGZyb20gJ25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyJ1xuICAgIGV4cG9ydCB7IGRlZmF1bHQgYXMgUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCB9IGZyb20gJ25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0J1xuICAgIGV4cG9ydCB7IGRlZmF1bHQgYXMgR2xvYmFsRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5XCJcblxuICAgIGV4cG9ydCB7IHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UgfSBmcm9tICduZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYXN5bmMtc3RvcmFnZSdcbiAgICBcbiAgICBleHBvcnQgeyByZXF1ZXN0QXN5bmNTdG9yYWdlIH0gZnJvbSAnbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlcXVlc3QtYXN5bmMtc3RvcmFnZSdcblxuICAgIGV4cG9ydCAqIGFzIHNlcnZlckhvb2tzIGZyb20gJ25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dCdcblxuICAgIGV4cG9ydCB7IHJlbmRlclRvUmVhZGFibGVTdHJlYW0gfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL3NlcnZlci5lZGdlJ1xuICAgIGV4cG9ydCBjb25zdCBfX25leHRfYXBwX3dlYnBhY2tfcmVxdWlyZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfX1xuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fpage&appPaths=%2Fpage&pagePath=private-next-app-dir%2Fpage.jsx&appDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram&isDev=true&tsconfigPath=tsconfig.json&assetPrefix=!\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FCard.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FDropdown.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FHighlights.jsx&server=true!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FCard.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FDropdown.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FHighlights.jsx&server=true! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/Card.jsx */ \"(sc_client)/./app/components/Card.jsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/Dropdown.jsx */ \"(sc_client)/./app/components/Dropdown.jsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/Highlights.jsx */ \"(sc_client)/./app/components/Highlights.jsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTJGVXNlcnMlMkZhbmFtZGlhenMlMkZEb2N1bWVudHMlMkZHaXRIdWIlMkZjYXRzdGFncmFtJTJGYXBwJTJGY29tcG9uZW50cyUyRkNhcmQuanN4Jm1vZHVsZXM9JTJGVXNlcnMlMkZhbmFtZGlhenMlMkZEb2N1bWVudHMlMkZHaXRIdWIlMkZjYXRzdGFncmFtJTJGYXBwJTJGY29tcG9uZW50cyUyRkRyb3Bkb3duLmpzeCZtb2R1bGVzPSUyRlVzZXJzJTJGYW5hbWRpYXpzJTJGRG9jdW1lbnRzJTJGR2l0SHViJTJGY2F0c3RhZ3JhbSUyRmFwcCUyRmNvbXBvbmVudHMlMkZIaWdobGlnaHRzLmpzeCZzZXJ2ZXI9dHJ1ZSEuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0tBQXlHO0FBQ3pHLDRLQUE2RztBQUM3RyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vP2EzMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5hbWRpYXpzL0RvY3VtZW50cy9HaXRIdWIvY2F0c3RhZ3JhbS9hcHAvY29tcG9uZW50cy9DYXJkLmpzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FuYW1kaWF6cy9Eb2N1bWVudHMvR2l0SHViL2NhdHN0YWdyYW0vYXBwL2NvbXBvbmVudHMvRHJvcGRvd24uanN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5hbWRpYXpzL0RvY3VtZW50cy9HaXRIdWIvY2F0c3RhZ3JhbS9hcHAvY29tcG9uZW50cy9IaWdobGlnaHRzLmpzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FCard.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FDropdown.jsx&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fcomponents%2FHighlights.jsx&server=true!\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fstyles%2Fglobals.css&server=true!":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp%2Fstyles%2Fglobals.css&server=true! ***!
  \**************************************************************************************************************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=true!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=true! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"(sc_client)/./node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(sc_client)/./node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(sc_client)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(sc_client)/./node_modules/next/dist/client/components/error-boundary.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTJGVXNlcnMlMkZhbmFtZGlhenMlMkZEb2N1bWVudHMlMkZHaXRIdWIlMkZjYXRzdGFncmFtJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGYXBwLXJvdXRlci5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGYW5hbWRpYXpzJTJGRG9jdW1lbnRzJTJGR2l0SHViJTJGY2F0c3RhZ3JhbSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmxheW91dC1yb3V0ZXIuanMmbW9kdWxlcz0lMkZVc2VycyUyRmFuYW1kaWF6cyUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRmNhdHN0YWdyYW0lMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJm1vZHVsZXM9JTJGVXNlcnMlMkZhbmFtZGlhenMlMkZEb2N1bWVudHMlMkZHaXRIdWIlMkZjYXRzdGFncmFtJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGZXJyb3ItYm91bmRhcnkuanMmc2VydmVyPXRydWUhLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdPQUF3STtBQUN4SSw4T0FBMkk7QUFDM0ksNFFBQTBKO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8/OGI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hbmFtZGlhenMvRG9jdW1lbnRzL0dpdEh1Yi9jYXRzdGFncmFtL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FuYW1kaWF6cy9Eb2N1bWVudHMvR2l0SHViL2NhdHN0YWdyYW0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5hbWRpYXpzL0RvY3VtZW50cy9HaXRIdWIvY2F0c3RhZ3JhbS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hbmFtZGlhenMvRG9jdW1lbnRzL0dpdEh1Yi9jYXRzdGFncmFtL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=true!\n");

/***/ }),

/***/ "(sc_server)/./app/styles/globals.css":
/*!********************************!*\
  !*** ./app/styles/globals.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"6756fb1058a9\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9hcHAvc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9hcHAvc3R5bGVzL2dsb2JhbHMuY3NzPzNkYWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2NzU2ZmIxMDU4YTlcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./app/styles/globals.css\n");

/***/ }),

/***/ "(sc_server)/./app/components/Card.jsx":
/*!*********************************!*\
  !*** ./app/components/Card.jsx ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* __next_internal_client_entry_do_not_use__ default */ const { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ "(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");
module.exports = createProxy("/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Card.jsx");


/***/ }),

/***/ "(sc_server)/./app/components/Dropdown.jsx":
/*!*************************************!*\
  !*** ./app/components/Dropdown.jsx ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* __next_internal_client_entry_do_not_use__ default */ const { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ "(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");
module.exports = createProxy("/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx");


/***/ }),

/***/ "(sc_server)/./app/components/Highlights.jsx":
/*!***************************************!*\
  !*** ./app/components/Highlights.jsx ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* __next_internal_client_entry_do_not_use__ default */ const { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ "(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");
module.exports = createProxy("/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Highlights.jsx");


/***/ }),

/***/ "(sc_server)/./app/components/Navbar.jsx":
/*!***********************************!*\
  !*** ./app/components/Navbar.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Navbar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(sc_server)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdown */ \"(sc_server)/./app/components/Dropdown.jsx\");\n/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Dropdown__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Navbar(props) {\n    const { breeds  } = props;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: \"w-full h-16 bg-rose-200 p-4 flex items-center z-50 justify-between\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex space-x-4 items-center lg:space-x-10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        className: \"w-10 h-10\",\n                        src: \"https://cdn-icons-png.flaticon.com/512/2865/2865523.png\"\n                    }, void 0, false, {\n                        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Navbar.jsx\",\n                        lineNumber: 9,\n                        columnNumber: 4\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-white text-lg lg:text-xl\",\n                        children: \"Catstagram\"\n                    }, void 0, false, {\n                        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Navbar.jsx\",\n                        lineNumber: 10,\n                        columnNumber: 4\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Navbar.jsx\",\n                lineNumber: 8,\n                columnNumber: 3\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_Dropdown__WEBPACK_IMPORTED_MODULE_1___default()), {\n                breeds: breeds\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Navbar.jsx\",\n                lineNumber: 12,\n                columnNumber: 3\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Navbar.jsx\",\n        lineNumber: 7,\n        columnNumber: 3\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9hcHAvY29tcG9uZW50cy9OYXZiYXIuanN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBR2xCLFNBQVNDLE9BQU9DLEtBQUssRUFBRTtJQUNyQyxNQUFNLEVBQUVDLE9BQU0sRUFBRSxHQUFHRDtJQUNsQixxQkFDQSw4REFBQ0U7UUFBSUMsV0FBVTs7MEJBQ2YsOERBQUNDO2dCQUFJRCxXQUFVOztrQ0FDZCw4REFBQ0U7d0JBQUlGLFdBQVU7d0JBQVlHLEtBQUk7Ozs7OztrQ0FDL0IsOERBQUNDO3dCQUFHSixXQUFVO2tDQUFnQzs7Ozs7Ozs7Ozs7OzBCQUUvQyw4REFBQ0wsa0RBQVFBO2dCQUFDRyxRQUFRQTs7Ozs7Ozs7Ozs7O0FBR3BCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vYXBwL2NvbXBvbmVudHMvTmF2YmFyLmpzeD82MGUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEcm9wZG93biBmcm9tIFwiLi9Ecm9wZG93blwiXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTmF2YmFyKHByb3BzKSB7XG5cdGNvbnN0IHsgYnJlZWRzIH0gPSBwcm9wc1xuICByZXR1cm4gKFxuXHQgPG5hdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC0xNiBiZy1yb3NlLTIwMCBwLTQgZmxleCBpdGVtcy1jZW50ZXIgei01MCBqdXN0aWZ5LWJldHdlZW5cIj5cblx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC00IGl0ZW1zLWNlbnRlciBsZzpzcGFjZS14LTEwXCI+XG5cdFx0XHQ8aW1nIGNsYXNzTmFtZT1cInctMTAgaC0xMFwiIHNyYz1cImh0dHBzOi8vY2RuLWljb25zLXBuZy5mbGF0aWNvbi5jb20vNTEyLzI4NjUvMjg2NTUyMy5wbmdcIi8+XG5cdFx0XHQ8aDEgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSB0ZXh0LWxnIGxnOnRleHQteGxcIj5DYXRzdGFncmFtPC9oMT5cblx0XHQ8L2Rpdj5cblx0XHQ8RHJvcGRvd24gYnJlZWRzPXticmVlZHN9IC8+XG5cdCA8L25hdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkRyb3Bkb3duIiwiTmF2YmFyIiwicHJvcHMiLCJicmVlZHMiLCJuYXYiLCJjbGFzc05hbWUiLCJkaXYiLCJpbWciLCJzcmMiLCJoMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./app/components/Navbar.jsx\n");

/***/ }),

/***/ "(sc_server)/./app/layout.js":
/*!***********************!*\
  !*** ./app/layout.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RootLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(sc_server)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/globals.css */ \"(sc_server)/./app/styles/globals.css\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recoil */ \"(sc_server)/./node_modules/recoil/cjs/index.js\");\n\n\n\nfunction RootLayout({ children  }) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_2__.RecoilRoot, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n            lang: \"en\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/layout.js\",\n                lineNumber: 14,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/layout.js\",\n            lineNumber: 13,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/layout.js\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9hcHAvbGF5b3V0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZCO0FBT1o7QUFFRixTQUFTSyxXQUFXLEVBQUVDLFNBQVEsRUFBRSxFQUFFO0lBQy9DLHFCQUNBLDhEQUFDTiw4Q0FBVUE7a0JBQ1YsNEVBQUNPO1lBQUtDLE1BQUs7c0JBQ1YsNEVBQUNDOzBCQUFNSDs7Ozs7Ozs7Ozs7Ozs7OztBQUlYLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vYXBwL2xheW91dC5qcz82MGU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zdHlsZXMvZ2xvYmFscy5jc3MnXG5pbXBvcnQge1xuXHRSZWNvaWxSb290LFxuXHRhdG9tLFxuXHRzZWxlY3Rvcixcblx0dXNlUmVjb2lsU3RhdGUsXG5cdHVzZVJlY29pbFZhbHVlLFxuIH0gZnJvbSAncmVjb2lsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUm9vdExheW91dCh7IGNoaWxkcmVuIH0pIHtcbiAgcmV0dXJuIChcblx0XHQ8UmVjb2lsUm9vdD5cblx0XHRcdDxodG1sIGxhbmc9XCJlblwiPlxuXHRcdFx0XHQ8Ym9keT57Y2hpbGRyZW59PC9ib2R5PlxuXHRcdFx0PC9odG1sPlxuXHRcdDwvUmVjb2lsUm9vdD5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlY29pbFJvb3QiLCJhdG9tIiwic2VsZWN0b3IiLCJ1c2VSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFZhbHVlIiwiUm9vdExheW91dCIsImNoaWxkcmVuIiwiaHRtbCIsImxhbmciLCJib2R5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./app/layout.js\n");

/***/ }),

/***/ "(sc_server)/./app/page.jsx":
/*!**********************!*\
  !*** ./app/page.jsx ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(sc_server)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_Card__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Card */ \"(sc_server)/./app/components/Card.jsx\");\n/* harmony import */ var _components_Card__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_components_Card__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Navbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Navbar */ \"(sc_server)/./app/components/Navbar.jsx\");\n/* harmony import */ var _components_Highlights__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/Highlights */ \"(sc_server)/./app/components/Highlights.jsx\");\n/* harmony import */ var _components_Highlights__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_Highlights__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recoil */ \"(sc_server)/./node_modules/recoil/cjs/index.js\");\n\n\n\n\n\nconst fetchCats = ()=>{\n    return fetch(\"https://api.thecatapi.com/v1/images/search?limit=50\", {\n        headers: {\n            \"x-api-key\": \"live_fn3DLX3NgTjf3rw6XZIExD27FysW12tRuN3KVBi8AYdRBEfMCFMpe9PKI2TSltXY\"\n        }\n    }).then((res)=>res.json());\n};\nconst fetchBreeds = ()=>{\n    return fetch(\"https://api.thecatapi.com/v1/breeds\", {\n        headers: {\n            \"x-api-key\": \"live_fn3DLX3NgTjf3rw6XZIExD27FysW12tRuN3KVBi8AYdRBEfMCFMpe9PKI2TSltXY\"\n        }\n    }).then((res)=>res.json());\n};\nasync function Home() {\n    const catData = await fetchCats();\n    const breedData = await fetchBreeds();\n    const breed = breedData.map((item)=>{\n        return item.name;\n    });\n    const filterBreed = (0,recoil__WEBPACK_IMPORTED_MODULE_4__.useRecoilValue)(breedState);\n    console.log(\"Breed value at home >>>\", filterBreed);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Navbar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                breeds: breed\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                lineNumber: 39,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-screen h-40 grid grid-flow-col justify-center items-center gap-6 overflow-x-auto pl-20\",\n                        children: breedData ? breedData.map((item)=>item.image ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_components_Highlights__WEBPACK_IMPORTED_MODULE_3___default()), {\n                                image: item.image.url,\n                                name: item.name\n                            }, item.id, false, {\n                                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                                lineNumber: 43,\n                                columnNumber: 20\n                            }, this) : console.log(\"Image not found..\")) : console.log(\"Cats loading....\")\n                    }, void 0, false, {\n                        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                        lineNumber: 41,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-3 lg:gap-4 lg:p-10 justify-center items-center\",\n                        children: catData ? catData.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_components_Card__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                image: item.url\n                            }, item.id, false, {\n                                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                                lineNumber: 48,\n                                columnNumber: 7\n                            }, this)) : console.log(\"Cats loading....\")\n                    }, void 0, false, {\n                        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                        lineNumber: 46,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/page.jsx\",\n                lineNumber: 40,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9hcHAvcGFnZS5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ29DO0FBQ0k7QUFDUTtBQUNUO0FBR3ZDLE1BQU1JLFlBQVksSUFBTTtJQUN2QixPQUFPQyxNQUFNLHVEQUFzRDtRQUNsRUMsU0FBUTtZQUNQLGFBQWE7UUFDZDtJQUNELEdBQ0NDLElBQUksQ0FBRUMsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSTtBQUN2QjtBQUNBLE1BQU1DLGNBQWMsSUFBTTtJQUN6QixPQUFPTCxNQUFNLHVDQUFzQztRQUNsREMsU0FBUTtZQUNQLGFBQWE7UUFDZDtJQUNELEdBQ0NDLElBQUksQ0FBRUMsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSTtBQUN2QjtBQUVlLGVBQWVFLE9BQU87SUFDcEMsTUFBTUMsVUFBVSxNQUFNUjtJQUN0QixNQUFNUyxZQUFZLE1BQU1IO0lBRXhCLE1BQU1JLFFBQVFELFVBQVVFLEdBQUcsQ0FBRUMsQ0FBQUEsT0FBUTtRQUNwQyxPQUFPQSxLQUFLQyxJQUFJO0lBQ2pCO0lBRUEsTUFBTUMsY0FBY2Ysc0RBQWNBLENBQUNnQjtJQUVuQ0MsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQkg7SUFFdkMscUJBQ0M7OzBCQUNDLDhEQUFDakIsMERBQU1BO2dCQUFDcUIsUUFBUVI7Ozs7OzswQkFDaEIsOERBQUNTOztrQ0FDQSw4REFBQ0M7d0JBQUlDLFdBQVU7a0NBQ2JaLFlBQVlBLFVBQVVFLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FDMUJBLEtBQUtVLEtBQUssaUJBQUcsOERBQUN4QiwrREFBVUE7Z0NBQWV3QixPQUFPVixLQUFLVSxLQUFLLENBQUNDLEdBQUc7Z0NBQUVWLE1BQU1ELEtBQUtDLElBQUk7K0JBQS9DRCxLQUFLWSxFQUFFOzs7O3VDQUE4Q1IsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQixJQUNoSEQsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjs7Ozs7O2tDQUVwQyw4REFBQ0c7d0JBQUlDLFdBQVU7a0NBQ2JiLFVBQVVBLFFBQVFHLEdBQUcsQ0FBQ0MsQ0FBQUEscUJBQ3RCLDhEQUFDaEIseURBQUlBO2dDQUFlMEIsT0FBT1YsS0FBS1csR0FBRzsrQkFBeEJYLEtBQUtZLEVBQUU7Ozs7d0NBQ2ZSLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUI7Ozs7Ozs7Ozs7Ozs7O0FBS3hDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vYXBwL3BhZ2UuanN4PzZlNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgQ2FyZCBmcm9tIFwiLi9jb21wb25lbnRzL0NhcmRcIlxuaW1wb3J0IE5hdmJhciBmcm9tIFwiLi9jb21wb25lbnRzL05hdmJhclwiXG5pbXBvcnQgSGlnaGxpZ2h0cyBmcm9tIFwiLi9jb21wb25lbnRzL0hpZ2hsaWdodHNcIlxuaW1wb3J0IHsgdXNlUmVjb2lsVmFsdWUgfSBmcm9tIFwicmVjb2lsXCJcblxuXG5jb25zdCBmZXRjaENhdHMgPSAoKSA9PiB7XG5cdHJldHVybiBmZXRjaChcImh0dHBzOi8vYXBpLnRoZWNhdGFwaS5jb20vdjEvaW1hZ2VzL3NlYXJjaD9saW1pdD01MFwiLHtcblx0XHRoZWFkZXJzOntcblx0XHRcdCd4LWFwaS1rZXknOiBcImxpdmVfZm4zRExYM05nVGpmM3J3NlhaSUV4RDI3RnlzVzEydFJ1TjNLVkJpOEFZZFJCRWZNQ0ZNcGU5UEtJMlRTbHRYWVwiXG5cdFx0fVxuXHR9KVxuXHQudGhlbiggcmVzID0+IHJlcy5qc29uKCkpXG59XG5jb25zdCBmZXRjaEJyZWVkcyA9ICgpID0+IHtcblx0cmV0dXJuIGZldGNoKFwiaHR0cHM6Ly9hcGkudGhlY2F0YXBpLmNvbS92MS9icmVlZHNcIix7XG5cdFx0aGVhZGVyczp7XG5cdFx0XHQneC1hcGkta2V5JzogXCJsaXZlX2ZuM0RMWDNOZ1RqZjNydzZYWklFeEQyN0Z5c1cxMnRSdU4zS1ZCaThBWWRSQkVmTUNGTXBlOVBLSTJUU2x0WFlcIlxuXHRcdH1cdFxuXHR9KVxuXHQudGhlbiggcmVzID0+IHJlcy5qc29uKCkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIEhvbWUoKSB7XG5cdGNvbnN0IGNhdERhdGEgPSBhd2FpdCBmZXRjaENhdHMoKTtcblx0Y29uc3QgYnJlZWREYXRhID0gYXdhaXQgZmV0Y2hCcmVlZHMoKTtcblxuXHRjb25zdCBicmVlZCA9IGJyZWVkRGF0YS5tYXAoIGl0ZW0gPT4ge1xuXHRcdHJldHVybiBpdGVtLm5hbWVcblx0fSlcblxuXHRjb25zdCBmaWx0ZXJCcmVlZCA9IHVzZVJlY29pbFZhbHVlKGJyZWVkU3RhdGUpXG5cblx0Y29uc29sZS5sb2coJ0JyZWVkIHZhbHVlIGF0IGhvbWUgPj4+JywgZmlsdGVyQnJlZWQpXG5cblx0cmV0dXJuKFxuXHRcdDw+XG5cdFx0XHQ8TmF2YmFyIGJyZWVkcz17YnJlZWR9Lz5cblx0XHRcdDxtYWluPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInctc2NyZWVuIGgtNDAgZ3JpZCBncmlkLWZsb3ctY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBnYXAtNiBvdmVyZmxvdy14LWF1dG8gcGwtMjBcIj5cblx0XHRcdFx0XHR7YnJlZWREYXRhID8gYnJlZWREYXRhLm1hcChpdGVtID0+IChcblx0XHRcdFx0XHRcdGl0ZW0uaW1hZ2UgPyA8SGlnaGxpZ2h0cyBrZXk9e2l0ZW0uaWR9IGltYWdlPXtpdGVtLmltYWdlLnVybH0gbmFtZT17aXRlbS5uYW1lfS8+IDogY29uc29sZS5sb2coXCJJbWFnZSBub3QgZm91bmQuLlwiKVxuXHRcdFx0XHRcdCkpOiBjb25zb2xlLmxvZygnQ2F0cyBsb2FkaW5nLi4uLicpfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0zIGxnOmdhcC00IGxnOnAtMTAganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG5cdFx0XHRcdFx0e2NhdERhdGEgPyBjYXREYXRhLm1hcChpdGVtID0+IChcblx0XHRcdFx0XHRcdDxDYXJkIGtleT17aXRlbS5pZH0gaW1hZ2U9e2l0ZW0udXJsfS8+XG5cdFx0XHRcdFx0KSk6IGNvbnNvbGUubG9nKCdDYXRzIGxvYWRpbmcuLi4uJyl9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9tYWluPlxuXHRcdDwvPlxuICApXG59XG4iXSwibmFtZXMiOlsiQ2FyZCIsIk5hdmJhciIsIkhpZ2hsaWdodHMiLCJ1c2VSZWNvaWxWYWx1ZSIsImZldGNoQ2F0cyIsImZldGNoIiwiaGVhZGVycyIsInRoZW4iLCJyZXMiLCJqc29uIiwiZmV0Y2hCcmVlZHMiLCJIb21lIiwiY2F0RGF0YSIsImJyZWVkRGF0YSIsImJyZWVkIiwibWFwIiwiaXRlbSIsIm5hbWUiLCJmaWx0ZXJCcmVlZCIsImJyZWVkU3RhdGUiLCJjb25zb2xlIiwibG9nIiwiYnJlZWRzIiwibWFpbiIsImRpdiIsImNsYXNzTmFtZSIsImltYWdlIiwidXJsIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./app/page.jsx\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createProxy = createProxy;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ // Modified from https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeRegister.js\nconst CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nconst PROMISE_PROTOTYPE = Promise.prototype;\nconst deepProxyHandlers = {\n    get: function(target, name, _receiver) {\n        switch(name){\n            // These names are read by the Flight runtime if you end up using the exports object.\n            case \"$$typeof\":\n                // These names are a little too common. We should probably have a way to\n                // have the Flight runtime extract the inner target instead.\n                return target.$$typeof;\n            case \"filepath\":\n                return target.filepath;\n            case \"name\":\n                return target.name;\n            case \"displayName\":\n                return undefined;\n            case \"async\":\n                return target.async;\n            // We need to special case this because createElement reads it if we pass this\n            // reference.\n            case \"defaultProps\":\n                return undefined;\n            // Avoid this attempting to be serialized.\n            case \"toJSON\":\n                return undefined;\n            case Symbol.toPrimitive.toString():\n                // @ts-ignore\n                return Object.prototype[Symbol.toPrimitive];\n            case \"Provider\":\n                throw new Error(`Cannot render a Client Context Provider on the Server. ` + `Instead, you can export a Client Component wrapper ` + `that itself renders a Client Context Provider.`);\n            default:\n                break;\n        }\n        let expression;\n        switch(target.name){\n            case \"\":\n                expression = String(name);\n                break;\n            case \"*\":\n                expression = String(name);\n                break;\n            default:\n                expression = String(target.name) + \".\" + String(name);\n        }\n        throw new Error(`Cannot access ${expression} on the server. ` + \"You cannot dot into a client module from a server component. \" + \"You can only pass the imported name through.\");\n    },\n    set: function() {\n        throw new Error(\"Cannot assign to a client module from a server module.\");\n    }\n};\nconst proxyHandlers = {\n    get: function(target, name, _receiver) {\n        switch(name){\n            // These names are read by the Flight runtime if you end up using the exports object.\n            case \"$$typeof\":\n                // These names are a little too common. We should probably have a way to\n                // have the Flight runtime extract the inner target instead.\n                return target.$$typeof;\n            case \"filepath\":\n                return target.filepath;\n            case \"name\":\n                return target.name;\n            case \"async\":\n                return target.async;\n            // We need to special case this because createElement reads it if we pass this\n            // reference.\n            case \"defaultProps\":\n                return undefined;\n            // Avoid this attempting to be serialized.\n            case \"toJSON\":\n                return undefined;\n            case Symbol.toPrimitive.toString():\n                // @ts-ignore\n                return Object.prototype[Symbol.toPrimitive];\n            case \"__esModule\":\n                // Something is conditionally checking which export to use. We'll pretend to be\n                // an ESM compat module but then we'll check again on the client.\n                const moduleId = target.filepath;\n                target.default = Object.defineProperties(function() {\n                    throw new Error(`Attempted to call the default export of ${moduleId} from the server ` + `but it's on the client. It's not possible to invoke a client function from ` + `the server, it can only be rendered as a Component or passed to props of a ` + `Client Component.`);\n                }, {\n                    // This a placeholder value that tells the client to conditionally use the\n                    // whole object or just the default export.\n                    name: {\n                        value: \"\"\n                    },\n                    $$typeof: {\n                        value: CLIENT_REFERENCE\n                    },\n                    filepath: {\n                        value: target.filepath\n                    },\n                    async: {\n                        value: target.async\n                    }\n                });\n                return true;\n            case \"then\":\n                if (target.then) {\n                    // Use a cached value\n                    return target.then;\n                }\n                if (!target.async) {\n                    // If this module is expected to return a Promise (such as an AsyncModule) then\n                    // we should resolve that with a client reference that unwraps the Promise on\n                    // the client.\n                    const clientReference = Object.defineProperties({}, {\n                        // Represents the whole Module object instead of a particular import.\n                        name: {\n                            value: \"*\"\n                        },\n                        $$typeof: {\n                            value: CLIENT_REFERENCE\n                        },\n                        filepath: {\n                            value: target.filepath\n                        },\n                        async: {\n                            value: true\n                        }\n                    });\n                    const proxy = new Proxy(clientReference, proxyHandlers);\n                    // Treat this as a resolved Promise for React's use()\n                    target.status = \"fulfilled\";\n                    target.value = proxy;\n                    const then = target.then = Object.defineProperties(function then(resolve, _reject) {\n                        // Expose to React.\n                        return Promise.resolve(resolve(proxy));\n                    }, // export then we should treat it as a reference to that name.\n                    {\n                        name: {\n                            value: \"then\"\n                        },\n                        $$typeof: {\n                            value: CLIENT_REFERENCE\n                        },\n                        filepath: {\n                            value: target.filepath\n                        },\n                        async: {\n                            value: false\n                        }\n                    });\n                    return then;\n                } else {\n                    // Since typeof .then === 'function' is a feature test we'd continue recursing\n                    // indefinitely if we return a function. Instead, we return an object reference\n                    // if we check further.\n                    return undefined;\n                }\n            default:\n                break;\n        }\n        let cachedReference = target[name];\n        if (!cachedReference) {\n            const reference = Object.defineProperties(function() {\n                throw new Error(`Attempted to call ${String(name)}() from the server but ${String(name)} is on the client. ` + `It's not possible to invoke a client function from the server, it can ` + `only be rendered as a Component or passed to props of a Client Component.`);\n            }, {\n                name: {\n                    value: name\n                },\n                $$typeof: {\n                    value: CLIENT_REFERENCE\n                },\n                filepath: {\n                    value: target.filepath\n                },\n                async: {\n                    value: target.async\n                }\n            });\n            cachedReference = target[name] = new Proxy(reference, deepProxyHandlers);\n        }\n        return cachedReference;\n    },\n    getPrototypeOf (_target) {\n        // Pretend to be a Promise in case anyone asks.\n        return PROMISE_PROTOTYPE;\n    },\n    set: function() {\n        throw new Error(\"Cannot assign to a client module from a server module.\");\n    }\n};\nfunction createProxy(moduleId) {\n    const clientReference = Object.defineProperties({}, {\n        // Represents the whole object instead of a particular import.\n        name: {\n            value: \"*\"\n        },\n        $$typeof: {\n            value: CLIENT_REFERENCE\n        },\n        filepath: {\n            value: moduleId\n        },\n        async: {\n            value: false\n        }\n    });\n    return new Proxy(clientReference, proxyHandlers);\n} //# sourceMappingURL=module-proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1sb2FkZXIvbW9kdWxlLXByb3h5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0Qjs7Ozs7Q0FLQyxHQUFHLG9JQUFvSTtBQUN4SSxNQUFNQyxtQkFBbUJDLE9BQU9DLEdBQUcsQ0FBQztBQUNwQyxNQUFNQyxvQkFBb0JDLFFBQVFDLFNBQVM7QUFDM0MsTUFBTUMsb0JBQW9CO0lBQ3RCQyxLQUFLLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUU7UUFDbkMsT0FBT0Q7WUFDSCxxRkFBcUY7WUFDckYsS0FBSztnQkFDRCx3RUFBd0U7Z0JBQ3hFLDREQUE0RDtnQkFDNUQsT0FBT0QsT0FBT0csUUFBUTtZQUMxQixLQUFLO2dCQUNELE9BQU9ILE9BQU9JLFFBQVE7WUFDMUIsS0FBSztnQkFDRCxPQUFPSixPQUFPQyxJQUFJO1lBQ3RCLEtBQUs7Z0JBQ0QsT0FBT0k7WUFDWCxLQUFLO2dCQUNELE9BQU9MLE9BQU9NLEtBQUs7WUFDdkIsOEVBQThFO1lBQzlFLGFBQWE7WUFDYixLQUFLO2dCQUNELE9BQU9EO1lBQ1gsMENBQTBDO1lBQzFDLEtBQUs7Z0JBQ0QsT0FBT0E7WUFDWCxLQUFLWixPQUFPYyxXQUFXLENBQUNDLFFBQVE7Z0JBQzVCLGFBQWE7Z0JBQ2IsT0FBT3JCLE9BQU9VLFNBQVMsQ0FBQ0osT0FBT2MsV0FBVyxDQUFDO1lBQy9DLEtBQUs7Z0JBQ0QsTUFBTSxJQUFJRSxNQUFNLENBQUMsdURBQXVELENBQUMsR0FBRyxDQUFDLG1EQUFtRCxDQUFDLEdBQUcsQ0FBQyw4Q0FBOEMsQ0FBQyxFQUFFO1lBQzFMO2dCQUNJLEtBQU07UUFDZDtRQUNBLElBQUlDO1FBQ0osT0FBT1YsT0FBT0MsSUFBSTtZ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TUFBTUksa0JBQWtCL0IsT0FBTzZCLGdCQUFnQixDQUFDLENBQUMsR0FBRztRQUNoRCw4REFBOEQ7UUFDOURmLE1BQU07WUFDRlgsT0FBTztRQUNYO1FBQ0FhLFVBQVU7WUFDTmIsT0FBT0U7UUFDWDtRQUNBWSxVQUFVO1lBQ05kLE9BQU93QjtRQUNYO1FBQ0FSLE9BQU87WUFDSGhCLE9BQU8sS0FBSztRQUNoQjtJQUNKO0lBQ0EsT0FBTyxJQUFJOEIsTUFBTUYsaUJBQWlCTDtBQUN0QyxFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1sb2FkZXIvbW9kdWxlLXByb3h5LmpzPzhhYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVByb3h5ID0gY3JlYXRlUHJveHk7XG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovIC8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svc3JjL1JlYWN0RmxpZ2h0V2VicGFja05vZGVSZWdpc3Rlci5qc1xuY29uc3QgQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuY29uc3QgUFJPTUlTRV9QUk9UT1RZUEUgPSBQcm9taXNlLnByb3RvdHlwZTtcbmNvbnN0IGRlZXBQcm94eUhhbmRsZXJzID0ge1xuICAgIGdldDogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBfcmVjZWl2ZXIpIHtcbiAgICAgICAgc3dpdGNoKG5hbWUpe1xuICAgICAgICAgICAgLy8gVGhlc2UgbmFtZXMgYXJlIHJlYWQgYnkgdGhlIEZsaWdodCBydW50aW1lIGlmIHlvdSBlbmQgdXAgdXNpbmcgdGhlIGV4cG9ydHMgb2JqZWN0LlxuICAgICAgICAgICAgY2FzZSBcIiQkdHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgbmFtZXMgYXJlIGEgbGl0dGxlIHRvbyBjb21tb24uIFdlIHNob3VsZCBwcm9iYWJseSBoYXZlIGEgd2F5IHRvXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0aGUgRmxpZ2h0IHJ1bnRpbWUgZXh0cmFjdCB0aGUgaW5uZXIgdGFyZ2V0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC4kJHR5cGVvZjtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlcGF0aFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZmlsZXBhdGg7XG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQubmFtZTtcbiAgICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFzeW5jO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcyBiZWNhdXNlIGNyZWF0ZUVsZW1lbnQgcmVhZHMgaXQgaWYgd2UgcGFzcyB0aGlzXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UuXG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFByb3BzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIEF2b2lkIHRoaXMgYXR0ZW1wdGluZyB0byBiZSBzZXJpYWxpemVkLlxuICAgICAgICAgICAgY2FzZSBcInRvSlNPTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIFN5bWJvbC50b1ByaW1pdGl2ZS50b1N0cmluZygpOlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICAgICAgY2FzZSBcIlByb3ZpZGVyXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVuZGVyIGEgQ2xpZW50IENvbnRleHQgUHJvdmlkZXIgb24gdGhlIFNlcnZlci4gYCArIGBJbnN0ZWFkLCB5b3UgY2FuIGV4cG9ydCBhIENsaWVudCBDb21wb25lbnQgd3JhcHBlciBgICsgYHRoYXQgaXRzZWxmIHJlbmRlcnMgYSBDbGllbnQgQ29udGV4dCBQcm92aWRlci5gKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCh0YXJnZXQubmFtZSl7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyh0YXJnZXQubmFtZSkgKyBcIi5cIiArIFN0cmluZyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhY2Nlc3MgJHtleHByZXNzaW9ufSBvbiB0aGUgc2VydmVyLiBgICsgXCJZb3UgY2Fubm90IGRvdCBpbnRvIGEgY2xpZW50IG1vZHVsZSBmcm9tIGEgc2VydmVyIGNvbXBvbmVudC4gXCIgKyBcIllvdSBjYW4gb25seSBwYXNzIHRoZSBpbXBvcnRlZCBuYW1lIHRocm91Z2guXCIpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFzc2lnbiB0byBhIGNsaWVudCBtb2R1bGUgZnJvbSBhIHNlcnZlciBtb2R1bGUuXCIpO1xuICAgIH1cbn07XG5jb25zdCBwcm94eUhhbmRsZXJzID0ge1xuICAgIGdldDogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBfcmVjZWl2ZXIpIHtcbiAgICAgICAgc3dpdGNoKG5hbWUpe1xuICAgICAgICAgICAgLy8gVGhlc2UgbmFtZXMgYXJlIHJlYWQgYnkgdGhlIEZsaWdodCBydW50aW1lIGlmIHlvdSBlbmQgdXAgdXNpbmcgdGhlIGV4cG9ydHMgb2JqZWN0LlxuICAgICAgICAgICAgY2FzZSBcIiQkdHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgbmFtZXMgYXJlIGEgbGl0dGxlIHRvbyBjb21tb24uIFdlIHNob3VsZCBwcm9iYWJseSBoYXZlIGEgd2F5IHRvXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0aGUgRmxpZ2h0IHJ1bnRpbWUgZXh0cmFjdCB0aGUgaW5uZXIgdGFyZ2V0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC4kJHR5cGVvZjtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlcGF0aFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZmlsZXBhdGg7XG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQubmFtZTtcbiAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXN5bmM7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGlzIGJlY2F1c2UgY3JlYXRlRWxlbWVudCByZWFkcyBpdCBpZiB3ZSBwYXNzIHRoaXNcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0UHJvcHNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gQXZvaWQgdGhpcyBhdHRlbXB0aW5nIHRvIGJlIHNlcmlhbGl6ZWQuXG4gICAgICAgICAgICBjYXNlIFwidG9KU09OXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgU3ltYm9sLnRvUHJpbWl0aXZlLnRvU3RyaW5nKCk6XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gICAgICAgICAgICBjYXNlIFwiX19lc01vZHVsZVwiOlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyBpcyBjb25kaXRpb25hbGx5IGNoZWNraW5nIHdoaWNoIGV4cG9ydCB0byB1c2UuIFdlJ2xsIHByZXRlbmQgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBhbiBFU00gY29tcGF0IG1vZHVsZSBidXQgdGhlbiB3ZSdsbCBjaGVjayBhZ2FpbiBvbiB0aGUgY2xpZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZUlkID0gdGFyZ2V0LmZpbGVwYXRoO1xuICAgICAgICAgICAgICAgIHRhcmdldC5kZWZhdWx0ID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGNhbGwgdGhlIGRlZmF1bHQgZXhwb3J0IG9mICR7bW9kdWxlSWR9IGZyb20gdGhlIHNlcnZlciBgICsgYGJ1dCBpdCdzIG9uIHRoZSBjbGllbnQuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIGludm9rZSBhIGNsaWVudCBmdW5jdGlvbiBmcm9tIGAgKyBgdGhlIHNlcnZlciwgaXQgY2FuIG9ubHkgYmUgcmVuZGVyZWQgYXMgYSBDb21wb25lbnQgb3IgcGFzc2VkIHRvIHByb3BzIG9mIGEgYCArIGBDbGllbnQgQ29tcG9uZW50LmApO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhIHBsYWNlaG9sZGVyIHZhbHVlIHRoYXQgdGVsbHMgdGhlIGNsaWVudCB0byBjb25kaXRpb25hbGx5IHVzZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hvbGUgb2JqZWN0IG9yIGp1c3QgdGhlIGRlZmF1bHQgZXhwb3J0LlxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAkJHR5cGVvZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IENMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQuZmlsZXBhdGhcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQuYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSBcInRoZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgY2FjaGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQudGhlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBtb2R1bGUgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSAoc3VjaCBhcyBhbiBBc3luY01vZHVsZSkgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgcmVzb2x2ZSB0aGF0IHdpdGggYSBjbGllbnQgcmVmZXJlbmNlIHRoYXQgdW53cmFwcyB0aGUgUHJvbWlzZSBvblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2xpZW50LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRSZWZlcmVuY2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwcmVzZW50cyB0aGUgd2hvbGUgTW9kdWxlIG9iamVjdCBpbnN0ZWFkIG9mIGEgcGFydGljdWxhciBpbXBvcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiKlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJCR0eXBlb2Y6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC5maWxlcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNsaWVudFJlZmVyZW5jZSwgcHJveHlIYW5kbGVycyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IHRoaXMgYXMgYSByZXNvbHZlZCBQcm9taXNlIGZvciBSZWFjdCdzIHVzZSgpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBwcm94eTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlbiA9IHRhcmdldC50aGVuID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZnVuY3Rpb24gdGhlbihyZXNvbHZlLCBfcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBvc2UgdG8gUmVhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJveHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgLy8gSWYgdGhpcyBpcyBub3QgdXNlZCBhcyBhIFByb21pc2UgYnV0IGlzIHRyZWF0ZWQgYXMgYSByZWZlcmVuY2UgdG8gYSBgLnRoZW5gXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB0aGVuIHdlIHNob3VsZCB0cmVhdCBpdCBhcyBhIHJlZmVyZW5jZSB0byB0aGF0IG5hbWUuXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJ0aGVuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAkJHR5cGVvZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBDTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0LmZpbGVwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHR5cGVvZiAudGhlbiA9PT0gJ2Z1bmN0aW9uJyBpcyBhIGZlYXR1cmUgdGVzdCB3ZSdkIGNvbnRpbnVlIHJlY3Vyc2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRlZmluaXRlbHkgaWYgd2UgcmV0dXJuIGEgZnVuY3Rpb24uIEluc3RlYWQsIHdlIHJldHVybiBhbiBvYmplY3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNoZWNrIGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FjaGVkUmVmZXJlbmNlID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICBpZiAoIWNhY2hlZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gY2FsbCAke1N0cmluZyhuYW1lKX0oKSBmcm9tIHRoZSBzZXJ2ZXIgYnV0ICR7U3RyaW5nKG5hbWUpfSBpcyBvbiB0aGUgY2xpZW50LiBgICsgYEl0J3Mgbm90IHBvc3NpYmxlIHRvIGludm9rZSBhIGNsaWVudCBmdW5jdGlvbiBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGNhbiBgICsgYG9ubHkgYmUgcmVuZGVyZWQgYXMgYSBDb21wb25lbnQgb3IgcGFzc2VkIHRvIHByb3BzIG9mIGEgQ2xpZW50IENvbXBvbmVudC5gKTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAkJHR5cGVvZjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsZXBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC5maWxlcGF0aFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXN5bmM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC5hc3luY1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGVkUmVmZXJlbmNlID0gdGFyZ2V0W25hbWVdID0gbmV3IFByb3h5KHJlZmVyZW5jZSwgZGVlcFByb3h5SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRSZWZlcmVuY2U7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZiAoX3RhcmdldCkge1xuICAgICAgICAvLyBQcmV0ZW5kIHRvIGJlIGEgUHJvbWlzZSBpbiBjYXNlIGFueW9uZSBhc2tzLlxuICAgICAgICByZXR1cm4gUFJPTUlTRV9QUk9UT1RZUEU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXNzaWduIHRvIGEgY2xpZW50IG1vZHVsZSBmcm9tIGEgc2VydmVyIG1vZHVsZS5cIik7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KG1vZHVsZUlkKSB7XG4gICAgY29uc3QgY2xpZW50UmVmZXJlbmNlID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHtcbiAgICAgICAgLy8gUmVwcmVzZW50cyB0aGUgd2hvbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBwYXJ0aWN1bGFyIGltcG9ydC5cbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgdmFsdWU6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgICQkdHlwZW9mOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICB9LFxuICAgICAgICBmaWxlcGF0aDoge1xuICAgICAgICAgICAgdmFsdWU6IG1vZHVsZUlkXG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJveHkoY2xpZW50UmVmZXJlbmNlLCBwcm94eUhhbmRsZXJzKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLXByb3h5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZVByb3h5IiwiQ0xJRU5UX1JFRkVSRU5DRSIsIlN5bWJvbCIsImZvciIsIlBST01JU0VfUFJPVE9UWVBFIiwiUHJvbWlzZSIsInByb3RvdHlwZSIsImRlZXBQcm94eUhhbmRsZXJzIiwiZ2V0IiwidGFyZ2V0IiwibmFtZSIsIl9yZWNlaXZlciIsIiQkdHlwZW9mIiwiZmlsZXBhdGgiLCJ1bmRlZmluZWQiLCJhc3luYyIsInRvUHJpbWl0aXZlIiwidG9TdHJpbmciLCJFcnJvciIsImV4cHJlc3Npb24iLCJTdHJpbmciLCJzZXQiLCJwcm94eUhhbmRsZXJzIiwibW9kdWxlSWQiLCJkZWZhdWx0IiwiZGVmaW5lUHJvcGVydGllcyIsInRoZW4iLCJjbGllbnRSZWZlcmVuY2UiLCJwcm94eSIsIlByb3h5Iiwic3RhdHVzIiwicmVzb2x2ZSIsIl9yZWplY3QiLCJjYWNoZWRSZWZlcmVuY2UiLCJyZWZlcmVuY2UiLCJnZXRQcm90b3R5cGVPZiIsIl90YXJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  */ \nconst { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ \"(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js\");\nmodule.exports = createProxy(\"/Users/anamdiazs/Documents/GitHub/catstagram/node_modules/next/dist/client/components/app-router.js\");\n //# sourceMappingURL=app-router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0NBd1NBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanM/NDE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwUm91dGVyO1xuZXhwb3J0cy51cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXI7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3JvdXRlclJlZHVjZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlclwiKTtcbnZhciBfcm91dGVyUmVkdWNlclR5cGVzID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG52YXIgX2hvb2tzQ2xpZW50Q29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0XCIpO1xudmFyIF91c2VSZWR1Y2VyV2l0aERldnRvb2xzID0gcmVxdWlyZShcIi4vdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29sc1wiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9jcmVhdGVJbml0aWFsUm91dGVyU3RhdGUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGVcIik7XG52YXIgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG52YXIgX2lzQm90ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdFwiKTtcbnZhciBfYWRkQmFzZVBhdGggPSByZXF1aXJlKFwiLi4vYWRkLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIEFwcFJvdXRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgZ2xvYmFsRXJyb3JDb21wb25lbnQgIH0gPSBwcm9wcywgcmVzdCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHByb3BzLCBbXG4gICAgICAgIFwiZ2xvYmFsRXJyb3JDb21wb25lbnRcIlxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2Vycm9yQm91bmRhcnkuRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBlcnJvckNvbXBvbmVudDogZ2xvYmFsRXJyb3JDb21wb25lbnRcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCBPYmplY3QuYXNzaWduKHt9LCByZXN0KSkpO1xufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuLy8gRW5zdXJlIHRoZSBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgYXJlIG5vdCBjb21iaW5lZCBiZWNhdXNlIG9mIGRvdWJsZS1yZW5kZXJpbmcgaW4gdGhlIGJyb3dzZXIgd2l0aCBTdHJpY3QgTW9kZS5cbmxldCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgPSBpc1NlcnZlciA/IG51bGwgOiBuZXcgTWFwKCk7XG5mdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsKSB7XG4gICAgY29uc3QgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAvLyBUT0RPLUFQUDogaGFuZGxlIC5yc2MgZm9yIHN0YXRpYyBleHBvcnQgY2FzZVxuICAgIHJldHVybiB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycztcbn1cbmNvbnN0IEhvdFJlbG9hZGVyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IG51bGwgOiByZXF1aXJlKCcuL3JlYWN0LWRldi1vdmVybGF5L2hvdC1yZWxvYWRlci1jbGllbnQnKS5kZWZhdWx0O1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG59XG4vKipcbiAqIFRoZSBnbG9iYWwgcm91dGVyIHRoYXQgd3JhcHMgdGhlIGFwcGxpY2F0aW9uIGNvbXBvbmVudHMuXG4gKi8gZnVuY3Rpb24gUm91dGVyKHsgaW5pdGlhbEhlYWQgLCBpbml0aWFsVHJlZSAsIGluaXRpYWxDYW5vbmljYWxVcmwgLCBjaGlsZHJlbiAsIGFzc2V0UHJlZml4ICB9KSB7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+KDAsIF9jcmVhdGVJbml0aWFsUm91dGVyU3RhdGUpLmNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSh7XG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGluaXRpYWxDYW5vbmljYWxVcmwsXG4gICAgICAgICAgICBpbml0aWFsVHJlZSxcbiAgICAgICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIGlzU2VydmVyLFxuICAgICAgICAgICAgbG9jYXRpb246ICFpc1NlcnZlciA/IHdpbmRvdy5sb2NhdGlvbiA6IG51bGwsXG4gICAgICAgICAgICBpbml0aWFsSGVhZFxuICAgICAgICB9KSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgaW5pdGlhbFRyZWUsXG4gICAgICAgIGluaXRpYWxIZWFkXG4gICAgXSk7XG4gICAgY29uc3QgW3sgdHJlZSAsIGNhY2hlICwgcHJlZmV0Y2hDYWNoZSAsIHB1c2hSZWYgLCBmb2N1c0FuZFNjcm9sbFJlZiAsIGNhbm9uaWNhbFVybCAgfSwgZGlzcGF0Y2gsIHN5bmMsIF0gPSAoMCwgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMpLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyhfcm91dGVyUmVkdWNlci5yZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGlzIGNsZWFuZWQgdXAgZnJvbSBtZW1vcnkgb25jZSBpdCdzIHVzZWQuXG4gICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyAsIHBhdGhuYW1lICB9ID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNhbm9uaWNhbFVybCwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjYW5vbmljYWxVcmxcbiAgICBdKTtcbiAgICAvKipcbiAgICogU2VydmVyIHJlc3BvbnNlIHRoYXQgb25seSBwYXRjaGVzIHRoZSBjYWNoZSBhbmQgdHJlZS5cbiAgICovIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygocHJldmlvdXNUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fU0VSVkVSX1BBVENILFxuICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSxcbiAgICAgICAgICAgIG92ZXJyaWRlQ2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIC8qKlxuICAgKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gSXQncyBvbmx5IGNvbmNlcm5lZCB3aXRoIGRpc3BhdGNoaW5nIGFjdGlvbnMgdG8gdGhlIHJlZHVjZXIsIGRvZXMgbm90IGhvbGQgc3RhdGUuXG4gICAqLyBjb25zdCBhcHBSb3V0ZXIgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IG5hdmlnYXRlID0gKGhyZWYsIG5hdmlnYXRlVHlwZSwgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbik9PntcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoaHJlZiksIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX05BVklHQVRFLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBpc0V4dGVybmFsVXJsOiBpc0V4dGVybmFsVVJMKHVybCksXG4gICAgICAgICAgICAgICAgbG9jYXRpb25TZWFyY2g6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVHlwZSxcbiAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlckluc3RhbmNlID0ge1xuICAgICAgICAgICAgYmFjazogKCk9PndpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgICAgICAgICAgIGZvcndhcmQ6ICgpPT53aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gICAgICAgICAgICBwcmVmZXRjaDogX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWZXaXRoQmFzZVBhdGggPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChocmVmKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBwcmVmZXRjaCBoYXMgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCwgZG9uJ3QgdHJpZ2dlciBpdCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMoaHJlZldpdGhCYXNlUGF0aCkgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9pc0JvdCkuaXNCb3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlZmV0Y2hlZC5hZGQoaHJlZldpdGhCYXNlUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmV2l0aEJhc2VQYXRoLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxVUkwodXJsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlclRyZWUgPSAoKHJlZiA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnRyZWUpIHx8IGluaXRpYWxUcmVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IHlpZWxkICgwLCBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSkuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIC8vIGluaXRpYWxUcmVlIGlzIHVzZWQgd2hlbiBoaXN0b3J5LnN0YXRlLnRyZWUgaXMgbWlzc2luZyBiZWNhdXNlIHRoZSBoaXN0b3J5IHN0YXRlIGlzIHNldCBpbiBgdXNlRWZmZWN0YCBiZWxvdywgaXQgYmVpbmcgbWlzc2luZyBtZWFucyB0aGlzIGlzIHRoZSBoeWRyYXRpb24gY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgcm91dGVyVHJlZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogcm91dGVyVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQUkVGRVRDSCBFUlJPUicsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXBsYWNlOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncmVwbGFjZScsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaDogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3B1c2gnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvdXRlckluc3RhbmNlO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIGluaXRpYWxUcmVlXG4gICAgXSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIFdoZW4gbXBhTmF2aWdhdGlvbiBmbGFnIGlzIHNldCBkbyBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgbmV3IHVybC5cbiAgICAgICAgaWYgKHB1c2hSZWYubXBhTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmFzc2lnbihjYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWRlbnRpZmllciBpcyBzaG9ydGVuZWQgaW50ZW50aW9uYWxseS5cbiAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgICAgICAgX19OQTogdHJ1ZSxcbiAgICAgICAgICAgIHRyZWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHB1c2hSZWYucGVuZGluZ1B1c2ggJiYgKDAsIF9jcmVhdGVIcmVmRnJvbVVybCkuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICAgICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmMoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHB1c2hSZWYsXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgc3luY1xuICAgIF0pO1xuICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICovIGNvbnN0IG9uUG9wU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoeyBzdGF0ZSAgfSk9PntcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgICBpZiAoIXN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIHVzZVRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoXG4gICAgXSk7XG4gICAgLy8gUmVnaXN0ZXIgcG9wc3RhdGUgZXZlbnQgdG8gY2FsbCBvblBvcHN0YXRlLlxuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG9uUG9wU3RhdGVcbiAgICBdKTtcbiAgICBjb25zdCBjb250ZW50ID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjYWNoZS5zdWJUcmVlRGF0YSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcGF0aG5hbWVcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5TZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZWFyY2hQYXJhbXNcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSxcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZlxuICAgICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGFwcFJvdXRlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjYWNoZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICAgICAgICB1cmw6IGNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSwgSG90UmVsb2FkZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSG90UmVsb2FkZXIsIHtcbiAgICAgICAgYXNzZXRQcmVmaXg6IGFzc2V0UHJlZml4XG4gICAgfSwgY29udGVudCkgOiBjb250ZW50KSkpKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/app-router.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/async-local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/async-local-storage.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createAsyncLocalStorage = createAsyncLocalStorage;\nclass FakeAsyncLocalStorage {\n    disable() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    getStore() {\n        // This fake implementation of AsyncLocalStorage always returns `undefined`.\n        return undefined;\n    }\n    run() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    exit() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    enterWith() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n}\nfunction createAsyncLocalStorage() {\n    if (globalThis.AsyncLocalStorage) {\n        return new globalThis.AsyncLocalStorage();\n    }\n    return new FakeAsyncLocalStorage();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=async-local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FzeW5jLWxvY2FsLXN0b3JhZ2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsK0JBQStCLEdBQUdFO0FBQ2xDLE1BQU1DO0lBQ0ZDLFVBQVU7UUFDTixNQUFNLElBQUlDLE1BQU0sOEVBQThFO0lBQ2xHO0lBQ0FDLFdBQVc7UUFDUCw0RUFBNEU7UUFDNUUsT0FBT0M7SUFDWDtJQUNBQyxNQUFNO1FBQ0YsTUFBTSxJQUFJSCxNQUFNLDhFQUE4RTtJQUNsRztJQUNBSSxPQUFPO1FBQ0gsTUFBTSxJQUFJSixNQUFNLDhFQUE4RTtJQUNsRztJQUNBSyxZQUFZO1FBQ1IsTUFBTSxJQUFJTCxNQUFNLDhFQUE4RTtJQUNsRztBQUNKO0FBQ0EsU0FBU0gsMEJBQTBCO0lBQy9CLElBQUlTLFdBQVdDLGlCQUFpQixFQUFFO1FBQzlCLE9BQU8sSUFBSUQsV0FBV0MsaUJBQWlCO0lBQzNDLENBQUM7SUFDRCxPQUFPLElBQUlUO0FBQ2Y7QUFFQSxJQUFJLENBQUMsT0FBT0gsUUFBUWEsT0FBTyxLQUFLLGNBQWUsT0FBT2IsUUFBUWEsT0FBTyxLQUFLLFlBQVliLFFBQVFhLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2IsUUFBUWEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWEsT0FBTyxFQUFFLGNBQWM7UUFBRVosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9pQixNQUFNLENBQUNmLFFBQVFhLE9BQU8sRUFBRWI7SUFDL0JnQixPQUFPaEIsT0FBTyxHQUFHQSxRQUFRYSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hc3luYy1sb2NhbC1zdG9yYWdlLmpzP2FmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlID0gY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2U7XG5jbGFzcyBGYWtlQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIC8vIFRoaXMgZmFrZSBpbXBsZW1lbnRhdGlvbiBvZiBBc3luY0xvY2FsU3RvcmFnZSBhbHdheXMgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogQXN5bmNMb2NhbFN0b3JhZ2UgYWNjZXNzZWQgaW4gcnVudGltZSB3aGVyZSBpdCBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIGV4aXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgZW50ZXJXaXRoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogQXN5bmNMb2NhbFN0b3JhZ2UgYWNjZXNzZWQgaW4gcnVudGltZSB3aGVyZSBpdCBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLkFzeW5jTG9jYWxTdG9yYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmFrZUFzeW5jTG9jYWxTdG9yYWdlKCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWxvY2FsLXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiLCJGYWtlQXN5bmNMb2NhbFN0b3JhZ2UiLCJkaXNhYmxlIiwiRXJyb3IiLCJnZXRTdG9yZSIsInVuZGVmaW5lZCIsInJ1biIsImV4aXQiLCJlbnRlcldpdGgiLCJnbG9iYWxUaGlzIiwiQXN5bmNMb2NhbFN0b3JhZ2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/async-local-storage.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/error-boundary.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/error-boundary.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  */ \nconst { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ \"(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js\");\nmodule.exports = createProxy(\"/Users/anamdiazs/Documents/GitHub/catstagram/node_modules/next/dist/client/components/error-boundary.js\");\n //# sourceMappingURL=error-boundary.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzLmpzIiwibWFwcGluZ3MiOiI7OztDQXNGQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcz83Njk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxFcnJvcjtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBHbG9iYWxFcnJvcih7IGVycm9yICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmVycm9yXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5kZXNjXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRleHRcbiAgICB9LCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cIiksIChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZGlnZXN0KSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy50ZXh0XG4gICAgfSwgYERpZ2VzdDogJHtlcnJvci5kaWdlc3R9YCkpKSkpO1xufVxuXG5jb25zdCBzdHlsZXMgPSB7XG4gICAgZXJyb3I6IHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tb2Rlcm4tbm9ybWFsaXplL2Jsb2IvbWFpbi9tb2Rlcm4tbm9ybWFsaXplLmNzcyNMMzgtTDUyXG4gICAgICAgIGZvbnRGYW1pbHk6ICdzeXN0ZW0tdWksXCJTZWdvZSBVSVwiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIHRleHRBbGlnbjogJ2xlZnQnXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgbGluZUhlaWdodDogJzNlbScsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH1cbn07XG5jbGFzcyBFcnJvckJvdW5kYXJ5SGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgdGhpcy5wcm9wcy5lcnJvclN0eWxlcywgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgICAgICByZXNldDogdGhpcy5yZXNldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpPT57XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRXJyb3JCb3VuZGFyeUhhbmRsZXIgPSBFcnJvckJvdW5kYXJ5SGFuZGxlcjtcbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBlcnJvckNvbXBvbmVudCAsIGVycm9yU3R5bGVzICwgY2hpbGRyZW4gIH0pIHtcbiAgICBpZiAoZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5SGFuZGxlciwge1xuICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1ib3VuZGFyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/error-boundary.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/hooks-server-context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/hooks-server-context.js ***!
  \**************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DYNAMIC_ERROR_CODE = void 0;\nconst DYNAMIC_ERROR_CODE = \"DYNAMIC_SERVER_USAGE\";\nexports.DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE;\nclass DynamicServerError extends Error {\n    constructor(type){\n        super(`Dynamic server usage: ${type}`);\n        this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nexports.DynamicServerError = DynamicServerError;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUUscUJBQXFCO0FBQzNCRiwwQkFBMEIsR0FBR0U7QUFDN0IsTUFBTUMsMkJBQTJCQztJQUM3QkMsWUFBWUMsSUFBSSxDQUFDO1FBQ2IsS0FBSyxDQUFDLENBQUMsc0JBQXNCLEVBQUVBLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUNDLE1BQU0sR0FBR0w7SUFDbEI7QUFDSjtBQUNBRiwwQkFBMEIsR0FBR0c7QUFFN0IsSUFBSSxDQUFDLE9BQU9ILFFBQVFRLE9BQU8sS0FBSyxjQUFlLE9BQU9SLFFBQVFRLE9BQU8sS0FBSyxZQUFZUixRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9SLFFBQVFRLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktYLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9ZLE1BQU0sQ0FBQ1YsUUFBUVEsT0FBTyxFQUFFUjtJQUMvQlcsT0FBT1gsT0FBTyxHQUFHQSxRQUFRUSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9ob29rcy1zZXJ2ZXItY29udGV4dC5qcz8wMDlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EWU5BTUlDX0VSUk9SX0NPREUgPSB2b2lkIDA7XG5jb25zdCBEWU5BTUlDX0VSUk9SX0NPREUgPSAnRFlOQU1JQ19TRVJWRVJfVVNBR0UnO1xuZXhwb3J0cy5EWU5BTUlDX0VSUk9SX0NPREUgPSBEWU5BTUlDX0VSUk9SX0NPREU7XG5jbGFzcyBEeW5hbWljU2VydmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKGBEeW5hbWljIHNlcnZlciB1c2FnZTogJHt0eXBlfWApO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IERZTkFNSUNfRVJST1JfQ09ERTtcbiAgICB9XG59XG5leHBvcnRzLkR5bmFtaWNTZXJ2ZXJFcnJvciA9IER5bmFtaWNTZXJ2ZXJFcnJvcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3Mtc2VydmVyLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRFlOQU1JQ19FUlJPUl9DT0RFIiwiRHluYW1pY1NlcnZlckVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJkaWdlc3QiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/hooks-server-context.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  */ \nconst { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ \"(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js\");\nmodule.exports = createProxy(\"/Users/anamdiazs/Documents/GitHub/catstagram/node_modules/next/dist/client/components/layout-router.js\");\n //# sourceMappingURL=layout-router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0NBNllBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG5leHBvcnRzLklubmVyTGF5b3V0Um91dGVyID0gSW5uZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbnZhciBfaW5maW5pdGVQcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uXCIpO1xudmFyIF9oYW5kbGVTbW9vdGhTY3JvbGwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG52YXIgX3JlZGlyZWN0ID0gcmVxdWlyZShcIi4vcmVkaXJlY3RcIik7XG52YXIgX2ZpbmRIZWFkSW5DYWNoZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZVwiKTtcbmZ1bmN0aW9uIE91dGVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCBzZWdtZW50UGF0aCAsIGNoaWxkUHJvcCAsIGVycm9yICwgZXJyb3JTdHlsZXMgLCB0ZW1wbGF0ZVN0eWxlcyAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAsIHRlbXBsYXRlICwgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBsYXlvdXQgcm91dGVyIHRvIGJlIG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZE5vZGVzICwgdHJlZSAsIHVybCAsIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsICB9ID0gY29udGV4dDtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYWxsZWxSb3V0ZXIgY2FjaGUgbm9kZVxuICAgIGxldCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIGlmICghY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBuZXcgTWFwKCkpO1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYWN0aXZlIHNlZ21lbnQgaW4gdGhlIHRyZWVcbiAgICAvLyBUaGUgcmVhc29uIGFycmF5cyBhcmUgdXNlZCBpbiB0aGUgZGF0YSBmb3JtYXQgaXMgdGhhdCB0aGVzZSBhcmUgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBicm93c2VyIHNvIGl0J3Mgb3B0aW1pemVkIHRvIHNhdmUgYnl0ZXMuXG4gICAgY29uc3QgdHJlZVNlZ21lbnQgPSB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVswXTtcbiAgICBjb25zdCBjaGlsZFByb3BTZWdtZW50ID0gQXJyYXkuaXNBcnJheShjaGlsZFByb3Auc2VnbWVudCkgPyBjaGlsZFByb3Auc2VnbWVudFsxXSA6IGNoaWxkUHJvcC5zZWdtZW50O1xuICAgIC8vIElmIHNlZ21lbnQgaXMgYW4gYXJyYXkgaXQncyBhIGR5bmFtaWMgcm91dGUgYW5kIHdlIHdhbnQgdG8gcmVhZCB0aGUgZHluYW1pYyByb3V0ZSB2YWx1ZSBhcyB0aGUgc2VnbWVudCB0byBnZXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgY29uc3QgY3VycmVudENoaWxkU2VnbWVudCA9IEFycmF5LmlzQXJyYXkodHJlZVNlZ21lbnQpID8gdHJlZVNlZ21lbnRbMV0gOiB0cmVlU2VnbWVudDtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgY3VycmVudENoaWxkU2VnbWVudFxuICAgIF07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICByZXR1cm4oLypcbiAgICAgICAgICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAgICAgICAgICovIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIGtleTogcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2Vycm9yQm91bmRhcnkuRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvcixcbiAgICAgICAgICAgICAgICBlcnJvclN0eWxlczogZXJyb3JTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChMb2FkaW5nQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBoYXNMb2FkaW5nOiBoYXNMb2FkaW5nLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlczogbG9hZGluZ1N0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgICAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RCb3VuZGFyeSwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KElubmVyTGF5b3V0Um91dGVyLCB7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXJLZXk6IHBhcmFsbGVsUm91dGVyS2V5LFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkUHJvcDogY2hpbGRQcm9wU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCA/IGNoaWxkUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIHBhdGg6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGN1cnJlbnRDaGlsZFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgICAgICAgICB9KSkpKSlcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGUpKSk7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgLy8gT25seSBhcHBseSBzdHJpY3QgbW9kZSB3YXJuaW5nIHdoZW4gbm90IGluIHByb2R1Y3Rpb25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gKC4uLm1lc3NhZ2VzKT0+e1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzdHJpY3QgbW9kZSB3YXJuaW5nIGZvciB0aGUgZmluZERvbU5vZGUgY2FsbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZXNbMF0uaW5jbHVkZXMoJ1dhcm5pbmc6ICVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4nKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVFcnJvciguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIGNvcm5lciBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovIGZ1bmN0aW9uIHRvcE9mRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodDtcbn1cbmNsYXNzIFNjcm9sbEFuZEZvY3VzSGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzY3JvbGwgYW5kIGZvY3VzLCBpdCdzIG9ubHkgYXBwbGllZCBvbmNlIGluIHRoZSBmaXJzdCB1c2VFZmZlY3QgdGhhdCB0cmlnZ2VycyB0aGF0IGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvLyBgZmluZERPTU5vZGVgIGlzIHRyaWNreSBiZWNhdXNlIGl0IHJldHVybnMganVzdCB0aGUgZmlyc3QgY2hpbGQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50LlxuICAgICAgICAvLyBUaGlzIGFscmVhZHkgY2F1c2VkIGEgYnVnIHdoZXJlIHRoZSBmaXJzdCBjaGlsZCB3YXMgYSA8bGluay8+IGluIGhlYWQuXG4gICAgICAgIGNvbnN0IGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ICYmIGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZVNtb290aFNjcm9sbCkuaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT57XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCdzIHRvcCBlZGdlIGlzIGFscmVhZHkgaW4gdGhlIHZpZXdwb3J0LCBleGl0IGVhcmx5LlxuICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxJbnRvVmlldygpIGNhbGxlZCBvbiBgPGh0bWwvPmAgZWxlbWVudCBzY3JvbGxzIGhvcml6b250YWxseSBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggKHRoYXQgc2hvdWxkbid0IGhhcHBlbilcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB1c2UgaXQgdG8gc2Nyb2xsIGhvcml6b250YWxseSBmb2xsb3dpbmcgUlRMIGJ1dCB0aGF0IGFsc28gc2VlbXMgdG8gYmUgYnJva2VuIC0gaXQgd2lsbCBhbHdheXMgc2Nyb2xsIGxlZnRcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIGRvbU5vZGUgaWYgZG9tTm9kZSBpcyBub3QgaW4gdmlld3BvcnQgd2hlbiBzY3JvbGxlZCB0byB0b3Agb2YgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbCBpbnRvIHZpZXcgZG9lc24ndCBzY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQgd2hlbiBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGRvbnRGb3JjZUxheW91dDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCB1cmwgLCBjaGlsZE5vZGVzICwgY2hpbGRQcm9wICwgc2VnbWVudFBhdGggLCB0cmVlICwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuLy8gaXNBY3RpdmUsXG5wYXRoICwgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWwgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlICwgdHJlZTogZnVsbFRyZWUgLCBmb2N1c0FuZFNjcm9sbFJlZiAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9maW5kSGVhZEluQ2FjaGUpLmZpbmRIZWFkSW5DYWNoZShjaGlsZE5vZGVzLCB0cmVlWzFdKTtcbiAgICB9LCBbXG4gICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgXSk7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIC8vIElmIGNoaWxkUHJvcCBpcyBhdmFpbGFibGUgdGhpcyBtZWFucyBpdCdzIHRoZSBGbGlnaHQgLyBTU1IgY2FzZS5cbiAgICBpZiAoY2hpbGRQcm9wICYmIC8vIFRPRE8tQVBQOiB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgbnVsbCBiYXNlZCBvbiB1c2VyIGNvZGVcbiAgICBjaGlsZFByb3AuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3ViVHJlZURhdGEgPSBjaGlsZFByb3AuY3VycmVudDtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCdzIHN1YlRyZWVEYXRhIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiBjaGlsZE5vZGUgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmICghY2hpbGROb2RlIHx8IGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgLyoqXG4gICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgZGF0YTogKDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pLCByZWZldGNoVHJlZSksXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLmhlYWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMgOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiBzbyBpdCB0aHJvd3MgYW4gZXJyb3IuIEl0IGluZGljYXRlcyB0aGVyZSdzIGEgYnVnIGluIHRoZSBOZXh0LmpzLlxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgYWx3YXlzIGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKGNoaWxkTm9kZS5zdWJUcmVlRGF0YSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGJvdGggc3ViVHJlZURhdGEgYW5kIGRhdGEnKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgYSBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byB1bndyYXAgcmVzcG9uc2UgYnkgYHVzZWAgYW5kIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCByZXNwb25zZSBkYXRhXG4gICAgICovIC8vIFdoZW4gdGhlIGRhdGEgaGFzIG5vdCByZXNvbHZlZCB5ZXQgYHVzZWAgd2lsbCBzdXNwZW5kIGhlcmUuXG4gICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSAoMCwgX3JlYWN0KS51c2UoY2hpbGROb2RlLmRhdGEpO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50UGF0aCBmcm9tIHRoZSBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGxheW91dCdzIHNlZ21lbnRQYXRoXG4gICAgICAgIGNoaWxkTm9kZS5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIHRvIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBoYWNrIGFyb3VuZCBSZWFjdC5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0sIGhlYWQsIGNoaWxkTm9kZS5zdWJUcmVlRGF0YSk7XG4gICAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JvbGxBbmRGb2N1c0hhbmRsZXIsIHtcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgfSwgc3VidHJlZSk7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgIH0pIHtcbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsb2FkaW5nU3R5bGVzLCBsb2FkaW5nKVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHsgcmVkaXJlY3QgIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pO1xuICAgIH0sIFtcbiAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgUmVkaXJlY3RFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgX3JlZGlyZWN0KS5pc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgX3JlZGlyZWN0KS5nZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/layout-router.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* __next_internal_client_entry_do_not_use__  */ \nconst { createProxy  } = __webpack_require__(/*! private-next-rsc-mod-ref-proxy */ \"(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js\");\nmodule.exports = createProxy(\"/Users/anamdiazs/Documents/GitHub/catstagram/node_modules/next/dist/client/components/render-from-template-context.js\");\n //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0NBcUJBLHdEQUF3RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanM/OGVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmZ1bmN0aW9uIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LlRlbXBsYXRlQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/render-from-template-context.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/client/components/request-async-storage.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/request-async-storage.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.requestAsyncStorage = void 0;\nvar _asyncLocalStorage = __webpack_require__(/*! ./async-local-storage */ \"(sc_server)/./node_modules/next/dist/client/components/async-local-storage.js\");\nconst requestAsyncStorage = (0, _asyncLocalStorage).createAsyncLocalStorage();\nexports.requestAsyncStorage = requestAsyncStorage;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-async-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlcXVlc3QtYXN5bmMtc3RvcmFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBRyxLQUFLO0FBQ25DLElBQUlHLHFCQUFxQkMsbUJBQU9BLENBQUMsNEdBQXVCO0FBQ3hELE1BQU1GLHNCQUFzQixDQUFDLEdBQUdDLGtCQUFrQixFQUFFRSx1QkFBdUI7QUFDM0VMLDJCQUEyQixHQUFHRTtBQUU5QixJQUFJLENBQUMsT0FBT0YsUUFBUU0sT0FBTyxLQUFLLGNBQWUsT0FBT04sUUFBUU0sT0FBTyxLQUFLLFlBQVlOLFFBQVFNLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT04sUUFBUU0sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTSxPQUFPLEVBQUUsY0FBYztRQUFFTCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1UsTUFBTSxDQUFDUixRQUFRTSxPQUFPLEVBQUVOO0lBQy9CUyxPQUFPVCxPQUFPLEdBQUdBLFFBQVFNLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlcXVlc3QtYXN5bmMtc3RvcmFnZS5qcz8zMzlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZXF1ZXN0QXN5bmNTdG9yYWdlID0gdm9pZCAwO1xudmFyIF9hc3luY0xvY2FsU3RvcmFnZSA9IHJlcXVpcmUoXCIuL2FzeW5jLWxvY2FsLXN0b3JhZ2VcIik7XG5jb25zdCByZXF1ZXN0QXN5bmNTdG9yYWdlID0gKDAsIF9hc3luY0xvY2FsU3RvcmFnZSkuY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbmV4cG9ydHMucmVxdWVzdEFzeW5jU3RvcmFnZSA9IHJlcXVlc3RBc3luY1N0b3JhZ2U7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QtYXN5bmMtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXF1ZXN0QXN5bmNTdG9yYWdlIiwiX2FzeW5jTG9jYWxTdG9yYWdlIiwicmVxdWlyZSIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/client/components/request-async-storage.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @license React\n * react-dom-server-rendering-stub.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var ReactVersion = \"18.3.0-next-6ddcbd4f9-20230209\";\n        var Internals = {\n            usingClientEntryPoint: false,\n            Events: null,\n            Dispatcher: {\n                current: null\n            }\n        };\n        function preinit() {\n            var dispatcher = Internals.Dispatcher.current;\n            if (dispatcher) {\n                dispatcher.preinit.apply(this, arguments);\n            } // We don't error because preinit needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function preload() {\n            var dispatcher = Internals.Dispatcher.current;\n            if (dispatcher) {\n                dispatcher.preload.apply(this, arguments);\n            } // We don't error because preload needs to be resilient to being called in a variety of scopes\n        // and the runtime may not be capable of responding. The function is optimistic and not critical\n        // so we favor silent bailout over warning or erroring.\n        }\n        function createPortal() {\n            throw new Error(\"createPortal was called on the server. Portals are not currently\" + \" supported on the server. Update your program to conditionally call\" + \" createPortal on the client only.\");\n        }\n        function flushSync() {\n            throw new Error(\"flushSync was called on the server. This is likely caused by a\" + \" function being called during render or in module scope that was\" + \" intended to be called from an effect or event handler. Update your\" + \" to not call flushSync no the server.\");\n        }\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\n        exports.createPortal = createPortal;\n        exports.flushSync = flushSync;\n        exports.preinit = preinit;\n        exports.preload = preload;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci1yZW5kZXJpbmctc3R1Yi5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QyxZQUFXO1FBQ2Q7UUFFQSxJQUFJQyxlQUFlO1FBRW5CLElBQUlDLFlBQVk7WUFDZEMsdUJBQXVCLEtBQUs7WUFDNUJDLFFBQVEsSUFBSTtZQUNaQyxZQUFZO2dCQUNWQyxTQUFTLElBQUk7WUFDZjtRQUNGO1FBRUEsU0FBU0MsVUFBVTtZQUNqQixJQUFJQyxhQUFhTixVQUFVRyxVQUFVLENBQUNDLE9BQU87WUFFN0MsSUFBSUUsWUFBWTtnQkFDZEEsV0FBV0QsT0FBTyxDQUFDRSxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNqQyxDQUFDLENBQUMsOEZBQThGO1FBQ2hHLGdHQUFnRztRQUNoRyx1REFBdUQ7UUFFekQ7UUFDQSxTQUFTQyxVQUFVO1lBQ2pCLElBQUlILGFBQWFOLFVBQVVHLFVBQVUsQ0FBQ0MsT0FBTztZQUU3QyxJQUFJRSxZQUFZO2dCQUNkQSxXQUFXRyxPQUFPLENBQUNGLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1lBQ2pDLENBQUMsQ0FBQyw4RkFBOEY7UUFDaEcsZ0dBQWdHO1FBQ2hHLHVEQUF1RDtRQUV6RDtRQUVBLFNBQVNFLGVBQWU7WUFDdEIsTUFBTSxJQUFJQyxNQUFNLHFFQUFxRSx3RUFBd0UscUNBQXFDO1FBQ3BNO1FBQ0EsU0FBU0MsWUFBWTtZQUNuQixNQUFNLElBQUlELE1BQU0sbUVBQW1FLHFFQUFxRSx3RUFBd0UseUNBQXlDO1FBQzNRO1FBRUFFLDBEQUEwRCxHQUFHYjtRQUM3RGEsb0JBQW9CLEdBQUdIO1FBQ3ZCRyxpQkFBaUIsR0FBR0Q7UUFDcEJDLGVBQWUsR0FBR1I7UUFDbEJRLGVBQWUsR0FBR0o7UUFDbEJJLGVBQWUsR0FBR2Q7SUFDaEI7QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLXJlbmRlcmluZy1zdHViLmRldmVsb3BtZW50LmpzPzhmNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1yZW5kZXJpbmctc3R1Yi5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4zLjAtbmV4dC02ZGRjYmQ0ZjktMjAyMzAyMDknO1xuXG52YXIgSW50ZXJuYWxzID0ge1xuICB1c2luZ0NsaWVudEVudHJ5UG9pbnQ6IGZhbHNlLFxuICBFdmVudHM6IG51bGwsXG4gIERpc3BhdGNoZXI6IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByZWluaXQoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gSW50ZXJuYWxzLkRpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoZGlzcGF0Y2hlcikge1xuICAgIGRpc3BhdGNoZXIucHJlaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IC8vIFdlIGRvbid0IGVycm9yIGJlY2F1c2UgcHJlaW5pdCBuZWVkcyB0byBiZSByZXNpbGllbnQgdG8gYmVpbmcgY2FsbGVkIGluIGEgdmFyaWV0eSBvZiBzY29wZXNcbiAgLy8gYW5kIHRoZSBydW50aW1lIG1heSBub3QgYmUgY2FwYWJsZSBvZiByZXNwb25kaW5nLiBUaGUgZnVuY3Rpb24gaXMgb3B0aW1pc3RpYyBhbmQgbm90IGNyaXRpY2FsXG4gIC8vIHNvIHdlIGZhdm9yIHNpbGVudCBiYWlsb3V0IG92ZXIgd2FybmluZyBvciBlcnJvcmluZy5cblxufVxuZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBJbnRlcm5hbHMuRGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgZGlzcGF0Y2hlci5wcmVsb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gLy8gV2UgZG9uJ3QgZXJyb3IgYmVjYXVzZSBwcmVsb2FkIG5lZWRzIHRvIGJlIHJlc2lsaWVudCB0byBiZWluZyBjYWxsZWQgaW4gYSB2YXJpZXR5IG9mIHNjb3Blc1xuICAvLyBhbmQgdGhlIHJ1bnRpbWUgbWF5IG5vdCBiZSBjYXBhYmxlIG9mIHJlc3BvbmRpbmcuIFRoZSBmdW5jdGlvbiBpcyBvcHRpbWlzdGljIGFuZCBub3QgY3JpdGljYWxcbiAgLy8gc28gd2UgZmF2b3Igc2lsZW50IGJhaWxvdXQgb3ZlciB3YXJuaW5nIG9yIGVycm9yaW5nLlxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVQb3J0YWwgd2FzIGNhbGxlZCBvbiB0aGUgc2VydmVyLiBQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5JyArICcgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIuIFVwZGF0ZSB5b3VyIHByb2dyYW0gdG8gY29uZGl0aW9uYWxseSBjYWxsJyArICcgY3JlYXRlUG9ydGFsIG9uIHRoZSBjbGllbnQgb25seS4nKTtcbn1cbmZ1bmN0aW9uIGZsdXNoU3luYygpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBvbiB0aGUgc2VydmVyLiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYScgKyAnIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBkdXJpbmcgcmVuZGVyIG9yIGluIG1vZHVsZSBzY29wZSB0aGF0IHdhcycgKyAnIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIGFuIGVmZmVjdCBvciBldmVudCBoYW5kbGVyLiBVcGRhdGUgeW91cicgKyAnIHRvIG5vdCBjYWxsIGZsdXNoU3luYyBubyB0aGUgc2VydmVyLicpO1xufVxuXG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMucHJlaW5pdCA9IHByZWluaXQ7XG5leHBvcnRzLnByZWxvYWQgPSBwcmVsb2FkO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdFZlcnNpb24iLCJJbnRlcm5hbHMiLCJ1c2luZ0NsaWVudEVudHJ5UG9pbnQiLCJFdmVudHMiLCJEaXNwYXRjaGVyIiwiY3VycmVudCIsInByZWluaXQiLCJkaXNwYXRjaGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcmVsb2FkIiwiY3JlYXRlUG9ydGFsIiwiRXJyb3IiLCJmbHVzaFN5bmMiLCJleHBvcnRzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-dom-server-rendering-stub.development.js */ \"(sc_server)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXItcmVuZGVyaW5nLXN0dWIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsOE1BQXlCO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vc2VydmVyLXJlbmRlcmluZy1zdHViLmpzP2RmYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItcmVuZGVyaW5nLXN0dWIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1yZW5kZXJpbmctc3R1Yi5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-server-dom-webpack-server.edge.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(sc_server)/./node_modules/next/dist/compiled/react/react.shared-subset.js\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(sc_server)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        var supportsRequestStorage = typeof AsyncLocalStorage === \"function\";\n        var requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null;\n        var VIEW_SIZE = 512;\n        var currentView = null;\n        var writtenBytes = 0;\n        function beginWriting(destination) {\n            currentView = new Uint8Array(VIEW_SIZE);\n            writtenBytes = 0;\n        }\n        function writeChunk(destination, chunk) {\n            if (chunk.length === 0) {\n                return;\n            }\n            if (chunk.length > VIEW_SIZE) {\n                {\n                    if (precomputedChunkSet.has(chunk)) {\n                        error(\"A large precomputed chunk was passed to writeChunk without being copied.\" + \" Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.\" + ' Use \"cloneChunk\" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');\n                    }\n                }\n                // one that is cached by the streaming renderer. We will enqueu\n                // it directly and expect it is not re-used\n                if (writtenBytes > 0) {\n                    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                destination.enqueue(chunk);\n                return;\n            }\n            var bytesToWrite = chunk;\n            var allowableBytes = currentView.length - writtenBytes;\n            if (allowableBytes < bytesToWrite.length) {\n                // this chunk would overflow the current view. We enqueue a full view\n                // and start a new view with the remaining chunk\n                if (allowableBytes === 0) {\n                    // the current view is already full, send it\n                    destination.enqueue(currentView);\n                } else {\n                    // fill up the current view and apply the remaining chunk bytes\n                    // to a new view.\n                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view\n                    destination.enqueue(currentView);\n                    bytesToWrite = bytesToWrite.subarray(allowableBytes);\n                }\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n            currentView.set(bytesToWrite, writtenBytes);\n            writtenBytes += bytesToWrite.length;\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more\n            return true;\n        }\n        function completeWriting(destination) {\n            if (currentView && writtenBytes > 0) {\n                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));\n                currentView = null;\n                writtenBytes = 0;\n            }\n        }\n        function close(destination) {\n            destination.close();\n        }\n        var textEncoder = new TextEncoder();\n        function stringToChunk(content) {\n            return textEncoder.encode(content);\n        }\n        var precomputedChunkSet = new Set();\n        function stringToPrecomputedChunk(content) {\n            var precomputedChunk = textEncoder.encode(content);\n            {\n                precomputedChunkSet.add(precomputedChunk);\n            }\n            return precomputedChunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[method-unbinding]\n            if (typeof destination.error === \"function\") {\n                // $FlowFixMe: This is an Error object or the destination accepts other types.\n                destination.error(error);\n            } else {\n                // Earlier implementations doesn't support this method. In that environment you're\n                // supposed to throw from a promise returned but we don't return a promise in our\n                // approach. We could fork this implementation but this is environment is an edge\n                // case to begin with. It's even less common to run this in an older environment.\n                // Even then, this is not where errors are supposed to happen and they get reported\n                // to a global callback in addition to this anyway. So it's fine just to close this.\n                destination.close();\n            }\n        }\n        // This file is an intermediate layer to translate between Flight\n        var stringify = JSON.stringify;\n        function serializeRowHeader(tag, id) {\n            return id.toString(16) + \":\" + tag;\n        }\n        function processErrorChunkProd(request, id, digest) {\n            {\n                // These errors should never make it into a build so we don't need to encode them in codes.json\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error(\"processErrorChunkProd should never be called while in development mode. Use processErrorChunkDev instead. This is a bug in React.\");\n            }\n            var errorInfo = {\n                digest: digest\n            };\n            var row = serializeRowHeader(\"E\", id) + stringify(errorInfo) + \"\\n\";\n        }\n        function processErrorChunkDev(request, id, digest, message, stack) {\n            var errorInfo = {\n                digest: digest,\n                message: message,\n                stack: stack\n            };\n            var row = serializeRowHeader(\"E\", id) + stringify(errorInfo) + \"\\n\";\n            return stringToChunk(row);\n        }\n        function processModelChunk(request, id, model) {\n            var json = stringify(model, request.toJSON);\n            var row = id.toString(16) + \":\" + json + \"\\n\";\n            return stringToChunk(row);\n        }\n        function processReferenceChunk(request, id, reference) {\n            var json = stringify(reference);\n            var row = id.toString(16) + \":\" + json + \"\\n\";\n            return stringToChunk(row);\n        }\n        function processModuleChunk(request, id, moduleMetaData) {\n            var json = stringify(moduleMetaData);\n            var row = serializeRowHeader(\"I\", id) + json + \"\\n\";\n            return stringToChunk(row);\n        }\n        // eslint-disable-next-line no-unused-vars\n        var CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\");\n        function getClientReferenceKey(reference) {\n            return reference.filepath + \"#\" + reference.name + (reference.async ? \"#async\" : \"\");\n        }\n        function isClientReference(reference) {\n            return reference.$$typeof === CLIENT_REFERENCE_TAG;\n        }\n        function resolveModuleMetaData(config, clientReference) {\n            var resolvedModuleData = config[clientReference.filepath][clientReference.name];\n            if (clientReference.async) {\n                return {\n                    id: resolvedModuleData.id,\n                    chunks: resolvedModuleData.chunks,\n                    name: resolvedModuleData.name,\n                    async: true\n                };\n            } else {\n                return resolvedModuleData;\n            }\n        }\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\n        // It is handled by React separately and shouldn't be written to the DOM.\n        var RESERVED = 0; // A simple string attribute.\n        // Attributes that aren't in the filter are presumed to have this type.\n        var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called\n        // \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n        // When true, it should be set to a \"true\" string.\n        // When false, it should be set to a \"false\" string.\n        var BOOLEANISH_STRING = 2; // A real boolean attribute.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        // For any other value, should be present with that value.\n        var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.\n        // When falsy, it should be removed.\n        var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.\n        // When falsy, it should be removed.\n        var POSITIVE_NUMERIC = 6;\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {\n            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n            this.attributeName = attributeName;\n            this.attributeNamespace = attributeNamespace;\n            this.mustUseProperty = mustUseProperty;\n            this.propertyName = name;\n            this.type = type;\n            this.sanitizeURL = sanitizeURL;\n            this.removeEmptyString = removeEmptyString;\n        } // When adding attributes to this list, be sure to also add them to\n        // the `possibleStandardNames` module to ensure casing and incorrect\n        // name warnings.\n        var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.\n        var reservedProps = [\n            \"children\",\n            \"dangerouslySetInnerHTML\",\n            // elements (not just inputs). Now that ReactDOMInput assigns to the\n            // defaultValue property -- do we need this?\n            \"defaultValue\",\n            \"defaultChecked\",\n            \"innerHTML\",\n            \"suppressContentEditableWarning\",\n            \"suppressHydrationWarning\",\n            \"style\"\n        ];\n        reservedProps.forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);\n        }); // A few React string attributes have a different name.\n        // This is a mapping from React prop names to the attribute names.\n        [\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"className\",\n                \"class\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ]\n        ].forEach(function(_ref) {\n            var name = _ref[0], attributeName = _ref[1];\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        [\n            \"contentEditable\",\n            \"draggable\",\n            \"spellCheck\",\n            \"value\"\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);\n        }); // These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        // Since these are SVG attributes, their attribute names are case-sensitive.\n        [\n            \"autoReverse\",\n            \"externalResourcesRequired\",\n            \"focusable\",\n            \"preserveAlpha\"\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);\n        }); // These are HTML boolean attributes.\n        [\n            \"allowFullScreen\",\n            \"async\",\n            // on the client side because the browsers are inconsistent. Instead we call focus().\n            \"autoFocus\",\n            \"autoPlay\",\n            \"controls\",\n            \"default\",\n            \"defer\",\n            \"disabled\",\n            \"disablePictureInPicture\",\n            \"disableRemotePlayback\",\n            \"formNoValidate\",\n            \"hidden\",\n            \"loop\",\n            \"noModule\",\n            \"noValidate\",\n            \"open\",\n            \"playsInline\",\n            \"readOnly\",\n            \"required\",\n            \"reversed\",\n            \"scoped\",\n            \"seamless\",\n            \"itemScope\"\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);\n        }); // These are the few React props that we set as DOM properties\n        // rather than attributes. These are all booleans.\n        [\n            \"checked\",\n            // disabled with `removeAttribute`. We have special logic for handling this.\n            \"multiple\",\n            \"muted\",\n            \"selected\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);\n        }); // These are HTML attributes that are \"overloaded booleans\": they behave like\n        // booleans, but can also accept a string value.\n        [\n            \"capture\",\n            \"download\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);\n        }); // These are HTML attributes that must be positive numbers.\n        [\n            \"cols\",\n            \"rows\",\n            \"size\",\n            \"span\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);\n        }); // These are HTML attributes that must be numbers.\n        [\n            \"rowSpan\",\n            \"start\"\n        ].forEach(function(name) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);\n        });\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\n        var capitalize = function(token) {\n            return token[1].toUpperCase();\n        }; // This is a list of all SVG attributes that need special casing, namespacing,\n        // or boolean value assignment. Regular attributes that just accept strings\n        // and have the same names are omitted, just like in the HTML attribute filter.\n        // Some of these attributes can be hard to find. This list was created by\n        // scraping the MDN documentation.\n        [\n            \"accent-height\",\n            \"alignment-baseline\",\n            \"arabic-form\",\n            \"baseline-shift\",\n            \"cap-height\",\n            \"clip-path\",\n            \"clip-rule\",\n            \"color-interpolation\",\n            \"color-interpolation-filters\",\n            \"color-profile\",\n            \"color-rendering\",\n            \"dominant-baseline\",\n            \"enable-background\",\n            \"fill-opacity\",\n            \"fill-rule\",\n            \"flood-color\",\n            \"flood-opacity\",\n            \"font-family\",\n            \"font-size\",\n            \"font-size-adjust\",\n            \"font-stretch\",\n            \"font-style\",\n            \"font-variant\",\n            \"font-weight\",\n            \"glyph-name\",\n            \"glyph-orientation-horizontal\",\n            \"glyph-orientation-vertical\",\n            \"horiz-adv-x\",\n            \"horiz-origin-x\",\n            \"image-rendering\",\n            \"letter-spacing\",\n            \"lighting-color\",\n            \"marker-end\",\n            \"marker-mid\",\n            \"marker-start\",\n            \"overline-position\",\n            \"overline-thickness\",\n            \"paint-order\",\n            \"panose-1\",\n            \"pointer-events\",\n            \"rendering-intent\",\n            \"shape-rendering\",\n            \"stop-color\",\n            \"stop-opacity\",\n            \"strikethrough-position\",\n            \"strikethrough-thickness\",\n            \"stroke-dasharray\",\n            \"stroke-dashoffset\",\n            \"stroke-linecap\",\n            \"stroke-linejoin\",\n            \"stroke-miterlimit\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"text-anchor\",\n            \"text-decoration\",\n            \"text-rendering\",\n            \"transform-origin\",\n            \"underline-position\",\n            \"underline-thickness\",\n            \"unicode-bidi\",\n            \"unicode-range\",\n            \"units-per-em\",\n            \"v-alphabetic\",\n            \"v-hanging\",\n            \"v-ideographic\",\n            \"v-mathematical\",\n            \"vector-effect\",\n            \"vert-adv-y\",\n            \"vert-origin-x\",\n            \"vert-origin-y\",\n            \"word-spacing\",\n            \"writing-mode\",\n            \"xmlns:xlink\",\n            \"x-height\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize); // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // String SVG attributes with the xlink namespace.\n        [\n            \"xlink:actuate\",\n            \"xlink:arcrole\",\n            \"xlink:role\",\n            \"xlink:show\",\n            \"xlink:title\",\n            \"xlink:type\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize); // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/1999/xlink\", false, false);\n        }); // String SVG attributes with the xml namespace.\n        [\n            \"xml:base\",\n            \"xml:lang\",\n            \"xml:space\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize); // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/XML/1998/namespace\", false, false);\n        }); // These attribute exists both in HTML and SVG.\n        // The attribute name is case-sensitive in SVG so we can't just use\n        // the React name like we do for attributes that exist only in HTML.\n        [\n            \"tabIndex\",\n            \"crossOrigin\"\n        ].forEach(function(attributeName) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);\n        }); // These attributes accept URLs. These must not allow javascript: URLS.\n        // These will also need to accept Trusted Types object in the future.\n        var xlinkHref = \"xlinkHref\"; // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n        properties[xlinkHref] = new PropertyInfoRecord(\"xlinkHref\", STRING, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n        [\n            \"src\",\n            \"href\",\n            \"action\",\n            \"formAction\"\n        ].forEach(function(attributeName) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);\n        });\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var isUnitlessNumber = {\n            animationIterationCount: true,\n            aspectRatio: true,\n            borderImageOutset: true,\n            borderImageSlice: true,\n            borderImageWidth: true,\n            boxFlex: true,\n            boxFlexGroup: true,\n            boxOrdinalGroup: true,\n            columnCount: true,\n            columns: true,\n            flex: true,\n            flexGrow: true,\n            flexPositive: true,\n            flexShrink: true,\n            flexNegative: true,\n            flexOrder: true,\n            gridArea: true,\n            gridRow: true,\n            gridRowEnd: true,\n            gridRowSpan: true,\n            gridRowStart: true,\n            gridColumn: true,\n            gridColumnEnd: true,\n            gridColumnSpan: true,\n            gridColumnStart: true,\n            fontWeight: true,\n            lineClamp: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            tabSize: true,\n            widows: true,\n            zIndex: true,\n            zoom: true,\n            // SVG-related properties\n            fillOpacity: true,\n            floodOpacity: true,\n            stopOpacity: true,\n            strokeDasharray: true,\n            strokeDashoffset: true,\n            strokeMiterlimit: true,\n            strokeOpacity: true,\n            strokeWidth: true\n        };\n        /**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */ function prefixKey(prefix, key) {\n            return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        /**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */ var prefixes = [\n            \"Webkit\",\n            \"ms\",\n            \"Moz\",\n            \"O\"\n        ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n        // infinite loop, because it iterates over the newly added props too.\n        Object.keys(isUnitlessNumber).forEach(function(prop) {\n            prefixes.forEach(function(prefix) {\n                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n            });\n        });\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(p,q,v){function r(l){this.s=l}for(var t=$RC,u=$RM,m=new Map,n=document,g,e,f=n.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),d=0;e=f[d++];)m.set(e.dataset.precedence,g=e);e=0;f=[];for(var c,h,b,a;c=v[e++];){var k=0;h=c[k++];if(b=u.get(h))\"l\"!==b.s&&f.push(b);else{a=n.createElement(\"link\");a.href=h;a.rel=\"stylesheet\";for(a.dataset.precedence=d=c[k++];b=c[k++];)a.setAttribute(b,c[k++]);b=a._p=new Promise(function(l,w){a.onload=l;a.onerror=w});b.then(r.bind(b,\\n\"l\"),r.bind(b,\"e\"));u.set(h,b);f.push(b);c=m.get(d)||g;c===g&&(g=a);m.set(d,a);c?c.parentNode.insertBefore(a,c.nextSibling):(d=n.head,d.insertBefore(a,d.firstChild))}}Promise.all(f).then(t.bind(null,p,q,\"\"),t.bind(null,p,q,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        var DOCTYPE = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        var endTag1 = stringToPrecomputedChunk(\"</\");\n        var endTag2 = stringToPrecomputedChunk(\">\");\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + ';$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + ';$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + \";\" + completeBoundaryWithStyles + ';$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + ';$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var precedencePlaceholderStart = stringToPrecomputedChunk('<style data-precedence=\"');\n        var precedencePlaceholderEnd = stringToPrecomputedChunk('\"></style>');\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext); // On the way back, we push the new ones that weren't common.\n                    pushNode(next);\n                }\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue;\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider() {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                var value = prevSnapshot.parentValue;\n                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue = value;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext(context) {\n            var value = context._currentValue;\n            return value;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFizzWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop, noop);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        var currentRequest = null;\n        var thenableIndexCounter = 0;\n        var thenableState = null;\n        function prepareToUseHooksForRequest(request) {\n            currentRequest = request;\n        }\n        function resetHooksForRequest() {\n            currentRequest = null;\n        }\n        function prepareToUseHooksForComponent(prevThenableState) {\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function readContext$1(context) {\n            {\n                if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {\n                    if (isClientReference(context)) {\n                        error(\"Cannot read a Client Context from a Server Component.\");\n                    } else {\n                        error(\"Only createServerContext is supported in Server Components.\");\n                    }\n                }\n                if (currentRequest === null) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext(context);\n        }\n        var HooksDispatcher = {\n            useMemo: function(nextCreate) {\n                return nextCreate();\n            },\n            useCallback: function(callback) {\n                return callback;\n            },\n            useDebugValue: function() {},\n            useDeferredValue: unsupportedHook,\n            useTransition: unsupportedHook,\n            readContext: readContext$1,\n            useContext: readContext$1,\n            useReducer: unsupportedHook,\n            useRef: unsupportedHook,\n            useState: unsupportedHook,\n            useInsertionEffect: unsupportedHook,\n            useLayoutEffect: unsupportedHook,\n            useImperativeHandle: unsupportedHook,\n            useEffect: unsupportedHook,\n            useId: useId,\n            useMutableSource: unsupportedHook,\n            useSyncExternalStore: unsupportedHook,\n            useCacheRefresh: function() {\n                return unsupportedRefresh;\n            },\n            useMemoCache: function(size) {\n                var data = new Array(size);\n                for(var i = 0; i < size; i++){\n                    data[i] = REACT_MEMO_CACHE_SENTINEL;\n                }\n                return data;\n            },\n            use: use\n        };\n        function unsupportedHook() {\n            throw new Error(\"This Hook is not supported in Server Components.\");\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Refreshing the cache is not supported in Server Components.\");\n        }\n        function useId() {\n            if (currentRequest === null) {\n                throw new Error(\"useId can only be used while React is rendering\");\n            }\n            var id = currentRequest.identifierCount++; // use 'S' for Flight components to distinguish from 'R' and 'r' in Fizz/Client\n            return \":\" + currentRequest.identifierPrefix + \"S\" + id.toString(32) + \":\";\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\" || typeof usable === \"function\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable; // Track the position of the thenable within this fiber.\n                    var index = thenableIndexCounter;\n                    thenableIndexCounter += 1;\n                    if (thenableState === null) {\n                        thenableState = createThenableState();\n                    }\n                    return trackUsedThenable(thenableState, thenable, index);\n                } else if (usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext$1(context);\n                }\n            }\n            {\n                if (isClientReference(usable)) {\n                    error(\"Cannot use() an already resolved Client Reference.\");\n                }\n            }\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function createSignal() {\n            return new AbortController().signal;\n        }\n        function resolveCache() {\n            if (currentCache) return currentCache;\n            if (supportsRequestStorage) {\n                var cache = requestStorage.getStore();\n                if (cache) return cache;\n            } // Since we override the dispatcher all the time, we're effectively always\n            // active and so to support cache() and fetch() outside of render, we yield\n            // an empty Map.\n            return new Map();\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: function() {\n                var cache = resolveCache();\n                var entry = cache.get(createSignal);\n                if (entry === undefined) {\n                    entry = createSignal();\n                    cache.set(createSignal, entry);\n                }\n                return entry;\n            },\n            getCacheForType: function(resourceType) {\n                var cache = resolveCache();\n                var entry = cache.get(resourceType);\n                if (entry === undefined) {\n                    entry = resourceType(); // TODO: Warn if undefined?\n                    cache.set(resourceType, entry);\n                }\n                return entry;\n            }\n        };\n        var currentCache = null;\n        function setCurrentCache(cache) {\n            currentCache = cache;\n            return currentCache;\n        }\n        function getCurrentCache() {\n            return currentCache;\n        }\n        var ContextRegistry = ReactSharedInternals.ContextRegistry;\n        function getOrCreateServerContext(globalName) {\n            if (!ContextRegistry[globalName]) {\n                ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);\n            }\n            return ContextRegistry[globalName];\n        }\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n        }\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2;\n        function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {\n            if (ReactCurrentCache.current !== null && ReactCurrentCache.current !== DefaultCacheDispatcher) {\n                throw new Error(\"Currently React only supports one RSC renderer at a time.\");\n            }\n            ReactCurrentCache.current = DefaultCacheDispatcher;\n            var abortSet = new Set();\n            var pingedTasks = [];\n            var request = {\n                status: OPEN,\n                fatalError: null,\n                destination: null,\n                bundlerConfig: bundlerConfig,\n                cache: new Map(),\n                nextChunkId: 0,\n                pendingChunks: 0,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                completedModuleChunks: [],\n                completedJSONChunks: [],\n                completedErrorChunks: [],\n                writtenSymbols: new Map(),\n                writtenModules: new Map(),\n                writtenProviders: new Map(),\n                identifierPrefix: identifierPrefix || \"\",\n                identifierCount: 1,\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                // $FlowFixMe[missing-this-annot]\n                toJSON: function(key, value) {\n                    return resolveModelToJSON(request, this, key, value);\n                }\n            };\n            request.pendingChunks++;\n            var rootContext = createRootContext(context);\n            var rootTask = createTask(request, model, rootContext, abortSet);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        function createRootContext(reqContext) {\n            return importServerContexts(reqContext);\n        }\n        var POP = {}; // Used for DEV messages to keep track of which parent rendered some props,\n        // in case they error.\n        var jsxPropsParents = new WeakMap();\n        var jsxChildrenParents = new WeakMap();\n        function serializeThenable(request, thenable) {\n            request.pendingChunks++;\n            var newTask = createTask(request, null, getActiveContext(), request.abortableTasks);\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        // We have the resolved value, we can go ahead and schedule it for serialization.\n                        newTask.model = thenable.value;\n                        pingTask(request, newTask);\n                        return newTask.id;\n                    }\n                case \"rejected\":\n                    {\n                        var x = thenable.reason;\n                        var digest = logRecoverableError(request, x);\n                        {\n                            var _getErrorMessageAndSt = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt.message, stack = _getErrorMessageAndSt.stack;\n                            emitErrorChunkDev(request, newTask.id, digest, message, stack);\n                        }\n                        return newTask.id;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") {\n                            break;\n                        }\n                        var pendingThenable = thenable;\n                        pendingThenable.status = \"pending\";\n                        pendingThenable.then(function(fulfilledValue) {\n                            if (thenable.status === \"pending\") {\n                                var fulfilledThenable = thenable;\n                                fulfilledThenable.status = \"fulfilled\";\n                                fulfilledThenable.value = fulfilledValue;\n                            }\n                        }, function(error) {\n                            if (thenable.status === \"pending\") {\n                                var rejectedThenable = thenable;\n                                rejectedThenable.status = \"rejected\";\n                                rejectedThenable.reason = error;\n                            }\n                        });\n                        break;\n                    }\n            }\n            thenable.then(function(value) {\n                newTask.model = value;\n                pingTask(request, newTask);\n            }, function(reason) {\n                // TODO: Is it safe to directly emit these without being inside a retry?\n                var digest = logRecoverableError(request, reason);\n                {\n                    var _getErrorMessageAndSt2 = getErrorMessageAndStackDev(reason), _message = _getErrorMessageAndSt2.message, _stack = _getErrorMessageAndSt2.stack;\n                    emitErrorChunkDev(request, newTask.id, digest, _message, _stack);\n                }\n            });\n            return newTask.id;\n        }\n        function readThenable(thenable) {\n            if (thenable.status === \"fulfilled\") {\n                return thenable.value;\n            } else if (thenable.status === \"rejected\") {\n                throw thenable.reason;\n            }\n            throw thenable;\n        }\n        function createLazyWrapperAroundWakeable(wakeable) {\n            // This is a temporary fork of the `use` implementation until we accept\n            // promises everywhere.\n            var thenable = wakeable;\n            switch(thenable.status){\n                case \"fulfilled\":\n                case \"rejected\":\n                    break;\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") {\n                            break;\n                        }\n                        var pendingThenable = thenable;\n                        pendingThenable.status = \"pending\";\n                        pendingThenable.then(function(fulfilledValue) {\n                            if (thenable.status === \"pending\") {\n                                var fulfilledThenable = thenable;\n                                fulfilledThenable.status = \"fulfilled\";\n                                fulfilledThenable.value = fulfilledValue;\n                            }\n                        }, function(error) {\n                            if (thenable.status === \"pending\") {\n                                var rejectedThenable = thenable;\n                                rejectedThenable.status = \"rejected\";\n                                rejectedThenable.reason = error;\n                            }\n                        });\n                        break;\n                    }\n            }\n            var lazyType = {\n                $$typeof: REACT_LAZY_TYPE,\n                _payload: thenable,\n                _init: readThenable\n            };\n            return lazyType;\n        }\n        function attemptResolveElement(request, type, key, ref, props, prevThenableState) {\n            if (ref !== null && ref !== undefined) {\n                // When the ref moves to the regular props object this will implicitly\n                // throw for functions. We could probably relax it to a DEV warning for other\n                // cases.\n                throw new Error(\"Refs cannot be used in Server Components, nor passed to Client Components.\");\n            }\n            {\n                jsxPropsParents.set(props, type);\n                if (typeof props.children === \"object\" && props.children !== null) {\n                    jsxChildrenParents.set(props.children, type);\n                }\n            }\n            if (typeof type === \"function\") {\n                if (isClientReference(type)) {\n                    // This is a reference to a Client Component.\n                    return [\n                        REACT_ELEMENT_TYPE,\n                        type,\n                        key,\n                        props\n                    ];\n                } // This is a server-side component.\n                prepareToUseHooksForComponent(prevThenableState);\n                var result = type(props);\n                if (typeof result === \"object\" && result !== null && typeof result.then === \"function\") {\n                    // When the return value is in children position we can resolve it immediately,\n                    // to its value without a wrapper if it's synchronously available.\n                    var thenable = result;\n                    if (thenable.status === \"fulfilled\") {\n                        return thenable.value;\n                    } // TODO: Once we accept Promises as children on the client, we can just return\n                    // the thenable here.\n                    return createLazyWrapperAroundWakeable(result);\n                }\n                return result;\n            } else if (typeof type === \"string\") {\n                // This is a host element. E.g. HTML.\n                return [\n                    REACT_ELEMENT_TYPE,\n                    type,\n                    key,\n                    props\n                ];\n            } else if (typeof type === \"symbol\") {\n                if (type === REACT_FRAGMENT_TYPE) {\n                    // For key-less fragments, we add a small optimization to avoid serializing\n                    // it as a wrapper.\n                    // TODO: If a key is specified, we should propagate its key to any children.\n                    // Same as if a Server Component has a key.\n                    return props.children;\n                } // This might be a built-in React component. We'll let the client decide.\n                // Any built-in works as long as its props are serializable.\n                return [\n                    REACT_ELEMENT_TYPE,\n                    type,\n                    key,\n                    props\n                ];\n            } else if (type != null && typeof type === \"object\") {\n                if (isClientReference(type)) {\n                    // This is a reference to a Client Component.\n                    return [\n                        REACT_ELEMENT_TYPE,\n                        type,\n                        key,\n                        props\n                    ];\n                }\n                switch(type.$$typeof){\n                    case REACT_LAZY_TYPE:\n                        {\n                            var payload = type._payload;\n                            var init = type._init;\n                            var wrappedType = init(payload);\n                            return attemptResolveElement(request, wrappedType, key, ref, props, prevThenableState);\n                        }\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            var render = type.render;\n                            prepareToUseHooksForComponent(prevThenableState);\n                            return render(props, undefined);\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            return attemptResolveElement(request, type.type, key, ref, props, prevThenableState);\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            pushProvider(type._context, props.value);\n                            {\n                                var extraKeys = Object.keys(props).filter(function(value) {\n                                    if (value === \"children\" || value === \"value\") {\n                                        return false;\n                                    }\n                                    return true;\n                                });\n                                if (extraKeys.length !== 0) {\n                                    error(\"ServerContext can only have a value prop and children. Found: %s\", JSON.stringify(extraKeys));\n                                }\n                            }\n                            return [\n                                REACT_ELEMENT_TYPE,\n                                type,\n                                key,\n                                {\n                                    value: props.value,\n                                    children: props.children,\n                                    __pop: POP\n                                }\n                            ];\n                        }\n                }\n            }\n            throw new Error(\"Unsupported Server Component type: \" + describeValueForErrorMessage(type));\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (pingedTasks.length === 1) {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createTask(request, model, context, abortSet) {\n            var id = request.nextChunkId++;\n            var task = {\n                id: id,\n                status: PENDING,\n                model: model,\n                context: context,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                thenableState: null\n            };\n            abortSet.add(task);\n            return task;\n        }\n        function serializeByValueID(id) {\n            return \"$\" + id.toString(16);\n        }\n        function serializeLazyID(id) {\n            return \"$L\" + id.toString(16);\n        }\n        function serializePromiseID(id) {\n            return \"$@\" + id.toString(16);\n        }\n        function serializeSymbolReference(name) {\n            return \"$S\" + name;\n        }\n        function serializeProviderReference(name) {\n            return \"$P\" + name;\n        }\n        function serializeClientReference(request, parent, key, moduleReference) {\n            var moduleKey = getClientReferenceKey(moduleReference);\n            var writtenModules = request.writtenModules;\n            var existingId = writtenModules.get(moduleKey);\n            if (existingId !== undefined) {\n                if (parent[0] === REACT_ELEMENT_TYPE && key === \"1\") {\n                    // If we're encoding the \"type\" of an element, we can refer\n                    // to that by a lazy reference instead of directly since React\n                    // knows how to deal with lazy values. This lets us suspend\n                    // on this component rather than its parent until the code has\n                    // loaded.\n                    return serializeLazyID(existingId);\n                }\n                return serializeByValueID(existingId);\n            }\n            try {\n                var moduleMetaData = resolveModuleMetaData(request.bundlerConfig, moduleReference);\n                request.pendingChunks++;\n                var moduleId = request.nextChunkId++;\n                emitModuleChunk(request, moduleId, moduleMetaData);\n                writtenModules.set(moduleKey, moduleId);\n                if (parent[0] === REACT_ELEMENT_TYPE && key === \"1\") {\n                    // If we're encoding the \"type\" of an element, we can refer\n                    // to that by a lazy reference instead of directly since React\n                    // knows how to deal with lazy values. This lets us suspend\n                    // on this component rather than its parent until the code has\n                    // loaded.\n                    return serializeLazyID(moduleId);\n                }\n                return serializeByValueID(moduleId);\n            } catch (x) {\n                request.pendingChunks++;\n                var errorId = request.nextChunkId++;\n                var digest = logRecoverableError(request, x);\n                {\n                    var _getErrorMessageAndSt3 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt3.message, stack = _getErrorMessageAndSt3.stack;\n                    emitErrorChunkDev(request, errorId, digest, message, stack);\n                }\n                return serializeByValueID(errorId);\n            }\n        }\n        function escapeStringValue(value) {\n            if (value[0] === \"$\") {\n                // We need to escape $ or @ prefixed strings since we use those to encode\n                // references to IDs and as special symbol values.\n                return \"$\" + value;\n            } else {\n                return value;\n            }\n        }\n        function isObjectPrototype(object) {\n            if (!object) {\n                return false;\n            }\n            var ObjectPrototype = Object.prototype;\n            if (object === ObjectPrototype) {\n                return true;\n            } // It might be an object from a different Realm which is\n            // still just a plain simple object.\n            if (Object.getPrototypeOf(object)) {\n                return false;\n            }\n            var names = Object.getOwnPropertyNames(object);\n            for(var i = 0; i < names.length; i++){\n                if (!(names[i] in ObjectPrototype)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function isSimpleObject(object) {\n            if (!isObjectPrototype(Object.getPrototypeOf(object))) {\n                return false;\n            }\n            var names = Object.getOwnPropertyNames(object);\n            for(var i = 0; i < names.length; i++){\n                var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);\n                if (!descriptor) {\n                    return false;\n                }\n                if (!descriptor.enumerable) {\n                    if ((names[i] === \"key\" || names[i] === \"ref\") && typeof descriptor.get === \"function\") {\n                        continue;\n                    }\n                    return false;\n                }\n            }\n            return true;\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeKeyForErrorMessage(key) {\n            var encodedKey = JSON.stringify(key);\n            return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n        }\n        function describeValueForErrorMessage(value) {\n            switch(typeof value){\n                case \"string\":\n                    {\n                        return JSON.stringify(value.length <= 10 ? value : value.substr(0, 10) + \"...\");\n                    }\n                case \"object\":\n                    {\n                        if (isArray(value)) {\n                            return \"[...]\";\n                        }\n                        var name = objectName(value);\n                        if (name === \"Object\") {\n                            return \"{...}\";\n                        }\n                        return name;\n                    }\n                case \"function\":\n                    return \"function\";\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describeElementType(type) {\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeElementType(type.render);\n                    case REACT_MEMO_TYPE:\n                        return describeElementType(type.type);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeElementType(init(payload));\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        function describeObjectForErrorMessage(objectOrArray, expandedName) {\n            var objKind = objectName(objectOrArray);\n            if (objKind !== \"Object\" && objKind !== \"Array\") {\n                return objKind;\n            }\n            var str = \"\";\n            var start = -1;\n            var length = 0;\n            if (isArray(objectOrArray)) {\n                if (jsxChildrenParents.has(objectOrArray)) {\n                    // Print JSX Children\n                    var type = jsxChildrenParents.get(objectOrArray);\n                    str = \"<\" + describeElementType(type) + \">\";\n                    var array = objectOrArray;\n                    for(var i = 0; i < array.length; i++){\n                        var value = array[i];\n                        var substr = void 0;\n                        if (typeof value === \"string\") {\n                            substr = value;\n                        } else if (typeof value === \"object\" && value !== null) {\n                            // $FlowFixMe[incompatible-call] found when upgrading Flow\n                            substr = \"{\" + describeObjectForErrorMessage(value) + \"}\";\n                        } else {\n                            substr = \"{\" + describeValueForErrorMessage(value) + \"}\";\n                        }\n                        if (\"\" + i === expandedName) {\n                            start = str.length;\n                            length = substr.length;\n                            str += substr;\n                        } else if (substr.length < 15 && str.length + substr.length < 40) {\n                            str += substr;\n                        } else {\n                            str += \"{...}\";\n                        }\n                    }\n                    str += \"</\" + describeElementType(type) + \">\";\n                } else {\n                    // Print Array\n                    str = \"[\";\n                    var _array = objectOrArray;\n                    for(var _i = 0; _i < _array.length; _i++){\n                        if (_i > 0) {\n                            str += \", \";\n                        }\n                        var _value = _array[_i];\n                        var _substr = void 0;\n                        if (typeof _value === \"object\" && _value !== null) {\n                            // $FlowFixMe[incompatible-call] found when upgrading Flow\n                            _substr = describeObjectForErrorMessage(_value);\n                        } else {\n                            _substr = describeValueForErrorMessage(_value);\n                        }\n                        if (\"\" + _i === expandedName) {\n                            start = str.length;\n                            length = _substr.length;\n                            str += _substr;\n                        } else if (_substr.length < 10 && str.length + _substr.length < 40) {\n                            str += _substr;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \"]\";\n                }\n            } else {\n                if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {\n                    str = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n                } else if (jsxPropsParents.has(objectOrArray)) {\n                    // Print JSX\n                    var _type = jsxPropsParents.get(objectOrArray);\n                    str = \"<\" + (describeElementType(_type) || \"...\");\n                    var object = objectOrArray;\n                    var names = Object.keys(object);\n                    for(var _i2 = 0; _i2 < names.length; _i2++){\n                        str += \" \";\n                        var name = names[_i2];\n                        str += describeKeyForErrorMessage(name) + \"=\";\n                        var _value2 = object[name];\n                        var _substr2 = void 0;\n                        if (name === expandedName && typeof _value2 === \"object\" && _value2 !== null) {\n                            // $FlowFixMe[incompatible-call] found when upgrading Flow\n                            _substr2 = describeObjectForErrorMessage(_value2);\n                        } else {\n                            _substr2 = describeValueForErrorMessage(_value2);\n                        }\n                        if (typeof _value2 !== \"string\") {\n                            _substr2 = \"{\" + _substr2 + \"}\";\n                        }\n                        if (name === expandedName) {\n                            start = str.length;\n                            length = _substr2.length;\n                            str += _substr2;\n                        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {\n                            str += _substr2;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \">\";\n                } else {\n                    // Print Object\n                    str = \"{\";\n                    var _object = objectOrArray;\n                    var _names = Object.keys(_object);\n                    for(var _i3 = 0; _i3 < _names.length; _i3++){\n                        if (_i3 > 0) {\n                            str += \", \";\n                        }\n                        var _name = _names[_i3];\n                        str += describeKeyForErrorMessage(_name) + \": \";\n                        var _value3 = _object[_name];\n                        var _substr3 = void 0;\n                        if (typeof _value3 === \"object\" && _value3 !== null) {\n                            // $FlowFixMe[incompatible-call] found when upgrading Flow\n                            _substr3 = describeObjectForErrorMessage(_value3);\n                        } else {\n                            _substr3 = describeValueForErrorMessage(_value3);\n                        }\n                        if (_name === expandedName) {\n                            start = str.length;\n                            length = _substr3.length;\n                            str += _substr3;\n                        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {\n                            str += _substr3;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \"}\";\n                }\n            }\n            if (expandedName === undefined) {\n                return str;\n            }\n            if (start > -1 && length > 0) {\n                var highlight = \" \".repeat(start) + \"^\".repeat(length);\n                return \"\\n  \" + str + \"\\n  \" + highlight;\n            }\n            return \"\\n  \" + str;\n        }\n        var insideContextProps = null;\n        var isInsideContextValue = false;\n        function resolveModelToJSON(request, parent, key, value) {\n            {\n                // $FlowFixMe\n                var originalValue = parent[key];\n                if (typeof originalValue === \"object\" && originalValue !== value) {\n                    if (objectName(originalValue) !== \"Object\") {\n                        var jsxParentType = jsxChildrenParents.get(parent);\n                        if (typeof jsxParentType === \"string\") {\n                            error(\"%s objects cannot be rendered as text children. Try formatting it using toString().%s\", objectName(originalValue), describeObjectForErrorMessage(parent, key));\n                        } else {\n                            error(\"Only plain objects can be passed to Client Components from Server Components. \" + \"%s objects are not supported.%s\", objectName(originalValue), describeObjectForErrorMessage(parent, key));\n                        }\n                    } else {\n                        error(\"Only plain objects can be passed to Client Components from Server Components. \" + \"Objects with toJSON methods are not supported. Convert it manually \" + \"to a simple value before passing it to props.%s\", describeObjectForErrorMessage(parent, key));\n                    }\n                }\n            }\n            switch(value){\n                case REACT_ELEMENT_TYPE:\n                    return \"$\";\n            }\n            {\n                if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === \"3\") {\n                    insideContextProps = value;\n                } else if (insideContextProps === parent && key === \"value\") {\n                    isInsideContextValue = true;\n                } else if (insideContextProps === parent && key === \"children\") {\n                    isInsideContextValue = false;\n                }\n            }\n            while(typeof value === \"object\" && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)){\n                {\n                    if (isInsideContextValue) {\n                        error(\"React elements are not allowed in ServerContext\");\n                    }\n                }\n                try {\n                    switch(value.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                // TODO: Concatenate keys of parents onto children.\n                                var element = value; // Attempt to render the Server Component.\n                                value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, null);\n                                break;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = value._payload;\n                                var init = value._init;\n                                value = init(payload);\n                                break;\n                            }\n                    }\n                } catch (thrownValue) {\n                    var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                        // Something suspended, we'll need to create a new task and resolve it later.\n                        request.pendingChunks++;\n                        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);\n                        var ping = newTask.ping;\n                        x.then(ping, ping);\n                        newTask.thenableState = getThenableStateAfterSuspending();\n                        return serializeLazyID(newTask.id);\n                    } else {\n                        // Something errored. We'll still send everything we have up until this point.\n                        // We'll replace this element with a lazy reference that throws on the client\n                        // once it gets rendered.\n                        request.pendingChunks++;\n                        var errorId = request.nextChunkId++;\n                        var digest = logRecoverableError(request, x);\n                        {\n                            var _getErrorMessageAndSt4 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt4.message, stack = _getErrorMessageAndSt4.stack;\n                            emitErrorChunkDev(request, errorId, digest, message, stack);\n                        }\n                        return serializeLazyID(errorId);\n                    }\n                }\n            }\n            if (value === null) {\n                return null;\n            }\n            if (typeof value === \"object\") {\n                if (isClientReference(value)) {\n                    return serializeClientReference(request, parent, key, value);\n                } else if (typeof value.then === \"function\") {\n                    // We assume that any object with a .then property is a \"Thenable\" type,\n                    // or a Promise type. Either of which can be represented by a Promise.\n                    var promiseId = serializeThenable(request, value);\n                    return serializePromiseID(promiseId);\n                } else if (value.$$typeof === REACT_PROVIDER_TYPE) {\n                    var providerKey = value._context._globalName;\n                    var writtenProviders = request.writtenProviders;\n                    var providerId = writtenProviders.get(key);\n                    if (providerId === undefined) {\n                        request.pendingChunks++;\n                        providerId = request.nextChunkId++;\n                        writtenProviders.set(providerKey, providerId);\n                        emitProviderChunk(request, providerId, providerKey);\n                    }\n                    return serializeByValueID(providerId);\n                } else if (value === POP) {\n                    popProvider();\n                    {\n                        insideContextProps = null;\n                        isInsideContextValue = false;\n                    }\n                    return undefined;\n                }\n                {\n                    if (value !== null && !isArray(value)) {\n                        // Verify that this is a simple plain object.\n                        if (objectName(value) !== \"Object\") {\n                            error(\"Only plain objects can be passed to Client Components from Server Components. \" + \"%s objects are not supported.%s\", objectName(value), describeObjectForErrorMessage(parent, key));\n                        } else if (!isSimpleObject(value)) {\n                            error(\"Only plain objects can be passed to Client Components from Server Components. \" + \"Classes or other objects with methods are not supported.%s\", describeObjectForErrorMessage(parent, key));\n                        } else if (Object.getOwnPropertySymbols) {\n                            var symbols = Object.getOwnPropertySymbols(value);\n                            if (symbols.length > 0) {\n                                error(\"Only plain objects can be passed to Client Components from Server Components. \" + \"Objects with symbol properties like %s are not supported.%s\", symbols[0].description, describeObjectForErrorMessage(parent, key));\n                            }\n                        }\n                    }\n                }\n                return value;\n            }\n            if (typeof value === \"string\") {\n                return escapeStringValue(value);\n            }\n            if (typeof value === \"boolean\" || typeof value === \"number\" || typeof value === \"undefined\") {\n                return value;\n            }\n            if (typeof value === \"function\") {\n                if (isClientReference(value)) {\n                    return serializeClientReference(request, parent, key, value);\n                }\n                if (/^on[A-Z]/.test(key)) {\n                    throw new Error(\"Event handlers cannot be passed to Client Component props.\" + describeObjectForErrorMessage(parent, key) + \"\\nIf you need interactivity, consider converting part of this to a Client Component.\");\n                } else {\n                    throw new Error(\"Functions cannot be passed directly to Client Components \" + \"because they're not serializable.\" + describeObjectForErrorMessage(parent, key));\n                }\n            }\n            if (typeof value === \"symbol\") {\n                var writtenSymbols = request.writtenSymbols;\n                var existingId = writtenSymbols.get(value);\n                if (existingId !== undefined) {\n                    return serializeByValueID(existingId);\n                } // $FlowFixMe `description` might be undefined\n                var name = value.description;\n                if (Symbol.for(name) !== value) {\n                    throw new Error(\"Only global symbols received from Symbol.for(...) can be passed to Client Components. \" + (\"The symbol Symbol.for(\" + // $FlowFixMe `description` might be undefined\n                    value.description + \") cannot be found among global symbols.\") + describeObjectForErrorMessage(parent, key));\n                }\n                request.pendingChunks++;\n                var symbolId = request.nextChunkId++;\n                emitSymbolChunk(request, symbolId, name);\n                writtenSymbols.set(value, symbolId);\n                return serializeByValueID(symbolId);\n            }\n            if (typeof value === \"bigint\") {\n                throw new Error(\"BigInt (\" + value + \") is not yet supported in Client Component props.\" + describeObjectForErrorMessage(parent, key));\n            }\n            throw new Error(\"Type \" + typeof value + \" is not supported in Client Component props.\" + describeObjectForErrorMessage(parent, key));\n        }\n        function logRecoverableError(request, error) {\n            var onError = request.onError;\n            var errorDigest = onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest || \"\";\n        }\n        function getErrorMessageAndStackDev(error) {\n            {\n                var message;\n                var stack = \"\";\n                try {\n                    if (error instanceof Error) {\n                        // eslint-disable-next-line react-internal/safe-string-coercion\n                        message = String(error.message); // eslint-disable-next-line react-internal/safe-string-coercion\n                        stack = String(error.stack);\n                    } else {\n                        message = \"Error: \" + error;\n                    }\n                } catch (x) {\n                    message = \"An error occurred but serializing the error message failed.\";\n                }\n                return {\n                    message: message,\n                    stack: stack\n                };\n            }\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if an error happens in React internals.\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function emitErrorChunkProd(request, id, digest) {\n            var processedChunk = processErrorChunkProd(request, id, digest);\n            request.completedErrorChunks.push(processedChunk);\n        }\n        function emitErrorChunkDev(request, id, digest, message, stack) {\n            var processedChunk = processErrorChunkDev(request, id, digest, message, stack);\n            request.completedErrorChunks.push(processedChunk);\n        }\n        function emitModuleChunk(request, id, moduleMetaData) {\n            var processedChunk = processModuleChunk(request, id, moduleMetaData);\n            request.completedModuleChunks.push(processedChunk);\n        }\n        function emitSymbolChunk(request, id, name) {\n            var symbolReference = serializeSymbolReference(name);\n            var processedChunk = processReferenceChunk(request, id, symbolReference);\n            request.completedModuleChunks.push(processedChunk);\n        }\n        function emitProviderChunk(request, id, contextName) {\n            var contextReference = serializeProviderReference(contextName);\n            var processedChunk = processReferenceChunk(request, id, contextReference);\n            request.completedJSONChunks.push(processedChunk);\n        }\n        function retryTask(request, task) {\n            if (task.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            }\n            switchContext(task.context);\n            try {\n                var value = task.model;\n                if (typeof value === \"object\" && value !== null && value.$$typeof === REACT_ELEMENT_TYPE) {\n                    // TODO: Concatenate keys of parents onto children.\n                    var element = value; // When retrying a component, reuse the thenableState from the\n                    // previous attempt.\n                    var prevThenableState = task.thenableState; // Attempt to render the Server Component.\n                    // Doing this here lets us reuse this same task if the next component\n                    // also suspends.\n                    task.model = value;\n                    value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, prevThenableState); // Successfully finished this component. We're going to keep rendering\n                    // using the same task, but we reset its thenable state before continuing.\n                    task.thenableState = null; // Keep rendering and reuse the same task. This inner loop is separate\n                    // from the render above because we don't need to reset the thenable state\n                    // until the next time something suspends and retries.\n                    while(typeof value === \"object\" && value !== null && value.$$typeof === REACT_ELEMENT_TYPE){\n                        // TODO: Concatenate keys of parents onto children.\n                        var nextElement = value;\n                        task.model = value;\n                        value = attemptResolveElement(request, nextElement.type, nextElement.key, nextElement.ref, nextElement.props, null);\n                    }\n                }\n                var processedChunk = processModelChunk(request, task.id, value);\n                request.completedJSONChunks.push(processedChunk);\n                request.abortableTasks.delete(task);\n                task.status = COMPLETED;\n            } catch (thrownValue) {\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue; // $FlowFixMe[method-unbinding]\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    // Something suspended again, let's pick it back up later.\n                    var ping = task.ping;\n                    x.then(ping, ping);\n                    task.thenableState = getThenableStateAfterSuspending();\n                    return;\n                } else {\n                    request.abortableTasks.delete(task);\n                    task.status = ERRORED;\n                    var digest = logRecoverableError(request, x);\n                    {\n                        var _getErrorMessageAndSt5 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt5.message, stack = _getErrorMessageAndSt5.stack;\n                        emitErrorChunkDev(request, task.id, digest, message, stack);\n                    }\n                }\n            }\n        }\n        function performWork(request) {\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            var prevCache = getCurrentCache();\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            setCurrentCache(request.cache);\n            prepareToUseHooksForRequest(request);\n            try {\n                var pingedTasks = request.pingedTasks;\n                request.pingedTasks = [];\n                for(var i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                if (request.destination !== null) {\n                    flushCompletedChunks(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                ReactCurrentDispatcher.current = prevDispatcher;\n                setCurrentCache(prevCache);\n                resetHooksForRequest();\n            }\n        }\n        function abortTask(task, request, errorId) {\n            task.status = ABORTED; // Instead of emitting an error per task.id, we emit a model that only\n            // has a single value referencing the error.\n            var ref = serializeByValueID(errorId);\n            var processedChunk = processReferenceChunk(request, task.id, ref);\n            request.completedErrorChunks.push(processedChunk);\n        }\n        function flushCompletedChunks(request, destination) {\n            beginWriting();\n            try {\n                // We emit module chunks first in the stream so that\n                // they can be preloaded as early as possible.\n                var moduleChunks = request.completedModuleChunks;\n                var i = 0;\n                for(; i < moduleChunks.length; i++){\n                    request.pendingChunks--;\n                    var chunk = moduleChunks[i];\n                    var keepWriting = writeChunkAndReturn(destination, chunk);\n                    if (!keepWriting) {\n                        request.destination = null;\n                        i++;\n                        break;\n                    }\n                }\n                moduleChunks.splice(0, i); // Next comes model data.\n                var jsonChunks = request.completedJSONChunks;\n                i = 0;\n                for(; i < jsonChunks.length; i++){\n                    request.pendingChunks--;\n                    var _chunk = jsonChunks[i];\n                    var _keepWriting = writeChunkAndReturn(destination, _chunk);\n                    if (!_keepWriting) {\n                        request.destination = null;\n                        i++;\n                        break;\n                    }\n                }\n                jsonChunks.splice(0, i); // Finally, errors are sent. The idea is that it's ok to delay\n                // any error messages and prioritize display of other parts of\n                // the page.\n                var errorChunks = request.completedErrorChunks;\n                i = 0;\n                for(; i < errorChunks.length; i++){\n                    request.pendingChunks--;\n                    var _chunk2 = errorChunks[i];\n                    var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);\n                    if (!_keepWriting2) {\n                        request.destination = null;\n                        i++;\n                        break;\n                    }\n                }\n                errorChunks.splice(0, i);\n            } finally{\n                completeWriting(destination);\n            }\n            if (request.pendingChunks === 0) {\n                // We're done.\n                close(destination);\n            }\n        }\n        function startWork(request) {\n            if (supportsRequestStorage) {\n                scheduleWork(function() {\n                    return requestStorage.run(request.cache, performWork, request);\n                });\n            } else {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedChunks(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        } // This is called to early terminate a request. It creates an error at all pending tasks.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    // We have tasks to abort. We'll emit one error row and then emit a reference\n                    // to that row from every row that's still remaining.\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    var digest = logRecoverableError(request, error);\n                    request.pendingChunks++;\n                    var errorId = request.nextChunkId++;\n                    if (true) {\n                        var _getErrorMessageAndSt6 = getErrorMessageAndStackDev(error), message = _getErrorMessageAndSt6.message, stack = _getErrorMessageAndSt6.stack;\n                        emitErrorChunkDev(request, errorId, digest, message, stack);\n                    } else {}\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, errorId);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedChunks(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function importServerContexts(contexts) {\n            if (contexts) {\n                var prevContext = getActiveContext();\n                switchContext(rootContextSnapshot);\n                for(var i = 0; i < contexts.length; i++){\n                    var _contexts$i = contexts[i], name = _contexts$i[0], value = _contexts$i[1];\n                    var context = getOrCreateServerContext(name);\n                    pushProvider(context, value);\n                }\n                var importedContext = getActiveContext();\n                switchContext(prevContext);\n                return importedContext;\n            }\n            return rootContextSnapshot;\n        }\n        function renderToReadableStream(model, webpackMap, options) {\n            var request = createRequest(model, webpackMap, options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);\n            if (options && options.signal) {\n                var signal = options.signal;\n                if (signal.aborted) {\n                    abort(request, signal.reason);\n                } else {\n                    var listener = function() {\n                        abort(request, signal.reason);\n                        signal.removeEventListener(\"abort\", listener);\n                    };\n                    signal.addEventListener(\"abort\", listener);\n                }\n            }\n            var stream = new ReadableStream({\n                type: \"bytes\",\n                start: function(controller) {\n                    startWork(request);\n                },\n                pull: function(controller) {\n                    startFlowing(request, controller);\n                },\n                cancel: function(reason) {}\n            }, {\n                highWaterMark: 0\n            });\n            return stream;\n        }\n        exports.renderToReadableStream = renderToReadableStream;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9janMvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrLXNlcnZlci5lZGdlLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDLFlBQVc7UUFDZDtRQUVBLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO1FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO1FBRXZCLElBQUlFLHVCQUF1QkgsTUFBTUksa0RBQWtEO1FBRW5GLFNBQVNDLE1BQU1DLE1BQU0sRUFBRTtZQUNyQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlDLFFBQVFDLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixRQUFRLElBQUlBLFFBQVEsSUFBSSxDQUFDLEdBQUdLLFFBQVEsR0FBR0EsUUFBUUwsT0FBT0ssUUFBUzt3QkFDakhGLElBQUksQ0FBQ0UsUUFBUSxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksTUFBTTtvQkFDcEM7b0JBRUFDLGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFDLEtBQUssRUFBRVIsTUFBTSxFQUFFSSxJQUFJLEVBQUU7WUFDekMsbURBQW1EO1lBQ25ELDZDQUE2QztZQUM3QztnQkFDRSxJQUFJSyx5QkFBeUJaLHFCQUFxQlksc0JBQXNCO2dCQUN4RSxJQUFJQyxRQUFRRCx1QkFBdUJFLGdCQUFnQjtnQkFFbkQsSUFBSUQsVUFBVSxJQUFJO29CQUNoQlYsVUFBVTtvQkFDVkksT0FBT0EsS0FBS1EsTUFBTSxDQUFDO3dCQUFDRjtxQkFBTTtnQkFDNUIsQ0FBQyxDQUFDLCtEQUErRDtnQkFHakUsSUFBSUcsaUJBQWlCVCxLQUFLVSxHQUFHLENBQUMsU0FBVUMsSUFBSSxFQUFFO29CQUM1QyxPQUFPQyxPQUFPRDtnQkFD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Q1Q7UUFFQSxTQUFTK1IsdUJBQXVCcGYsS0FBSyxFQUFFcWYsVUFBVSxFQUFFQyxPQUFPLEVBQUU7WUFDMUQsSUFBSTlmLFVBQVVxVixjQUFjN1UsT0FBT3FmLFlBQVlDLFVBQVVBLFFBQVF2SyxPQUFPLEdBQUdqRyxTQUFTLEVBQUV3USxVQUFVQSxRQUFRN1IsT0FBTyxHQUFHcUIsU0FBUyxFQUFFd1EsVUFBVUEsUUFBUXpNLGdCQUFnQixHQUFHL0QsU0FBUztZQUUzSyxJQUFJd1EsV0FBV0EsUUFBUXJNLE1BQU0sRUFBRTtnQkFDN0IsSUFBSUEsU0FBU3FNLFFBQVFyTSxNQUFNO2dCQUUzQixJQUFJQSxPQUFPc00sT0FBTyxFQUFFO29CQUNsQlYsTUFBTXJmLFNBQVN5VCxPQUFPOUMsTUFBTTtnQkFDOUIsT0FBTztvQkFDTCxJQUFJcVAsV0FBVyxXQUFZO3dCQUN6QlgsTUFBTXJmLFNBQVN5VCxPQUFPOUMsTUFBTTt3QkFDNUI4QyxPQUFPd00sbUJBQW1CLENBQUMsU0FBU0Q7b0JBQ3RDO29CQUVBdk0sT0FBT3lNLGdCQUFnQixDQUFDLFNBQVNGO2dCQUNuQyxDQUFDO1lBQ0gsQ0FBQztZQUVELElBQUlHLFNBQVMsSUFBSUMsZUFBZTtnQkFDOUJwZCxNQUFNO2dCQUNOdVksT0FBTyxTQUFVOEUsVUFBVSxFQUFFO29CQUMzQm5CLFVBQVVsZjtnQkFDWjtnQkFDQXNnQixNQUFNLFNBQVVELFVBQVUsRUFBRTtvQkFDMUJqQixhQUFhcGYsU0FBU3FnQjtnQkFDeEI7Z0JBQ0FFLFFBQVEsU0FBVTVQLE1BQU0sRUFBRSxDQUFDO1lBQzdCLEdBQ0E7Z0JBQ0U2UCxlQUFlO1lBQ2pCO1lBQ0EsT0FBT0w7UUFDVDtRQUVBTSw4QkFBOEIsR0FBR2I7SUFDL0I7QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stc2VydmVyLmVkZ2UuZGV2ZWxvcG1lbnQuanM/NDQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stc2VydmVyLmVkZ2UuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbnZhciBzdXBwb3J0c1JlcXVlc3RTdG9yYWdlID0gdHlwZW9mIEFzeW5jTG9jYWxTdG9yYWdlID09PSAnZnVuY3Rpb24nO1xudmFyIHJlcXVlc3RTdG9yYWdlID0gc3VwcG9ydHNSZXF1ZXN0U3RvcmFnZSA/IG5ldyBBc3luY0xvY2FsU3RvcmFnZSgpIDogbnVsbDtcbnZhciBWSUVXX1NJWkUgPSA1MTI7XG52YXIgY3VycmVudFZpZXcgPSBudWxsO1xudmFyIHdyaXR0ZW5CeXRlcyA9IDA7XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaHVuay5sZW5ndGggPiBWSUVXX1NJWkUpIHtcbiAgICB7XG4gICAgICBpZiAocHJlY29tcHV0ZWRDaHVua1NldC5oYXMoY2h1bmspKSB7XG4gICAgICAgIGVycm9yKCdBIGxhcmdlIHByZWNvbXB1dGVkIGNodW5rIHdhcyBwYXNzZWQgdG8gd3JpdGVDaHVuayB3aXRob3V0IGJlaW5nIGNvcGllZC4nICsgJyBMYXJnZSBjaHVua3MgZ2V0IGVucXVldWVkIGRpcmVjdGx5IGFuZCBhcmUgbm90IGNvcGllZC4gVGhpcyBpcyBpbmNvbXBhdGlibGUgd2l0aCBwcmVjb21wdXRlZCBjaHVua3MgYmVjYXVzZSB5b3UgY2Fubm90IGVucXVldWUgdGhlIHNhbWUgcHJlY29tcHV0ZWQgY2h1bmsgdHdpY2UuJyArICcgVXNlIFwiY2xvbmVDaHVua1wiIHRvIG1ha2UgYSBjb3B5IG9mIHRoaXMgbGFyZ2UgcHJlY29tcHV0ZWQgY2h1bmsgYmVmb3JlIHdyaXRpbmcgaXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSAvLyB0aGlzIGNodW5rIG1heSBvdmVyZmxvdyBhIHNpbmdsZSB2aWV3IHdoaWNoIGltcGxpZXMgaXQgd2FzIG5vdFxuICAgIC8vIG9uZSB0aGF0IGlzIGNhY2hlZCBieSB0aGUgc3RyZWFtaW5nIHJlbmRlcmVyLiBXZSB3aWxsIGVucXVldVxuICAgIC8vIGl0IGRpcmVjdGx5IGFuZCBleHBlY3QgaXQgaXMgbm90IHJlLXVzZWRcblxuXG4gICAgaWYgKHdyaXR0ZW5CeXRlcyA+IDApIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoY3VycmVudFZpZXcuYnVmZmVyLCAwLCB3cml0dGVuQnl0ZXMpKTtcbiAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoVklFV19TSVpFKTtcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgfVxuXG4gICAgZGVzdGluYXRpb24uZW5xdWV1ZShjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJ5dGVzVG9Xcml0ZSA9IGNodW5rO1xuICB2YXIgYWxsb3dhYmxlQnl0ZXMgPSBjdXJyZW50Vmlldy5sZW5ndGggLSB3cml0dGVuQnl0ZXM7XG5cbiAgaWYgKGFsbG93YWJsZUJ5dGVzIDwgYnl0ZXNUb1dyaXRlLmxlbmd0aCkge1xuICAgIC8vIHRoaXMgY2h1bmsgd291bGQgb3ZlcmZsb3cgdGhlIGN1cnJlbnQgdmlldy4gV2UgZW5xdWV1ZSBhIGZ1bGwgdmlld1xuICAgIC8vIGFuZCBzdGFydCBhIG5ldyB2aWV3IHdpdGggdGhlIHJlbWFpbmluZyBjaHVua1xuICAgIGlmIChhbGxvd2FibGVCeXRlcyA9PT0gMCkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBpcyBhbHJlYWR5IGZ1bGwsIHNlbmQgaXRcbiAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaWxsIHVwIHRoZSBjdXJyZW50IHZpZXcgYW5kIGFwcGx5IHRoZSByZW1haW5pbmcgY2h1bmsgYnl0ZXNcbiAgICAgIC8vIHRvIGEgbmV3IHZpZXcuXG4gICAgICBjdXJyZW50Vmlldy5zZXQoYnl0ZXNUb1dyaXRlLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSwgd3JpdHRlbkJ5dGVzKTsgLy8gd3JpdHRlbkJ5dGVzICs9IGFsbG93YWJsZUJ5dGVzOyAvLyB0aGlzIGNhbiBiZSBza2lwcGVkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIGltbWVkaWF0ZWx5IHJlc2V0IHRoZSB2aWV3XG5cbiAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpO1xuICAgICAgYnl0ZXNUb1dyaXRlID0gYnl0ZXNUb1dyaXRlLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxuXG4gIGN1cnJlbnRWaWV3LnNldChieXRlc1RvV3JpdGUsIHdyaXR0ZW5CeXRlcyk7XG4gIHdyaXR0ZW5CeXRlcyArPSBieXRlc1RvV3JpdGUubGVuZ3RoO1xufVxuZnVuY3Rpb24gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspOyAvLyBpbiB3ZWIgc3RyZWFtcyB0aGVyZSBpcyBubyBiYWNrcHJlc3N1cmUgc28gd2UgY2FuIGFsd2FzIHdyaXRlIG1vcmVcblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbikge1xuICBpZiAoY3VycmVudFZpZXcgJiYgd3JpdHRlbkJ5dGVzID4gMCkge1xuICAgIGRlc3RpbmF0aW9uLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoY3VycmVudFZpZXcuYnVmZmVyLCAwLCB3cml0dGVuQnl0ZXMpKTtcbiAgICBjdXJyZW50VmlldyA9IG51bGw7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gY2xvc2UoZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24uY2xvc2UoKTtcbn1cbnZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG59XG52YXIgcHJlY29tcHV0ZWRDaHVua1NldCA9ICBuZXcgU2V0KCkgO1xuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgdmFyIHByZWNvbXB1dGVkQ2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG5cbiAge1xuICAgIHByZWNvbXB1dGVkQ2h1bmtTZXQuYWRkKHByZWNvbXB1dGVkQ2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHByZWNvbXB1dGVkQ2h1bms7XG59XG5mdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVhcmxpZXIgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC4gSW4gdGhhdCBlbnZpcm9ubWVudCB5b3UncmVcbiAgICAvLyBzdXBwb3NlZCB0byB0aHJvdyBmcm9tIGEgcHJvbWlzZSByZXR1cm5lZCBidXQgd2UgZG9uJ3QgcmV0dXJuIGEgcHJvbWlzZSBpbiBvdXJcbiAgICAvLyBhcHByb2FjaC4gV2UgY291bGQgZm9yayB0aGlzIGltcGxlbWVudGF0aW9uIGJ1dCB0aGlzIGlzIGVudmlyb25tZW50IGlzIGFuIGVkZ2VcbiAgICAvLyBjYXNlIHRvIGJlZ2luIHdpdGguIEl0J3MgZXZlbiBsZXNzIGNvbW1vbiB0byBydW4gdGhpcyBpbiBhbiBvbGRlciBlbnZpcm9ubWVudC5cbiAgICAvLyBFdmVuIHRoZW4sIHRoaXMgaXMgbm90IHdoZXJlIGVycm9ycyBhcmUgc3VwcG9zZWQgdG8gaGFwcGVuIGFuZCB0aGV5IGdldCByZXBvcnRlZFxuICAgIC8vIHRvIGEgZ2xvYmFsIGNhbGxiYWNrIGluIGFkZGl0aW9uIHRvIHRoaXMgYW55d2F5LiBTbyBpdCdzIGZpbmUganVzdCB0byBjbG9zZSB0aGlzLlxuICAgIGRlc3RpbmF0aW9uLmNsb3NlKCk7XG4gIH1cbn1cblxuLy8gVGhpcyBmaWxlIGlzIGFuIGludGVybWVkaWF0ZSBsYXllciB0byB0cmFuc2xhdGUgYmV0d2VlbiBGbGlnaHRcbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxuZnVuY3Rpb24gc2VyaWFsaXplUm93SGVhZGVyKHRhZywgaWQpIHtcbiAgcmV0dXJuIGlkLnRvU3RyaW5nKDE2KSArICc6JyArIHRhZztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Vycm9yQ2h1bmtQcm9kKHJlcXVlc3QsIGlkLCBkaWdlc3QpIHtcbiAge1xuICAgIC8vIFRoZXNlIGVycm9ycyBzaG91bGQgbmV2ZXIgbWFrZSBpdCBpbnRvIGEgYnVpbGQgc28gd2UgZG9uJ3QgbmVlZCB0byBlbmNvZGUgdGhlbSBpbiBjb2Rlcy5qc29uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3NFcnJvckNodW5rUHJvZCBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHdoaWxlIGluIGRldmVsb3BtZW50IG1vZGUuIFVzZSBwcm9jZXNzRXJyb3JDaHVua0RldiBpbnN0ZWFkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgdmFyIGVycm9ySW5mbyA9IHtcbiAgICBkaWdlc3Q6IGRpZ2VzdFxuICB9O1xuICB2YXIgcm93ID0gc2VyaWFsaXplUm93SGVhZGVyKCdFJywgaWQpICsgc3RyaW5naWZ5KGVycm9ySW5mbykgKyAnXFxuJztcbn1cbmZ1bmN0aW9uIHByb2Nlc3NFcnJvckNodW5rRGV2KHJlcXVlc3QsIGlkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKSB7XG5cbiAgdmFyIGVycm9ySW5mbyA9IHtcbiAgICBkaWdlc3Q6IGRpZ2VzdCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIHN0YWNrOiBzdGFja1xuICB9O1xuICB2YXIgcm93ID0gc2VyaWFsaXplUm93SGVhZGVyKCdFJywgaWQpICsgc3RyaW5naWZ5KGVycm9ySW5mbykgKyAnXFxuJztcbiAgcmV0dXJuIHN0cmluZ1RvQ2h1bmsocm93KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NNb2RlbENodW5rKHJlcXVlc3QsIGlkLCBtb2RlbCkge1xuICB2YXIganNvbiA9IHN0cmluZ2lmeShtb2RlbCwgcmVxdWVzdC50b0pTT04pO1xuICB2YXIgcm93ID0gaWQudG9TdHJpbmcoMTYpICsgJzonICsganNvbiArICdcXG4nO1xuICByZXR1cm4gc3RyaW5nVG9DaHVuayhyb3cpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JlZmVyZW5jZUNodW5rKHJlcXVlc3QsIGlkLCByZWZlcmVuY2UpIHtcbiAgdmFyIGpzb24gPSBzdHJpbmdpZnkocmVmZXJlbmNlKTtcbiAgdmFyIHJvdyA9IGlkLnRvU3RyaW5nKDE2KSArICc6JyArIGpzb24gKyAnXFxuJztcbiAgcmV0dXJuIHN0cmluZ1RvQ2h1bmsocm93KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NNb2R1bGVDaHVuayhyZXF1ZXN0LCBpZCwgbW9kdWxlTWV0YURhdGEpIHtcbiAgdmFyIGpzb24gPSBzdHJpbmdpZnkobW9kdWxlTWV0YURhdGEpO1xuICB2YXIgcm93ID0gc2VyaWFsaXplUm93SGVhZGVyKCdJJywgaWQpICsganNvbiArICdcXG4nO1xuICByZXR1cm4gc3RyaW5nVG9DaHVuayhyb3cpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGdldENsaWVudFJlZmVyZW5jZUtleShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZS5maWxlcGF0aCArICcjJyArIHJlZmVyZW5jZS5uYW1lICsgKHJlZmVyZW5jZS5hc3luYyA/ICcjYXN5bmMnIDogJycpO1xufVxuZnVuY3Rpb24gaXNDbGllbnRSZWZlcmVuY2UocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZU1ldGFEYXRhKGNvbmZpZywgY2xpZW50UmVmZXJlbmNlKSB7XG4gIHZhciByZXNvbHZlZE1vZHVsZURhdGEgPSBjb25maWdbY2xpZW50UmVmZXJlbmNlLmZpbGVwYXRoXVtjbGllbnRSZWZlcmVuY2UubmFtZV07XG5cbiAgaWYgKGNsaWVudFJlZmVyZW5jZS5hc3luYykge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcmVzb2x2ZWRNb2R1bGVEYXRhLmlkLFxuICAgICAgY2h1bmtzOiByZXNvbHZlZE1vZHVsZURhdGEuY2h1bmtzLFxuICAgICAgbmFtZTogcmVzb2x2ZWRNb2R1bGVEYXRhLm5hbWUsXG4gICAgICBhc3luYzogdHJ1ZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc29sdmVkTW9kdWxlRGF0YTtcbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWwnKTtcblxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuXG52YXIgUkVTRVJWRUQgPSAwOyAvLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgZmlsdGVyIGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cblxudmFyIFNUUklORyA9IDE7IC8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxuXG52YXIgQk9PTEVBTklTSF9TVFJJTkcgPSAyOyAvLyBBIHJlYWwgYm9vbGVhbiBhdHRyaWJ1dGUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cblxudmFyIEJPT0xFQU4gPSAzOyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cblxudmFyIE9WRVJMT0FERURfQk9PTEVBTiA9IDQ7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIE5VTUVSSUMgPSA1OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5cbnJlc2VydmVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblxuWydhbGxvd0Z1bGxTY3JlZW4nLCAnYXN5bmMnLCAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLCAvLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBubyBsb25nZXIgc3VwcG9ydHMgY2FsbGluZyBuZXcgb24gZnVuY3Rpb25zXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuXG5bJ2NoZWNrZWQnLCAvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblxuWydjYXB0dXJlJywgJ2Rvd25sb2FkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBPVkVSTE9BREVEX0JPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBubyBsb25nZXIgc3VwcG9ydHMgY2FsbGluZyBuZXcgb24gZnVuY3Rpb25zXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBubyBsb25nZXIgc3VwcG9ydHMgY2FsbGluZyBuZXcgb24gZnVuY3Rpb25zXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7XG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG5cbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTsgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZywgbmFtZXNwYWNpbmcsXG4vLyBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3Ncbi8vIGFuZCBoYXZlIHRoZSBzYW1lIG5hbWVzIGFyZSBvbWl0dGVkLCBqdXN0IGxpa2UgaW4gdGhlIEhUTUwgYXR0cmlidXRlIGZpbHRlci5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwaW5nIHRoZSBNRE4gZG9jdW1lbnRhdGlvbi5cblxuXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RyYW5zZm9ybS1vcmlnaW4nLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTsgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcblxuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTsgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcblxuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpOyAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJzsgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcblxucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBubyBsb25nZXIgc3VwcG9ydHMgY2FsbGluZyBuZXcgb24gZnVuY3Rpb25zXG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGFzcGVjdFJhdGlvOiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGUgYnVpbGQgc2NyaXB0IGlzIGF0IHNjcmlwdHMvcm9sbHVwL2dlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWUuanMuXG4vLyBSdW4gYHlhcm4gZ2VuZXJhdGUtaW5saW5lLWZpenotcnVudGltZWAgdG8gZ2VuZXJhdGUuXG52YXIgY2xpZW50UmVuZGVyQm91bmRhcnkgPSAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnO1xudmFyIGNvbXBsZXRlQm91bmRhcnkgPSAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyA9ICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24ocCxxLHYpe2Z1bmN0aW9uIHIobCl7dGhpcy5zPWx9Zm9yKHZhciB0PSRSQyx1PSRSTSxtPW5ldyBNYXAsbj1kb2N1bWVudCxnLGUsZj1uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiKSxkPTA7ZT1mW2QrK107KW0uc2V0KGUuZGF0YXNldC5wcmVjZWRlbmNlLGc9ZSk7ZT0wO2Y9W107Zm9yKHZhciBjLGgsYixhO2M9dltlKytdOyl7dmFyIGs9MDtoPWNbaysrXTtpZihiPXUuZ2V0KGgpKVwibFwiIT09Yi5zJiZmLnB1c2goYik7ZWxzZXthPW4uY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPWg7YS5yZWw9XCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWQ9Y1trKytdO2I9Y1trKytdOylhLnNldEF0dHJpYnV0ZShiLGNbaysrXSk7Yj1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGwsdyl7YS5vbmxvYWQ9bDthLm9uZXJyb3I9d30pO2IudGhlbihyLmJpbmQoYixcXG5cImxcIiksci5iaW5kKGIsXCJlXCIpKTt1LnNldChoLGIpO2YucHVzaChiKTtjPW0uZ2V0KGQpfHxnO2M9PT1nJiYoZz1hKTttLnNldChkLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihkPW4uaGVhZCxkLmluc2VydEJlZm9yZShhLGQuZmlyc3RDaGlsZCkpfX1Qcm9taXNlLmFsbChmKS50aGVuKHQuYmluZChudWxsLHAscSxcIlwiKSx0LmJpbmQobnVsbCxwLHEsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9Oyc7XG52YXIgY29tcGxldGVTZWdtZW50ID0gJyRSUz1mdW5jdGlvbihhLGIpe2E9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7Yj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtmb3IoYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2EuZmlyc3RDaGlsZDspYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLmZpcnN0Q2hpbGQsYik7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfTsnO1xuXG52YXIgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5EaXNwYXRjaGVyO1xuXG52YXIgZGF0YUVsZW1lbnRRdW90ZWRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKTtcbnZhciBlbmRBc3luY1NjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgYXN5bmM9XCJcIj48L3NjcmlwdD4nKTtcblxudmFyIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0gLS0+Jyk7XG5cbnZhciBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc3R5bGU9XCInKTtcbnZhciBzdHlsZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnOicpO1xudmFyIHN0eWxlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc7Jyk7XG5cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBhdHRyaWJ1dGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIicpO1xudmFyIGF0dHJpYnV0ZUVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKTtcblxudmFyIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz4nKTtcbnZhciBlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJy8+Jyk7XG5cbnZhciBzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIHNlbGVjdGVkPVwiXCInKTtcblxudmFyIGxlYWRpbmdOZXdsaW5lID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcXG4nKTtcblxudmFyIERPQ1RZUEUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhRE9DVFlQRSBodG1sPicpO1xudmFyIGVuZFRhZzEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvJyk7XG52YXIgZW5kVGFnMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xuLy8gQSBwbGFjZWhvbGRlciBpcyBhIG5vZGUgaW5zaWRlIGEgaGlkZGVuIHBhcnRpYWwgdHJlZSB0aGF0IGNhbiBiZSBmaWxsZWQgaW4gbGF0ZXIsIGJ1dCBiZWZvcmVcbi8vIGRpc3BsYXkuIEl0J3MgbmV2ZXIgdmlzaWJsZSB0byB1c2Vycy4gV2UgdXNlIHRoZSB0ZW1wbGF0ZSB0YWcgYmVjYXVzZSBpdCBjYW4gYmUgdXNlZCBpbiBldmVyeVxuLy8gdHlwZSBvZiBwYXJlbnQuIDxzY3JpcHQ+IHRhZ3MgYWxzbyB3b3JrIGluIGV2ZXJ5IG90aGVyIHRhZyBleGNlcHQgPGNvbGdyb3VwPi5cblxudmFyIHBsYWNlaG9sZGVyMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGlkPVwiJyk7XG52YXIgcGxhY2Vob2xkZXIyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xuXG52YXIgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJC0tPicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJD8tLT48dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbnZhciBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQhLS0+Jyk7XG52YXIgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLS8kLS0+Jyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUnKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0U2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxkaXYgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2Rpdj4nKTtcbnZhciBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3ZnPicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvbWF0aD4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZUJvZHkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3Rib2R5PjwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PHRyIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdHI+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48Y29sZ3JvdXAgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9jb2xncm91cD48L3RhYmxlPicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlU2VnbWVudCArICc7JFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArICc7JFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUkMoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5ICsgJzsnICsgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMgKyAnOyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJzskUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlIoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLCcpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yY2k9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJyaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXNpZD1cIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlEYXRhM2EgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3R5PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY2xpZW50UmVuZGVyQm91bmRhcnkgKyAnOyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlgoXCInKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLCcpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnKTwvc2NyaXB0PicpO1xudmFyIGNsaWVudFJlbmRlckRhdGExID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yeGk9XCJcIiBkYXRhLWJpZD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWRnc3Q9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1tc2c9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhNCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdGNrPVwiJyk7XG5cbnZhciBwcmVjZWRlbmNlUGxhY2Vob2xkZXJTdGFydCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIHByZWNlZGVuY2VQbGFjZWhvbGRlckVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC9zdHlsZT4nKTtcblxudmFyIGFycmF5Rmlyc3RPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnWycpO1xudmFyIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsWycpO1xudmFyIGFycmF5SW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgYXJyYXlDbG9zZUJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ10nKTsgLy8gVGhpcyBmdW5jdGlvbiB3cml0ZXMgYSAyRCBhcnJheSBvZiBzdHJpbmdzIHRvIGJlIGVtYmVkZGVkIGluIGphdmFzY3JpcHQuXG5cbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59IC8vIFVzZWQgdG8gc3RvcmUgdGhlIHBhcmVudCBwYXRoIG9mIGFsbCBjb250ZXh0IG92ZXJyaWRlcyBpbiBhIHNoYXJlZCBsaW5rZWQgbGlzdC5cbi8vIEZvcm1pbmcgYSByZXZlcnNlIHRyZWUuXG4vLyBUaGUgc3RydWN0dXJlIG9mIGEgY29udGV4dCBzbmFwc2hvdCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZpbGUuXG4vLyBDdXJyZW50bHksIGl0J3MgaW1wbGVtZW50ZWQgYXMgdHJhY2tpbmcgdGhlIGN1cnJlbnQgYWN0aXZlIG5vZGUuXG5cblxudmFyIHJvb3RDb250ZXh0U25hcHNob3QgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIHJ1bnRpbWUgb3ducyB0aGUgXCJjdXJyZW50XCIgZmllbGQgb24gYWxsIFJlYWN0Q29udGV4dCBpbnN0YW5jZXMuXG4vLyBUaGlzIGdsb2JhbCAoYWN0dWFsbHkgdGhyZWFkIGxvY2FsKSBzdGF0ZSByZXByZXNlbnRzIHdoYXQgc3RhdGUgYWxsIHRob3NlIFwiY3VycmVudFwiLFxuLy8gZmllbGRzIGFyZSBjdXJyZW50bHkgaW4uXG5cbnZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsO1xuXG5mdW5jdGlvbiBwb3BOb2RlKHByZXYpIHtcbiAge1xuICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoTm9kZShuZXh0KSB7XG4gIHtcbiAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICBpZiAocHJldiA9PT0gbmV4dCkgOyBlbHNlIHtcbiAgICBwb3BOb2RlKHByZXYpO1xuICAgIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICAgIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBwYXJlbnROZXh0KTsgLy8gT24gdGhlIHdheSBiYWNrLCB3ZSBwdXNoIHRoZSBuZXcgb25lcyB0aGF0IHdlcmVuJ3QgY29tbW9uLlxuXG4gICAgICBwdXNoTm9kZShuZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ICE9PSBudWxsKSB7XG4gICAgcG9wQWxsUHJldmlvdXMocGFyZW50UHJldik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn1cblxuZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocGFyZW50UHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHBhcmVudFByZXYsIG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocHJldi5kZXB0aCA9PT0gcGFyZW50TmV4dC5kZXB0aCkge1xuICAgIC8vIFdlIGZvdW5kIHRoZSBzYW1lIGxldmVsLiBOb3cgd2UganVzdCBuZWVkIHRvIGZpbmQgYSBzaGFyZWQgYW5jZXN0b3IuXG4gICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgbXVzdCBzdGlsbCBiZSBkZWVwZXIuXG4gICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgcGFyZW50TmV4dCk7XG4gIH1cblxuICBwdXNoTm9kZShuZXh0KTtcbn0gLy8gUGVyZm9ybSBjb250ZXh0IHN3aXRjaGluZyB0byB0aGUgbmV3IHNuYXBzaG90LlxuLy8gVG8gbWFrZSBpdCBjaGVhcCB0byByZWFkIG1hbnkgY29udGV4dHMsIHdoaWxlIG5vdCBzdXNwZW5kaW5nLCB3ZSBtYWtlIHRoZSBzd2l0Y2ggZWFnZXJseSBieVxuLy8gdXBkYXRpbmcgYWxsIHRoZSBjb250ZXh0J3MgY3VycmVudCB2YWx1ZXMuIFRoYXQgd2F5IHJlYWRzLCBhbHdheXMganVzdCByZWFkIHRoZSBjdXJyZW50IHZhbHVlLlxuLy8gQXQgdGhlIGNvc3Qgb2YgdXBkYXRpbmcgY29udGV4dHMgZXZlbiBpZiB0aGV5J3JlIG5ldmVyIHJlYWQgYnkgdGhpcyBzdWJ0cmVlLlxuXG5cbmZ1bmN0aW9uIHN3aXRjaENvbnRleHQobmV3U25hcHNob3QpIHtcbiAgLy8gVGhlIGJhc2ljIGFsZ29yaXRobSB3ZSBuZWVkIHRvIGRvIGlzIHRvIHBvcCBiYWNrIGFueSBjb250ZXh0cyB0aGF0IGFyZSBubyBsb25nZXIgb24gdGhlIHN0YWNrLlxuICAvLyBXZSBhbHNvIG5lZWQgdG8gdXBkYXRlIGFueSBuZXcgY29udGV4dHMgdGhhdCBhcmUgbm93IG9uIHRoZSBzdGFjayB3aXRoIHRoZSBkZWVwZXN0IHZhbHVlLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gdXBkYXRlIG5ldyBjb250ZXh0cyBpcyB0byBqdXN0IHJlYXBwbHkgdGhlbSBpbiByZXZlcnNlIG9yZGVyIGZyb20gdGhlXG4gIC8vIHBlcnNwZWN0aXZlIG9mIHRoZSBiYWNrcG9pbnRlcnMuIFRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsb3Qgd2hlbiBzd2l0Y2hpbmcsIHdlIHVzZSB0aGUgc3RhY2tcbiAgLy8gZm9yIHRoYXQuIFRoZXJlZm9yZSB0aGlzIGFsZ29yaXRobSBpcyByZWN1cnNpdmUuXG4gIC8vIDEpIEZpcnN0IHdlIHBvcCB3aGljaCBldmVyIHNuYXBzaG90IHRyZWUgd2FzIGRlZXBlc3QuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAyKSBUaGVuIHdlIGZpbmQgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGZyb20gdGhlcmUuIFBvcHBpbmcgb2xkIGNvbnRleHRzIGFzIHdlIGdvLlxuICAvLyAzKSBUaGVuIHdlIHJlYXBwbHkgbmV3IGNvbnRleHRzIG9uIHRoZSB3YXkgYmFjayB1cCB0aGUgc3RhY2suXG4gIHZhciBwcmV2ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV4dCA9IG5ld1NuYXBzaG90O1xuXG4gIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWU6IFRoaXMgaGFzIHRvIGJlIG5vbi1udWxsIHNpbmNlIGl0J3Mgbm90IGVxdWFsIHRvIHByZXYuXG4gICAgICBwdXNoQWxsTmV4dChuZXh0KTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIHBvcEFsbFByZXZpb3VzKHByZXYpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmV2LmRlcHRoID4gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIoY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHZhciBwcmV2VmFsdWU7XG5cbiAge1xuICAgIHByZXZWYWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldk5vZGUgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXdOb2RlID0ge1xuICAgIHBhcmVudDogcHJldk5vZGUsXG4gICAgZGVwdGg6IHByZXZOb2RlID09PSBudWxsID8gMCA6IHByZXZOb2RlLmRlcHRoICsgMSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIHBhcmVudFZhbHVlOiBwcmV2VmFsdWUsXG4gICAgdmFsdWU6IG5leHRWYWx1ZVxuICB9O1xuICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdOb2RlO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKCkge1xuICB2YXIgcHJldlNuYXBzaG90ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuXG4gIGlmIChwcmV2U25hcHNob3QgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHBvcCBhIENvbnRleHQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsdWUgPSBwcmV2U25hcHNob3QucGFyZW50VmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCkge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTbmFwc2hvdC5jb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gcHJldlNuYXBzaG90LnBhcmVudDtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUNvbnRleHQoKSB7XG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9ICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIENvcnJlc3BvbmRzIHRvIFJlYWN0RmliZXJXYWtlYWJsZSBhbmQgUmVhY3RGaXp6V2FrZWFibGUgbW9kdWxlcy4gR2VuZXJhbGx5LFxuLy8gY2hhbmdlcyB0byBvbmUgbW9kdWxlIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gdGhlIG90aGVycy5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIG1vZHVsZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgRmliZXIgb25lIHRvIFwiVGhlbmFibGVcIlxuLy8gaW5zdGVhZCBvZiBcIldha2VhYmxlXCIuIE9yIHNvbWUgb3RoZXIgbW9yZSBhcHByb3ByaWF0ZSBuYW1lLlxuLy8gQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gKGUuZy4gYnkgYHVzZWApIHRvIHRyaWdnZXIgU3VzcGVuc2UuIElmIHdlXG4vLyBkZXRlY3QgdGhpcyBpcyBjYXVnaHQgYnkgdXNlcnNwYWNlLCB3ZSdsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xuZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgLy8gVGhlIFRoZW5hYmxlU3RhdGUgaXMgY3JlYXRlZCB0aGUgZmlyc3QgdGltZSBhIGNvbXBvbmVudCBzdXNwZW5kcy4gSWYgaXRcbiAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlJ2xsIHJldXNlIHRoZSBzYW1lIHN0YXRlLlxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgdmFyIHByZXZpb3VzID0gdGhlbmFibGVTdGF0ZVtpbmRleF07XG5cbiAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2aW91cyAhPT0gdGhlbmFibGUpIHtcbiAgICAgIC8vIFJldXNlIHRoZSBwcmV2aW91cyB0aGVuYWJsZSwgYW5kIGRyb3AgdGhlIG5ldyBvbmUuIFdlIGNhbiBhc3N1bWVcbiAgICAgIC8vIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIHZhbHVlLCBiZWNhdXNlIGNvbXBvbmVudHMgYXJlIGlkZW1wb3RlbnQuXG4gICAgICAvLyBBdm9pZCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycyBmb3IgdGhlIFByb21pc2VzIHRoYXQgd2UnbGxcbiAgICAgIC8vIGludGVudGlvbmFsbHkgaWdub3JlLlxuICAgICAgdGhlbmFibGUudGhlbihub29wLCBub29wKTtcbiAgICAgIHRoZW5hYmxlID0gcHJldmlvdXM7XG4gICAgfVxuICB9IC8vIFdlIHVzZSBhbiBleHBhbmRvIHRvIHRyYWNrIHRoZSBzdGF0dXMgYW5kIHJlc3VsdCBvZiBhIHRoZW5hYmxlIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHN5bmNocm9ub3VzbHkgdW53cmFwIHRoZSB2YWx1ZS4gVGhpbmsgb2YgdGhpcyBhcyBhbiBleHRlbnNpb24gb2YgdGhlXG4gIC8vIFByb21pc2UgQVBJLCBvciBhIGN1c3RvbSBpbnRlcmZhY2UgdGhhdCBpcyBhIHN1cGVyc2V0IG9mIFRoZW5hYmxlLlxuICAvL1xuICAvLyBJZiB0aGUgdGhlbmFibGUgZG9lc24ndCBoYXZlIGEgc3RhdHVzLCBzZXQgaXQgdG8gXCJwZW5kaW5nXCIgYW5kIGF0dGFjaFxuICAvLyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgaXRzIHN0YXR1cyBhbmQgcmVzdWx0IHdoZW4gaXQgcmVzb2x2ZXMuXG5cblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciByZWplY3RlZEVycm9yID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkVGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWplY3RlZFRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHJvd2luZyBoZXJlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGFsbG93cyB1cyB0byB1bndpbmQgdGhlXG4gICAgICAgIC8vIGNhbGwgc3RhY2suIEJ1dCB3ZSBzaG91bGRuJ3QgYWxsb3cgaXQgdG8gbGVhayBpbnRvIHVzZXJzcGFjZS4gVGhyb3cgYW5cbiAgICAgICAgLy8gb3BhcXVlIHBsYWNlaG9sZGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0aGVuYWJsZS4gSWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBnZXQgY2FwdHVyZWQgYnkgdGhlIHdvcmsgbG9vcCwgbG9nIGEgd2FybmluZywgYmVjYXVzZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHNvbWV0aGluZyBpbiB1c2Vyc3BhY2UgbXVzdCBoYXZlIGNhdWdodCBpdC5cblxuXG4gICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICB9XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciBgdXNlYCBzdXNwZW5kcyBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uIGB1c2VgXG4gIC8vIHRocm93cyBhbiBvcGFxdWUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgdGhlbmFibGUgaXRzZWxmIHNvIHRoYXQgaXQgY2FuJ3QgYmVcbiAgLy8gY2F1Z2h0IGluIHVzZXJzcGFjZS4gVGhlbiB0aGUgd29yayBsb29wIGFjY2Vzc2VzIHRoZSBhY3R1YWwgdGhlbmFibGUgdXNpbmdcbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHN1c3BlbmRlZFRoZW5hYmxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cblxudmFyIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG52YXIgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rc0ZvclJlcXVlc3QocmVxdWVzdCkge1xuICBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzRm9yUmVxdWVzdCgpIHtcbiAgY3VycmVudFJlcXVlc3QgPSBudWxsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3NGb3JDb21wb25lbnQocHJldlRoZW5hYmxlU3RhdGUpIHtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dCQxKGNvbnRleHQpIHtcbiAge1xuICAgIGlmIChjb250ZXh0LiQkdHlwZW9mICE9PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UoY29udGV4dCkpIHtcbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCByZWFkIGEgQ2xpZW50IENvbnRleHQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignT25seSBjcmVhdGVTZXJ2ZXJDb250ZXh0IGlzIHN1cHBvcnRlZCBpbiBTZXJ2ZXIgQ29tcG9uZW50cy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG59XG5cbnZhciBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gIHVzZU1lbW86IGZ1bmN0aW9uIChuZXh0Q3JlYXRlKSB7XG4gICAgcmV0dXJuIG5leHRDcmVhdGUoKTtcbiAgfSxcbiAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge30sXG4gIHVzZURlZmVycmVkVmFsdWU6IHVuc3VwcG9ydGVkSG9vayxcbiAgdXNlVHJhbnNpdGlvbjogdW5zdXBwb3J0ZWRIb29rLFxuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQkMSxcbiAgdXNlQ29udGV4dDogcmVhZENvbnRleHQkMSxcbiAgdXNlUmVkdWNlcjogdW5zdXBwb3J0ZWRIb29rLFxuICB1c2VSZWY6IHVuc3VwcG9ydGVkSG9vayxcbiAgdXNlU3RhdGU6IHVuc3VwcG9ydGVkSG9vayxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB1bnN1cHBvcnRlZEhvb2ssXG4gIHVzZUxheW91dEVmZmVjdDogdW5zdXBwb3J0ZWRIb29rLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB1bnN1cHBvcnRlZEhvb2ssXG4gIHVzZUVmZmVjdDogdW5zdXBwb3J0ZWRIb29rLFxuICB1c2VJZDogdXNlSWQsXG4gIHVzZU11dGFibGVTb3VyY2U6IHVuc3VwcG9ydGVkSG9vayxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVuc3VwcG9ydGVkSG9vayxcbiAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuc3VwcG9ydGVkUmVmcmVzaDtcbiAgfSxcbiAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuICB1c2U6ICB1c2UgXG59O1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZEhvb2soKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBIb29rIGlzIG5vdCBzdXBwb3J0ZWQgaW4gU2VydmVyIENvbXBvbmVudHMuJyk7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoaW5nIHRoZSBjYWNoZSBpcyBub3Qgc3VwcG9ydGVkIGluIFNlcnZlciBDb21wb25lbnRzLicpO1xufVxuXG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgaWYgKGN1cnJlbnRSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VJZCBjYW4gb25seSBiZSB1c2VkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZycpO1xuICB9XG5cbiAgdmFyIGlkID0gY3VycmVudFJlcXVlc3QuaWRlbnRpZmllckNvdW50Kys7IC8vIHVzZSAnUycgZm9yIEZsaWdodCBjb21wb25lbnRzIHRvIGRpc3Rpbmd1aXNoIGZyb20gJ1InIGFuZCAncicgaW4gRml6ei9DbGllbnRcblxuICByZXR1cm4gJzonICsgY3VycmVudFJlcXVlc3QuaWRlbnRpZmllclByZWZpeCArICdTJyArIGlkLnRvU3RyaW5nKDMyKSArICc6Jztcbn1cblxuZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICBpZiAodXNhYmxlICE9PSBudWxsICYmIHR5cGVvZiB1c2FibGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB1c2FibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgaWYgKHR5cGVvZiB1c2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRoZW5hYmxlLlxuICAgICAgdmFyIHRoZW5hYmxlID0gdXNhYmxlOyAvLyBUcmFjayB0aGUgcG9zaXRpb24gb2YgdGhlIHRoZW5hYmxlIHdpdGhpbiB0aGlzIGZpYmVyLlxuXG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG5cbiAgICAgIGlmICh0aGVuYWJsZVN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dCQxKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodXNhYmxlKSkge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCB1c2UoKSBhbiBhbHJlYWR5IHJlc29sdmVkIENsaWVudCBSZWZlcmVuY2UuJyk7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6ICcgKyBTdHJpbmcodXNhYmxlKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ25hbCgpIHtcbiAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDYWNoZSgpIHtcbiAgaWYgKGN1cnJlbnRDYWNoZSkgcmV0dXJuIGN1cnJlbnRDYWNoZTtcblxuICBpZiAoc3VwcG9ydHNSZXF1ZXN0U3RvcmFnZSkge1xuICAgIHZhciBjYWNoZSA9IHJlcXVlc3RTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKGNhY2hlKSByZXR1cm4gY2FjaGU7XG4gIH0gLy8gU2luY2Ugd2Ugb3ZlcnJpZGUgdGhlIGRpc3BhdGNoZXIgYWxsIHRoZSB0aW1lLCB3ZSdyZSBlZmZlY3RpdmVseSBhbHdheXNcbiAgLy8gYWN0aXZlIGFuZCBzbyB0byBzdXBwb3J0IGNhY2hlKCkgYW5kIGZldGNoKCkgb3V0c2lkZSBvZiByZW5kZXIsIHdlIHlpZWxkXG4gIC8vIGFuIGVtcHR5IE1hcC5cblxuXG4gIHJldHVybiBuZXcgTWFwKCk7XG59XG5cbnZhciBEZWZhdWx0Q2FjaGVEaXNwYXRjaGVyID0ge1xuICBnZXRDYWNoZVNpZ25hbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWNoZSA9IHJlc29sdmVDYWNoZSgpO1xuICAgIHZhciBlbnRyeSA9IGNhY2hlLmdldChjcmVhdGVTaWduYWwpO1xuXG4gICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVudHJ5ID0gY3JlYXRlU2lnbmFsKCk7XG4gICAgICBjYWNoZS5zZXQoY3JlYXRlU2lnbmFsLCBlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5O1xuICB9LFxuICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICB2YXIgY2FjaGUgPSByZXNvbHZlQ2FjaGUoKTtcbiAgICB2YXIgZW50cnkgPSBjYWNoZS5nZXQocmVzb3VyY2VUeXBlKTtcblxuICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbnRyeSA9IHJlc291cmNlVHlwZSgpOyAvLyBUT0RPOiBXYXJuIGlmIHVuZGVmaW5lZD9cblxuICAgICAgY2FjaGUuc2V0KHJlc291cmNlVHlwZSwgZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxufTtcbnZhciBjdXJyZW50Q2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudENhY2hlKGNhY2hlKSB7XG4gIGN1cnJlbnRDYWNoZSA9IGNhY2hlO1xuICByZXR1cm4gY3VycmVudENhY2hlO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudENhY2hlKCkge1xuICByZXR1cm4gY3VycmVudENhY2hlO1xufVxuXG52YXIgQ29udGV4dFJlZ2lzdHJ5ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQ29udGV4dFJlZ2lzdHJ5O1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTZXJ2ZXJDb250ZXh0KGdsb2JhbE5hbWUpIHtcbiAgaWYgKCFDb250ZXh0UmVnaXN0cnlbZ2xvYmFsTmFtZV0pIHtcbiAgICBDb250ZXh0UmVnaXN0cnlbZ2xvYmFsTmFtZV0gPSBSZWFjdC5jcmVhdGVTZXJ2ZXJDb250ZXh0KGdsb2JhbE5hbWUsIC8vICRGbG93Rml4TWUgZnVuY3Rpb24gc2lnbmF0dXJlIGRvZXNuJ3QgcmVmbGVjdCB0aGUgc3ltYm9sIHZhbHVlXG4gICAgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKTtcbiAgfVxuXG4gIHJldHVybiBDb250ZXh0UmVnaXN0cnlbZ2xvYmFsTmFtZV07XG59XG5cbnZhciBQRU5ESU5HID0gMDtcbnZhciBDT01QTEVURUQgPSAxO1xudmFyIEFCT1JURUQgPSAzO1xudmFyIEVSUk9SRUQgPSA0O1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0Q3VycmVudENhY2hlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50Q2FjaGU7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxufVxuXG52YXIgT1BFTiA9IDA7XG52YXIgQ0xPU0lORyA9IDE7XG52YXIgQ0xPU0VEID0gMjtcbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QobW9kZWwsIGJ1bmRsZXJDb25maWcsIG9uRXJyb3IsIGNvbnRleHQsIGlkZW50aWZpZXJQcmVmaXgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudENhY2hlLmN1cnJlbnQgIT09IG51bGwgJiYgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCAhPT0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IFJlYWN0IG9ubHkgc3VwcG9ydHMgb25lIFJTQyByZW5kZXJlciBhdCBhIHRpbWUuJyk7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRDYWNoZS5jdXJyZW50ID0gRGVmYXVsdENhY2hlRGlzcGF0Y2hlcjtcbiAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgcGluZ2VkVGFza3MgPSBbXTtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgc3RhdHVzOiBPUEVOLFxuICAgIGZhdGFsRXJyb3I6IG51bGwsXG4gICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgYnVuZGxlckNvbmZpZzogYnVuZGxlckNvbmZpZyxcbiAgICBjYWNoZTogbmV3IE1hcCgpLFxuICAgIG5leHRDaHVua0lkOiAwLFxuICAgIHBlbmRpbmdDaHVua3M6IDAsXG4gICAgYWJvcnRhYmxlVGFza3M6IGFib3J0U2V0LFxuICAgIHBpbmdlZFRhc2tzOiBwaW5nZWRUYXNrcyxcbiAgICBjb21wbGV0ZWRNb2R1bGVDaHVua3M6IFtdLFxuICAgIGNvbXBsZXRlZEpTT05DaHVua3M6IFtdLFxuICAgIGNvbXBsZXRlZEVycm9yQ2h1bmtzOiBbXSxcbiAgICB3cml0dGVuU3ltYm9sczogbmV3IE1hcCgpLFxuICAgIHdyaXR0ZW5Nb2R1bGVzOiBuZXcgTWFwKCksXG4gICAgd3JpdHRlblByb3ZpZGVyczogbmV3IE1hcCgpLFxuICAgIGlkZW50aWZpZXJQcmVmaXg6IGlkZW50aWZpZXJQcmVmaXggfHwgJycsXG4gICAgaWRlbnRpZmllckNvdW50OiAxLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yLFxuICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuICAgIHRvSlNPTjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kZWxUb0pTT04ocmVxdWVzdCwgdGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgdmFyIHJvb3RDb250ZXh0ID0gY3JlYXRlUm9vdENvbnRleHQoY29udGV4dCk7XG4gIHZhciByb290VGFzayA9IGNyZWF0ZVRhc2socmVxdWVzdCwgbW9kZWwsIHJvb3RDb250ZXh0LCBhYm9ydFNldCk7XG4gIHBpbmdlZFRhc2tzLnB1c2gocm9vdFRhc2spO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdENvbnRleHQocmVxQ29udGV4dCkge1xuICByZXR1cm4gaW1wb3J0U2VydmVyQ29udGV4dHMocmVxQ29udGV4dCk7XG59XG5cbnZhciBQT1AgPSB7fTsgLy8gVXNlZCBmb3IgREVWIG1lc3NhZ2VzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcGFyZW50IHJlbmRlcmVkIHNvbWUgcHJvcHMsXG4vLyBpbiBjYXNlIHRoZXkgZXJyb3IuXG5cbnZhciBqc3hQcm9wc1BhcmVudHMgPSBuZXcgV2Vha01hcCgpO1xudmFyIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRoZW5hYmxlKHJlcXVlc3QsIHRoZW5hYmxlKSB7XG4gIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICB2YXIgbmV3VGFzayA9IGNyZWF0ZVRhc2socmVxdWVzdCwgbnVsbCwgZ2V0QWN0aXZlQ29udGV4dCgpLCByZXF1ZXN0LmFib3J0YWJsZVRhc2tzKTtcblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIHJlc29sdmVkIHZhbHVlLCB3ZSBjYW4gZ28gYWhlYWQgYW5kIHNjaGVkdWxlIGl0IGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICBuZXdUYXNrLm1vZGVsID0gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIHBpbmdUYXNrKHJlcXVlc3QsIG5ld1Rhc2spO1xuICAgICAgICByZXR1cm4gbmV3VGFzay5pZDtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHggPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIHZhciBkaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIHgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2dldEVycm9yTWVzc2FnZUFuZFN0ID0gZ2V0RXJyb3JNZXNzYWdlQW5kU3RhY2tEZXYoeCksXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBfZ2V0RXJyb3JNZXNzYWdlQW5kU3QubWVzc2FnZSxcbiAgICAgICAgICAgICAgc3RhY2sgPSBfZ2V0RXJyb3JNZXNzYWdlQW5kU3Quc3RhY2s7XG5cbiAgICAgICAgICBlbWl0RXJyb3JDaHVua0RldihyZXF1ZXN0LCBuZXdUYXNrLmlkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUYXNrLmlkO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gT25seSBpbnN0cnVtZW50IHRoZSB0aGVuYWJsZSBpZiB0aGUgc3RhdHVzIGlmIG5vdCBkZWZpbmVkLiBJZlxuICAgICAgICAgIC8vIGl0J3MgZGVmaW5lZCwgYnV0IGFuIHVua25vd24gdmFsdWUsIGFzc3VtZSBpdCdzIGJlZW4gaW5zdHJ1bWVudGVkIGJ5XG4gICAgICAgICAgLy8gc29tZSBjdXN0b20gdXNlcnNwYWNlIGltcGxlbWVudGF0aW9uLiBXZSB0cmVhdCBpdCBhcyBcInBlbmRpbmdcIi5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIG5ld1Rhc2subW9kZWwgPSB2YWx1ZTtcbiAgICBwaW5nVGFzayhyZXF1ZXN0LCBuZXdUYXNrKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRPRE86IElzIGl0IHNhZmUgdG8gZGlyZWN0bHkgZW1pdCB0aGVzZSB3aXRob3V0IGJlaW5nIGluc2lkZSBhIHJldHJ5P1xuICAgIHZhciBkaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIHJlYXNvbik7XG5cbiAgICB7XG4gICAgICB2YXIgX2dldEVycm9yTWVzc2FnZUFuZFN0MiA9IGdldEVycm9yTWVzc2FnZUFuZFN0YWNrRGV2KHJlYXNvbiksXG4gICAgICAgICAgX21lc3NhZ2UgPSBfZ2V0RXJyb3JNZXNzYWdlQW5kU3QyLm1lc3NhZ2UsXG4gICAgICAgICAgX3N0YWNrID0gX2dldEVycm9yTWVzc2FnZUFuZFN0Mi5zdGFjaztcblxuICAgICAgZW1pdEVycm9yQ2h1bmtEZXYocmVxdWVzdCwgbmV3VGFzay5pZCwgZGlnZXN0LCBfbWVzc2FnZSwgX3N0YWNrKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3VGFzay5pZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgfVxuXG4gIHRocm93IHRoZW5hYmxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMYXp5V3JhcHBlckFyb3VuZFdha2VhYmxlKHdha2VhYmxlKSB7XG4gIC8vIFRoaXMgaXMgYSB0ZW1wb3JhcnkgZm9yayBvZiB0aGUgYHVzZWAgaW1wbGVtZW50YXRpb24gdW50aWwgd2UgYWNjZXB0XG4gIC8vIHByb21pc2VzIGV2ZXJ5d2hlcmUuXG4gIHZhciB0aGVuYWJsZSA9IHdha2VhYmxlO1xuXG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhlbmFibGUuc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIE9ubHkgaW5zdHJ1bWVudCB0aGUgdGhlbmFibGUgaWYgdGhlIHN0YXR1cyBpZiBub3QgZGVmaW5lZC4gSWZcbiAgICAgICAgICAvLyBpdCdzIGRlZmluZWQsIGJ1dCBhbiB1bmtub3duIHZhbHVlLCBhc3N1bWUgaXQncyBiZWVuIGluc3RydW1lbnRlZCBieVxuICAgICAgICAgIC8vIHNvbWUgY3VzdG9tIHVzZXJzcGFjZSBpbXBsZW1lbnRhdGlvbi4gV2UgdHJlYXQgaXQgYXMgXCJwZW5kaW5nXCIuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVuZGluZ1RoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgIHBlbmRpbmdUaGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHRoZW5hYmxlLFxuICAgIF9pbml0OiByZWFkVGhlbmFibGVcbiAgfTtcbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0UmVzb2x2ZUVsZW1lbnQocmVxdWVzdCwgdHlwZSwga2V5LCByZWYsIHByb3BzLCBwcmV2VGhlbmFibGVTdGF0ZSkge1xuICBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2hlbiB0aGUgcmVmIG1vdmVzIHRvIHRoZSByZWd1bGFyIHByb3BzIG9iamVjdCB0aGlzIHdpbGwgaW1wbGljaXRseVxuICAgIC8vIHRocm93IGZvciBmdW5jdGlvbnMuIFdlIGNvdWxkIHByb2JhYmx5IHJlbGF4IGl0IHRvIGEgREVWIHdhcm5pbmcgZm9yIG90aGVyXG4gICAgLy8gY2FzZXMuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWZzIGNhbm5vdCBiZSB1c2VkIGluIFNlcnZlciBDb21wb25lbnRzLCBub3IgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzLicpO1xuICB9XG5cbiAge1xuICAgIGpzeFByb3BzUGFyZW50cy5zZXQocHJvcHMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcgJiYgcHJvcHMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cy5zZXQocHJvcHMuY2hpbGRyZW4sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc0NsaWVudFJlZmVyZW5jZSh0eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBhIENsaWVudCBDb21wb25lbnQuXG4gICAgICByZXR1cm4gW1JFQUNUX0VMRU1FTlRfVFlQRSwgdHlwZSwga2V5LCBwcm9wc107XG4gICAgfSAvLyBUaGlzIGlzIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuXG5cbiAgICBwcmVwYXJlVG9Vc2VIb29rc0ZvckNvbXBvbmVudChwcmV2VGhlbmFibGVTdGF0ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHR5cGUocHJvcHMpO1xuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdoZW4gdGhlIHJldHVybiB2YWx1ZSBpcyBpbiBjaGlsZHJlbiBwb3NpdGlvbiB3ZSBjYW4gcmVzb2x2ZSBpdCBpbW1lZGlhdGVseSxcbiAgICAgIC8vIHRvIGl0cyB2YWx1ZSB3aXRob3V0IGEgd3JhcHBlciBpZiBpdCdzIHN5bmNocm9ub3VzbHkgYXZhaWxhYmxlLlxuICAgICAgdmFyIHRoZW5hYmxlID0gcmVzdWx0O1xuXG4gICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICB9IC8vIFRPRE86IE9uY2Ugd2UgYWNjZXB0IFByb21pc2VzIGFzIGNoaWxkcmVuIG9uIHRoZSBjbGllbnQsIHdlIGNhbiBqdXN0IHJldHVyblxuICAgICAgLy8gdGhlIHRoZW5hYmxlIGhlcmUuXG5cblxuICAgICAgcmV0dXJuIGNyZWF0ZUxhenlXcmFwcGVyQXJvdW5kV2FrZWFibGUocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRoaXMgaXMgYSBob3N0IGVsZW1lbnQuIEUuZy4gSFRNTC5cbiAgICByZXR1cm4gW1JFQUNUX0VMRU1FTlRfVFlQRSwgdHlwZSwga2V5LCBwcm9wc107XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIC8vIEZvciBrZXktbGVzcyBmcmFnbWVudHMsIHdlIGFkZCBhIHNtYWxsIG9wdGltaXphdGlvbiB0byBhdm9pZCBzZXJpYWxpemluZ1xuICAgICAgLy8gaXQgYXMgYSB3cmFwcGVyLlxuICAgICAgLy8gVE9ETzogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB3ZSBzaG91bGQgcHJvcGFnYXRlIGl0cyBrZXkgdG8gYW55IGNoaWxkcmVuLlxuICAgICAgLy8gU2FtZSBhcyBpZiBhIFNlcnZlciBDb21wb25lbnQgaGFzIGEga2V5LlxuICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gVGhpcyBtaWdodCBiZSBhIGJ1aWx0LWluIFJlYWN0IGNvbXBvbmVudC4gV2UnbGwgbGV0IHRoZSBjbGllbnQgZGVjaWRlLlxuICAgIC8vIEFueSBidWlsdC1pbiB3b3JrcyBhcyBsb25nIGFzIGl0cyBwcm9wcyBhcmUgc2VyaWFsaXphYmxlLlxuXG5cbiAgICByZXR1cm4gW1JFQUNUX0VMRU1FTlRfVFlQRSwgdHlwZSwga2V5LCBwcm9wc107XG4gIH0gZWxzZSBpZiAodHlwZSAhPSBudWxsICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChpc0NsaWVudFJlZmVyZW5jZSh0eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBhIENsaWVudCBDb21wb25lbnQuXG4gICAgICByZXR1cm4gW1JFQUNUX0VMRU1FTlRfVFlQRSwgdHlwZSwga2V5LCBwcm9wc107XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgdmFyIHdyYXBwZWRUeXBlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gYXR0ZW1wdFJlc29sdmVFbGVtZW50KHJlcXVlc3QsIHdyYXBwZWRUeXBlLCBrZXksIHJlZiwgcHJvcHMsIHByZXZUaGVuYWJsZVN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVuZGVyID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgcHJlcGFyZVRvVXNlSG9va3NGb3JDb21wb25lbnQocHJldlRoZW5hYmxlU3RhdGUpO1xuICAgICAgICAgIHJldHVybiByZW5kZXIocHJvcHMsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gYXR0ZW1wdFJlc29sdmVFbGVtZW50KHJlcXVlc3QsIHR5cGUudHlwZSwga2V5LCByZWYsIHByb3BzLCBwcmV2VGhlbmFibGVTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKHR5cGUuX2NvbnRleHQsIHByb3BzLnZhbHVlKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBleHRyYUtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdjaGlsZHJlbicgfHwgdmFsdWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBlcnJvcignU2VydmVyQ29udGV4dCBjYW4gb25seSBoYXZlIGEgdmFsdWUgcHJvcCBhbmQgY2hpbGRyZW4uIEZvdW5kOiAlcycsIEpTT04uc3RyaW5naWZ5KGV4dHJhS2V5cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbUkVBQ1RfRUxFTUVOVF9UWVBFLCB0eXBlLCBrZXksIC8vIFJlbHkgb24gX19wb3BQcm92aWRlciBiZWluZyBzZXJpYWxpemVkIGxhc3QgdG8gcG9wIHRoZSBwcm92aWRlci5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBfX3BvcDogUE9QXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBTZXJ2ZXIgQ29tcG9uZW50IHR5cGU6IFwiICsgZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh0eXBlKSk7XG59XG5cbmZ1bmN0aW9uIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgcGluZ2VkVGFza3MucHVzaCh0YXNrKTtcblxuICBpZiAocGluZ2VkVGFza3MubGVuZ3RoID09PSAxKSB7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUYXNrKHJlcXVlc3QsIG1vZGVsLCBjb250ZXh0LCBhYm9ydFNldCkge1xuICB2YXIgaWQgPSByZXF1ZXN0Lm5leHRDaHVua0lkKys7XG4gIHZhciB0YXNrID0ge1xuICAgIGlkOiBpZCxcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgbW9kZWw6IG1vZGVsLFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH0sXG4gICAgdGhlbmFibGVTdGF0ZTogbnVsbFxuICB9O1xuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVCeVZhbHVlSUQoaWQpIHtcbiAgcmV0dXJuICckJyArIGlkLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTGF6eUlEKGlkKSB7XG4gIHJldHVybiAnJEwnICsgaWQudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVQcm9taXNlSUQoaWQpIHtcbiAgcmV0dXJuICckQCcgKyBpZC50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbFJlZmVyZW5jZShuYW1lKSB7XG4gIHJldHVybiAnJFMnICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplUHJvdmlkZXJSZWZlcmVuY2UobmFtZSkge1xuICByZXR1cm4gJyRQJyArIG5hbWU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNsaWVudFJlZmVyZW5jZShyZXF1ZXN0LCBwYXJlbnQsIGtleSwgbW9kdWxlUmVmZXJlbmNlKSB7XG4gIHZhciBtb2R1bGVLZXkgPSBnZXRDbGllbnRSZWZlcmVuY2VLZXkobW9kdWxlUmVmZXJlbmNlKTtcbiAgdmFyIHdyaXR0ZW5Nb2R1bGVzID0gcmVxdWVzdC53cml0dGVuTW9kdWxlcztcbiAgdmFyIGV4aXN0aW5nSWQgPSB3cml0dGVuTW9kdWxlcy5nZXQobW9kdWxlS2V5KTtcblxuICBpZiAoZXhpc3RpbmdJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhcmVudFswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmIGtleSA9PT0gJzEnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBlbmNvZGluZyB0aGUgXCJ0eXBlXCIgb2YgYW4gZWxlbWVudCwgd2UgY2FuIHJlZmVyXG4gICAgICAvLyB0byB0aGF0IGJ5IGEgbGF6eSByZWZlcmVuY2UgaW5zdGVhZCBvZiBkaXJlY3RseSBzaW5jZSBSZWFjdFxuICAgICAgLy8ga25vd3MgaG93IHRvIGRlYWwgd2l0aCBsYXp5IHZhbHVlcy4gVGhpcyBsZXRzIHVzIHN1c3BlbmRcbiAgICAgIC8vIG9uIHRoaXMgY29tcG9uZW50IHJhdGhlciB0aGFuIGl0cyBwYXJlbnQgdW50aWwgdGhlIGNvZGUgaGFzXG4gICAgICAvLyBsb2FkZWQuXG4gICAgICByZXR1cm4gc2VyaWFsaXplTGF6eUlEKGV4aXN0aW5nSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVCeVZhbHVlSUQoZXhpc3RpbmdJZCk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBtb2R1bGVNZXRhRGF0YSA9IHJlc29sdmVNb2R1bGVNZXRhRGF0YShyZXF1ZXN0LmJ1bmRsZXJDb25maWcsIG1vZHVsZVJlZmVyZW5jZSk7XG4gICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgdmFyIG1vZHVsZUlkID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrO1xuICAgIGVtaXRNb2R1bGVDaHVuayhyZXF1ZXN0LCBtb2R1bGVJZCwgbW9kdWxlTWV0YURhdGEpO1xuICAgIHdyaXR0ZW5Nb2R1bGVzLnNldChtb2R1bGVLZXksIG1vZHVsZUlkKTtcblxuICAgIGlmIChwYXJlbnRbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJiBrZXkgPT09ICcxJykge1xuICAgICAgLy8gSWYgd2UncmUgZW5jb2RpbmcgdGhlIFwidHlwZVwiIG9mIGFuIGVsZW1lbnQsIHdlIGNhbiByZWZlclxuICAgICAgLy8gdG8gdGhhdCBieSBhIGxhenkgcmVmZXJlbmNlIGluc3RlYWQgb2YgZGlyZWN0bHkgc2luY2UgUmVhY3RcbiAgICAgIC8vIGtub3dzIGhvdyB0byBkZWFsIHdpdGggbGF6eSB2YWx1ZXMuIFRoaXMgbGV0cyB1cyBzdXNwZW5kXG4gICAgICAvLyBvbiB0aGlzIGNvbXBvbmVudCByYXRoZXIgdGhhbiBpdHMgcGFyZW50IHVudGlsIHRoZSBjb2RlIGhhc1xuICAgICAgLy8gbG9hZGVkLlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUxhenlJRChtb2R1bGVJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRChtb2R1bGVJZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICB2YXIgZXJyb3JJZCA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICB2YXIgZGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCB4KTtcblxuICAgIHtcbiAgICAgIHZhciBfZ2V0RXJyb3JNZXNzYWdlQW5kU3QzID0gZ2V0RXJyb3JNZXNzYWdlQW5kU3RhY2tEZXYoeCksXG4gICAgICAgICAgbWVzc2FnZSA9IF9nZXRFcnJvck1lc3NhZ2VBbmRTdDMubWVzc2FnZSxcbiAgICAgICAgICBzdGFjayA9IF9nZXRFcnJvck1lc3NhZ2VBbmRTdDMuc3RhY2s7XG5cbiAgICAgIGVtaXRFcnJvckNodW5rRGV2KHJlcXVlc3QsIGVycm9ySWQsIGRpZ2VzdCwgbWVzc2FnZSwgc3RhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVCeVZhbHVlSUQoZXJyb3JJZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlWzBdID09PSAnJCcpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGVzY2FwZSAkIG9yIEAgcHJlZml4ZWQgc3RyaW5ncyBzaW5jZSB3ZSB1c2UgdGhvc2UgdG8gZW5jb2RlXG4gICAgLy8gcmVmZXJlbmNlcyB0byBJRHMgYW5kIGFzIHNwZWNpYWwgc3ltYm9sIHZhbHVlcy5cbiAgICByZXR1cm4gJyQnICsgdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0UHJvdG90eXBlKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIGlmIChvYmplY3QgPT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEl0IG1pZ2h0IGJlIGFuIG9iamVjdCBmcm9tIGEgZGlmZmVyZW50IFJlYWxtIHdoaWNoIGlzXG4gIC8vIHN0aWxsIGp1c3QgYSBwbGFpbiBzaW1wbGUgb2JqZWN0LlxuXG5cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCEobmFtZXNbaV0gaW4gT2JqZWN0UHJvdG90eXBlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1NpbXBsZU9iamVjdChvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdFByb3RvdHlwZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lc1tpXSk7XG5cbiAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKChuYW1lc1tpXSA9PT0gJ2tleScgfHwgbmFtZXNbaV0gPT09ICdyZWYnKSAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUmVhY3QgYWRkcyBrZXkgYW5kIHJlZiBnZXR0ZXJzIHRvIHByb3BzIG9iamVjdHMgdG8gaXNzdWUgd2FybmluZ3MuXG4gICAgICAgIC8vIFRob3NlIGdldHRlcnMgd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQgdG8gdGhlIGNsaWVudCwgYnV0IHRoYXQncyBvayxcbiAgICAgICAgLy8gc28gd2UnbGwgc3BlY2lhbCBjYXNlIHRoZW0uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdmFyIG5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgIHJldHVybiBwMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICB2YXIgZW5jb2RlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubGVuZ3RoIDw9IDEwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgMTApICsgJy4uLicpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShvYmplY3RPckFycmF5LCBleHBhbmRlZE5hbWUpIHtcbiAgdmFyIG9iaktpbmQgPSBvYmplY3ROYW1lKG9iamVjdE9yQXJyYXkpO1xuXG4gIGlmIChvYmpLaW5kICE9PSAnT2JqZWN0JyAmJiBvYmpLaW5kICE9PSAnQXJyYXknKSB7XG4gICAgcmV0dXJuIG9iaktpbmQ7XG4gIH1cblxuICB2YXIgc3RyID0gJyc7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgbGVuZ3RoID0gMDtcblxuICBpZiAoaXNBcnJheShvYmplY3RPckFycmF5KSkge1xuICAgIGlmICgganN4Q2hpbGRyZW5QYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgLy8gUHJpbnQgSlNYIENoaWxkcmVuXG4gICAgICB2YXIgdHlwZSA9IGpzeENoaWxkcmVuUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICBzdHIgPSAnPCcgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgJz4nO1xuICAgICAgdmFyIGFycmF5ID0gb2JqZWN0T3JBcnJheTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgdmFyIHN1YnN0ciA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN1YnN0ciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgc3Vic3RyID0gJ3snICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgJ30nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YnN0ciA9ICd7JyArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgJ30nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCcnICsgaSA9PT0gZXhwYW5kZWROYW1lKSB7XG4gICAgICAgICAgc3RhcnQgPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxlbmd0aCA9IHN1YnN0ci5sZW5ndGg7XG4gICAgICAgICAgc3RyICs9IHN1YnN0cjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWJzdHIubGVuZ3RoIDwgMTUgJiYgc3RyLmxlbmd0aCArIHN1YnN0ci5sZW5ndGggPCA0MCkge1xuICAgICAgICAgIHN0ciArPSBzdWJzdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICd7Li4ufSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyICs9ICc8LycgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcmludCBBcnJheVxuICAgICAgc3RyID0gJ1snO1xuICAgICAgdmFyIF9hcnJheSA9IG9iamVjdE9yQXJyYXk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfYXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGlmIChfaSA+IDApIHtcbiAgICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdmFsdWUgPSBfYXJyYXlbX2ldO1xuXG4gICAgICAgIHZhciBfc3Vic3RyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlID09PSAnb2JqZWN0JyAmJiBfdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgX3N1YnN0ciA9IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N1YnN0ciA9IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnJyArIF9pID09PSBleHBhbmRlZE5hbWUpIHtcbiAgICAgICAgICBzdGFydCA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgbGVuZ3RoID0gX3N1YnN0ci5sZW5ndGg7XG4gICAgICAgICAgc3RyICs9IF9zdWJzdHI7XG4gICAgICAgIH0gZWxzZSBpZiAoX3N1YnN0ci5sZW5ndGggPCAxMCAmJiBzdHIubGVuZ3RoICsgX3N1YnN0ci5sZW5ndGggPCA0MCkge1xuICAgICAgICAgIHN0ciArPSBfc3Vic3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSAnLi4uJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgKz0gJ10nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICBzdHIgPSAnPCcgKyBkZXNjcmliZUVsZW1lbnRUeXBlKG9iamVjdE9yQXJyYXkudHlwZSkgKyAnLz4nO1xuICAgIH0gZWxzZSBpZiAoIGpzeFByb3BzUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgIC8vIFByaW50IEpTWFxuICAgICAgdmFyIF90eXBlID0ganN4UHJvcHNQYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcblxuICAgICAgc3RyID0gJzwnICsgKGRlc2NyaWJlRWxlbWVudFR5cGUoX3R5cGUpIHx8ICcuLi4nKTtcbiAgICAgIHZhciBvYmplY3QgPSBvYmplY3RPckFycmF5O1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmFtZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBzdHIgKz0gJyAnO1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW19pMl07XG4gICAgICAgIHN0ciArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZShuYW1lKSArICc9JztcbiAgICAgICAgdmFyIF92YWx1ZTIgPSBvYmplY3RbbmFtZV07XG5cbiAgICAgICAgdmFyIF9zdWJzdHIyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChuYW1lID09PSBleHBhbmRlZE5hbWUgJiYgdHlwZW9mIF92YWx1ZTIgPT09ICdvYmplY3QnICYmIF92YWx1ZTIgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgX3N1YnN0cjIgPSBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3Vic3RyMiA9IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF92YWx1ZTIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX3N1YnN0cjIgPSAneycgKyBfc3Vic3RyMiArICd9JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSBleHBhbmRlZE5hbWUpIHtcbiAgICAgICAgICBzdGFydCA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgbGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoO1xuICAgICAgICAgIHN0ciArPSBfc3Vic3RyMjtcbiAgICAgICAgfSBlbHNlIGlmIChfc3Vic3RyMi5sZW5ndGggPCAxMCAmJiBzdHIubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICBzdHIgKz0gX3N1YnN0cjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByaW50IE9iamVjdFxuICAgICAgc3RyID0gJ3snO1xuICAgICAgdmFyIF9vYmplY3QgPSBvYmplY3RPckFycmF5O1xuXG4gICAgICB2YXIgX25hbWVzID0gT2JqZWN0LmtleXMoX29iamVjdCk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9uYW1lcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGlmIChfaTMgPiAwKSB7XG4gICAgICAgICAgc3RyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25hbWUgPSBfbmFtZXNbX2kzXTtcbiAgICAgICAgc3RyICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKF9uYW1lKSArICc6ICc7XG4gICAgICAgIHZhciBfdmFsdWUzID0gX29iamVjdFtfbmFtZV07XG5cbiAgICAgICAgdmFyIF9zdWJzdHIzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlMyA9PT0gJ29iamVjdCcgJiYgX3ZhbHVlMyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBfc3Vic3RyMyA9IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdWJzdHIzID0gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfbmFtZSA9PT0gZXhwYW5kZWROYW1lKSB7XG4gICAgICAgICAgc3RhcnQgPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxlbmd0aCA9IF9zdWJzdHIzLmxlbmd0aDtcbiAgICAgICAgICBzdHIgKz0gX3N1YnN0cjM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3N1YnN0cjMubGVuZ3RoIDwgMTAgJiYgc3RyLmxlbmd0aCArIF9zdWJzdHIzLmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgc3RyICs9IF9zdWJzdHIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSAnLi4uJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgKz0gJ30nO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHBhbmRlZE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAoc3RhcnQgPiAtMSAmJiBsZW5ndGggPiAwKSB7XG4gICAgdmFyIGhpZ2hsaWdodCA9ICcgJy5yZXBlYXQoc3RhcnQpICsgJ14nLnJlcGVhdChsZW5ndGgpO1xuICAgIHJldHVybiAnXFxuICAnICsgc3RyICsgJ1xcbiAgJyArIGhpZ2hsaWdodDtcbiAgfVxuXG4gIHJldHVybiAnXFxuICAnICsgc3RyO1xufVxuXG52YXIgaW5zaWRlQ29udGV4dFByb3BzID0gbnVsbDtcbnZhciBpc0luc2lkZUNvbnRleHRWYWx1ZSA9IGZhbHNlO1xuZnVuY3Rpb24gcmVzb2x2ZU1vZGVsVG9KU09OKHJlcXVlc3QsIHBhcmVudCwga2V5LCB2YWx1ZSkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gcGFyZW50W2tleV07XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVmFsdWUgPT09ICdvYmplY3QnICYmIG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBpZiAob2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgdmFyIGpzeFBhcmVudFR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBqc3hQYXJlbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yKCclcyBvYmplY3RzIGNhbm5vdCBiZSByZW5kZXJlZCBhcyB0ZXh0IGNoaWxkcmVuLiBUcnkgZm9ybWF0dGluZyBpdCB1c2luZyB0b1N0cmluZygpLiVzJywgb2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSwgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gJyArICclcyBvYmplY3RzIGFyZSBub3Qgc3VwcG9ydGVkLiVzJywgb2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSwgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzIGZyb20gU2VydmVyIENvbXBvbmVudHMuICcgKyAnT2JqZWN0cyB3aXRoIHRvSlNPTiBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiBDb252ZXJ0IGl0IG1hbnVhbGx5ICcgKyAndG8gYSBzaW1wbGUgdmFsdWUgYmVmb3JlIHBhc3NpbmcgaXQgdG8gcHJvcHMuJXMnLCBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIGtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTcGVjaWFsIFN5bWJvbHNcblxuXG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnJCc7XG4gIH1cblxuICB7XG4gICAgaWYgKHBhcmVudFswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmIHBhcmVudFsxXSAmJiBwYXJlbnRbMV0uJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgJiYga2V5ID09PSAnMycpIHtcbiAgICAgIGluc2lkZUNvbnRleHRQcm9wcyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaW5zaWRlQ29udGV4dFByb3BzID09PSBwYXJlbnQgJiYga2V5ID09PSAndmFsdWUnKSB7XG4gICAgICBpc0luc2lkZUNvbnRleHRWYWx1ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpbnNpZGVDb250ZXh0UHJvcHMgPT09IHBhcmVudCAmJiBrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIGlzSW5zaWRlQ29udGV4dFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlc29sdmUgU2VydmVyIENvbXBvbmVudHMuXG5cblxuICB3aGlsZSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fCB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSkge1xuICAgIHtcbiAgICAgIGlmIChpc0luc2lkZUNvbnRleHRWYWx1ZSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZWxlbWVudHMgYXJlIG5vdCBhbGxvd2VkIGluIFNlcnZlckNvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh2YWx1ZS4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDb25jYXRlbmF0ZSBrZXlzIG9mIHBhcmVudHMgb250byBjaGlsZHJlbi5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdmFsdWU7IC8vIEF0dGVtcHQgdG8gcmVuZGVyIHRoZSBTZXJ2ZXIgQ29tcG9uZW50LlxuXG4gICAgICAgICAgICB2YWx1ZSA9IGF0dGVtcHRSZXNvbHZlRWxlbWVudChyZXF1ZXN0LCBlbGVtZW50LnR5cGUsIGVsZW1lbnQua2V5LCBlbGVtZW50LnJlZiwgZWxlbWVudC5wcm9wcywgbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB2YWx1ZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gdmFsdWUuX2luaXQ7XG4gICAgICAgICAgICB2YWx1ZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIHZhciB4ID0gdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uID8gLy8gVGhpcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiBleGNlcHRpb24gdXNlZCBmb3IgU3VzcGVuc2UuIEZvciBoaXN0b3JpY2FsXG4gICAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgICAvLyB2YWx1ZSB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZVxuICAgICAgLy8gKHVuc3RhYmxlKSBBUEkgZm9yIHN1c3BlbmRpbmcuIFRoaXMgaW1wbGVtZW50YXRpb24gZGV0YWlsIGNhbiBjaGFuZ2VcbiAgICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICAgIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkgOiB0aHJvd25WYWx1ZTsgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLCB3ZSdsbCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB0YXNrIGFuZCByZXNvbHZlIGl0IGxhdGVyLlxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgICAgdmFyIG5ld1Rhc2sgPSBjcmVhdGVUYXNrKHJlcXVlc3QsIHZhbHVlLCBnZXRBY3RpdmVDb250ZXh0KCksIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MpO1xuICAgICAgICB2YXIgcGluZyA9IG5ld1Rhc2sucGluZztcbiAgICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgICAgICBuZXdUYXNrLnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVMYXp5SUQobmV3VGFzay5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTb21ldGhpbmcgZXJyb3JlZC4gV2UnbGwgc3RpbGwgc2VuZCBldmVyeXRoaW5nIHdlIGhhdmUgdXAgdW50aWwgdGhpcyBwb2ludC5cbiAgICAgICAgLy8gV2UnbGwgcmVwbGFjZSB0aGlzIGVsZW1lbnQgd2l0aCBhIGxhenkgcmVmZXJlbmNlIHRoYXQgdGhyb3dzIG9uIHRoZSBjbGllbnRcbiAgICAgICAgLy8gb25jZSBpdCBnZXRzIHJlbmRlcmVkLlxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgICAgdmFyIGVycm9ySWQgPSByZXF1ZXN0Lm5leHRDaHVua0lkKys7XG4gICAgICAgIHZhciBkaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIHgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2dldEVycm9yTWVzc2FnZUFuZFN0NCA9IGdldEVycm9yTWVzc2FnZUFuZFN0YWNrRGV2KHgpLFxuICAgICAgICAgICAgICBtZXNzYWdlID0gX2dldEVycm9yTWVzc2FnZUFuZFN0NC5tZXNzYWdlLFxuICAgICAgICAgICAgICBzdGFjayA9IF9nZXRFcnJvck1lc3NhZ2VBbmRTdDQuc3RhY2s7XG5cbiAgICAgICAgICBlbWl0RXJyb3JDaHVua0RldihyZXF1ZXN0LCBlcnJvcklkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVMYXp5SUQoZXJyb3JJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChpc0NsaWVudFJlZmVyZW5jZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVDbGllbnRSZWZlcmVuY2UocmVxdWVzdCwgcGFyZW50LCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBhbnkgb2JqZWN0IHdpdGggYSAudGhlbiBwcm9wZXJ0eSBpcyBhIFwiVGhlbmFibGVcIiB0eXBlLFxuICAgICAgLy8gb3IgYSBQcm9taXNlIHR5cGUuIEVpdGhlciBvZiB3aGljaCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgYSBQcm9taXNlLlxuICAgICAgdmFyIHByb21pc2VJZCA9IHNlcmlhbGl6ZVRoZW5hYmxlKHJlcXVlc3QsIHZhbHVlKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVQcm9taXNlSUQocHJvbWlzZUlkKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICB2YXIgcHJvdmlkZXJLZXkgPSB2YWx1ZS5fY29udGV4dC5fZ2xvYmFsTmFtZTtcbiAgICAgIHZhciB3cml0dGVuUHJvdmlkZXJzID0gcmVxdWVzdC53cml0dGVuUHJvdmlkZXJzO1xuICAgICAgdmFyIHByb3ZpZGVySWQgPSB3cml0dGVuUHJvdmlkZXJzLmdldChrZXkpO1xuXG4gICAgICBpZiAocHJvdmlkZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgICBwcm92aWRlcklkID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrO1xuICAgICAgICB3cml0dGVuUHJvdmlkZXJzLnNldChwcm92aWRlcktleSwgcHJvdmlkZXJJZCk7XG4gICAgICAgIGVtaXRQcm92aWRlckNodW5rKHJlcXVlc3QsIHByb3ZpZGVySWQsIHByb3ZpZGVyS2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRChwcm92aWRlcklkKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBQT1ApIHtcbiAgICAgIHBvcFByb3ZpZGVyKCk7XG5cbiAgICAgIHtcbiAgICAgICAgaW5zaWRlQ29udGV4dFByb3BzID0gbnVsbDtcbiAgICAgICAgaXNJbnNpZGVDb250ZXh0VmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoaXMgaXMgYSBzaW1wbGUgcGxhaW4gb2JqZWN0LlxuICAgICAgICBpZiAob2JqZWN0TmFtZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzIGZyb20gU2VydmVyIENvbXBvbmVudHMuICcgKyAnJXMgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZC4lcycsIG9iamVjdE5hbWUodmFsdWUpLCBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1NpbXBsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBlcnJvcignT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gJyArICdDbGFzc2VzIG9yIG90aGVyIG9iamVjdHMgd2l0aCBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiVzJywgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChzeW1ib2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycm9yKCdPbmx5IHBsYWluIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB0byBDbGllbnQgQ29tcG9uZW50cyBmcm9tIFNlcnZlciBDb21wb25lbnRzLiAnICsgJ09iamVjdHMgd2l0aCBzeW1ib2wgcHJvcGVydGllcyBsaWtlICVzIGFyZSBub3Qgc3VwcG9ydGVkLiVzJywgc3ltYm9sc1swXS5kZXNjcmlwdGlvbiwgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVcblxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXNjYXBlU3RyaW5nVmFsdWUodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplQ2xpZW50UmVmZXJlbmNlKHJlcXVlc3QsIHBhcmVudCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKC9eb25bQS1aXS8udGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IGhhbmRsZXJzIGNhbm5vdCBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudCBwcm9wcy4nICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpICsgJ1xcbklmIHlvdSBuZWVkIGludGVyYWN0aXZpdHksIGNvbnNpZGVyIGNvbnZlcnRpbmcgcGFydCBvZiB0aGlzIHRvIGEgQ2xpZW50IENvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbnMgY2Fubm90IGJlIHBhc3NlZCBkaXJlY3RseSB0byBDbGllbnQgQ29tcG9uZW50cyAnICsgXCJiZWNhdXNlIHRoZXkncmUgbm90IHNlcmlhbGl6YWJsZS5cIiArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwga2V5KSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICB2YXIgd3JpdHRlblN5bWJvbHMgPSByZXF1ZXN0LndyaXR0ZW5TeW1ib2xzO1xuICAgIHZhciBleGlzdGluZ0lkID0gd3JpdHRlblN5bWJvbHMuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChleGlzdGluZ0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVCeVZhbHVlSUQoZXhpc3RpbmdJZCk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIGBkZXNjcmlwdGlvbmAgbWlnaHQgYmUgdW5kZWZpbmVkXG5cblxuICAgIHZhciBuYW1lID0gdmFsdWUuZGVzY3JpcHRpb247XG5cbiAgICBpZiAoU3ltYm9sLmZvcihuYW1lKSAhPT0gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBnbG9iYWwgc3ltYm9scyByZWNlaXZlZCBmcm9tIFN5bWJvbC5mb3IoLi4uKSBjYW4gYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzLiAnICsgKFwiVGhlIHN5bWJvbCBTeW1ib2wuZm9yKFwiICsgLy8gJEZsb3dGaXhNZSBgZGVzY3JpcHRpb25gIG1pZ2h0IGJlIHVuZGVmaW5lZFxuICAgICAgdmFsdWUuZGVzY3JpcHRpb24gKyBcIikgY2Fubm90IGJlIGZvdW5kIGFtb25nIGdsb2JhbCBzeW1ib2xzLlwiKSArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwga2V5KSk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgdmFyIHN5bWJvbElkID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrO1xuICAgIGVtaXRTeW1ib2xDaHVuayhyZXF1ZXN0LCBzeW1ib2xJZCwgbmFtZSk7XG4gICAgd3JpdHRlblN5bWJvbHMuc2V0KHZhbHVlLCBzeW1ib2xJZCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRChzeW1ib2xJZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCAoXCIgKyB2YWx1ZSArIFwiKSBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50IHByb3BzLlwiICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlR5cGUgXCIgKyB0eXBlb2YgdmFsdWUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnQgcHJvcHMuXCIgKyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIGtleSkpO1xufVxuXG5mdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIHZhciBvbkVycm9yID0gcmVxdWVzdC5vbkVycm9yO1xuICB2YXIgZXJyb3JEaWdlc3QgPSBvbkVycm9yKGVycm9yKTtcblxuICBpZiAoZXJyb3JEaWdlc3QgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3JEaWdlc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFxcXCJzdHJpbmdcXFwiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcXFwiXCIgKyB0eXBlb2YgZXJyb3JEaWdlc3QgKyBcIlxcXCIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvckRpZ2VzdCB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlQW5kU3RhY2tEZXYoZXJyb3IpIHtcbiAge1xuICAgIHZhciBtZXNzYWdlO1xuICAgIHZhciBzdGFjayA9ICcnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICBtZXNzYWdlID0gU3RyaW5nKGVycm9yLm1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuICAgICAgICBzdGFjayA9IFN0cmluZyhlcnJvci5zdGFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gJ0Vycm9yOiAnICsgZXJyb3I7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgbWVzc2FnZSA9ICdBbiBlcnJvciBvY2N1cnJlZCBidXQgc2VyaWFsaXppbmcgdGhlIGVycm9yIG1lc3NhZ2UgZmFpbGVkLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFjazogc3RhY2tcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgb3V0c2lkZSBlcnJvciBoYW5kbGluZyBjb2RlIHN1Y2ggYXMgaWYgYW4gZXJyb3IgaGFwcGVucyBpbiBSZWFjdCBpbnRlcm5hbHMuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IocmVxdWVzdC5kZXN0aW5hdGlvbiwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0lORztcbiAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JDaHVua1Byb2QocmVxdWVzdCwgaWQsIGRpZ2VzdCkge1xuICB2YXIgcHJvY2Vzc2VkQ2h1bmsgPSBwcm9jZXNzRXJyb3JDaHVua1Byb2QocmVxdWVzdCwgaWQsIGRpZ2VzdCk7XG4gIHJlcXVlc3QuY29tcGxldGVkRXJyb3JDaHVua3MucHVzaChwcm9jZXNzZWRDaHVuayk7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckNodW5rRGV2KHJlcXVlc3QsIGlkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKSB7XG4gIHZhciBwcm9jZXNzZWRDaHVuayA9IHByb2Nlc3NFcnJvckNodW5rRGV2KHJlcXVlc3QsIGlkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKTtcbiAgcmVxdWVzdC5jb21wbGV0ZWRFcnJvckNodW5rcy5wdXNoKHByb2Nlc3NlZENodW5rKTtcbn1cblxuZnVuY3Rpb24gZW1pdE1vZHVsZUNodW5rKHJlcXVlc3QsIGlkLCBtb2R1bGVNZXRhRGF0YSkge1xuICB2YXIgcHJvY2Vzc2VkQ2h1bmsgPSBwcm9jZXNzTW9kdWxlQ2h1bmsocmVxdWVzdCwgaWQsIG1vZHVsZU1ldGFEYXRhKTtcbiAgcmVxdWVzdC5jb21wbGV0ZWRNb2R1bGVDaHVua3MucHVzaChwcm9jZXNzZWRDaHVuayk7XG59XG5cbmZ1bmN0aW9uIGVtaXRTeW1ib2xDaHVuayhyZXF1ZXN0LCBpZCwgbmFtZSkge1xuICB2YXIgc3ltYm9sUmVmZXJlbmNlID0gc2VyaWFsaXplU3ltYm9sUmVmZXJlbmNlKG5hbWUpO1xuICB2YXIgcHJvY2Vzc2VkQ2h1bmsgPSBwcm9jZXNzUmVmZXJlbmNlQ2h1bmsocmVxdWVzdCwgaWQsIHN5bWJvbFJlZmVyZW5jZSk7XG4gIHJlcXVlc3QuY29tcGxldGVkTW9kdWxlQ2h1bmtzLnB1c2gocHJvY2Vzc2VkQ2h1bmspO1xufVxuXG5mdW5jdGlvbiBlbWl0UHJvdmlkZXJDaHVuayhyZXF1ZXN0LCBpZCwgY29udGV4dE5hbWUpIHtcbiAgdmFyIGNvbnRleHRSZWZlcmVuY2UgPSBzZXJpYWxpemVQcm92aWRlclJlZmVyZW5jZShjb250ZXh0TmFtZSk7XG4gIHZhciBwcm9jZXNzZWRDaHVuayA9IHByb2Nlc3NSZWZlcmVuY2VDaHVuayhyZXF1ZXN0LCBpZCwgY29udGV4dFJlZmVyZW5jZSk7XG4gIHJlcXVlc3QuY29tcGxldGVkSlNPTkNodW5rcy5wdXNoKHByb2Nlc3NlZENodW5rKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgaWYgKHRhc2suc3RhdHVzICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gV2UgY29tcGxldGVkIHRoaXMgYnkgb3RoZXIgbWVhbnMgYmVmb3JlIHdlIGhhZCBhIGNoYW5jZSB0byByZXRyeSBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2hDb250ZXh0KHRhc2suY29udGV4dCk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdmFsdWUgPSB0YXNrLm1vZGVsO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgLy8gVE9ETzogQ29uY2F0ZW5hdGUga2V5cyBvZiBwYXJlbnRzIG9udG8gY2hpbGRyZW4uXG4gICAgICB2YXIgZWxlbWVudCA9IHZhbHVlOyAvLyBXaGVuIHJldHJ5aW5nIGEgY29tcG9uZW50LCByZXVzZSB0aGUgdGhlbmFibGVTdGF0ZSBmcm9tIHRoZVxuICAgICAgLy8gcHJldmlvdXMgYXR0ZW1wdC5cblxuICAgICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlOyAvLyBBdHRlbXB0IHRvIHJlbmRlciB0aGUgU2VydmVyIENvbXBvbmVudC5cbiAgICAgIC8vIERvaW5nIHRoaXMgaGVyZSBsZXRzIHVzIHJldXNlIHRoaXMgc2FtZSB0YXNrIGlmIHRoZSBuZXh0IGNvbXBvbmVudFxuICAgICAgLy8gYWxzbyBzdXNwZW5kcy5cblxuICAgICAgdGFzay5tb2RlbCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSBhdHRlbXB0UmVzb2x2ZUVsZW1lbnQocmVxdWVzdCwgZWxlbWVudC50eXBlLCBlbGVtZW50LmtleSwgZWxlbWVudC5yZWYsIGVsZW1lbnQucHJvcHMsIHByZXZUaGVuYWJsZVN0YXRlKTsgLy8gU3VjY2Vzc2Z1bGx5IGZpbmlzaGVkIHRoaXMgY29tcG9uZW50LiBXZSdyZSBnb2luZyB0byBrZWVwIHJlbmRlcmluZ1xuICAgICAgLy8gdXNpbmcgdGhlIHNhbWUgdGFzaywgYnV0IHdlIHJlc2V0IGl0cyB0aGVuYWJsZSBzdGF0ZSBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDsgLy8gS2VlcCByZW5kZXJpbmcgYW5kIHJldXNlIHRoZSBzYW1lIHRhc2suIFRoaXMgaW5uZXIgbG9vcCBpcyBzZXBhcmF0ZVxuICAgICAgLy8gZnJvbSB0aGUgcmVuZGVyIGFib3ZlIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0byByZXNldCB0aGUgdGhlbmFibGUgc3RhdGVcbiAgICAgIC8vIHVudGlsIHRoZSBuZXh0IHRpbWUgc29tZXRoaW5nIHN1c3BlbmRzIGFuZCByZXRyaWVzLlxuXG4gICAgICB3aGlsZSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIC8vIFRPRE86IENvbmNhdGVuYXRlIGtleXMgb2YgcGFyZW50cyBvbnRvIGNoaWxkcmVuLlxuICAgICAgICB2YXIgbmV4dEVsZW1lbnQgPSB2YWx1ZTtcbiAgICAgICAgdGFzay5tb2RlbCA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGF0dGVtcHRSZXNvbHZlRWxlbWVudChyZXF1ZXN0LCBuZXh0RWxlbWVudC50eXBlLCBuZXh0RWxlbWVudC5rZXksIG5leHRFbGVtZW50LnJlZiwgbmV4dEVsZW1lbnQucHJvcHMsIG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9jZXNzZWRDaHVuayA9IHByb2Nlc3NNb2RlbENodW5rKHJlcXVlc3QsIHRhc2suaWQsIHZhbHVlKTtcbiAgICByZXF1ZXN0LmNvbXBsZXRlZEpTT05DaHVua3MucHVzaChwcm9jZXNzZWRDaHVuayk7XG4gICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5kZWxldGUodGFzayk7XG4gICAgdGFzay5zdGF0dXMgPSBDT01QTEVURUQ7XG4gIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFnYWluLCBsZXQncyBwaWNrIGl0IGJhY2sgdXAgbGF0ZXIuXG4gICAgICB2YXIgcGluZyA9IHRhc2sucGluZztcbiAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5kZWxldGUodGFzayk7XG4gICAgICB0YXNrLnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgICB2YXIgZGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCB4KTtcblxuICAgICAge1xuICAgICAgICB2YXIgX2dldEVycm9yTWVzc2FnZUFuZFN0NSA9IGdldEVycm9yTWVzc2FnZUFuZFN0YWNrRGV2KHgpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IF9nZXRFcnJvck1lc3NhZ2VBbmRTdDUubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrID0gX2dldEVycm9yTWVzc2FnZUFuZFN0NS5zdGFjaztcblxuICAgICAgICBlbWl0RXJyb3JDaHVua0RldihyZXF1ZXN0LCB0YXNrLmlkLCBkaWdlc3QsIG1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gIHZhciBwcmV2Q2FjaGUgPSBnZXRDdXJyZW50Q2FjaGUoKTtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyO1xuICBzZXRDdXJyZW50Q2FjaGUocmVxdWVzdC5jYWNoZSk7XG4gIHByZXBhcmVUb1VzZUhvb2tzRm9yUmVxdWVzdChyZXF1ZXN0KTtcblxuICB0cnkge1xuICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gICAgcmVxdWVzdC5waW5nZWRUYXNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhc2sgPSBwaW5nZWRUYXNrc1tpXTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRDaHVua3MocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgIHNldEN1cnJlbnRDYWNoZShwcmV2Q2FjaGUpO1xuICAgIHJlc2V0SG9va3NGb3JSZXF1ZXN0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9ySWQpIHtcbiAgdGFzay5zdGF0dXMgPSBBQk9SVEVEOyAvLyBJbnN0ZWFkIG9mIGVtaXR0aW5nIGFuIGVycm9yIHBlciB0YXNrLmlkLCB3ZSBlbWl0IGEgbW9kZWwgdGhhdCBvbmx5XG4gIC8vIGhhcyBhIHNpbmdsZSB2YWx1ZSByZWZlcmVuY2luZyB0aGUgZXJyb3IuXG5cbiAgdmFyIHJlZiA9IHNlcmlhbGl6ZUJ5VmFsdWVJRChlcnJvcklkKTtcbiAgdmFyIHByb2Nlc3NlZENodW5rID0gcHJvY2Vzc1JlZmVyZW5jZUNodW5rKHJlcXVlc3QsIHRhc2suaWQsIHJlZik7XG4gIHJlcXVlc3QuY29tcGxldGVkRXJyb3JDaHVua3MucHVzaChwcm9jZXNzZWRDaHVuayk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQ2h1bmtzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gIGJlZ2luV3JpdGluZygpO1xuXG4gIHRyeSB7XG4gICAgLy8gV2UgZW1pdCBtb2R1bGUgY2h1bmtzIGZpcnN0IGluIHRoZSBzdHJlYW0gc28gdGhhdFxuICAgIC8vIHRoZXkgY2FuIGJlIHByZWxvYWRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICB2YXIgbW9kdWxlQ2h1bmtzID0gcmVxdWVzdC5jb21wbGV0ZWRNb2R1bGVDaHVua3M7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBtb2R1bGVDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcy0tO1xuICAgICAgdmFyIGNodW5rID0gbW9kdWxlQ2h1bmtzW2ldO1xuICAgICAgdmFyIGtlZXBXcml0aW5nID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspO1xuXG4gICAgICBpZiAoIWtlZXBXcml0aW5nKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZUNodW5rcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgY29tZXMgbW9kZWwgZGF0YS5cblxuICAgIHZhciBqc29uQ2h1bmtzID0gcmVxdWVzdC5jb21wbGV0ZWRKU09OQ2h1bmtzO1xuICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBqc29uQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MtLTtcbiAgICAgIHZhciBfY2h1bmsgPSBqc29uQ2h1bmtzW2ldO1xuXG4gICAgICB2YXIgX2tlZXBXcml0aW5nID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgX2NodW5rKTtcblxuICAgICAgaWYgKCFfa2VlcFdyaXRpbmcpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAganNvbkNodW5rcy5zcGxpY2UoMCwgaSk7IC8vIEZpbmFsbHksIGVycm9ycyBhcmUgc2VudC4gVGhlIGlkZWEgaXMgdGhhdCBpdCdzIG9rIHRvIGRlbGF5XG4gICAgLy8gYW55IGVycm9yIG1lc3NhZ2VzIGFuZCBwcmlvcml0aXplIGRpc3BsYXkgb2Ygb3RoZXIgcGFydHMgb2ZcbiAgICAvLyB0aGUgcGFnZS5cblxuICAgIHZhciBlcnJvckNodW5rcyA9IHJlcXVlc3QuY29tcGxldGVkRXJyb3JDaHVua3M7XG4gICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGVycm9yQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MtLTtcbiAgICAgIHZhciBfY2h1bmsyID0gZXJyb3JDaHVua3NbaV07XG5cbiAgICAgIHZhciBfa2VlcFdyaXRpbmcyID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgX2NodW5rMik7XG5cbiAgICAgIGlmICghX2tlZXBXcml0aW5nMikge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvckNodW5rcy5zcGxpY2UoMCwgaSk7XG4gIH0gZmluYWxseSB7XG4gICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnBlbmRpbmdDaHVua3MgPT09IDApIHtcbiAgICAvLyBXZSdyZSBkb25lLlxuICAgIGNsb3NlKGRlc3RpbmF0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICBpZiAoc3VwcG9ydHNSZXF1ZXN0U3RvcmFnZSkge1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdFN0b3JhZ2UucnVuKHJlcXVlc3QuY2FjaGUsIHBlcmZvcm1Xb3JrLCByZXF1ZXN0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TSU5HKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgZmxvd2luZy5cbiAgICByZXR1cm47XG4gIH1cblxuICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG5cbiAgdHJ5IHtcbiAgICBmbHVzaENvbXBsZXRlZENodW5rcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH1cbn0gLy8gVGhpcyBpcyBjYWxsZWQgdG8gZWFybHkgdGVybWluYXRlIGEgcmVxdWVzdC4gSXQgY3JlYXRlcyBhbiBlcnJvciBhdCBhbGwgcGVuZGluZyB0YXNrcy5cblxuZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcblxuICAgIGlmIChhYm9ydGFibGVUYXNrcy5zaXplID4gMCkge1xuICAgICAgLy8gV2UgaGF2ZSB0YXNrcyB0byBhYm9ydC4gV2UnbGwgZW1pdCBvbmUgZXJyb3Igcm93IGFuZCB0aGVuIGVtaXQgYSByZWZlcmVuY2VcbiAgICAgIC8vIHRvIHRoYXQgcm93IGZyb20gZXZlcnkgcm93IHRoYXQncyBzdGlsbCByZW1haW5pbmcuXG4gICAgICB2YXIgZXJyb3IgPSByZWFzb24gPT09IHVuZGVmaW5lZCA/IG5ldyBFcnJvcignVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uJykgOiByZWFzb247XG4gICAgICB2YXIgZGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgIHZhciBlcnJvcklkID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrO1xuXG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICB2YXIgX2dldEVycm9yTWVzc2FnZUFuZFN0NiA9IGdldEVycm9yTWVzc2FnZUFuZFN0YWNrRGV2KGVycm9yKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfZ2V0RXJyb3JNZXNzYWdlQW5kU3Q2Lm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjayA9IF9nZXRFcnJvck1lc3NhZ2VBbmRTdDYuc3RhY2s7XG5cbiAgICAgICAgZW1pdEVycm9yQ2h1bmtEZXYocmVxdWVzdCwgZXJyb3JJZCwgZGlnZXN0LCBtZXNzYWdlLCBzdGFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0RXJyb3JDaHVua1Byb2QocmVxdWVzdCwgZXJyb3JJZCwgZGlnZXN0KTtcbiAgICAgIH1cblxuICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9ySWQpO1xuICAgICAgfSk7XG4gICAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBmbHVzaENvbXBsZXRlZENodW5rcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0U2VydmVyQ29udGV4dHMoY29udGV4dHMpIHtcbiAgaWYgKGNvbnRleHRzKSB7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gZ2V0QWN0aXZlQ29udGV4dCgpO1xuICAgIHN3aXRjaENvbnRleHQocm9vdENvbnRleHRTbmFwc2hvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2NvbnRleHRzJGkgPSBjb250ZXh0c1tpXSxcbiAgICAgICAgICBuYW1lID0gX2NvbnRleHRzJGlbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfY29udGV4dHMkaVsxXTtcbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0T3JDcmVhdGVTZXJ2ZXJDb250ZXh0KG5hbWUpO1xuICAgICAgcHVzaFByb3ZpZGVyKGNvbnRleHQsIHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgaW1wb3J0ZWRDb250ZXh0ID0gZ2V0QWN0aXZlQ29udGV4dCgpO1xuICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIHJldHVybiBpbXBvcnRlZENvbnRleHQ7XG4gIH1cblxuICByZXR1cm4gcm9vdENvbnRleHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9SZWFkYWJsZVN0cmVhbShtb2RlbCwgd2VicGFja01hcCwgb3B0aW9ucykge1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QobW9kZWwsIHdlYnBhY2tNYXAsIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLmNvbnRleHQgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB1bmRlZmluZWQpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuXG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHR5cGU6ICdieXRlcycsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBzdGFydFdvcmsocmVxdWVzdCk7XG4gICAgfSxcbiAgICBwdWxsOiBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgc3RhcnRGbG93aW5nKHJlcXVlc3QsIGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgY2FuY2VsOiBmdW5jdGlvbiAocmVhc29uKSB7fVxuICB9LCAvLyAkRmxvd0ZpeE1lIHNpemUoKSBtZXRob2RzIGFyZSBub3QgYWxsb3dlZCBvbiBieXRlIHN0cmVhbXMuXG4gIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiAwXG4gIH0pO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5leHBvcnRzLnJlbmRlclRvUmVhZGFibGVTdHJlYW0gPSByZW5kZXJUb1JlYWRhYmxlU3RyZWFtO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwic2NoZWR1bGVXb3JrIiwiY2FsbGJhY2siLCJzdXBwb3J0c1JlcXVlc3RTdG9yYWdlIiwiQXN5bmNMb2NhbFN0b3JhZ2UiLCJyZXF1ZXN0U3RvcmFnZSIsIlZJRVdfU0laRSIsImN1cnJlbnRWaWV3Iiwid3JpdHRlbkJ5dGVzIiwiYmVnaW5Xcml0aW5nIiwiZGVzdGluYXRpb24iLCJVaW50OEFycmF5Iiwid3JpdGVDaHVuayIsImNodW5rIiwicHJlY29tcHV0ZWRDaHVua1NldCIsImhhcyIsImVucXVldWUiLCJidWZmZXIiLCJieXRlc1RvV3JpdGUiLCJhbGxvd2FibGVCeXRlcyIsInNldCIsInN1YmFycmF5Iiwid3JpdGVDaHVua0FuZFJldHVybiIsImNvbXBsZXRlV3JpdGluZyIsImNsb3NlIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsInN0cmluZ1RvQ2h1bmsiLCJjb250ZW50IiwiZW5jb2RlIiwiU2V0Iiwic3RyaW5nVG9QcmVjb21wdXRlZENodW5rIiwicHJlY29tcHV0ZWRDaHVuayIsImFkZCIsImNsb3NlV2l0aEVycm9yIiwic3RyaW5naWZ5IiwiSlNPTiIsInNlcmlhbGl6ZVJvd0hlYWRlciIsInRhZyIsImlkIiwidG9TdHJpbmciLCJwcm9jZXNzRXJyb3JDaHVua1Byb2QiLCJyZXF1ZXN0IiwiZGlnZXN0IiwiRXJyb3IiLCJlcnJvckluZm8iLCJyb3ciLCJwcm9jZXNzRXJyb3JDaHVua0RldiIsIm1lc3NhZ2UiLCJwcm9jZXNzTW9kZWxDaHVuayIsIm1vZGVsIiwianNvbiIsInRvSlNPTiIsInByb2Nlc3NSZWZlcmVuY2VDaHVuayIsInJlZmVyZW5jZSIsInByb2Nlc3NNb2R1bGVDaHVuayIsIm1vZHVsZU1ldGFEYXRhIiwiQ0xJRU5UX1JFRkVSRU5DRV9UQUciLCJTeW1ib2wiLCJmb3IiLCJnZXRDbGllbnRSZWZlcmVuY2VLZXkiLCJmaWxlcGF0aCIsIm5hbWUiLCJhc3luYyIsImlzQ2xpZW50UmVmZXJlbmNlIiwiJCR0eXBlb2YiLCJyZXNvbHZlTW9kdWxlTWV0YURhdGEiLCJjb25maWciLCJjbGllbnRSZWZlcmVuY2UiLCJyZXNvbHZlZE1vZHVsZURhdGEiLCJjaHVua3MiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCIsIlJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwiLCJSRVNFUlZFRCIsIlNUUklORyIsIkJPT0xFQU5JU0hfU1RSSU5HIiwiQk9PTEVBTiIsIk9WRVJMT0FERURfQk9PTEVBTiIsIk5VTUVSSUMiLCJQT1NJVElWRV9OVU1FUklDIiwiUHJvcGVydHlJbmZvUmVjb3JkIiwidHlwZSIsIm11c3RVc2VQcm9wZXJ0eSIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJzYW5pdGl6ZVVSTCIsInJlbW92ZUVtcHR5U3RyaW5nIiwiYWNjZXB0c0Jvb2xlYW5zIiwicHJvcGVydHlOYW1lIiwicHJvcGVydGllcyIsInJlc2VydmVkUHJvcHMiLCJmb3JFYWNoIiwiX3JlZiIsInRvTG93ZXJDYXNlIiwiQ0FNRUxJWkUiLCJjYXBpdGFsaXplIiwidG9rZW4iLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJ4bGlua0hyZWYiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhc3BlY3RSYXRpbyIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRBcmVhIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeCIsImtleSIsImNoYXJBdCIsInN1YnN0cmluZyIsInByZWZpeGVzIiwiT2JqZWN0Iiwia2V5cyIsInByb3AiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwiY2xpZW50UmVuZGVyQm91bmRhcnkiLCJjb21wbGV0ZUJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMiLCJjb21wbGV0ZVNlZ21lbnQiLCJSZWFjdERPTVNoYXJlZEludGVybmFscyIsIlJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIiLCJEaXNwYXRjaGVyIiwiZGF0YUVsZW1lbnRRdW90ZWRFbmQiLCJzdGFydElubGluZVNjcmlwdCIsImVuZElubGluZVNjcmlwdCIsInN0YXJ0U2NyaXB0U3JjIiwic3RhcnRNb2R1bGVTcmMiLCJzY3JpcHRJbnRlZ2lydHkiLCJlbmRBc3luY1NjcmlwdCIsInRleHRTZXBhcmF0b3IiLCJzdHlsZUF0dHJpYnV0ZVN0YXJ0Iiwic3R5bGVBc3NpZ24iLCJzdHlsZVNlcGFyYXRvciIsImF0dHJpYnV0ZVNlcGFyYXRvciIsImF0dHJpYnV0ZUFzc2lnbiIsImF0dHJpYnV0ZUVuZCIsImF0dHJpYnV0ZUVtcHR5U3RyaW5nIiwiZW5kT2ZTdGFydFRhZyIsImVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwibGVhZGluZ05ld2xpbmUiLCJET0NUWVBFIiwiZW5kVGFnMSIsImVuZFRhZzIiLCJwbGFjZWhvbGRlcjEiLCJwbGFjZWhvbGRlcjIiLCJzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkiLCJzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyIiwic3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJlbmRTdXNwZW5zZUJvdW5kYXJ5IiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyIiwic3RhcnRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudEhUTUwyIiwiZW5kU2VnbWVudEhUTUwiLCJzdGFydFNlZ21lbnRTVkciLCJzdGFydFNlZ21lbnRTVkcyIiwiZW5kU2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudE1hdGhNTCIsInN0YXJ0U2VnbWVudE1hdGhNTDIiLCJlbmRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZTIiLCJlbmRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkyIiwiZW5kU2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50VGFibGVSb3cyIiwiZW5kU2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50Q29sR3JvdXAiLCJzdGFydFNlZ21lbnRDb2xHcm91cDIiLCJlbmRTZWdtZW50Q29sR3JvdXAiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVTZWdtZW50U2NyaXB0MiIsImNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCIsImNvbXBsZXRlU2VnbWVudERhdGExIiwiY29tcGxldGVTZWdtZW50RGF0YTIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQyIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCIsImNvbXBsZXRlQm91bmRhcnlEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTIiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhIiwiY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwiLCJjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCIsImNsaWVudFJlbmRlclNjcmlwdDFBIiwiY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHRFbmQiLCJjbGllbnRSZW5kZXJEYXRhMSIsImNsaWVudFJlbmRlckRhdGEyIiwiY2xpZW50UmVuZGVyRGF0YTMiLCJjbGllbnRSZW5kZXJEYXRhNCIsInByZWNlZGVuY2VQbGFjZWhvbGRlclN0YXJ0IiwicHJlY2VkZW5jZVBsYWNlaG9sZGVyRW5kIiwiYXJyYXlGaXJzdE9wZW5CcmFja2V0IiwiYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQiLCJhcnJheUludGVyc3RpdGlhbCIsImFycmF5Q2xvc2VCcmFja2V0IiwicmVuZGVyZXJTaWdpbCIsInJvb3RDb250ZXh0U25hcHNob3QiLCJjdXJyZW50QWN0aXZlU25hcHNob3QiLCJwb3BOb2RlIiwicHJldiIsImNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsIm5leHQiLCJ2YWx1ZSIsInBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yIiwicGFyZW50UHJldiIsInBhcmVudCIsInBhcmVudE5leHQiLCJwb3BBbGxQcmV2aW91cyIsInB1c2hBbGxOZXh0IiwicG9wUHJldmlvdXNUb0NvbW1vbkxldmVsIiwiZGVwdGgiLCJwb3BOZXh0VG9Db21tb25MZXZlbCIsInN3aXRjaENvbnRleHQiLCJuZXdTbmFwc2hvdCIsInB1c2hQcm92aWRlciIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIiLCJ1bmRlZmluZWQiLCJwcmV2Tm9kZSIsIm5ld05vZGUiLCJwb3BQcm92aWRlciIsInByZXZTbmFwc2hvdCIsIl9kZWZhdWx0VmFsdWUiLCJnZXRBY3RpdmVDb250ZXh0IiwicmVhZENvbnRleHQiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJub29wIiwidHJhY2tVc2VkVGhlbmFibGUiLCJ0aGVuYWJsZVN0YXRlIiwidGhlbmFibGUiLCJpbmRleCIsInByZXZpb3VzIiwicHVzaCIsInRoZW4iLCJzdGF0dXMiLCJmdWxmaWxsZWRWYWx1ZSIsInJlamVjdGVkRXJyb3IiLCJyZWFzb24iLCJwZW5kaW5nVGhlbmFibGUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsInJlamVjdGVkVGhlbmFibGUiLCJzdXNwZW5kZWRUaGVuYWJsZSIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwiY3VycmVudFJlcXVlc3QiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsInByZXBhcmVUb1VzZUhvb2tzRm9yUmVxdWVzdCIsInJlc2V0SG9va3NGb3JSZXF1ZXN0IiwicHJlcGFyZVRvVXNlSG9va3NGb3JDb21wb25lbnQiLCJwcmV2VGhlbmFibGVTdGF0ZSIsImdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmciLCJzdGF0ZSIsInJlYWRDb250ZXh0JDEiLCJIb29rc0Rpc3BhdGNoZXIiLCJ1c2VNZW1vIiwibmV4dENyZWF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1bnN1cHBvcnRlZEhvb2siLCJ1c2VUcmFuc2l0aW9uIiwidXNlQ29udGV4dCIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUNhY2hlUmVmcmVzaCIsInVuc3VwcG9ydGVkUmVmcmVzaCIsInVzZU1lbW9DYWNoZSIsInNpemUiLCJkYXRhIiwiaSIsInVzZSIsImlkZW50aWZpZXJDb3VudCIsImlkZW50aWZpZXJQcmVmaXgiLCJ1c2FibGUiLCJjcmVhdGVTaWduYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJyZXNvbHZlQ2FjaGUiLCJjdXJyZW50Q2FjaGUiLCJjYWNoZSIsImdldFN0b3JlIiwiTWFwIiwiRGVmYXVsdENhY2hlRGlzcGF0Y2hlciIsImdldENhY2hlU2lnbmFsIiwiZW50cnkiLCJnZXQiLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJzZXRDdXJyZW50Q2FjaGUiLCJnZXRDdXJyZW50Q2FjaGUiLCJDb250ZXh0UmVnaXN0cnkiLCJnZXRPckNyZWF0ZVNlcnZlckNvbnRleHQiLCJnbG9iYWxOYW1lIiwiY3JlYXRlU2VydmVyQ29udGV4dCIsIlBFTkRJTkciLCJDT01QTEVURUQiLCJBQk9SVEVEIiwiRVJST1JFRCIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnRDYWNoZSIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsImNyZWF0ZVJlcXVlc3QiLCJidW5kbGVyQ29uZmlnIiwib25FcnJvciIsImN1cnJlbnQiLCJhYm9ydFNldCIsInBpbmdlZFRhc2tzIiwiZmF0YWxFcnJvciIsIm5leHRDaHVua0lkIiwicGVuZGluZ0NodW5rcyIsImFib3J0YWJsZVRhc2tzIiwiY29tcGxldGVkTW9kdWxlQ2h1bmtzIiwiY29tcGxldGVkSlNPTkNodW5rcyIsImNvbXBsZXRlZEVycm9yQ2h1bmtzIiwid3JpdHRlblN5bWJvbHMiLCJ3cml0dGVuTW9kdWxlcyIsIndyaXR0ZW5Qcm92aWRlcnMiLCJyZXNvbHZlTW9kZWxUb0pTT04iLCJyb290Q29udGV4dCIsImNyZWF0ZVJvb3RDb250ZXh0Iiwicm9vdFRhc2siLCJjcmVhdGVUYXNrIiwicmVxQ29udGV4dCIsImltcG9ydFNlcnZlckNvbnRleHRzIiwiUE9QIiwianN4UHJvcHNQYXJlbnRzIiwiV2Vha01hcCIsImpzeENoaWxkcmVuUGFyZW50cyIsInNlcmlhbGl6ZVRoZW5hYmxlIiwibmV3VGFzayIsInBpbmdUYXNrIiwieCIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJfZ2V0RXJyb3JNZXNzYWdlQW5kU3QiLCJnZXRFcnJvck1lc3NhZ2VBbmRTdGFja0RldiIsImVtaXRFcnJvckNodW5rRGV2IiwiX2dldEVycm9yTWVzc2FnZUFuZFN0MiIsIl9tZXNzYWdlIiwiX3N0YWNrIiwicmVhZFRoZW5hYmxlIiwiY3JlYXRlTGF6eVdyYXBwZXJBcm91bmRXYWtlYWJsZSIsIndha2VhYmxlIiwibGF6eVR5cGUiLCJfcGF5bG9hZCIsIl9pbml0IiwiYXR0ZW1wdFJlc29sdmVFbGVtZW50IiwicmVmIiwicHJvcHMiLCJjaGlsZHJlbiIsInJlc3VsdCIsInBheWxvYWQiLCJpbml0Iiwid3JhcHBlZFR5cGUiLCJyZW5kZXIiLCJfY29udGV4dCIsImV4dHJhS2V5cyIsImZpbHRlciIsIl9fcG9wIiwiZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSIsInRhc2siLCJwZXJmb3JtV29yayIsInBpbmciLCJzZXJpYWxpemVCeVZhbHVlSUQiLCJzZXJpYWxpemVMYXp5SUQiLCJzZXJpYWxpemVQcm9taXNlSUQiLCJzZXJpYWxpemVTeW1ib2xSZWZlcmVuY2UiLCJzZXJpYWxpemVQcm92aWRlclJlZmVyZW5jZSIsInNlcmlhbGl6ZUNsaWVudFJlZmVyZW5jZSIsIm1vZHVsZVJlZmVyZW5jZSIsIm1vZHVsZUtleSIsImV4aXN0aW5nSWQiLCJtb2R1bGVJZCIsImVtaXRNb2R1bGVDaHVuayIsImVycm9ySWQiLCJfZ2V0RXJyb3JNZXNzYWdlQW5kU3QzIiwiZXNjYXBlU3RyaW5nVmFsdWUiLCJpc09iamVjdFByb3RvdHlwZSIsIm9iamVjdCIsIk9iamVjdFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwibmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiaXNTaW1wbGVPYmplY3QiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIm9iamVjdE5hbWUiLCJtIiwicDAiLCJkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSIsImVuY29kZWRLZXkiLCJzdWJzdHIiLCJkZXNjcmliZUVsZW1lbnRUeXBlIiwibGF6eUNvbXBvbmVudCIsImRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlIiwib2JqZWN0T3JBcnJheSIsImV4cGFuZGVkTmFtZSIsIm9iaktpbmQiLCJzdHIiLCJzdGFydCIsImFycmF5IiwiX2FycmF5IiwiX2kiLCJfdmFsdWUiLCJfc3Vic3RyIiwiX3R5cGUiLCJfaTIiLCJfdmFsdWUyIiwiX3N1YnN0cjIiLCJfb2JqZWN0IiwiX25hbWVzIiwiX2kzIiwiX25hbWUiLCJfdmFsdWUzIiwiX3N1YnN0cjMiLCJoaWdobGlnaHQiLCJyZXBlYXQiLCJpbnNpZGVDb250ZXh0UHJvcHMiLCJpc0luc2lkZUNvbnRleHRWYWx1ZSIsIm9yaWdpbmFsVmFsdWUiLCJqc3hQYXJlbnRUeXBlIiwiZWxlbWVudCIsInRocm93blZhbHVlIiwiX2dldEVycm9yTWVzc2FnZUFuZFN0NCIsInByb21pc2VJZCIsInByb3ZpZGVyS2V5IiwiX2dsb2JhbE5hbWUiLCJwcm92aWRlcklkIiwiZW1pdFByb3ZpZGVyQ2h1bmsiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZGVzY3JpcHRpb24iLCJ0ZXN0Iiwic3ltYm9sSWQiLCJlbWl0U3ltYm9sQ2h1bmsiLCJlcnJvckRpZ2VzdCIsImVtaXRFcnJvckNodW5rUHJvZCIsInByb2Nlc3NlZENodW5rIiwic3ltYm9sUmVmZXJlbmNlIiwiY29udGV4dE5hbWUiLCJjb250ZXh0UmVmZXJlbmNlIiwicmV0cnlUYXNrIiwibmV4dEVsZW1lbnQiLCJkZWxldGUiLCJfZ2V0RXJyb3JNZXNzYWdlQW5kU3Q1IiwicHJldkRpc3BhdGNoZXIiLCJwcmV2Q2FjaGUiLCJmbHVzaENvbXBsZXRlZENodW5rcyIsImFib3J0VGFzayIsIm1vZHVsZUNodW5rcyIsImtlZXBXcml0aW5nIiwic3BsaWNlIiwianNvbkNodW5rcyIsIl9jaHVuayIsIl9rZWVwV3JpdGluZyIsImVycm9yQ2h1bmtzIiwiX2NodW5rMiIsIl9rZWVwV3JpdGluZzIiLCJzdGFydFdvcmsiLCJydW4iLCJzdGFydEZsb3dpbmciLCJhYm9ydCIsIl9nZXRFcnJvck1lc3NhZ2VBbmRTdDYiLCJjbGVhciIsImNvbnRleHRzIiwicHJldkNvbnRleHQiLCJfY29udGV4dHMkaSIsImltcG9ydGVkQ29udGV4dCIsInJlbmRlclRvUmVhZGFibGVTdHJlYW0iLCJ3ZWJwYWNrTWFwIiwib3B0aW9ucyIsImFib3J0ZWQiLCJsaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJjb250cm9sbGVyIiwicHVsbCIsImNhbmNlbCIsImhpZ2hXYXRlck1hcmsiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-server-dom-webpack-server.edge.development.js */ \"(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9zZXJ2ZXIuZWRnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyx1T0FBeUI7QUFDM0IsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9zZXJ2ZXIuZWRnZS5qcz84N2ViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stc2VydmVyLmVkZ2UucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrLXNlcnZlci5lZGdlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(sc_server)/./node_modules/next/dist/compiled/react/react.shared-subset.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                    case REACT_SERVER_CONTEXT_TYPE:\n                        {\n                            var context2 = type;\n                            return (context2.displayName || context2._globalName) + \".Provider\";\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        } // $FlowFixMe[prop-missing] found when upgrading Flow\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    } // TODO(luna): This will currently only throw if the function component\n                    // tries to access React/ReactDOM/props. We should probably make this throw\n                    // in simple components too\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ var ReactElement = function(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        };\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner$1.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement$1(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement$1(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE$1) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement$1(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement$1(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement$1(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement$1(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV$1 = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV$1;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEMsWUFBVztRQUNkO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7UUFFcEIsWUFBWTtRQUNaLHdDQUF3QztRQUN4QyxrRkFBa0Y7UUFDbEYsc0RBQXNEO1FBQ3RELElBQUlDLHFCQUFxQkMsT0FBT0MsR0FBRyxDQUFDO1FBQ3BDLElBQUlDLG9CQUFvQkYsT0FBT0MsR0FBRyxDQUFDO1FBQ25DLElBQUlFLHNCQUFzQkgsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlHLHlCQUF5QkosT0FBT0MsR0FBRyxDQUFDO1FBQ3hDLElBQUlJLHNCQUFzQkwsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlLLHNCQUFzQk4sT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlNLHFCQUFxQlAsT0FBT0MsR0FBRyxDQUFDO1FBQ3BDLElBQUlPLDRCQUE0QlIsT0FBT0MsR0FBRyxDQUFDO1FBQzNDLElBQUlRLHlCQUF5QlQsT0FBT0MsR0FBRyxDQUFDO1FBQ3hDLElBQUlTLHNCQUFzQlYsT0FBT0MsR0FBRyxDQUFDO1FBQ3JDLElBQUlVLDJCQUEyQlgsT0FBT0MsR0FBRyxDQUFDO1FBQzFDLElBQUlXLGtCQUFrQlosT0FBT0MsR0FBRyxDQUFDO1FBQ2pDLElBQUlZLGtCQUFrQmIsT0FBT0MsR0FBRyxDQUFDO1FBQ2pDLElBQUlhLHVCQUF1QmQsT0FBT0MsR0FBRyxDQUFDO1FBQ3RDLElBQUljLG1CQUFtQmYsT0FBT0MsR0FBRyxDQUFDO1FBQ2xDLElBQUllLHdCQUF3QmhCLE9BQU9pQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhLEVBQUU7WUFDcEMsSUFBSUEs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ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9mZTYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJlYWN0IiwicmVxdWlyZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiY29udGV4dDIiLCJfZ2xvYmFsTmFtZSIsImFzc2lnbiIsIk9iamVjdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwid2FybiIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsIkVycm9yIiwibWF0Y2giLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJnZXQiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsImMiLCJfZnJhbWUiLCJyZXBsYWNlIiwiaW5jbHVkZXMiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJoYXNPd25Qcm9wZXJ0eSIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIiLCJSRVNFUlZFRF9QUk9QUyIsImtleSIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzZWxmIiwic3RhdGVOb2RlIiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIl9zdG9yZSIsImZyZWV6ZSIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImkiLCJjaGlsZCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsIm5leHQiLCJkb25lIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJfbmFtZSIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJrZXlzIiwiZGlkV2FybkFib3V0S2V5U3ByZWFkIiwianN4V2l0aFZhbGlkYXRpb24iLCJpc1N0YXRpY0NoaWxkcmVuIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJjaGlsZHJlbiIsImZpbHRlciIsImsiLCJiZWZvcmVFeGFtcGxlIiwiam9pbiIsImFmdGVyRXhhbXBsZSIsImpzeERFViQxIiwiZXhwb3J0cyIsIkZyYWdtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @license React\n * react.shared-subset.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /**\n * Keeps track of the current dispatcher.\n */ var ReactCurrentDispatcher = {\n            current: null\n        };\n        /**\n * Keeps track of the current Cache dispatcher.\n */ var ReactCurrentCache = {\n            current: null\n        };\n        /**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */ var ReactCurrentBatchConfig = {\n            transition: null\n        };\n        var ReactCurrentActQueue = {\n            current: null,\n            // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n            isBatchingLegacy: false,\n            didScheduleLegacyUpdate: false,\n            // Tracks whether something called `use` during the current batch of work.\n            // Determines whether we should yield to microtasks to unwrap already resolved\n            // promises without suspending.\n            didUsePromise: false\n        };\n        /**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */ var ReactCurrentOwner = {\n            /**\n   * @internal\n   * @type {ReactComponent}\n   */ current: null\n        };\n        var ReactDebugCurrentFrame = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n            {\n                currentExtraStackFrame = stack;\n            }\n        }\n        {\n            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {\n                {\n                    currentExtraStackFrame = stack;\n                }\n            }; // Stack implementation injected by the current renderer.\n            ReactDebugCurrentFrame.getCurrentStack = null;\n            ReactDebugCurrentFrame.getStackAddendum = function() {\n                var stack = \"\"; // Add an extra top frame while an element is being validated\n                if (currentExtraStackFrame) {\n                    stack += currentExtraStackFrame;\n                } // Delegate to the injected renderer-specific implementation\n                var impl = ReactDebugCurrentFrame.getCurrentStack;\n                if (impl) {\n                    stack += impl() || \"\";\n                }\n                return stack;\n            };\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var ContextRegistry = {};\n        var ReactSharedInternals = {\n            ReactCurrentDispatcher: ReactCurrentDispatcher,\n            ReactCurrentCache: ReactCurrentCache,\n            ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n            ReactCurrentOwner: ReactCurrentOwner\n        };\n        {\n            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        {\n            ReactSharedInternals.ContextRegistry = ContextRegistry;\n        }\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var assign = Object.assign;\n        function createFetchCache() {\n            return new Map();\n        }\n        var simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]'; // generateCacheKey(new Request('https://blank'));\n        function generateCacheKey(request) {\n            // We pick the fields that goes into the key used to dedupe requests.\n            // We don't include the `cache` field, because we end up using whatever\n            // caching resulted from the first request.\n            // Notably we currently don't consider non-standard (or future) options.\n            // This might not be safe. TODO: warn for non-standard extensions differing.\n            // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n            return JSON.stringify([\n                request.method,\n                Array.from(request.headers.entries()),\n                request.mode,\n                request.redirect,\n                request.credentials,\n                request.referrer,\n                request.referrerPolicy,\n                request.integrity\n            ]);\n        }\n        {\n            if (typeof fetch === \"function\") {\n                var originalFetch = fetch;\n                var cachedFetch = function fetch1(resource, options) {\n                    var dispatcher = ReactCurrentCache.current;\n                    if (!dispatcher) {\n                        // We're outside a cached scope.\n                        return originalFetch(resource, options);\n                    }\n                    if (options && options.signal && options.signal !== dispatcher.getCacheSignal()) {\n                        // If we're passed a signal that is not ours, then we assume that\n                        // someone else controls the lifetime of this object and opts out of\n                        // caching. It's effectively the opt-out mechanism.\n                        // Ideally we should be able to check this on the Request but\n                        // it always gets initialized with its own signal so we don't\n                        // know if it's supposed to override - unless we also override the\n                        // Request constructor.\n                        return originalFetch(resource, options);\n                    } // Normalize the Request\n                    var url;\n                    var cacheKey;\n                    if (typeof resource === \"string\" && !options) {\n                        // Fast path.\n                        cacheKey = simpleCacheKey;\n                        url = resource;\n                    } else {\n                        // Normalize the request.\n                        var request = new Request(resource, options);\n                        if (request.method !== \"GET\" && request.method !== \"HEAD\" || // $FlowFixMe: keepalive is real\n                        request.keepalive) {\n                            // We currently don't dedupe requests that might have side-effects. Those\n                            // have to be explicitly cached. We assume that the request doesn't have a\n                            // body if it's GET or HEAD.\n                            // keepalive gets treated the same as if you passed a custom cache signal.\n                            return originalFetch(resource, options);\n                        }\n                        cacheKey = generateCacheKey(request);\n                        url = request.url;\n                    }\n                    var cache = dispatcher.getCacheForType(createFetchCache);\n                    var cacheEntries = cache.get(url);\n                    var match;\n                    if (cacheEntries === undefined) {\n                        // We pass the original arguments here in case normalizing the Request\n                        // doesn't include all the options in this environment.\n                        match = originalFetch(resource, options);\n                        cache.set(url, [\n                            cacheKey,\n                            match\n                        ]);\n                    } else {\n                        // We use an array as the inner data structure since it's lighter and\n                        // we typically only expect to see one or two entries here.\n                        for(var i = 0, l = cacheEntries.length; i < l; i += 2){\n                            var key = cacheEntries[i];\n                            var value = cacheEntries[i + 1];\n                            if (key === cacheKey) {\n                                match = value; // I would've preferred a labelled break but lint says no.\n                                return match.then(function(response) {\n                                    return response.clone();\n                                });\n                            }\n                        }\n                        match = originalFetch(resource, options);\n                        cacheEntries.push(cacheKey, match);\n                    } // We clone the response so that each time you call this you get a new read\n                    // of the body so that it can be read multiple times.\n                    return match.then(function(response) {\n                        return response.clone();\n                    });\n                }; // We don't expect to see any extra properties on fetch but if there are any,\n                // copy them over. Useful for extended fetch environments or mocks.\n                assign(cachedFetch, originalFetch);\n                try {\n                    // eslint-disable-next-line no-native-reassign\n                    fetch = cachedFetch;\n                } catch (error1) {\n                    try {\n                        // In case assigning it globally fails, try globalThis instead just in case it exists.\n                        globalThis.fetch = cachedFetch;\n                    } catch (error2) {\n                        // Log even in production just to make sure this is seen if only prod is frozen.\n                        // eslint-disable-next-line react-internal/no-production-logging\n                        warn(\"React was unable to patch the fetch() function in this environment. \" + \"Suspensey APIs might not work correctly as a result.\");\n                    }\n                }\n            }\n        }\n        var ReactVersion = \"18.3.0-next-6ddcbd4f9-20230209\";\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n                    return;\n                }\n                error(\"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n                didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n            }\n        }\n        /**\n * This is the abstract API for an update queue.\n */ var ReactNoopUpdateQueue = {\n            /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */ isMounted: function(publicInstance) {\n                return false;\n            },\n            /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {\n                warnNoop(publicInstance, \"forceUpdate\");\n            },\n            /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n                warnNoop(publicInstance, \"replaceState\");\n            },\n            /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n                warnNoop(publicInstance, \"setState\");\n            }\n        };\n        var emptyObject = {};\n        {\n            Object.freeze(emptyObject);\n        }\n        /**\n * Base class helpers for the updating state of a component.\n */ function Component(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n            // renderer.\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        /**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */ Component.prototype.setState = function(partialState, callback) {\n            if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n                throw new Error(\"setState(...): takes an object of state variables to update or a \" + \"function which returns an object of state variables.\");\n            }\n            this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        /**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */ Component.prototype.forceUpdate = function(callback) {\n            this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        /**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */ {\n            var deprecatedAPIs = {\n                isMounted: [\n                    \"isMounted\",\n                    \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"\n                ],\n                replaceState: [\n                    \"replaceState\",\n                    \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"\n                ]\n            };\n            var defineDeprecationWarning = function(methodName, info) {\n                Object.defineProperty(Component.prototype, methodName, {\n                    get: function() {\n                        warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                        return undefined;\n                    }\n                });\n            };\n            for(var fnName in deprecatedAPIs){\n                if (deprecatedAPIs.hasOwnProperty(fnName)) {\n                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n                }\n            }\n        }\n        function ComponentDummy() {}\n        ComponentDummy.prototype = Component.prototype;\n        /**\n * Convenience component with default shallow equality check for sCU.\n */ function PureComponent(props, context, updater) {\n            this.props = props;\n            this.context = context; // If a component has string refs, we will assign a different object later.\n            this.refs = emptyObject;\n            this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        // an immutable object with a single mutable value\n        function createRef() {\n            var refObject = {\n                current: null\n            };\n            {\n                Object.seal(refObject);\n            }\n            return refObject;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                    case REACT_SERVER_CONTEXT_TYPE:\n                        {\n                            var context2 = type;\n                            return (context2.displayName || context2._globalName) + \".Provider\";\n                        }\n                }\n            }\n            return null;\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            var warnAboutAccessingKey = function() {\n                {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n                get: warnAboutAccessingKey,\n                configurable: true\n            });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            var warnAboutAccessingRef = function() {\n                {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n                get: warnAboutAccessingRef,\n                configurable: true\n            });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", componentName, config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ var ReactElement = function(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        };\n        /**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */ function createElement(type, config, children) {\n            var propName; // Reserved names are extracted\n            var props = {};\n            var key = null;\n            var ref = null;\n            var self = null;\n            var source = null;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    {\n                        warnIfStringRefCannotBeAutoConverted(config);\n                    }\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                self = config.__self === undefined ? null : config.__self;\n                source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                {\n                    if (Object.freeze) {\n                        Object.freeze(childArray);\n                    }\n                }\n                props.children = childArray;\n            } // Resolve default props\n            if (type && type.defaultProps) {\n                var defaultProps = type.defaultProps;\n                for(propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n            }\n            {\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n            return newElement;\n        }\n        /**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */ function cloneElement(element, config, children) {\n            if (element === null || element === undefined) {\n                throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n            }\n            var propName; // Original props are copied\n            var props = assign({}, element.props); // Reserved names are extracted\n            var key = element.key;\n            var ref = element.ref; // Self is preserved since the owner is preserved.\n            var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n            // transpiler, and the original source is probably a better indicator of the\n            // true owner.\n            var source = element._source; // Owner will be preserved, unless ref is overridden\n            var owner = element._owner;\n            if (config != null) {\n                if (hasValidRef(config)) {\n                    // Silently steal the ref from the parent.\n                    ref = config.ref;\n                    owner = ReactCurrentOwner.current;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                } // Remaining properties override existing props\n                var defaultProps;\n                if (element.type && element.type.defaultProps) {\n                    defaultProps = element.type.defaultProps;\n                }\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        if (config[propName] === undefined && defaultProps !== undefined) {\n                            // Resolve default props\n                            props[propName] = defaultProps[propName];\n                        } else {\n                            props[propName] = config[propName];\n                        }\n                    }\n                }\n            } // Children can be more than one argument, and those are transferred onto\n            // the newly allocated props object.\n            var childrenLength = arguments.length - 2;\n            if (childrenLength === 1) {\n                props.children = children;\n            } else if (childrenLength > 1) {\n                var childArray = Array(childrenLength);\n                for(var i = 0; i < childrenLength; i++){\n                    childArray[i] = arguments[i + 2];\n                }\n                props.children = childArray;\n            }\n            return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        /**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */ function escape(key) {\n            var escapeRegex = /[=:]/g;\n            var escaperLookup = {\n                \"=\": \"=0\",\n                \":\": \"=2\"\n            };\n            var escapedString = key.replace(escapeRegex, function(match) {\n                return escaperLookup[match];\n            });\n            return \"$\" + escapedString;\n        }\n        /**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */ var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n            return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        /**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */ function getElementKey(element, index) {\n            // Do some typechecking here since we call this blindly. We want to ensure\n            // that we don't block potential future ES APIs.\n            if (typeof element === \"object\" && element !== null && element.key != null) {\n                // Explicit key\n                {\n                    checkKeyStringCoercion(element.key);\n                }\n                return escape(\"\" + element.key);\n            } // Implicit key determined by the index in the set\n            return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n            var type = typeof children;\n            if (type === \"undefined\" || type === \"boolean\") {\n                // All of the above are perceived as null.\n                children = null;\n            }\n            var invokeCallback = false;\n            if (children === null) {\n                invokeCallback = true;\n            } else {\n                switch(type){\n                    case \"string\":\n                    case \"number\":\n                        invokeCallback = true;\n                        break;\n                    case \"object\":\n                        switch(children.$$typeof){\n                            case REACT_ELEMENT_TYPE:\n                            case REACT_PORTAL_TYPE:\n                                invokeCallback = true;\n                        }\n                }\n            }\n            if (invokeCallback) {\n                var _child = children;\n                var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n                // so that it's consistent if the number of children grows:\n                var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n                if (isArray(mappedChild)) {\n                    var escapedChildKey = \"\";\n                    if (childKey != null) {\n                        escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n                    }\n                    mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                        return c;\n                    });\n                } else if (mappedChild != null) {\n                    if (isValidElement(mappedChild)) {\n                        {\n                            // The `if` statement here prevents auto-disabling of the safe\n                            // coercion ESLint rule, so we must manually disable it below.\n                            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                                checkKeyStringCoercion(mappedChild.key);\n                            }\n                        }\n                        mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children\n                        escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion\n                        ) + \"/\" : \"\") + childKey);\n                    }\n                    array.push(mappedChild);\n                }\n                return 1;\n            }\n            var child;\n            var nextName;\n            var subtreeCount = 0; // Count of children found in the current subtree.\n            var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n            if (isArray(children)) {\n                for(var i = 0; i < children.length; i++){\n                    child = children[i];\n                    nextName = nextNamePrefix + getElementKey(child, i);\n                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                }\n            } else {\n                var iteratorFn = getIteratorFn(children);\n                if (typeof iteratorFn === \"function\") {\n                    var iterableChildren = children;\n                    {\n                        // Warn about using Maps as children\n                        if (iteratorFn === iterableChildren.entries) {\n                            if (!didWarnAboutMaps) {\n                                warn(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                            }\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                    var iterator = iteratorFn.call(iterableChildren);\n                    var step;\n                    var ii = 0; // $FlowFixMe `iteratorFn` might return null according to typing.\n                    while(!(step = iterator.next()).done){\n                        child = step.value;\n                        nextName = nextNamePrefix + getElementKey(child, ii++);\n                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n                    }\n                } else if (type === \"object\") {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    var childrenString = String(children);\n                    throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n                }\n            }\n            return subtreeCount;\n        }\n        /**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */ function mapChildren(children, func, context) {\n            if (children == null) {\n                return children;\n            }\n            var result = [];\n            var count = 0;\n            mapIntoArray(children, result, \"\", \"\", function(child) {\n                return func.call(context, child, count++);\n            });\n            return result;\n        }\n        /**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */ function countChildren(children) {\n            var n = 0;\n            mapChildren(children, function() {\n                n++; // Don't return anything\n            });\n            return n;\n        }\n        /**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */ function forEachChildren(children, forEachFunc, forEachContext) {\n            mapChildren(children, function() {\n                forEachFunc.apply(this, arguments); // Don't return anything.\n            }, forEachContext);\n        }\n        /**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */ function toArray(children) {\n            return mapChildren(children, function(child) {\n                return child;\n            }) || [];\n        }\n        /**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */ function onlyChild(children) {\n            if (!isValidElement(children)) {\n                throw new Error(\"React.Children.only expected to receive a single React element child.\");\n            }\n            return children;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n            if (payload._status === Uninitialized) {\n                var ctor = payload._result;\n                var thenable = ctor(); // Transition to the next state.\n                // This might throw either because it's missing or throws. If so, we treat it\n                // as still uninitialized and try again next time. Which is the same as what\n                // happens if the ctor or any wrappers processing the ctor throws. This might\n                // end up fixing it if the resolution was a concurrency bug.\n                thenable.then(function(moduleObject) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var resolved = payload;\n                        resolved._status = Resolved;\n                        resolved._result = moduleObject;\n                    }\n                }, function(error) {\n                    if (payload._status === Pending || payload._status === Uninitialized) {\n                        // Transition to the next state.\n                        var rejected = payload;\n                        rejected._status = Rejected;\n                        rejected._result = error;\n                    }\n                });\n                if (payload._status === Uninitialized) {\n                    // In case, we're still uninitialized, then we're waiting for the thenable\n                    // to resolve. Set it as pending in the meantime.\n                    var pending = payload;\n                    pending._status = Pending;\n                    pending._result = thenable;\n                }\n            }\n            if (payload._status === Resolved) {\n                var moduleObject = payload._result;\n                {\n                    if (moduleObject === undefined) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\\n\\n\" + \"Did you accidentally put curly braces around the import?\", moduleObject);\n                    }\n                }\n                {\n                    if (!(\"default\" in moduleObject)) {\n                        error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + \"Instead received: %s\\n\\nYour code should look like: \\n  \" + // Break up imports to avoid accidentally parsing them as dependencies.\n                        \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\", moduleObject);\n                    }\n                }\n                return moduleObject.default;\n            } else {\n                throw payload._result;\n            }\n        }\n        function lazy(ctor) {\n            var payload = {\n                // We use these fields to store the result.\n                _status: Uninitialized,\n                _result: ctor\n            };\n            var lazyType = {\n                $$typeof: REACT_LAZY_TYPE,\n                _payload: payload,\n                _init: lazyInitializer\n            };\n            {\n                // In production, this would just set it on the object.\n                var defaultProps;\n                var propTypes; // $FlowFixMe\n                Object.defineProperties(lazyType, {\n                    defaultProps: {\n                        configurable: true,\n                        get: function() {\n                            return defaultProps;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newDefaultProps) {\n                            error(\"React.lazy(...): It is not supported to assign `defaultProps` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            defaultProps = newDefaultProps; // Match production behavior more closely:\n                            // $FlowFixMe\n                            Object.defineProperty(lazyType, \"defaultProps\", {\n                                enumerable: true\n                            });\n                        }\n                    },\n                    propTypes: {\n                        configurable: true,\n                        get: function() {\n                            return propTypes;\n                        },\n                        // $FlowFixMe[missing-local-annot]\n                        set: function(newPropTypes) {\n                            error(\"React.lazy(...): It is not supported to assign `propTypes` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                            propTypes = newPropTypes; // Match production behavior more closely:\n                            // $FlowFixMe\n                            Object.defineProperty(lazyType, \"propTypes\", {\n                                enumerable: true\n                            });\n                        }\n                    }\n                });\n            }\n            return lazyType;\n        }\n        function forwardRef(render) {\n            {\n                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n                    error(\"forwardRef requires a render function but received a `memo` \" + \"component. Instead of forwardRef(memo(...)), use \" + \"memo(forwardRef(...)).\");\n                } else if (typeof render !== \"function\") {\n                    error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n                } else {\n                    if (render.length !== 0 && render.length !== 2) {\n                        error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n                    }\n                }\n                if (render != null) {\n                    if (render.defaultProps != null || render.propTypes != null) {\n                        error(\"forwardRef render functions do not support propTypes or defaultProps. \" + \"Did you accidentally pass a React component?\");\n                    }\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_FORWARD_REF_TYPE,\n                render: render\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.forwardRef((props, ref) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!render.name && !render.displayName) {\n                            render.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function memo(type, compare) {\n            {\n                if (!isValidElementType(type)) {\n                    error(\"memo: The first argument must be a component. Instead \" + \"received: %s\", type === null ? \"null\" : typeof type);\n                }\n            }\n            var elementType = {\n                $$typeof: REACT_MEMO_TYPE,\n                type: type,\n                compare: compare === undefined ? null : compare\n            };\n            {\n                var ownName;\n                Object.defineProperty(elementType, \"displayName\", {\n                    enumerable: false,\n                    configurable: true,\n                    get: function() {\n                        return ownName;\n                    },\n                    set: function(name) {\n                        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n                        // because the component may be used elsewhere.\n                        // But it's nice for anonymous functions to inherit the name,\n                        // so that our component-stack generation logic will display their frames.\n                        // An anonymous function generally suggests a pattern like:\n                        //   React.memo((props) => {...});\n                        // This kind of inner function is not used elsewhere so the side effect is okay.\n                        if (!type.name && !type.displayName) {\n                            type.displayName = name;\n                        }\n                    }\n                });\n            }\n            return elementType;\n        }\n        var UNTERMINATED = 0;\n        var TERMINATED = 1;\n        var ERRORED = 2;\n        function createCacheRoot() {\n            return new WeakMap();\n        }\n        function createCacheNode() {\n            return {\n                s: UNTERMINATED,\n                // status, represents whether the cached computation returned a value or threw an error\n                v: undefined,\n                // value, either the cached result or an error, depending on s\n                o: null,\n                // object cache, a WeakMap where non-primitive arguments are stored\n                p: null // primitive cache, a regular Map where primitive arguments are stored.\n            };\n        }\n        function cache(fn) {\n            return function() {\n                var dispatcher = ReactCurrentCache.current;\n                if (!dispatcher) {\n                    // If there is no dispatcher, then we treat this as not being cached.\n                    // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n                    return fn.apply(null, arguments);\n                }\n                var fnMap = dispatcher.getCacheForType(createCacheRoot);\n                var fnNode = fnMap.get(fn);\n                var cacheNode;\n                if (fnNode === undefined) {\n                    cacheNode = createCacheNode();\n                    fnMap.set(fn, cacheNode);\n                } else {\n                    cacheNode = fnNode;\n                }\n                for(var i = 0, l = arguments.length; i < l; i++){\n                    var arg = arguments[i];\n                    if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n                        // Objects go into a WeakMap\n                        var objectCache = cacheNode.o;\n                        if (objectCache === null) {\n                            cacheNode.o = objectCache = new WeakMap();\n                        }\n                        var objectNode = objectCache.get(arg);\n                        if (objectNode === undefined) {\n                            cacheNode = createCacheNode();\n                            objectCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = objectNode;\n                        }\n                    } else {\n                        // Primitives go into a regular Map\n                        var primitiveCache = cacheNode.p;\n                        if (primitiveCache === null) {\n                            cacheNode.p = primitiveCache = new Map();\n                        }\n                        var primitiveNode = primitiveCache.get(arg);\n                        if (primitiveNode === undefined) {\n                            cacheNode = createCacheNode();\n                            primitiveCache.set(arg, cacheNode);\n                        } else {\n                            cacheNode = primitiveNode;\n                        }\n                    }\n                }\n                if (cacheNode.s === TERMINATED) {\n                    return cacheNode.v;\n                }\n                if (cacheNode.s === ERRORED) {\n                    throw cacheNode.v;\n                }\n                try {\n                    // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n                    var result = fn.apply(null, arguments);\n                    var terminatedNode = cacheNode;\n                    terminatedNode.s = TERMINATED;\n                    terminatedNode.v = result;\n                    return result;\n                } catch (error) {\n                    // We store the first error that's thrown and rethrow it.\n                    var erroredNode = cacheNode;\n                    erroredNode.s = ERRORED;\n                    erroredNode.v = error;\n                    throw error;\n                }\n            };\n        }\n        function resolveDispatcher() {\n            var dispatcher = ReactCurrentDispatcher.current;\n            {\n                if (dispatcher === null) {\n                    error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n                }\n            }\n            // intentionally don't throw our own error because this is in a hot path.\n            // Also helps ensure this is inlined.\n            return dispatcher;\n        }\n        function useContext(Context) {\n            var dispatcher = resolveDispatcher();\n            {\n                // TODO: add a more generic warning for invalid values.\n                if (Context._context !== undefined) {\n                    var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n                    // and nobody should be using this in existing code.\n                    if (realContext.Consumer === Context) {\n                        error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be \" + \"removed in a future major release. Did you mean to call useContext(Context) instead?\");\n                    } else if (realContext.Provider === Context) {\n                        error(\"Calling useContext(Context.Provider) is not supported. \" + \"Did you mean to call useContext(Context) instead?\");\n                    }\n                }\n            }\n            return dispatcher.useContext(Context);\n        }\n        function useCallback(callback, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useMemo(create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n            {\n                var dispatcher = resolveDispatcher();\n                return dispatcher.useDebugValue(value, formatterFn);\n            }\n        }\n        function useId() {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useId();\n        }\n        function use(usable) {\n            var dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n            return dispatcher.use(usable);\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        } // $FlowFixMe[prop-missing] found when upgrading Flow\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    } // TODO(luna): This will currently only throw if the function component\n                    // tries to access React/ReactDOM/props. We should probably make this throw\n                    // in simple components too\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    setExtraStackFrame(stack);\n                } else {\n                    setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n            if (ReactCurrentOwner.current) {\n                var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                if (name) {\n                    return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                }\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n            if (source !== undefined) {\n                var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                var lineNumber = source.lineNumber;\n                return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n            if (elementProps !== null && elementProps !== undefined) {\n                return getSourceInfoErrorAddendum(elementProps.__source);\n            }\n            return \"\";\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n                var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                if (parentName) {\n                    info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                }\n            }\n            return info;\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            if (!element._store || element._store.validated || element.key != null) {\n                return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n            // property, it may be the creator of the child that's responsible for\n            // assigning it a key.\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                // Give the component that originally created this child.\n                childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            {\n                setCurrentlyValidatingElement$1(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement$1(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            if (typeof node !== \"object\" || !node) {\n                return;\n            }\n            if (node.$$typeof === REACT_CLIENT_REFERENCE$1) ;\n            else if (isArray(node)) {\n                for(var i = 0; i < node.length; i++){\n                    var child = node[i];\n                    if (isValidElement(child)) {\n                        validateExplicitKey(child, parentType);\n                    }\n                }\n            } else if (isValidElement(node)) {\n                // This element was passed in a valid location.\n                if (node._store) {\n                    node._store.validated = true;\n                }\n            } else {\n                var iteratorFn = getIteratorFn(node);\n                if (typeof iteratorFn === \"function\") {\n                    // Entry iterators used to provide implicit keys,\n                    // but now we print a separate warning for them later.\n                    if (iteratorFn !== node.entries) {\n                        var iterator = iteratorFn.call(node);\n                        var step;\n                        while(!(step = iterator.next()).done){\n                            if (isValidElement(step.value)) {\n                                validateExplicitKey(step.value, parentType);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement$1(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement$1(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement$1(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement$1(null);\n                }\n            }\n        }\n        function createElementWithValidation(type, props, children) {\n            var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n            // succeed and there will likely be errors in render.\n            if (!validType) {\n                var info = \"\";\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                }\n                var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n                if (sourceInfo) {\n                    info += sourceInfo;\n                } else {\n                    info += getDeclarationErrorAddendum();\n                }\n                var typeString;\n                if (type === null) {\n                    typeString = \"null\";\n                } else if (isArray(type)) {\n                    typeString = \"array\";\n                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                    typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                    info = \" Did you accidentally export a JSX literal instead of a component?\";\n                } else {\n                    typeString = typeof type;\n                }\n                {\n                    error(\"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n            }\n            var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n            // TODO: Drop this when these are no longer allowed as the type argument.\n            if (element == null) {\n                return element;\n            } // Skip key warning if the type isn't valid since our key validation logic\n            // doesn't expect a non-string/function type and can throw confusing errors.\n            // We don't want exception behavior to differ between dev and prod.\n            // (Rendering will throw with a helpful message and as soon as the type is\n            // fixed, the key warnings will appear.)\n            if (validType) {\n                for(var i = 2; i < arguments.length; i++){\n                    validateChildKeys(arguments[i], type);\n                }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n                validateFragmentProps(element);\n            } else {\n                validatePropTypes(element);\n            }\n            return element;\n        }\n        function cloneElementWithValidation(element, props, children) {\n            var newElement = cloneElement.apply(this, arguments);\n            for(var i = 2; i < arguments.length; i++){\n                validateChildKeys(arguments[i], newElement.type);\n            }\n            validatePropTypes(newElement);\n            return newElement;\n        }\n        var ContextRegistry$1 = ReactSharedInternals.ContextRegistry;\n        function createServerContext(globalName, defaultValue) {\n            var wasDefined = true;\n            if (!ContextRegistry$1[globalName]) {\n                wasDefined = false;\n                var _context = {\n                    $$typeof: REACT_SERVER_CONTEXT_TYPE,\n                    // As a workaround to support multiple concurrent renderers, we categorize\n                    // some renderers as primary and others as secondary. We only expect\n                    // there to be two concurrent renderers at most: React Native (primary) and\n                    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n                    // Secondary renderers store their context values on separate fields.\n                    _currentValue: defaultValue,\n                    _currentValue2: defaultValue,\n                    _defaultValue: defaultValue,\n                    // Used to track how many concurrent renderers this context currently\n                    // supports within in a single renderer. Such as parallel server rendering.\n                    _threadCount: 0,\n                    // These are circular\n                    Provider: null,\n                    Consumer: null,\n                    _globalName: globalName\n                };\n                _context.Provider = {\n                    $$typeof: REACT_PROVIDER_TYPE,\n                    _context: _context\n                };\n                {\n                    var hasWarnedAboutUsingConsumer;\n                    _context._currentRenderer = null;\n                    _context._currentRenderer2 = null;\n                    Object.defineProperties(_context, {\n                        Consumer: {\n                            get: function() {\n                                if (!hasWarnedAboutUsingConsumer) {\n                                    error(\"Consumer pattern is not supported by ReactServerContext\");\n                                    hasWarnedAboutUsingConsumer = true;\n                                }\n                                return null;\n                            }\n                        }\n                    });\n                }\n                ContextRegistry$1[globalName] = _context;\n            }\n            var context = ContextRegistry$1[globalName];\n            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                context._defaultValue = defaultValue;\n                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    context._currentValue = defaultValue;\n                }\n                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    context._currentValue2 = defaultValue;\n                }\n            } else if (wasDefined) {\n                throw new Error(\"ServerContext: \" + globalName + \" already defined\");\n            }\n            return context;\n        }\n        function startTransition(scope, options) {\n            var prevTransition = ReactCurrentBatchConfig.transition;\n            ReactCurrentBatchConfig.transition = {};\n            var currentTransition = ReactCurrentBatchConfig.transition;\n            {\n                ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n            }\n            try {\n                scope();\n            } finally{\n                ReactCurrentBatchConfig.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                    }\n                }\n            }\n        }\n        var createElement$1 = createElementWithValidation;\n        var cloneElement$1 = cloneElementWithValidation;\n        var Children = {\n            map: mapChildren,\n            forEach: forEachChildren,\n            count: countChildren,\n            toArray: toArray,\n            only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.cache = cache;\n        exports.cloneElement = cloneElement$1;\n        exports.createElement = createElement$1;\n        exports.createRef = createRef;\n        exports.createServerContext = createServerContext;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.use = use;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useId = useId;\n        exports.useMemo = useMemo;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC5zaGFyZWQtc3Vic2V0LmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDLFlBQVc7UUFDZDtRQUVBOztDQUVDLEdBQ0QsSUFBSUMseUJBQXlCO1lBQzNCQyxTQUFTLElBQUk7UUFDZjtRQUVBOztDQUVDLEdBQ0QsSUFBSUMsb0JBQW9CO1lBQ3RCRCxTQUFTLElBQUk7UUFDZjtRQUVBOzs7Q0FHQyxHQUNELElBQUlFLDBCQUEwQjtZQUM1QkMsWUFBWSxJQUFJO1FBQ2xCO1FBRUEsSUFBSUMsdUJBQXVCO1lBQ3pCSixTQUFTLElBQUk7WUFDYixpRUFBaUU7WUFDakVLLGtCQUFrQixLQUFLO1lBQ3ZCQyx5QkFBeUIsS0FBSztZQUM5QiwwRUFBMEU7WUFDMUUsOEVBQThFO1lBQzlFLCtCQUErQjtZQUMvQkMsZUFBZSxLQUFLO1FBQ3RCO1FBRUE7Ozs7O0NBS0MsR0FDRCxJQUFJQyxvQkFBb0I7WUFDdEI7OztHQUdDLEdBQ0RSLFNBQVMsSUFBSTtRQUNmO1FBRUEsSUFBSVMseUJBQXlCLENBQUM7UUFDOUIsSUFBSUMseUJBQXlCLElBQUk7UUFDakMsU0FBU0MsbUJBQW1CQyxLQUFLLEVBQUU7WUFDakM7Z0JBQ0VGLHlCQUF5QkU7WUFDM0I7UUFDRjtRQUVBO1lBQ0VILHVCQUF1QkUsa0JBQWtCLEdBQUcsU0FBVUMsS0FBSyxFQUFFO2dCQUMzRDtvQkFDRUYseUJBQXlCRTtnQkFDM0I7WUFDRixHQUFHLHlEQUF5RDtZQUc1REgsdUJBQXVCSSxlQUFlLEdBQUcsSUFBSTtZQUU3Q0osdUJBQXVCSyxnQkFBZ0IsR0FBRyxXQUFZO2dCQUNwRCxJQUFJRixRQUFRLElBQUksNkRBQTZEO2dCQUU3RSxJQUFJRix3QkFBd0I7b0JBQzFCRSxTQUFTRjtnQkFDWCxDQUFDLENBQUMs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dUJBQXVCLEdBQUdkO1FBQzFCYyxXQUFXLEdBQUdwSDtRQUNkb0gsbUJBQW1CLEdBQUczSDtRQUN0QjJILGtCQUFrQixHQUFHaEk7UUFDckJnSSxxQkFBcUIsR0FBR3ZIO1FBQ3hCdUgsYUFBYSxHQUFHckg7UUFDaEJxSCxlQUFlLEdBQUd6SDtRQUNsQnlILGVBQWUsR0FBR25YO0lBQ2hCO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC5zaGFyZWQtc3Vic2V0LmRldmVsb3BtZW50LmpzPzk5NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3Quc2hhcmVkLXN1YnNldC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBDYWNoZSBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50Q2FjaGUgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogbnVsbFxufTtcblxudmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0ge1xuICBjdXJyZW50OiBudWxsLFxuICAvLyBVc2VkIHRvIHJlcHJvZHVjZSBiZWhhdmlvciBvZiBgYmF0Y2hlZFVwZGF0ZXNgIGluIGxlZ2FjeSBtb2RlLlxuICBpc0JhdGNoaW5nTGVnYWN5OiBmYWxzZSxcbiAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6IGZhbHNlLFxuICAvLyBUcmFja3Mgd2hldGhlciBzb21ldGhpbmcgY2FsbGVkIGB1c2VgIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCBvZiB3b3JrLlxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIHlpZWxkIHRvIG1pY3JvdGFza3MgdG8gdW53cmFwIGFscmVhZHkgcmVzb2x2ZWRcbiAgLy8gcHJvbWlzZXMgd2l0aG91dCBzdXNwZW5kaW5nLlxuICBkaWRVc2VQcm9taXNlOiBmYWxzZVxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIENvbnRleHRSZWdpc3RyeSA9IHt9O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudENhY2hlOiBSZWFjdEN1cnJlbnRDYWNoZSxcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXJcbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEFjdFF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWU7XG59XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQ29udGV4dFJlZ2lzdHJ5ID0gQ29udGV4dFJlZ2lzdHJ5O1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDYWNoZSgpIHtcbiAgcmV0dXJuIG5ldyBNYXAoKTtcbn1cblxudmFyIHNpbXBsZUNhY2hlS2V5ID0gJ1tcIkdFVFwiLFtdLG51bGwsXCJmb2xsb3dcIixudWxsLG51bGwsbnVsbCxudWxsXSc7IC8vIGdlbmVyYXRlQ2FjaGVLZXkobmV3IFJlcXVlc3QoJ2h0dHBzOi8vYmxhbmsnKSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGVLZXkocmVxdWVzdCkge1xuICAvLyBXZSBwaWNrIHRoZSBmaWVsZHMgdGhhdCBnb2VzIGludG8gdGhlIGtleSB1c2VkIHRvIGRlZHVwZSByZXF1ZXN0cy5cbiAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgYGNhY2hlYCBmaWVsZCwgYmVjYXVzZSB3ZSBlbmQgdXAgdXNpbmcgd2hhdGV2ZXJcbiAgLy8gY2FjaGluZyByZXN1bHRlZCBmcm9tIHRoZSBmaXJzdCByZXF1ZXN0LlxuICAvLyBOb3RhYmx5IHdlIGN1cnJlbnRseSBkb24ndCBjb25zaWRlciBub24tc3RhbmRhcmQgKG9yIGZ1dHVyZSkgb3B0aW9ucy5cbiAgLy8gVGhpcyBtaWdodCBub3QgYmUgc2FmZS4gVE9ETzogd2FybiBmb3Igbm9uLXN0YW5kYXJkIGV4dGVuc2lvbnMgZGlmZmVyaW5nLlxuICAvLyBJRiBZT1UgQ0hBTkdFIFRISVMgVVBEQVRFIFRIRSBzaW1wbGVDYWNoZUtleSBBQk9WRS5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtyZXF1ZXN0Lm1ldGhvZCwgQXJyYXkuZnJvbShyZXF1ZXN0LmhlYWRlcnMuZW50cmllcygpKSwgcmVxdWVzdC5tb2RlLCByZXF1ZXN0LnJlZGlyZWN0LCByZXF1ZXN0LmNyZWRlbnRpYWxzLCByZXF1ZXN0LnJlZmVycmVyLCByZXF1ZXN0LnJlZmVycmVyUG9saWN5LCByZXF1ZXN0LmludGVncml0eV0pO1xufVxuXG57XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgb3JpZ2luYWxGZXRjaCA9IGZldGNoO1xuXG4gICAgdmFyIGNhY2hlZEZldGNoID0gZnVuY3Rpb24gZmV0Y2gocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcblxuICAgICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICAgIC8vIFdlJ3JlIG91dHNpZGUgYSBjYWNoZWQgc2NvcGUuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbEZldGNoKHJlc291cmNlLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwgJiYgb3B0aW9ucy5zaWduYWwgIT09IGRpc3BhdGNoZXIuZ2V0Q2FjaGVTaWduYWwoKSkge1xuICAgICAgICAvLyBJZiB3ZSdyZSBwYXNzZWQgYSBzaWduYWwgdGhhdCBpcyBub3Qgb3VycywgdGhlbiB3ZSBhc3N1bWUgdGhhdFxuICAgICAgICAvLyBzb21lb25lIGVsc2UgY29udHJvbHMgdGhlIGxpZmV0aW1lIG9mIHRoaXMgb2JqZWN0IGFuZCBvcHRzIG91dCBvZlxuICAgICAgICAvLyBjYWNoaW5nLiBJdCdzIGVmZmVjdGl2ZWx5IHRoZSBvcHQtb3V0IG1lY2hhbmlzbS5cbiAgICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgYmUgYWJsZSB0byBjaGVjayB0aGlzIG9uIHRoZSBSZXF1ZXN0IGJ1dFxuICAgICAgICAvLyBpdCBhbHdheXMgZ2V0cyBpbml0aWFsaXplZCB3aXRoIGl0cyBvd24gc2lnbmFsIHNvIHdlIGRvbid0XG4gICAgICAgIC8vIGtub3cgaWYgaXQncyBzdXBwb3NlZCB0byBvdmVycmlkZSAtIHVubGVzcyB3ZSBhbHNvIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyBSZXF1ZXN0IGNvbnN0cnVjdG9yLlxuICAgICAgICByZXR1cm4gb3JpZ2luYWxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICB9IC8vIE5vcm1hbGl6ZSB0aGUgUmVxdWVzdFxuXG5cbiAgICAgIHZhciB1cmw7XG4gICAgICB2YXIgY2FjaGVLZXk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnICYmICFvcHRpb25zKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aC5cbiAgICAgICAgY2FjaGVLZXkgPSBzaW1wbGVDYWNoZUtleTtcbiAgICAgICAgdXJsID0gcmVzb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHJlcXVlc3QuXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVzb3VyY2UsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyB8fCAvLyAkRmxvd0ZpeE1lOiBrZWVwYWxpdmUgaXMgcmVhbFxuICAgICAgICByZXF1ZXN0LmtlZXBhbGl2ZSkge1xuICAgICAgICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBkZWR1cGUgcmVxdWVzdHMgdGhhdCBtaWdodCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhvc2VcbiAgICAgICAgICAvLyBoYXZlIHRvIGJlIGV4cGxpY2l0bHkgY2FjaGVkLiBXZSBhc3N1bWUgdGhhdCB0aGUgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYVxuICAgICAgICAgIC8vIGJvZHkgaWYgaXQncyBHRVQgb3IgSEVBRC5cbiAgICAgICAgICAvLyBrZWVwYWxpdmUgZ2V0cyB0cmVhdGVkIHRoZSBzYW1lIGFzIGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY2FjaGUgc2lnbmFsLlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZldGNoKHJlc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlS2V5ID0gZ2VuZXJhdGVDYWNoZUtleShyZXF1ZXN0KTtcbiAgICAgICAgdXJsID0gcmVxdWVzdC51cmw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWNoZSA9IGRpc3BhdGNoZXIuZ2V0Q2FjaGVGb3JUeXBlKGNyZWF0ZUZldGNoQ2FjaGUpO1xuICAgICAgdmFyIGNhY2hlRW50cmllcyA9IGNhY2hlLmdldCh1cmwpO1xuICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICBpZiAoY2FjaGVFbnRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2UgcGFzcyB0aGUgb3JpZ2luYWwgYXJndW1lbnRzIGhlcmUgaW4gY2FzZSBub3JtYWxpemluZyB0aGUgUmVxdWVzdFxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgYWxsIHRoZSBvcHRpb25zIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAgICAgIG1hdGNoID0gb3JpZ2luYWxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhY2hlLnNldCh1cmwsIFtjYWNoZUtleSwgbWF0Y2hdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHVzZSBhbiBhcnJheSBhcyB0aGUgaW5uZXIgZGF0YSBzdHJ1Y3R1cmUgc2luY2UgaXQncyBsaWdodGVyIGFuZFxuICAgICAgICAvLyB3ZSB0eXBpY2FsbHkgb25seSBleHBlY3QgdG8gc2VlIG9uZSBvciB0d28gZW50cmllcyBoZXJlLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlRW50cmllcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgICB2YXIga2V5ID0gY2FjaGVFbnRyaWVzW2ldO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNhY2hlRW50cmllc1tpICsgMV07XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBjYWNoZUtleSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB2YWx1ZTsgLy8gSSB3b3VsZCd2ZSBwcmVmZXJyZWQgYSBsYWJlbGxlZCBicmVhayBidXQgbGludCBzYXlzIG5vLlxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2gudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaCA9IG9yaWdpbmFsRmV0Y2gocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICBjYWNoZUVudHJpZXMucHVzaChjYWNoZUtleSwgbWF0Y2gpO1xuICAgICAgfSAvLyBXZSBjbG9uZSB0aGUgcmVzcG9uc2Ugc28gdGhhdCBlYWNoIHRpbWUgeW91IGNhbGwgdGhpcyB5b3UgZ2V0IGEgbmV3IHJlYWRcbiAgICAgIC8vIG9mIHRoZSBib2R5IHNvIHRoYXQgaXQgY2FuIGJlIHJlYWQgbXVsdGlwbGUgdGltZXMuXG5cblxuICAgICAgcmV0dXJuIG1hdGNoLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTsgLy8gV2UgZG9uJ3QgZXhwZWN0IHRvIHNlZSBhbnkgZXh0cmEgcHJvcGVydGllcyBvbiBmZXRjaCBidXQgaWYgdGhlcmUgYXJlIGFueSxcbiAgICAvLyBjb3B5IHRoZW0gb3Zlci4gVXNlZnVsIGZvciBleHRlbmRlZCBmZXRjaCBlbnZpcm9ubWVudHMgb3IgbW9ja3MuXG5cblxuICAgIGFzc2lnbihjYWNoZWRGZXRjaCwgb3JpZ2luYWxGZXRjaCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5hdGl2ZS1yZWFzc2lnblxuICAgICAgZmV0Y2ggPSBjYWNoZWRGZXRjaDtcbiAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEluIGNhc2UgYXNzaWduaW5nIGl0IGdsb2JhbGx5IGZhaWxzLCB0cnkgZ2xvYmFsVGhpcyBpbnN0ZWFkIGp1c3QgaW4gY2FzZSBpdCBleGlzdHMuXG4gICAgICAgIGdsb2JhbFRoaXMuZmV0Y2ggPSBjYWNoZWRGZXRjaDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAvLyBMb2cgZXZlbiBpbiBwcm9kdWN0aW9uIGp1c3QgdG8gbWFrZSBzdXJlIHRoaXMgaXMgc2VlbiBpZiBvbmx5IHByb2QgaXMgZnJvemVuLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG4gICAgICAgIHdhcm4oJ1JlYWN0IHdhcyB1bmFibGUgdG8gcGF0Y2ggdGhlIGZldGNoKCkgZnVuY3Rpb24gaW4gdGhpcyBlbnZpcm9ubWVudC4gJyArICdTdXNwZW5zZXkgQVBJcyBtaWdodCBub3Qgd29yayBjb3JyZWN0bHkgYXMgYSByZXN1bHQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTguMy4wLW5leHQtNmRkY2JkNGY5LTIwMjMwMjA5JztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250ZXh0MiA9IHR5cGU7XG4gICAgICAgICAgcmV0dXJuIChjb250ZXh0Mi5kaXNwbGF5TmFtZSB8fCBjb250ZXh0Mi5fZ2xvYmFsTmFtZSkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAge1xuICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXBwZWRDaGlsZC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICAgICAgJycgKyBtYXBwZWRDaGlsZC5rZXkgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICApICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwOyAvLyAkRmxvd0ZpeE1lIGBpdGVyYXRvckZuYCBtaWdodCByZXR1cm4gbnVsbCBhY2NvcmRpbmcgdG8gdHlwaW5nLlxuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5cblxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgZWl0aGVyIGJlY2F1c2UgaXQncyBtaXNzaW5nIG9yIHRocm93cy4gSWYgc28sIHdlIHRyZWF0IGl0XG4gICAgLy8gYXMgc3RpbGwgdW5pbml0aWFsaXplZCBhbmQgdHJ5IGFnYWluIG5leHQgdGltZS4gV2hpY2ggaXMgdGhlIHNhbWUgYXMgd2hhdFxuICAgIC8vIGhhcHBlbnMgaWYgdGhlIGN0b3Igb3IgYW55IHdyYXBwZXJzIHByb2Nlc3NpbmcgdGhlIGN0b3IgdGhyb3dzLiBUaGlzIG1pZ2h0XG4gICAgLy8gZW5kIHVwIGZpeGluZyBpdCBpZiB0aGUgcmVzb2x1dGlvbiB3YXMgYSBjb25jdXJyZW5jeSBidWcuXG5cbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcgfHwgcGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IG1vZHVsZU9iamVjdDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcgfHwgcGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgLy8gSW4gY2FzZSwgd2UncmUgc3RpbGwgdW5pbml0aWFsaXplZCwgdGhlbiB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgdGhlbmFibGVcbiAgICAgIC8vIHRvIHJlc29sdmUuIFNldCBpdCBhcyBwZW5kaW5nIGluIHRoZSBtZWFudGltZS5cbiAgICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB9XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHZhciBtb2R1bGVPYmplY3QgPSBwYXlsb2FkLl9yZXN1bHQ7XG5cbiAgICB7XG4gICAgICBpZiAobW9kdWxlT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVxcblxcblwiICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHB1dCBjdXJseSBicmFjZXMgYXJvdW5kIHRoZSBpbXBvcnQ/JywgbW9kdWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoISgnZGVmYXVsdCcgaW4gbW9kdWxlT2JqZWN0KSkge1xuICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IFVuaW5pdGlhbGl6ZWQsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7IC8vIFRoZSBpbm5lciBjb21wb25lbnQgc2hvdWxkbid0IGluaGVyaXQgdGhpcyBkaXNwbGF5IG5hbWUgaW4gbW9zdCBjYXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAvLyBzbyB0aGF0IG91ciBjb21wb25lbnQtc3RhY2sgZ2VuZXJhdGlvbiBsb2dpYyB3aWxsIGRpc3BsYXkgdGhlaXIgZnJhbWVzLlxuICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIHVzZWQgZWxzZXdoZXJlLlxuICAgICAgICAvLyBCdXQgaXQncyBuaWNlIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRvIGluaGVyaXQgdGhlIG5hbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG4gICAgICAgIC8vIEFuIGFub255bW91cyBmdW5jdGlvbiBnZW5lcmFsbHkgc3VnZ2VzdHMgYSBwYXR0ZXJuIGxpa2U6XG4gICAgICAgIC8vICAgUmVhY3QubWVtbygocHJvcHMpID0+IHsuLi59KTtcbiAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuICAgICAgICBpZiAoIXR5cGUubmFtZSAmJiAhdHlwZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbnZhciBVTlRFUk1JTkFURUQgPSAwO1xudmFyIFRFUk1JTkFURUQgPSAxO1xudmFyIEVSUk9SRUQgPSAyO1xuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZVJvb3QoKSB7XG4gIHJldHVybiBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGUoKSB7XG4gIHJldHVybiB7XG4gICAgczogVU5URVJNSU5BVEVELFxuICAgIC8vIHN0YXR1cywgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBjYWNoZWQgY29tcHV0YXRpb24gcmV0dXJuZWQgYSB2YWx1ZSBvciB0aHJldyBhbiBlcnJvclxuICAgIHY6IHVuZGVmaW5lZCxcbiAgICAvLyB2YWx1ZSwgZWl0aGVyIHRoZSBjYWNoZWQgcmVzdWx0IG9yIGFuIGVycm9yLCBkZXBlbmRpbmcgb24gc1xuICAgIG86IG51bGwsXG4gICAgLy8gb2JqZWN0IGNhY2hlLCBhIFdlYWtNYXAgd2hlcmUgbm9uLXByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZFxuICAgIHA6IG51bGwgLy8gcHJpbWl0aXZlIGNhY2hlLCBhIHJlZ3VsYXIgTWFwIHdoZXJlIHByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZC5cblxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWNoZShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudDtcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGlzcGF0Y2hlciwgdGhlbiB3ZSB0cmVhdCB0aGlzIGFzIG5vdCBiZWluZyBjYWNoZWQuXG4gICAgICAvLyAkRmxvd0ZpeE1lOiBXZSBkb24ndCB3YW50IHRvIHVzZSByZXN0IGFyZ3VtZW50cyBzaW5jZSB3ZSB0cmFuc3BpbGUgdGhlIGNvZGUuXG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgZm5NYXAgPSBkaXNwYXRjaGVyLmdldENhY2hlRm9yVHlwZShjcmVhdGVDYWNoZVJvb3QpO1xuICAgIHZhciBmbk5vZGUgPSBmbk1hcC5nZXQoZm4pO1xuICAgIHZhciBjYWNoZU5vZGU7XG5cbiAgICBpZiAoZm5Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgZm5NYXAuc2V0KGZuLCBjYWNoZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZU5vZGUgPSBmbk5vZGU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gT2JqZWN0cyBnbyBpbnRvIGEgV2Vha01hcFxuICAgICAgICB2YXIgb2JqZWN0Q2FjaGUgPSBjYWNoZU5vZGUubztcblxuICAgICAgICBpZiAob2JqZWN0Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUubyA9IG9iamVjdENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYmplY3ROb2RlID0gb2JqZWN0Q2FjaGUuZ2V0KGFyZyk7XG5cbiAgICAgICAgaWYgKG9iamVjdE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gb2JqZWN0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBnbyBpbnRvIGEgcmVndWxhciBNYXBcbiAgICAgICAgdmFyIHByaW1pdGl2ZUNhY2hlID0gY2FjaGVOb2RlLnA7XG5cbiAgICAgICAgaWYgKHByaW1pdGl2ZUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgY2FjaGVOb2RlLnAgPSBwcmltaXRpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmltaXRpdmVOb2RlID0gcHJpbWl0aXZlQ2FjaGUuZ2V0KGFyZyk7XG5cbiAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xuICAgICAgICAgIHByaW1pdGl2ZUNhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGVOb2RlID0gcHJpbWl0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gVEVSTUlOQVRFRCkge1xuICAgICAgcmV0dXJuIGNhY2hlTm9kZS52O1xuICAgIH1cblxuICAgIGlmIChjYWNoZU5vZGUucyA9PT0gRVJST1JFRCkge1xuICAgICAgdGhyb3cgY2FjaGVOb2RlLnY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vICRGbG93Rml4TWU6IFdlIGRvbid0IHdhbnQgdG8gdXNlIHJlc3QgYXJndW1lbnRzIHNpbmNlIHdlIHRyYW5zcGlsZSB0aGUgY29kZS5cbiAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIHRlcm1pbmF0ZWROb2RlID0gY2FjaGVOb2RlO1xuICAgICAgdGVybWluYXRlZE5vZGUucyA9IFRFUk1JTkFURUQ7XG4gICAgICB0ZXJtaW5hdGVkTm9kZS52ID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gV2Ugc3RvcmUgdGhlIGZpcnN0IGVycm9yIHRoYXQncyB0aHJvd24gYW5kIHJldGhyb3cgaXQuXG4gICAgICB2YXIgZXJyb3JlZE5vZGUgPSBjYWNoZU5vZGU7XG4gICAgICBlcnJvcmVkTm9kZS5zID0gRVJST1JFRDtcbiAgICAgIGVycm9yZWROb2RlLnYgPSBlcnJvcjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG59XG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTsgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIHVuc3RhYmxlLCB0aHVzIG9wdGlvbmFsXG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlKHVzYWJsZSk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgQ29udGV4dFJlZ2lzdHJ5JDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5Db250ZXh0UmVnaXN0cnk7XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJDb250ZXh0KGdsb2JhbE5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gIHZhciB3YXNEZWZpbmVkID0gdHJ1ZTtcblxuICBpZiAoIUNvbnRleHRSZWdpc3RyeSQxW2dsb2JhbE5hbWVdKSB7XG4gICAgd2FzRGVmaW5lZCA9IGZhbHNlO1xuICAgIHZhciBfY29udGV4dCA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFLFxuICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgICAgX2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgIF9nbG9iYWxOYW1lOiBnbG9iYWxOYW1lXG4gICAgfTtcbiAgICBfY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgICAgX2NvbnRleHQ6IF9jb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXI7XG4gICAgICBfY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIF9jb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9jb250ZXh0LCB7XG4gICAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lcikge1xuICAgICAgICAgICAgICBlcnJvcignQ29uc3VtZXIgcGF0dGVybiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFJlYWN0U2VydmVyQ29udGV4dCcpO1xuXG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgQ29udGV4dFJlZ2lzdHJ5JDFbZ2xvYmFsTmFtZV0gPSBfY29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gQ29udGV4dFJlZ2lzdHJ5JDFbZ2xvYmFsTmFtZV07XG5cbiAgaWYgKGNvbnRleHQuX2RlZmF1bHRWYWx1ZSA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgY29udGV4dC5fZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCkge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAod2FzRGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZlckNvbnRleHQ6IFwiICsgZ2xvYmFsTmFtZSArIFwiIGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2NvcGUsIG9wdGlvbnMpIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHt9O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBzY29wZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIHtcbiAgICAgIGlmIChwcmV2VHJhbnNpdGlvbiA9PT0gbnVsbCAmJiBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcblxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5Qcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNhY2hlID0gY2FjaGU7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmNyZWF0ZVNlcnZlckNvbnRleHQgPSBjcmVhdGVTZXJ2ZXJDb250ZXh0O1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBzdGFydFRyYW5zaXRpb247XG5leHBvcnRzLnVzZSA9IHVzZTtcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VJZCA9IHVzZUlkO1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImN1cnJlbnQiLCJSZWFjdEN1cnJlbnRDYWNoZSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnIiwidHJhbnNpdGlvbiIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlIiwiaXNCYXRjaGluZ0xlZ2FjeSIsImRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlIiwiZGlkVXNlUHJvbWlzZSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImN1cnJlbnRFeHRyYVN0YWNrRnJhbWUiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJzdGFjayIsImdldEN1cnJlbnRTdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJpbXBsIiwiZW5hYmxlU2NvcGVBUEkiLCJlbmFibGVDYWNoZUVsZW1lbnQiLCJlbmFibGVUcmFuc2l0aW9uVHJhY2luZyIsImVuYWJsZUxlZ2FjeUhpZGRlbiIsImVuYWJsZURlYnVnVHJhY2luZyIsIkNvbnRleHRSZWdpc3RyeSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiY3JlYXRlRmV0Y2hDYWNoZSIsIk1hcCIsInNpbXBsZUNhY2hlS2V5IiwiZ2VuZXJhdGVDYWNoZUtleSIsInJlcXVlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0aG9kIiwiZnJvbSIsImhlYWRlcnMiLCJlbnRyaWVzIiwibW9kZSIsInJlZGlyZWN0IiwiY3JlZGVudGlhbHMiLCJyZWZlcnJlciIsInJlZmVycmVyUG9saWN5IiwiaW50ZWdyaXR5IiwiZmV0Y2giLCJvcmlnaW5hbEZldGNoIiwiY2FjaGVkRmV0Y2giLCJyZXNvdXJjZSIsIm9wdGlvbnMiLCJkaXNwYXRjaGVyIiwic2lnbmFsIiwiZ2V0Q2FjaGVTaWduYWwiLCJ1cmwiLCJjYWNoZUtleSIsIlJlcXVlc3QiLCJrZWVwYWxpdmUiLCJjYWNoZSIsImdldENhY2hlRm9yVHlwZSIsImNhY2hlRW50cmllcyIsImdldCIsIm1hdGNoIiwidW5kZWZpbmVkIiwic2V0IiwiaSIsImwiLCJrZXkiLCJ2YWx1ZSIsInRoZW4iLCJyZXNwb25zZSIsImNsb25lIiwicHVzaCIsImVycm9yMSIsImdsb2JhbFRoaXMiLCJlcnJvcjIiLCJSZWFjdFZlcnNpb24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJfY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjYWxsYmFjayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJDb21wb25lbnQiLCJwcm9wcyIsImNvbnRleHQiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsIkVycm9yIiwiZm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJpbmZvIiwiZGVmaW5lUHJvcGVydHkiLCJmbk5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsIkNvbXBvbmVudER1bW15IiwiUHVyZUNvbXBvbmVudCIsInB1cmVDb21wb25lbnRQcm90b3R5cGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNyZWF0ZVJlZiIsInJlZk9iamVjdCIsInNlYWwiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidHlwZSIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0YWciLCIkJHR5cGVvZiIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImNvbnRleHQyIiwiX2dsb2JhbE5hbWUiLCJSRVNFUlZFRF9QUk9QUyIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic3RhdGVOb2RlIiwiUmVhY3RFbGVtZW50Iiwic2VsZiIsInNvdXJjZSIsIm93bmVyIiwiZWxlbWVudCIsIl9vd25lciIsIl9zdG9yZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNyZWF0ZUVsZW1lbnQiLCJjaGlsZHJlbiIsInByb3BOYW1lIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiZGVmYXVsdFByb3BzIiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJfc2VsZiIsIl9zb3VyY2UiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJyZXBsYWNlIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsImdldEVsZW1lbnRLZXkiLCJpbmRleCIsInRvU3RyaW5nIiwibWFwSW50b0FycmF5IiwiYXJyYXkiLCJlc2NhcGVkUHJlZml4IiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJfY2hpbGQiLCJtYXBwZWRDaGlsZCIsImNoaWxkS2V5IiwiZXNjYXBlZENoaWxkS2V5IiwiYyIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJpdGVyYWJsZUNoaWxkcmVuIiwic3RlcCIsImlpIiwibmV4dCIsImRvbmUiLCJjaGlsZHJlblN0cmluZyIsImtleXMiLCJqb2luIiwibWFwQ2hpbGRyZW4iLCJmdW5jIiwicmVzdWx0IiwiY291bnQiLCJjb3VudENoaWxkcmVuIiwibiIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJ0b0FycmF5Iiwib25seUNoaWxkIiwiVW5pbml0aWFsaXplZCIsIlBlbmRpbmciLCJSZXNvbHZlZCIsIlJlamVjdGVkIiwibGF6eUluaXRpYWxpemVyIiwiX3N0YXR1cyIsImN0b3IiLCJfcmVzdWx0IiwidGhlbmFibGUiLCJtb2R1bGVPYmplY3QiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwicGVuZGluZyIsImRlZmF1bHQiLCJsYXp5IiwibGF6eVR5cGUiLCJwcm9wVHlwZXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwibmV3RGVmYXVsdFByb3BzIiwibmV3UHJvcFR5cGVzIiwiZm9yd2FyZFJlZiIsImVsZW1lbnRUeXBlIiwib3duTmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXRNb2R1bGVJZCIsIm1lbW8iLCJjb21wYXJlIiwiVU5URVJNSU5BVEVEIiwiVEVSTUlOQVRFRCIsIkVSUk9SRUQiLCJjcmVhdGVDYWNoZVJvb3QiLCJXZWFrTWFwIiwiY3JlYXRlQ2FjaGVOb2RlIiwicyIsInYiLCJvIiwicCIsImZuIiwiZm5NYXAiLCJmbk5vZGUiLCJjYWNoZU5vZGUiLCJhcmciLCJvYmplY3RDYWNoZSIsIm9iamVjdE5vZGUiLCJwcmltaXRpdmVDYWNoZSIsInByaW1pdGl2ZU5vZGUiLCJ0ZXJtaW5hdGVkTm9kZSIsImVycm9yZWROb2RlIiwicmVzb2x2ZURpc3BhdGNoZXIiLCJ1c2VDb250ZXh0IiwiQ29udGV4dCIsInJlYWxDb250ZXh0IiwiQ29uc3VtZXIiLCJQcm92aWRlciIsInVzZUNhbGxiYWNrIiwiZGVwcyIsInVzZU1lbW8iLCJjcmVhdGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1c2VJZCIsInVzZSIsInVzYWJsZSIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm93bmVyRm4iLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiY29uc3RydWN0IiwiZnJhbWUiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiRmFrZSIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiX2ZyYW1lIiwiaW5jbHVkZXMiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhhcyIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzIiwiZWxlbWVudFByb3BzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsInZhbGlkYXRlZCIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJfbmFtZSIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwiQ29udGV4dFJlZ2lzdHJ5JDEiLCJjcmVhdGVTZXJ2ZXJDb250ZXh0IiwiZ2xvYmFsTmFtZSIsImRlZmF1bHRWYWx1ZSIsIndhc0RlZmluZWQiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRWYWx1ZTIiLCJfZGVmYXVsdFZhbHVlIiwiX3RocmVhZENvdW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50UmVuZGVyZXIyIiwic3RhcnRUcmFuc2l0aW9uIiwic2NvcGUiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJTZXQiLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJzaXplIiwiY2xlYXIiLCJjcmVhdGVFbGVtZW50JDEiLCJjbG9uZUVsZW1lbnQkMSIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsIm9ubHkiLCJleHBvcnRzIiwiRnJhZ21lbnQiLCJQcm9maWxlciIsIlN0cmljdE1vZGUiLCJTdXNwZW5zZSIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(sc_server)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxzTEFBeUI7QUFDM0IsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/next/dist/compiled/react/react.shared-subset.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/react.shared-subset.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react.shared-subset.development.js */ \"(sc_server)/./node_modules/next/dist/compiled/react/cjs/react.shared-subset.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L3JlYWN0LnNoYXJlZC1zdWJzZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsa0xBQXlCO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9yZWFjdC5zaGFyZWQtc3Vic2V0LmpzP2M2MjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnNoYXJlZC1zdWJzZXQucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3Quc2hhcmVkLXN1YnNldC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/next/dist/compiled/react/react.shared-subset.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/recoil/cjs/index.js":
/*!******************************************!*\
  !*** ./node_modules/recoil/cjs/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar react = _interopDefault(__webpack_require__(/*! react */ \"(sc_server)/./node_modules/next/dist/compiled/react/react.shared-subset.js\"));\nvar reactDom = _interopDefault(__webpack_require__(/*! react-dom */ \"(sc_server)/./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js\"));\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function err(message) {\n    const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n    // err.stack property is accessed.\n    if (error.stack === undefined) {\n        // IE sets the stack only if error is thrown\n        try {\n            throw error;\n        } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n    }\n    return error;\n}\nvar err_1 = err;\n// @oss-only\nvar Recoil_err = err_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ // Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\nfunction isPromise(p) {\n    return !!p && typeof p.then === \"function\";\n}\nvar Recoil_isPromise = isPromise;\nfunction nullthrows(x, message) {\n    if (x != null) {\n        return x;\n    }\n    throw Recoil_err(message !== null && message !== void 0 ? message : \"Got unexpected null or undefined\");\n}\nvar Recoil_nullthrows = nullthrows;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass BaseLoadable {\n    getValue() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    toPromise() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    valueMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    valueOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n    }\n    promiseMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    promiseOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n    }\n    errorMaybe() {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n    errorOrThrow() {\n        // $FlowFixMe[prop-missing]\n        throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n    }\n    is(other) {\n        // $FlowFixMe[prop-missing]\n        return other.state === this.state && other.contents === this.contents;\n    }\n    map(_map) {\n        throw Recoil_err(\"BaseLoadable\");\n    }\n}\nclass ValueLoadable extends BaseLoadable {\n    constructor(value){\n        super();\n        _defineProperty(this, \"state\", \"hasValue\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = value;\n    }\n    getValue() {\n        return this.contents;\n    }\n    toPromise() {\n        return Promise.resolve(this.contents);\n    }\n    valueMaybe() {\n        return this.contents;\n    }\n    valueOrThrow() {\n        return this.contents;\n    }\n    promiseMaybe() {\n        return undefined;\n    }\n    errorMaybe() {\n        return undefined;\n    }\n    map(map) {\n        try {\n            const next = map(this.contents);\n            return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n        } catch (e) {\n            return Recoil_isPromise(e) ? // errors and subsequent retries will be handled in 'loading' case\n            // $FlowFixMe[prop-missing]\n            loadableWithPromise(e.next(()=>this.map(map))) : loadableWithError(e);\n        }\n    }\n}\nclass ErrorLoadable extends BaseLoadable {\n    constructor(error){\n        super();\n        _defineProperty(this, \"state\", \"hasError\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = error;\n    }\n    getValue() {\n        throw this.contents;\n    }\n    toPromise() {\n        return Promise.reject(this.contents);\n    }\n    valueMaybe() {\n        return undefined;\n    }\n    promiseMaybe() {\n        return undefined;\n    }\n    errorMaybe() {\n        return this.contents;\n    }\n    errorOrThrow() {\n        return this.contents;\n    }\n    map(_map) {\n        // $FlowIssue[incompatible-return]\n        return this;\n    }\n}\nclass LoadingLoadable extends BaseLoadable {\n    constructor(promise){\n        super();\n        _defineProperty(this, \"state\", \"loading\");\n        _defineProperty(this, \"contents\", void 0);\n        this.contents = promise;\n    }\n    getValue() {\n        throw this.contents;\n    }\n    toPromise() {\n        return this.contents;\n    }\n    valueMaybe() {\n        return undefined;\n    }\n    promiseMaybe() {\n        return this.contents;\n    }\n    promiseOrThrow() {\n        return this.contents;\n    }\n    errorMaybe() {\n        return undefined;\n    }\n    map(map) {\n        return loadableWithPromise(this.contents.then((value)=>{\n            const next = map(value);\n            if (isLoadable(next)) {\n                const nextLoadable = next;\n                switch(nextLoadable.state){\n                    case \"hasValue\":\n                        return nextLoadable.contents;\n                    case \"hasError\":\n                        throw nextLoadable.contents;\n                    case \"loading\":\n                        return nextLoadable.contents;\n                }\n            } // $FlowIssue[incompatible-return]\n            return next;\n        }).catch((e)=>{\n            if (Recoil_isPromise(e)) {\n                // we were \"suspended,\" try again\n                return e.then(()=>this.map(map).contents);\n            }\n            throw e;\n        }));\n    }\n}\nfunction loadableWithValue(value) {\n    return Object.freeze(new ValueLoadable(value));\n}\nfunction loadableWithError(error) {\n    return Object.freeze(new ErrorLoadable(error));\n}\nfunction loadableWithPromise(promise) {\n    return Object.freeze(new LoadingLoadable(promise));\n}\nfunction loadableLoading() {\n    return Object.freeze(new LoadingLoadable(new Promise(()=>{})));\n}\nfunction loadableAllArray(inputs) {\n    return inputs.every((i)=>i.state === \"hasValue\") ? loadableWithValue(inputs.map((i)=>i.contents)) : inputs.some((i)=>i.state === \"hasError\") ? loadableWithError(Recoil_nullthrows(inputs.find((i)=>i.state === \"hasError\"), \"Invalid loadable passed to loadableAll\").contents) : loadableWithPromise(Promise.all(inputs.map((i)=>i.contents)));\n}\nfunction loadableAll(inputs) {\n    const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map((key)=>inputs[key]);\n    const normalizedInputs = unwrapedInputs.map((x)=>isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n    const output = loadableAllArray(normalizedInputs);\n    return Array.isArray(inputs) ? output : // $FlowIssue[incompatible-call]\n    output.map((outputs)=>Object.getOwnPropertyNames(inputs).reduce((out, key, idx)=>({\n                ...out,\n                [key]: outputs[idx]\n            }), {}));\n}\nfunction isLoadable(x) {\n    return x instanceof BaseLoadable;\n}\nconst LoadableStaticInterface = {\n    of: (value)=>Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n    error: (error)=>loadableWithError(error),\n    // $FlowIssue[incompatible-return]\n    loading: ()=>loadableLoading(),\n    // $FlowIssue[unclear-type]\n    all: loadableAll,\n    isLoadable\n};\nvar Recoil_Loadable = {\n    loadableWithValue,\n    loadableWithError,\n    loadableWithPromise,\n    loadableLoading,\n    loadableAll,\n    isLoadable,\n    RecoilLoadable: LoadableStaticInterface\n};\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\nvar Recoil_Loadable$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    loadableWithValue: Recoil_Loadable_1,\n    loadableWithError: Recoil_Loadable_2,\n    loadableWithPromise: Recoil_Loadable_3,\n    loadableLoading: Recoil_Loadable_4,\n    loadableAll: Recoil_Loadable_5,\n    isLoadable: Recoil_Loadable_6,\n    RecoilLoadable: Recoil_Loadable_7\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ const gks = new Map().set(\"recoil_hamt_2020\", true).set(\"recoil_sync_external_store\", true).set(\"recoil_suppress_rerender_in_callback\", true).set(\"recoil_memory_managament_2020\", true);\nfunction Recoil_gkx_OSS(gk) {\n    var _gks$get;\n    return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\nRecoil_gkx_OSS.setPass = (gk)=>{\n    gks.set(gk, true);\n};\nRecoil_gkx_OSS.setFail = (gk)=>{\n    gks.set(gk, false);\n};\nRecoil_gkx_OSS.clear = ()=>{\n    gks.clear();\n};\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function recoverableViolation(message, _projectName, { error  } = {}) {\n    if (true) {\n        console.error(message, error);\n    }\n    return null;\n}\nvar recoverableViolation_1 = recoverableViolation;\n// @oss-only\nvar Recoil_recoverableViolation = recoverableViolation_1;\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\nconst createMutableSource = (_createMutableSource = react.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : react.unstable_createMutableSource;\nconst useMutableSource = (_useMutableSource = react.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : react.unstable_useMutableSource; // https://github.com/reactwg/react-18/discussions/86\nconst useSyncExternalStore = (_useSyncExternalStore = react.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : react.unstable_useSyncExternalStore;\nlet ReactRendererVersionMismatchWarnOnce = false; // Check if the current renderer supports `useSyncExternalStore()`.\n// Since React goes through a proxy dispatcher and the current renderer can\n// change we can't simply check if `React.useSyncExternalStore()` is defined.\nfunction currentRendererSupportsUseSyncExternalStore() {\n    var _ReactCurrentDispatch;\n    // $FlowFixMe[incompatible-use]\n    const { ReactCurrentDispatcher , ReactCurrentOwner  } = /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism\n   * to detect if the current renderer supports useSyncExternalStore()\n   * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */ react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;\n    const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;\n    if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {\n        ReactRendererVersionMismatchWarnOnce = true;\n        Recoil_recoverableViolation(\"A React renderer without React 18+ API support is being used with React 18+.\");\n    }\n    return isUseSyncExternalStoreSupported;\n}\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */ function reactMode() {\n    // NOTE: This mode is currently broken with some Suspense cases\n    // see Recoil_selector-test.js\n    if (Recoil_gkx(\"recoil_transition_support\")) {\n        return {\n            mode: \"TRANSITION_SUPPORT\",\n            early: true,\n            concurrent: true\n        };\n    }\n    if (Recoil_gkx(\"recoil_sync_external_store\") && useSyncExternalStore != null) {\n        return {\n            mode: \"SYNC_EXTERNAL_STORE\",\n            early: true,\n            concurrent: false\n        };\n    }\n    if (Recoil_gkx(\"recoil_mutable_source\") && useMutableSource != null && \"undefined\" !== \"undefined\" && 0) {}\n    return Recoil_gkx(\"recoil_suppress_rerender_in_callback\") ? {\n        mode: \"LEGACY\",\n        early: true,\n        concurrent: false\n    } : {\n        mode: \"LEGACY\",\n        early: false,\n        concurrent: false\n    };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\nfunction isFastRefreshEnabled() {\n    // @fb-only: const {isAcceptingUpdate} = require('__debug');\n    // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n    return false; // @oss-only\n}\nvar Recoil_ReactMode = {\n    createMutableSource,\n    useMutableSource,\n    useSyncExternalStore,\n    currentRendererSupportsUseSyncExternalStore,\n    reactMode,\n    isFastRefreshEnabled\n};\nconst env = {\n    RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true\n};\n/**\n * Allow NodeJS/NextJS/etc to set the initial state through process.env variable\n * Note:  we don't assume 'process' is available in all runtime environments\n *\n * @see https://github.com/facebookexperimental/Recoil/issues/733\n */ function applyProcessEnvFlagOverrides() {\n    var _process, _process$env$RECOIL_D, _process$env$RECOIL_D2;\n    // note: this check is needed in addition to the check below, runtime error will occur without it!\n    // eslint-disable-next-line fb-www/typeof-undefined\n    if (typeof process === \"undefined\") {\n        return;\n    }\n    if (((_process = process) === null || _process === void 0 ? void 0 : _process.env) == null) {\n        return;\n    }\n    const sanitizedValue = (_process$env$RECOIL_D = process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) === null || _process$env$RECOIL_D === void 0 ? void 0 : (_process$env$RECOIL_D2 = _process$env$RECOIL_D.toLowerCase()) === null || _process$env$RECOIL_D2 === void 0 ? void 0 : _process$env$RECOIL_D2.trim();\n    if (sanitizedValue == null || sanitizedValue === \"\") {\n        return;\n    }\n    const allowedValues = [\n        \"true\",\n        \"false\"\n    ];\n    if (!allowedValues.includes(sanitizedValue)) {\n        throw Recoil_err(`process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED value must be 'true', 'false', or empty: ${sanitizedValue}`);\n    }\n    env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = sanitizedValue === \"true\";\n}\napplyProcessEnvFlagOverrides();\nvar Recoil_RecoilEnv = env;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ // eslint-disable-next-line no-unused-vars\nclass AbstractRecoilValue {\n    constructor(newKey){\n        _defineProperty(this, \"key\", void 0);\n        this.key = newKey;\n    }\n    toJSON() {\n        return {\n            key: this.key\n        };\n    }\n}\nclass RecoilState extends AbstractRecoilValue {\n}\nclass RecoilValueReadOnly extends AbstractRecoilValue {\n}\nfunction isRecoilValue(x) {\n    return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\nvar Recoil_RecoilValue = {\n    AbstractRecoilValue,\n    RecoilState,\n    RecoilValueReadOnly,\n    isRecoilValue\n};\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\nvar Recoil_RecoilValue$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AbstractRecoilValue: Recoil_RecoilValue_1,\n    RecoilState: Recoil_RecoilValue_2,\n    RecoilValueReadOnly: Recoil_RecoilValue_3,\n    isRecoilValue: Recoil_RecoilValue_4\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function sprintf(format, ...args) {\n    let index = 0;\n    return format.replace(/%s/g, ()=>String(args[index++]));\n}\nvar sprintf_1 = sprintf;\nfunction expectationViolation(format, ...args) {\n    if (true) {\n        const message = sprintf_1.call(null, format, ...args);\n        const error = new Error(message);\n        error.name = \"Expectation Violation\";\n        console.error(error);\n    }\n}\nvar expectationViolation_1 = expectationViolation;\n// @oss-only\nvar Recoil_expectationViolation = expectationViolation_1;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */ function mapIterable(iterable, callback) {\n    // Use generator to create iterable/iterator\n    return function*() {\n        let index = 0;\n        for (const value of iterable){\n            yield callback(value, index++);\n        }\n    }();\n}\nvar Recoil_mapIterable = mapIterable;\nconst { isFastRefreshEnabled: isFastRefreshEnabled$1  } = Recoil_ReactMode;\nclass DefaultValue {\n}\nconst DEFAULT_VALUE = new DefaultValue();\n// flowlint-next-line unclear-type:off\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */ function recoilValuesForKeys(keys) {\n    return Recoil_mapIterable(keys, (key)=>Recoil_nullthrows(recoilValues.get(key)));\n}\nfunction checkForDuplicateAtomKey(key) {\n    if (nodes.has(key)) {\n        const message = `Duplicate atom key \"${key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n        if (true) {\n            // TODO Figure this out for open-source\n            if (!isFastRefreshEnabled$1()) {\n                Recoil_expectationViolation(message, \"recoil\");\n            }\n        } else {}\n    }\n}\nfunction registerNode(node) {\n    if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {\n        checkForDuplicateAtomKey(node.key);\n    }\n    nodes.set(node.key, node);\n    const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n    recoilValues.set(node.key, recoilValue);\n    return recoilValue;\n}\n/* eslint-enable no-redeclare */ class NodeMissingError extends Error {\n} // flowlint-next-line unclear-type:off\nfunction getNode(key) {\n    const node = nodes.get(key);\n    if (node == null) {\n        throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n    }\n    return node;\n} // flowlint-next-line unclear-type:off\nfunction getNodeMaybe(key) {\n    return nodes.get(key);\n}\nconst configDeletionHandlers = new Map();\nfunction deleteNodeConfigIfPossible(key) {\n    var _node$shouldDeleteCon;\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const node = nodes.get(key);\n    if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n        var _getConfigDeletionHan;\n        nodes.delete(key);\n        (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n        configDeletionHandlers.delete(key);\n    }\n}\nfunction setConfigDeletionHandler(key, fn) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    if (fn === undefined) {\n        configDeletionHandlers.delete(key);\n    } else {\n        configDeletionHandlers.set(key, fn);\n    }\n}\nfunction getConfigDeletionHandler(key) {\n    return configDeletionHandlers.get(key);\n}\nvar Recoil_Node = {\n    nodes,\n    recoilValues,\n    registerNode,\n    getNode,\n    getNodeMaybe,\n    deleteNodeConfigIfPossible,\n    setConfigDeletionHandler,\n    getConfigDeletionHandler,\n    recoilValuesForKeys,\n    NodeMissingError,\n    DefaultValue,\n    DEFAULT_VALUE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function enqueueExecution(s, f) {\n    f();\n}\nvar Recoil_Queue = {\n    enqueueExecution\n};\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\nvar hamt_1 = createCommonjsModule(function(module) {\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n    /**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/ var hamt = {}; // export\n    /* Configuration\n ******************************************************************************/ var SIZE = 5;\n    var BUCKET_SIZE = Math.pow(2, SIZE);\n    var MASK = BUCKET_SIZE - 1;\n    var MAX_INDEX_NODE = BUCKET_SIZE / 2;\n    var MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n    /*\n ******************************************************************************/ var nothing = {};\n    var constant = function constant(x) {\n        return function() {\n            return x;\n        };\n    };\n    /**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/ var hash = hamt.hash = function(str) {\n        var type = typeof str === \"undefined\" ? \"undefined\" : _typeof(str);\n        if (type === \"number\") return str;\n        if (type !== \"string\") str += \"\";\n        var hash = 0;\n        for(var i = 0, len = str.length; i < len; ++i){\n            var c = str.charCodeAt(i);\n            hash = (hash << 5) - hash + c | 0;\n        }\n        return hash;\n    };\n    /* Bit Ops\n ******************************************************************************/ /**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/ var popcount = function popcount(x) {\n        x -= x >> 1 & 0x55555555;\n        x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n        x = x + (x >> 4) & 0x0f0f0f0f;\n        x += x >> 8;\n        x += x >> 16;\n        return x & 0x7f;\n    };\n    var hashFragment = function hashFragment(shift, h) {\n        return h >>> shift & MASK;\n    };\n    var toBitmap = function toBitmap(x) {\n        return 1 << x;\n    };\n    var fromBitmap = function fromBitmap(bitmap, bit) {\n        return popcount(bitmap & bit - 1);\n    };\n    /* Array Ops\n ******************************************************************************/ /**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/ var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n        var out = arr;\n        if (!mutate) {\n            var len = arr.length;\n            out = new Array(len);\n            for(var i = 0; i < len; ++i){\n                out[i] = arr[i];\n            }\n        }\n        out[at] = v;\n        return out;\n    };\n    /**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/ var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n        var newLen = arr.length - 1;\n        var i = 0;\n        var g = 0;\n        var out = arr;\n        if (mutate) {\n            i = g = at;\n        } else {\n            out = new Array(newLen);\n            while(i < at){\n                out[g++] = arr[i++];\n            }\n        }\n        ++i;\n        while(i <= newLen){\n            out[g++] = arr[i++];\n        }\n        if (mutate) {\n            out.length = newLen;\n        }\n        return out;\n    };\n    /**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/ var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n        var len = arr.length;\n        if (mutate) {\n            var _i = len;\n            while(_i >= at){\n                arr[_i--] = arr[_i];\n            }\n            arr[at] = v;\n            return arr;\n        }\n        var i = 0, g = 0;\n        var out = new Array(len + 1);\n        while(i < at){\n            out[g++] = arr[i++];\n        }\n        out[at] = v;\n        while(i < len){\n            out[++g] = arr[i++];\n        }\n        return out;\n    };\n    /* Node Structures\n ******************************************************************************/ var LEAF = 1;\n    var COLLISION = 2;\n    var INDEX = 3;\n    var ARRAY = 4;\n    /**\n    Empty node.\n*/ var empty = {\n        __hamt_isEmpty: true\n    };\n    var isEmptyNode = function isEmptyNode(x) {\n        return x === empty || x && x.__hamt_isEmpty;\n    };\n    /**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/ var Leaf = function Leaf(edit, hash, key, value) {\n        return {\n            type: LEAF,\n            edit: edit,\n            hash: hash,\n            key: key,\n            value: value,\n            _modify: Leaf__modify\n        };\n    };\n    /**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/ var Collision = function Collision(edit, hash, children) {\n        return {\n            type: COLLISION,\n            edit: edit,\n            hash: hash,\n            children: children,\n            _modify: Collision__modify\n        };\n    };\n    /**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/ var IndexedNode = function IndexedNode(edit, mask, children) {\n        return {\n            type: INDEX,\n            edit: edit,\n            mask: mask,\n            children: children,\n            _modify: IndexedNode__modify\n        };\n    };\n    /**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/ var ArrayNode = function ArrayNode(edit, size, children) {\n        return {\n            type: ARRAY,\n            edit: edit,\n            size: size,\n            children: children,\n            _modify: ArrayNode__modify\n        };\n    };\n    /**\n    Is `node` a leaf node?\n*/ var isLeaf = function isLeaf(node) {\n        return node === empty || node.type === LEAF || node.type === COLLISION;\n    };\n    /* Internal node operations.\n ******************************************************************************/ /**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/ var expand = function expand(edit, frag, child, bitmap, subNodes) {\n        var arr = [];\n        var bit = bitmap;\n        var count = 0;\n        for(var i = 0; bit; ++i){\n            if (bit & 1) arr[i] = subNodes[count++];\n            bit >>>= 1;\n        }\n        arr[frag] = child;\n        return ArrayNode(edit, count + 1, arr);\n    };\n    /**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/ var pack = function pack(edit, count, removed, elements) {\n        var children = new Array(count - 1);\n        var g = 0;\n        var bitmap = 0;\n        for(var i = 0, len = elements.length; i < len; ++i){\n            if (i !== removed) {\n                var elem = elements[i];\n                if (elem && !isEmptyNode(elem)) {\n                    children[g++] = elem;\n                    bitmap |= 1 << i;\n                }\n            }\n        }\n        return IndexedNode(edit, bitmap, children);\n    };\n    /**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/ var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n        if (h1 === h2) return Collision(edit, h1, [\n            n2,\n            n1\n        ]);\n        var subH1 = hashFragment(shift, h1);\n        var subH2 = hashFragment(shift, h2);\n        return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [\n            mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)\n        ] : subH1 < subH2 ? [\n            n1,\n            n2\n        ] : [\n            n2,\n            n1\n        ]);\n    };\n    /**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/ var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n        var len = list.length;\n        for(var i = 0; i < len; ++i){\n            var child = list[i];\n            if (keyEq(k, child.key)) {\n                var value = child.value;\n                var _newValue = f(value);\n                if (_newValue === value) return list;\n                if (_newValue === nothing) {\n                    --size.value;\n                    return arraySpliceOut(mutate, i, list);\n                }\n                return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n            }\n        }\n        var newValue = f();\n        if (newValue === nothing) return list;\n        ++size.value;\n        return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n    };\n    var canEditNode = function canEditNode(edit, node) {\n        return edit === node.edit;\n    };\n    /* Editing\n ******************************************************************************/ var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n        if (keyEq(k, this.key)) {\n            var _v = f(this.value);\n            if (_v === this.value) return this;\n            else if (_v === nothing) {\n                --size.value;\n                return empty;\n            }\n            if (canEditNode(edit, this)) {\n                this.value = _v;\n                return this;\n            }\n            return Leaf(edit, h, k, _v);\n        }\n        var v = f();\n        if (v === nothing) return this;\n        ++size.value;\n        return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n    };\n    var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n        if (h === this.hash) {\n            var canEdit = canEditNode(edit, this);\n            var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n            if (list === this.children) return this;\n            return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n        }\n        var v = f();\n        if (v === nothing) return this;\n        ++size.value;\n        return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n    };\n    var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n        var mask = this.mask;\n        var children = this.children;\n        var frag = hashFragment(shift, h);\n        var bit = toBitmap(frag);\n        var indx = fromBitmap(mask, bit);\n        var exists = mask & bit;\n        var current = exists ? children[indx] : empty;\n        var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n        if (current === child) return this;\n        var canEdit = canEditNode(edit, this);\n        var bitmap = mask;\n        var newChildren = void 0;\n        if (exists && isEmptyNode(child)) {\n            // remove\n            bitmap &= ~bit;\n            if (!bitmap) return empty;\n            if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n            newChildren = arraySpliceOut(canEdit, indx, children);\n        } else if (!exists && !isEmptyNode(child)) {\n            // add\n            if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n            bitmap |= bit;\n            newChildren = arraySpliceIn(canEdit, indx, child, children);\n        } else {\n            // modify\n            newChildren = arrayUpdate(canEdit, indx, child, children);\n        }\n        if (canEdit) {\n            this.mask = bitmap;\n            this.children = newChildren;\n            return this;\n        }\n        return IndexedNode(edit, bitmap, newChildren);\n    };\n    var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n        var count = this.size;\n        var children = this.children;\n        var frag = hashFragment(shift, h);\n        var child = children[frag];\n        var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n        if (child === newChild) return this;\n        var canEdit = canEditNode(edit, this);\n        var newChildren = void 0;\n        if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n            // add\n            ++count;\n            newChildren = arrayUpdate(canEdit, frag, newChild, children);\n        } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n            // remove\n            --count;\n            if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n            newChildren = arrayUpdate(canEdit, frag, empty, children);\n        } else {\n            // modify\n            newChildren = arrayUpdate(canEdit, frag, newChild, children);\n        }\n        if (canEdit) {\n            this.size = count;\n            this.children = newChildren;\n            return this;\n        }\n        return ArrayNode(edit, count, newChildren);\n    };\n    empty._modify = function(edit, keyEq, shift, f, h, k, size) {\n        var v = f();\n        if (v === nothing) return empty;\n        ++size.value;\n        return Leaf(edit, h, k, v);\n    };\n    /*\n ******************************************************************************/ function Map1(editable, edit, config, root, size) {\n        this._editable = editable;\n        this._edit = edit;\n        this._config = config;\n        this._root = root;\n        this._size = size;\n    }\n    Map1.prototype.setTree = function(newRoot, newSize) {\n        if (this._editable) {\n            this._root = newRoot;\n            this._size = newSize;\n            return this;\n        }\n        return newRoot === this._root ? this : new Map1(this._editable, this._edit, this._config, newRoot, newSize);\n    };\n    /* Queries\n ******************************************************************************/ /**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/ var tryGetHash = hamt.tryGetHash = function(alt, hash, key, map) {\n        var node = map._root;\n        var shift = 0;\n        var keyEq = map._config.keyEq;\n        while(true){\n            switch(node.type){\n                case LEAF:\n                    {\n                        return keyEq(key, node.key) ? node.value : alt;\n                    }\n                case COLLISION:\n                    {\n                        if (hash === node.hash) {\n                            var children = node.children;\n                            for(var i = 0, len = children.length; i < len; ++i){\n                                var child = children[i];\n                                if (keyEq(key, child.key)) return child.value;\n                            }\n                        }\n                        return alt;\n                    }\n                case INDEX:\n                    {\n                        var frag = hashFragment(shift, hash);\n                        var bit = toBitmap(frag);\n                        if (node.mask & bit) {\n                            node = node.children[fromBitmap(node.mask, bit)];\n                            shift += SIZE;\n                            break;\n                        }\n                        return alt;\n                    }\n                case ARRAY:\n                    {\n                        node = node.children[hashFragment(shift, hash)];\n                        if (node) {\n                            shift += SIZE;\n                            break;\n                        }\n                        return alt;\n                    }\n                default:\n                    return alt;\n            }\n        }\n    };\n    Map1.prototype.tryGetHash = function(alt, hash, key) {\n        return tryGetHash(alt, hash, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/ var tryGet = hamt.tryGet = function(alt, key, map) {\n        return tryGetHash(alt, map._config.hash(key), key, map);\n    };\n    Map1.prototype.tryGet = function(alt, key) {\n        return tryGet(alt, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/ var getHash = hamt.getHash = function(hash, key, map) {\n        return tryGetHash(undefined, hash, key, map);\n    };\n    Map1.prototype.getHash = function(hash, key) {\n        return getHash(hash, key, this);\n    };\n    /**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/ var get = hamt.get = function(key, map) {\n        return tryGetHash(undefined, map._config.hash(key), key, map);\n    };\n    Map1.prototype.get = function(key, alt) {\n        return tryGet(alt, key, this);\n    };\n    /**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/ var hasHash = hamt.has = function(hash, key, map) {\n        return tryGetHash(nothing, hash, key, map) !== nothing;\n    };\n    Map1.prototype.hasHash = function(hash, key) {\n        return hasHash(hash, key, this);\n    };\n    /**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/ var has = hamt.has = function(key, map) {\n        return hasHash(map._config.hash(key), key, map);\n    };\n    Map1.prototype.has = function(key) {\n        return has(key, this);\n    };\n    var defKeyCompare = function defKeyCompare(x, y) {\n        return x === y;\n    };\n    /**\n    Create an empty map.\n\n    @param config Configuration.\n*/ hamt.make = function(config) {\n        return new Map1(0, 0, {\n            keyEq: config && config.keyEq || defKeyCompare,\n            hash: config && config.hash || hash\n        }, empty, 0);\n    };\n    /**\n    Empty map.\n*/ hamt.empty = hamt.make();\n    /**\n    Does `map` contain any elements?\n*/ var isEmpty = hamt.isEmpty = function(map) {\n        return map && !!isEmptyNode(map._root);\n    };\n    Map1.prototype.isEmpty = function() {\n        return isEmpty(this);\n    };\n    /* Updates\n ******************************************************************************/ /**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/ var modifyHash = hamt.modifyHash = function(f, hash, key, map) {\n        var size = {\n            value: map._size\n        };\n        var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n        return map.setTree(newRoot, size.value);\n    };\n    Map1.prototype.modifyHash = function(hash, key, f) {\n        return modifyHash(f, hash, key, this);\n    };\n    /**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/ var modify = hamt.modify = function(f, key, map) {\n        return modifyHash(f, map._config.hash(key), key, map);\n    };\n    Map1.prototype.modify = function(key, f) {\n        return modify(f, key, this);\n    };\n    /**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/ var setHash = hamt.setHash = function(hash, key, value, map) {\n        return modifyHash(constant(value), hash, key, map);\n    };\n    Map1.prototype.setHash = function(hash, key, value) {\n        return setHash(hash, key, value, this);\n    };\n    /**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/ var set = hamt.set = function(key, value, map) {\n        return setHash(map._config.hash(key), key, value, map);\n    };\n    Map1.prototype.set = function(key, value) {\n        return set(key, value, this);\n    };\n    /**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/ var del = constant(nothing);\n    var removeHash = hamt.removeHash = function(hash, key, map) {\n        return modifyHash(del, hash, key, map);\n    };\n    Map1.prototype.removeHash = Map1.prototype.deleteHash = function(hash, key) {\n        return removeHash(hash, key, this);\n    };\n    /**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/ var remove = hamt.remove = function(key, map) {\n        return removeHash(map._config.hash(key), key, map);\n    };\n    Map1.prototype.remove = Map1.prototype.delete = function(key) {\n        return remove(key, this);\n    };\n    /* Mutation\n ******************************************************************************/ /**\n    Mark `map` as mutable.\n */ var beginMutation = hamt.beginMutation = function(map) {\n        return new Map1(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n    };\n    Map1.prototype.beginMutation = function() {\n        return beginMutation(this);\n    };\n    /**\n    Mark `map` as immutable.\n */ var endMutation = hamt.endMutation = function(map) {\n        map._editable = map._editable && map._editable - 1;\n        return map;\n    };\n    Map1.prototype.endMutation = function() {\n        return endMutation(this);\n    };\n    /**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/ var mutate = hamt.mutate = function(f, map) {\n        var transient = beginMutation(map);\n        f(transient);\n        return endMutation(transient);\n    };\n    Map1.prototype.mutate = function(f) {\n        return mutate(f, this);\n    };\n    /* Traversal\n ******************************************************************************/ /**\n    Apply a continuation.\n*/ var appk = function appk(k) {\n        return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n    };\n    /**\n    Recursively visit all values stored in an array of nodes lazily.\n*/ var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n        while(i < len){\n            var child = children[i++];\n            if (child && !isEmptyNode(child)) return lazyVisit(child, f, [\n                len,\n                children,\n                i,\n                f,\n                k\n            ]);\n        }\n        return appk(k);\n    };\n    /**\n    Recursively visit all values stored in `node` lazily.\n*/ var lazyVisit = function lazyVisit(node, f, k) {\n        switch(node.type){\n            case LEAF:\n                return {\n                    value: f(node),\n                    rest: k\n                };\n            case COLLISION:\n            case ARRAY:\n            case INDEX:\n                var children = node.children;\n                return lazyVisitChildren(children.length, children, 0, f, k);\n            default:\n                return appk(k);\n        }\n    };\n    var DONE = {\n        done: true\n    };\n    /**\n    Javascript iterator over a map.\n*/ function MapIterator(v) {\n        this.v = v;\n    }\n    MapIterator.prototype.next = function() {\n        if (!this.v) return DONE;\n        var v0 = this.v;\n        this.v = appk(v0.rest);\n        return v0;\n    };\n    MapIterator.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n    /**\n    Lazily visit each value in map with function `f`.\n*/ var visit = function visit(map, f) {\n        return new MapIterator(lazyVisit(map._root, f));\n    };\n    /**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/ var buildPairs = function buildPairs(x) {\n        return [\n            x.key,\n            x.value\n        ];\n    };\n    var entries = hamt.entries = function(map) {\n        return visit(map, buildPairs);\n    };\n    Map1.prototype.entries = Map1.prototype[Symbol.iterator] = function() {\n        return entries(this);\n    };\n    /**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/ var buildKeys = function buildKeys(x) {\n        return x.key;\n    };\n    var keys = hamt.keys = function(map) {\n        return visit(map, buildKeys);\n    };\n    Map1.prototype.keys = function() {\n        return keys(this);\n    };\n    /**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/ var buildValues = function buildValues(x) {\n        return x.value;\n    };\n    var values = hamt.values = Map1.prototype.values = function(map) {\n        return visit(map, buildValues);\n    };\n    Map1.prototype.values = function() {\n        return values(this);\n    };\n    /* Fold\n ******************************************************************************/ /**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/ var fold = hamt.fold = function(f, z, m) {\n        var root = m._root;\n        if (root.type === LEAF) return f(z, root.value, root.key);\n        var toVisit = [\n            root.children\n        ];\n        var children = void 0;\n        while(children = toVisit.pop()){\n            for(var i = 0, len = children.length; i < len;){\n                var child = children[i++];\n                if (child && child.type) {\n                    if (child.type === LEAF) z = f(z, child.value, child.key);\n                    else toVisit.push(child.children);\n                }\n            }\n        }\n        return z;\n    };\n    Map1.prototype.fold = function(f, z) {\n        return fold(f, z, this);\n    };\n    /**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/ var forEach = hamt.forEach = function(f, map) {\n        return fold(function(_, value, key) {\n            return f(value, key, map);\n        }, null, map);\n    };\n    Map1.prototype.forEach = function(f) {\n        return forEach(f, this);\n    };\n    /* Aggregate\n ******************************************************************************/ /**\n    Get the number of entries in `map`.\n*/ var count = hamt.count = function(map) {\n        return map._size;\n    };\n    Map1.prototype.count = function() {\n        return count(this);\n    };\n    Object.defineProperty(Map1.prototype, \"size\", {\n        get: Map1.prototype.count\n    });\n    /* Export\n ******************************************************************************/ if (module.exports) {\n        module.exports = hamt;\n    } else {\n        undefined.hamt = hamt;\n    }\n});\nclass BuiltInMap {\n    constructor(existing){\n        _defineProperty(this, \"_map\", void 0);\n        this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n    }\n    keys() {\n        return this._map.keys();\n    }\n    entries() {\n        return this._map.entries();\n    }\n    get(k) {\n        return this._map.get(k);\n    }\n    has(k) {\n        return this._map.has(k);\n    }\n    set(k, v) {\n        this._map.set(k, v);\n        return this;\n    }\n    delete(k) {\n        this._map.delete(k);\n        return this;\n    }\n    clone() {\n        return persistentMap(this);\n    }\n    toMap() {\n        return new Map(this._map);\n    }\n}\nclass HashArrayMappedTrieMap {\n    // Because hamt.empty is not a function there is no way to introduce type\n    // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n    // $FlowIssue\n    constructor(existing){\n        _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n        if (existing instanceof HashArrayMappedTrieMap) {\n            const h = existing._hamt.endMutation();\n            existing._hamt = h.beginMutation();\n            this._hamt = h.beginMutation();\n        } else if (existing) {\n            for (const [k, v] of existing.entries()){\n                this._hamt.set(k, v);\n            }\n        }\n    }\n    keys() {\n        return this._hamt.keys();\n    }\n    entries() {\n        return this._hamt.entries();\n    }\n    get(k) {\n        return this._hamt.get(k);\n    }\n    has(k) {\n        return this._hamt.has(k);\n    }\n    set(k, v) {\n        this._hamt.set(k, v);\n        return this;\n    }\n    delete(k) {\n        this._hamt.delete(k);\n        return this;\n    }\n    clone() {\n        return persistentMap(this);\n    }\n    toMap() {\n        return new Map(this._hamt);\n    }\n}\nfunction persistentMap(existing) {\n    if (Recoil_gkx(\"recoil_hamt_2020\")) {\n        return new HashArrayMappedTrieMap(existing);\n    } else {\n        return new BuiltInMap(existing);\n    }\n}\nvar Recoil_PersistentMap = {\n    persistentMap\n};\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\nvar Recoil_PersistentMap$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    persistentMap: Recoil_PersistentMap_1\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */ function differenceSets(set, ...setsWithValuesToRemove) {\n    const ret = new Set();\n    FIRST: for (const value of set){\n        for (const otherSet of setsWithValuesToRemove){\n            if (otherSet.has(value)) {\n                continue FIRST;\n            }\n        }\n        ret.add(value);\n    }\n    return ret;\n}\nvar Recoil_differenceSets = differenceSets;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */ function mapMap(map, callback) {\n    const result = new Map();\n    map.forEach((value, key)=>{\n        result.set(key, callback(value, key));\n    });\n    return result;\n}\nvar Recoil_mapMap = mapMap;\nfunction makeGraph() {\n    return {\n        nodeDeps: new Map(),\n        nodeToNodeSubscriptions: new Map()\n    };\n}\nfunction cloneGraph(graph) {\n    return {\n        nodeDeps: Recoil_mapMap(graph.nodeDeps, (s)=>new Set(s)),\n        nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, (s)=>new Set(s))\n    };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\nfunction mergeDepsIntoGraph(key, newDeps, graph, // graph compared with olderGraph:\nolderGraph) {\n    const { nodeDeps , nodeToNodeSubscriptions  } = graph;\n    const oldDeps = nodeDeps.get(key);\n    if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n        return;\n    } // Update nodeDeps:\n    nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n    const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n    for (const dep of addedDeps){\n        if (!nodeToNodeSubscriptions.has(dep)) {\n            nodeToNodeSubscriptions.set(dep, new Set());\n        }\n        const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n        existing.add(key);\n    } // Remove removed deps from nodeToNodeSubscriptions:\n    if (oldDeps) {\n        const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n        for (const dep of removedDeps){\n            if (!nodeToNodeSubscriptions.has(dep)) {\n                return;\n            }\n            const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n            existing.delete(key);\n            if (existing.size === 0) {\n                nodeToNodeSubscriptions.delete(dep);\n            }\n        }\n    }\n}\nfunction saveDepsToStore(key, deps, store, version) {\n    var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n    const storeState = store.getState();\n    if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n        Recoil_recoverableViolation(\"Tried to save dependencies to a discarded tree\");\n    } // Merge the dependencies discovered into the store's dependency map\n    // for the version that was read:\n    const graph = store.getGraph(version);\n    mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n    // into later versions if they don't already have their own:\n    if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n        const currentGraph = store.getGraph(storeState.currentTree.version);\n        mergeDepsIntoGraph(key, deps, currentGraph, graph);\n    }\n    if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n        var _storeState$nextTree2;\n        const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n        if (nextVersion !== undefined) {\n            const nextGraph = store.getGraph(nextVersion);\n            mergeDepsIntoGraph(key, deps, nextGraph, graph);\n        }\n    }\n}\nvar Recoil_Graph = {\n    cloneGraph,\n    graph: makeGraph,\n    saveDepsToStore\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ let nextTreeStateVersion = 0;\nconst getNextTreeStateVersion = ()=>nextTreeStateVersion++;\nlet nextStoreID = 0;\nconst getNextStoreID = ()=>nextStoreID++;\nlet nextComponentID = 0;\nconst getNextComponentID = ()=>nextComponentID++;\nvar Recoil_Keys = {\n    getNextTreeStateVersion,\n    getNextStoreID,\n    getNextComponentID\n};\nconst { persistentMap: persistentMap$1  } = Recoil_PersistentMap$1;\nconst { graph  } = Recoil_Graph;\nconst { getNextTreeStateVersion: getNextTreeStateVersion$1  } = Recoil_Keys;\nfunction makeEmptyTreeState() {\n    const version = getNextTreeStateVersion$1();\n    return {\n        version,\n        stateID: version,\n        transactionMetadata: {},\n        dirtyAtoms: new Set(),\n        atomValues: persistentMap$1(),\n        nonvalidatedAtoms: persistentMap$1()\n    };\n}\nfunction makeEmptyStoreState() {\n    const currentTree = makeEmptyTreeState();\n    return {\n        currentTree,\n        nextTree: null,\n        previousTree: null,\n        commitDepth: 0,\n        knownAtoms: new Set(),\n        knownSelectors: new Set(),\n        transactionSubscriptions: new Map(),\n        nodeTransactionSubscriptions: new Map(),\n        nodeToComponentSubscriptions: new Map(),\n        queuedComponentCallbacks_DEPRECATED: [],\n        suspendedComponentResolvers: new Set(),\n        graphsByVersion: new Map().set(currentTree.version, graph()),\n        retention: {\n            referenceCounts: new Map(),\n            nodesRetainedByZone: new Map(),\n            retainablesToCheckForRelease: new Set()\n        },\n        nodeCleanupFunctions: new Map()\n    };\n}\nvar Recoil_State = {\n    makeEmptyTreeState,\n    makeEmptyStoreState,\n    getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class RetentionZone {\n}\nfunction retentionZone() {\n    return new RetentionZone();\n}\nvar Recoil_RetentionZone = {\n    RetentionZone,\n    retentionZone\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */ function setByAddingToSet(set, v) {\n    const next = new Set(set);\n    next.add(v);\n    return next;\n}\nfunction setByDeletingFromSet(set, v) {\n    const next = new Set(set);\n    next.delete(v);\n    return next;\n}\nfunction mapBySettingInMap(map, k, v) {\n    const next = new Map(map);\n    next.set(k, v);\n    return next;\n}\nfunction mapByUpdatingInMap(map, k, updater) {\n    const next = new Map(map);\n    next.set(k, updater(next.get(k)));\n    return next;\n}\nfunction mapByDeletingFromMap(map, k) {\n    const next = new Map(map);\n    next.delete(k);\n    return next;\n}\nfunction mapByDeletingMultipleFromMap(map, ks) {\n    const next = new Map(map);\n    ks.forEach((k)=>next.delete(k));\n    return next;\n}\nvar Recoil_CopyOnWrite = {\n    setByAddingToSet,\n    setByDeletingFromSet,\n    mapBySettingInMap,\n    mapByUpdatingInMap,\n    mapByDeletingFromMap,\n    mapByDeletingMultipleFromMap\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */ function* filterIterable(iterable, predicate) {\n    // Use generator to create iterable/iterator\n    let index = 0;\n    for (const value of iterable){\n        if (predicate(value, index++)) {\n            yield value;\n        }\n    }\n}\nvar Recoil_filterIterable = filterIterable;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */ // $FlowIssue[unclear-type]\nfunction lazyProxy(base, factories) {\n    const proxy = new Proxy(base, {\n        // Compute and cache lazy property if not already done.\n        get: (target, prop)=>{\n            if (!(prop in target) && prop in factories) {\n                target[prop] = factories[prop]();\n            }\n            return target[prop];\n        },\n        // This method allows user to iterate keys as normal\n        ownKeys: (target)=>{\n            return Object.keys(target);\n        }\n    }); // $FlowIssue[incompatible-return]\n    return proxy;\n}\nvar Recoil_lazyProxy = lazyProxy;\nconst { getNode: getNode$1 , getNodeMaybe: getNodeMaybe$1 , recoilValuesForKeys: recoilValuesForKeys$1  } = Recoil_Node;\nconst { RetentionZone: RetentionZone$1  } = Recoil_RetentionZone;\nconst { setByAddingToSet: setByAddingToSet$1  } = Recoil_CopyOnWrite;\n// flowlint-next-line unclear-type:off\nconst emptySet = Object.freeze(new Set());\nclass ReadOnlyRecoilValueError extends Error {\n}\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return ()=>undefined;\n    }\n    const { nodesRetainedByZone  } = store.getState().retention;\n    function addToZone(zone) {\n        let set = nodesRetainedByZone.get(zone);\n        if (!set) {\n            nodesRetainedByZone.set(zone, set = new Set());\n        }\n        set.add(nodeKey);\n    }\n    if (retainedBy instanceof RetentionZone$1) {\n        addToZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n        for (const zone of retainedBy){\n            addToZone(zone);\n        }\n    }\n    return ()=>{\n        if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            return;\n        }\n        const { retention  } = store.getState();\n        function deleteFromZone(zone) {\n            const set = retention.nodesRetainedByZone.get(zone);\n            set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n            if (set && set.size === 0) {\n                retention.nodesRetainedByZone.delete(zone);\n            }\n        }\n        if (retainedBy instanceof RetentionZone$1) {\n            deleteFromZone(retainedBy);\n        } else if (Array.isArray(retainedBy)) {\n            for (const zone of retainedBy){\n                deleteFromZone(zone);\n            }\n        }\n    };\n}\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n    const storeState = store.getState();\n    if (storeState.nodeCleanupFunctions.has(key)) {\n        return;\n    }\n    const node = getNode$1(key);\n    const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n    const nodeCleanup = node.init(store, treeState, trigger);\n    storeState.nodeCleanupFunctions.set(key, ()=>{\n        nodeCleanup();\n        retentionCleanup();\n    });\n}\nfunction initializeNode(store, key, trigger) {\n    initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\nfunction cleanUpNode(store, key) {\n    var _state$nodeCleanupFun;\n    const state = store.getState();\n    (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n    state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\nfunction getNodeLoadable(store, state, key) {\n    initializeNodeIfNewToStore(store, state, key, \"get\");\n    return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\nfunction peekNodeLoadable(store, state, key) {\n    return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n    var _node$invalidate;\n    const node = getNodeMaybe$1(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    return {\n        ...state,\n        atomValues: state.atomValues.clone().delete(key),\n        nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n        dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n    };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\nfunction setNodeValue(store, state, key, newValue) {\n    const node = getNode$1(key);\n    if (node.set == null) {\n        throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n    }\n    const set = node.set; // so flow doesn't lose the above refinement.\n    initializeNodeIfNewToStore(store, state, key, \"set\");\n    return set(store, state, newValue);\n}\nfunction peekNodeInfo(store, state, key) {\n    const storeState = store.getState();\n    const graph = store.getGraph(state.version);\n    const type = getNode$1(key).nodeType;\n    return Recoil_lazyProxy({\n        type\n    }, {\n        loadable: ()=>peekNodeLoadable(store, state, key),\n        isActive: ()=>storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n        isSet: ()=>type === \"selector\" ? false : state.atomValues.has(key),\n        isModified: ()=>state.dirtyAtoms.has(key),\n        // Report current dependencies.  If the node hasn't been evaluated, then\n        // dependencies may be missing based on the current state.\n        deps: ()=>{\n            var _graph$nodeDeps$get;\n            return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n        },\n        // Reports all \"current\" subscribers.  Evaluating other nodes or\n        // previous in-progress async evaluations may introduce new subscribers.\n        subscribers: ()=>{\n            var _storeState$nodeToCom, _storeState$nodeToCom2;\n            return {\n                nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([\n                    key\n                ])), (nodeKey)=>nodeKey !== key)),\n                components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name])=>({\n                        name\n                    }))\n            };\n        }\n    });\n} // Find all of the recursively dependent nodes\nfunction getDownstreamNodes(store, state, keys) {\n    const visitedNodes = new Set();\n    const visitingNodes = Array.from(keys);\n    const graph = store.getGraph(state.version);\n    for(let key = visitingNodes.pop(); key; key = visitingNodes.pop()){\n        var _graph$nodeToNodeSubs;\n        visitedNodes.add(key);\n        const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n        for (const downstreamNode of subscribedNodes){\n            if (!visitedNodes.has(downstreamNode)) {\n                visitingNodes.push(downstreamNode);\n            }\n        }\n    }\n    return visitedNodes;\n}\nvar Recoil_FunctionalCore = {\n    getNodeLoadable,\n    peekNodeLoadable,\n    setNodeValue,\n    initializeNode,\n    cleanUpNode,\n    setUnvalidatedAtomValue_DEPRECATED,\n    peekNodeInfo,\n    getDownstreamNodes\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ let _invalidateMemoizedSnapshot = null;\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n    _invalidateMemoizedSnapshot = invalidate;\n}\nfunction invalidateMemoizedSnapshot() {\n    var _invalidateMemoizedSn;\n    (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\nvar Recoil_SnapshotCache = {\n    setInvalidateMemoizedSnapshot,\n    invalidateMemoizedSnapshot\n};\nconst { getDownstreamNodes: getDownstreamNodes$1 , getNodeLoadable: getNodeLoadable$1 , setNodeValue: setNodeValue$1  } = Recoil_FunctionalCore;\nconst { getNextComponentID: getNextComponentID$1  } = Recoil_Keys;\nconst { getNode: getNode$2 , getNodeMaybe: getNodeMaybe$2  } = Recoil_Node;\nconst { DefaultValue: DefaultValue$1  } = Recoil_Node;\nconst { reactMode: reactMode$1  } = Recoil_ReactMode;\nconst { AbstractRecoilValue: AbstractRecoilValue$1 , RecoilState: RecoilState$1 , RecoilValueReadOnly: RecoilValueReadOnly$1 , isRecoilValue: isRecoilValue$1  } = Recoil_RecoilValue$1;\nconst { invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1  } = Recoil_SnapshotCache;\nfunction getRecoilValueAsLoadable(store, { key  }, treeState = store.getState().currentTree) {\n    var _storeState$nextTree, _storeState$previousT;\n    // Reading from an older tree can cause bugs because the dependencies that we\n    // discover during the read are lost.\n    const storeState = store.getState();\n    if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n        Recoil_recoverableViolation(\"Tried to read from a discarded tree\");\n    }\n    const loadable = getNodeLoadable$1(store, treeState, key);\n    if (loadable.state === \"loading\") {\n        loadable.contents.catch(()=>{\n            /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */ return;\n        });\n    }\n    return loadable;\n}\nfunction applyAtomValueWrites(atomValues, writes) {\n    const result = atomValues.clone();\n    writes.forEach((v, k)=>{\n        if (v.state === \"hasValue\" && v.contents instanceof DefaultValue$1) {\n            result.delete(k);\n        } else {\n            result.set(k, v);\n        }\n    });\n    return result;\n}\nfunction valueFromValueOrUpdater(store, state, { key  }, valueOrUpdater) {\n    if (typeof valueOrUpdater === \"function\") {\n        // Updater form: pass in the current value. Throw if the current value\n        // is unavailable (namely when updating an async selector that's\n        // pending or errored):\n        const current = getNodeLoadable$1(store, state, key);\n        if (current.state === \"loading\") {\n            const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n            Recoil_recoverableViolation(msg);\n            throw Recoil_err(msg);\n        } else if (current.state === \"hasError\") {\n            throw current.contents;\n        } // T itself may be a function, so our refinement is not sufficient:\n        return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n    } else {\n        return valueOrUpdater;\n    }\n}\nfunction applyAction(store, state, action) {\n    if (action.type === \"set\") {\n        const { recoilValue , valueOrUpdater  } = action;\n        const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n        const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n        for (const [key, loadable] of writes.entries()){\n            writeLoadableToTreeState(state, key, loadable);\n        }\n    } else if (action.type === \"setLoadable\") {\n        const { recoilValue: { key  } , loadable  } = action;\n        writeLoadableToTreeState(state, key, loadable);\n    } else if (action.type === \"markModified\") {\n        const { recoilValue: { key  }  } = action;\n        state.dirtyAtoms.add(key);\n    } else if (action.type === \"setUnvalidated\") {\n        var _node$invalidate;\n        // Write value directly to state bypassing the Node interface as the node\n        // definitions may not have been loaded yet when processing the initial snapshot.\n        const { recoilValue: { key  } , unvalidatedValue  } = action;\n        const node = getNodeMaybe$2(key);\n        node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n        state.atomValues.delete(key);\n        state.nonvalidatedAtoms.set(key, unvalidatedValue);\n        state.dirtyAtoms.add(key);\n    } else {\n        Recoil_recoverableViolation(`Unknown action ${action.type}`);\n    }\n}\nfunction writeLoadableToTreeState(state, key, loadable) {\n    if (loadable.state === \"hasValue\" && loadable.contents instanceof DefaultValue$1) {\n        state.atomValues.delete(key);\n    } else {\n        state.atomValues.set(key, loadable);\n    }\n    state.dirtyAtoms.add(key);\n    state.nonvalidatedAtoms.delete(key);\n}\nfunction applyActionsToStore(store, actions) {\n    store.replaceState((state)=>{\n        const newState = copyTreeState(state);\n        for (const action of actions){\n            applyAction(store, newState, action);\n        }\n        invalidateDownstreams(store, newState);\n        invalidateMemoizedSnapshot$1();\n        return newState;\n    });\n}\nfunction queueOrPerformStateUpdate(store, action) {\n    if (batchStack.length) {\n        const actionsByStore = batchStack[batchStack.length - 1];\n        let actions = actionsByStore.get(store);\n        if (!actions) {\n            actionsByStore.set(store, actions = []);\n        }\n        actions.push(action);\n    } else {\n        applyActionsToStore(store, [\n            action\n        ]);\n    }\n}\nconst batchStack = [];\nfunction batchStart() {\n    const actionsByStore = new Map();\n    batchStack.push(actionsByStore);\n    return ()=>{\n        for (const [store, actions] of actionsByStore){\n            applyActionsToStore(store, actions);\n        }\n        const popped = batchStack.pop();\n        if (popped !== actionsByStore) {\n            Recoil_recoverableViolation(\"Incorrect order of batch popping\");\n        }\n    };\n}\nfunction copyTreeState(state) {\n    return {\n        ...state,\n        atomValues: state.atomValues.clone(),\n        nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n        dirtyAtoms: new Set(state.dirtyAtoms)\n    };\n}\nfunction invalidateDownstreams(store, state) {\n    // Inform any nodes that were changed or downstream of changes so that they\n    // can clear out any caches as needed due to the update:\n    const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n    for (const key of downstreams){\n        var _getNodeMaybe, _getNodeMaybe$invalid;\n        (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n    }\n}\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n    queueOrPerformStateUpdate(store, {\n        type: \"set\",\n        recoilValue,\n        valueOrUpdater\n    });\n}\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n    if (loadable instanceof DefaultValue$1) {\n        return setRecoilValue(store, recoilValue, loadable);\n    }\n    queueOrPerformStateUpdate(store, {\n        type: \"setLoadable\",\n        recoilValue,\n        loadable: loadable\n    });\n}\nfunction markRecoilValueModified(store, recoilValue) {\n    queueOrPerformStateUpdate(store, {\n        type: \"markModified\",\n        recoilValue\n    });\n}\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n    queueOrPerformStateUpdate(store, {\n        type: \"setUnvalidated\",\n        recoilValue,\n        unvalidatedValue\n    });\n}\nfunction subscribeToRecoilValue(store, { key  }, callback, componentDebugName = null) {\n    const subID = getNextComponentID$1();\n    const storeState = store.getState();\n    if (!storeState.nodeToComponentSubscriptions.has(key)) {\n        storeState.nodeToComponentSubscriptions.set(key, new Map());\n    }\n    Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [\n        componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : \"<not captured>\",\n        callback\n    ]); // Handle the case that, during the same tick that we are subscribing, an atom\n    // has been updated by some effect handler. Otherwise we will miss the update.\n    const mode = reactMode$1();\n    if (mode.early && (mode.mode === \"LEGACY\" || mode.mode === \"MUTABLE_SOURCE\")) {\n        const nextTree = store.getState().nextTree;\n        if (nextTree && nextTree.dirtyAtoms.has(key)) {\n            callback(nextTree);\n        }\n    }\n    return {\n        release: ()=>{\n            const releaseStoreState = store.getState();\n            const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n            if (subs === undefined || !subs.has(subID)) {\n                Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n                return;\n            }\n            subs.delete(subID);\n            if (subs.size === 0) {\n                releaseStoreState.nodeToComponentSubscriptions.delete(key);\n            }\n        }\n    };\n}\nfunction refreshRecoilValue(store, recoilValue) {\n    var _node$clearCache;\n    const { currentTree  } = store.getState();\n    const node = getNode$2(recoilValue.key);\n    (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\nvar Recoil_RecoilValueInterface = {\n    RecoilValueReadOnly: RecoilValueReadOnly$1,\n    AbstractRecoilValue: AbstractRecoilValue$1,\n    RecoilState: RecoilState$1,\n    getRecoilValueAsLoadable,\n    setRecoilValue,\n    setRecoilValueLoadable,\n    markRecoilValueModified,\n    setUnvalidatedRecoilValue,\n    subscribeToRecoilValue,\n    isRecoilValue: isRecoilValue$1,\n    applyAtomValueWrites,\n    // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n    batchStart,\n    writeLoadableToTreeState,\n    invalidateDownstreams,\n    copyTreeState,\n    refreshRecoilValue\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */ function someSet(set, callback, context) {\n    const iterator = set.entries();\n    let current = iterator.next();\n    while(!current.done){\n        const entry = current.value;\n        if (callback.call(context, entry[1], entry[0], set)) {\n            return true;\n        }\n        current = iterator.next();\n    }\n    return false;\n}\nvar Recoil_someSet = someSet;\nconst { cleanUpNode: cleanUpNode$1  } = Recoil_FunctionalCore;\nconst { deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1 , getNode: getNode$3  } = Recoil_Node;\nconst { RetentionZone: RetentionZone$2  } = Recoil_RetentionZone;\n// Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree;\n    if (storeState.nextTree) {\n        Recoil_recoverableViolation(\"releaseNodesNowOnCurrentTree should only be called at the end of a batch\");\n        return; // leak memory rather than erase something that's about to be used.\n    }\n    const nodes = new Set();\n    for (const r of retainables){\n        if (r instanceof RetentionZone$2) {\n            for (const n of nodesRetainedByZone(storeState, r)){\n                nodes.add(n);\n            }\n        } else {\n            nodes.add(r);\n        }\n    }\n    const releasableNodes = findReleasableNodes(store, nodes);\n    for (const node of releasableNodes){\n        releaseNode(store, treeState, node);\n    }\n}\nfunction findReleasableNodes(store, searchFromNodes) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree;\n    const graph = store.getGraph(treeState.version);\n    const releasableNodes = new Set(); // mutated to collect answer\n    const nonReleasableNodes = new Set();\n    findReleasableNodesInner(searchFromNodes);\n    return releasableNodes;\n    function findReleasableNodesInner(searchFromNodes) {\n        const releasableNodesFoundThisIteration = new Set();\n        const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, nonReleasableNodes // don't descend into these\n        ); // Find which of the downstream nodes are releasable and which are not:\n        for (const node of downstreams){\n            var _storeState$retention;\n            // Not releasable if configured to be retained forever:\n            if (getNode$3(node).retainedBy === \"recoilRoot\") {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if retained directly by a component:\n            if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if retained by a zone:\n            if (zonesThatCouldRetainNode(node).some((z)=>storeState.retention.referenceCounts.get(z))) {\n                nonReleasableNodes.add(node);\n                continue;\n            } // Not releasable if it has a non-releasable child (which will already be in\n            // nonReleasableNodes because we are going in topological order):\n            const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n            if (nodeChildren && Recoil_someSet(nodeChildren, (child)=>nonReleasableNodes.has(child))) {\n                nonReleasableNodes.add(node);\n                continue;\n            }\n            releasableNodes.add(node);\n            releasableNodesFoundThisIteration.add(node);\n        } // If we found any releasable nodes, we need to walk UP from those nodes to\n        // find whether their parents can now be released as well:\n        const parents = new Set();\n        for (const node of releasableNodesFoundThisIteration){\n            for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1){\n                var _graph$nodeDeps$get;\n                if (!releasableNodes.has(parent)) {\n                    parents.add(parent);\n                }\n            }\n        }\n        if (parents.size) {\n            findReleasableNodesInner(parents);\n        }\n    }\n} // Children before parents\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, doNotDescendInto1, doNotDescendInto2) {\n    const graph = store.getGraph(treeState.version);\n    const answer = [];\n    const visited = new Set();\n    while(nodes.size > 0){\n        visit(Recoil_nullthrows(nodes.values().next().value));\n    }\n    return answer;\n    function visit(node) {\n        if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n            nodes.delete(node);\n            return;\n        }\n        if (visited.has(node)) {\n            return;\n        }\n        const children = graph.nodeToNodeSubscriptions.get(node);\n        if (children) {\n            for (const child of children){\n                visit(child);\n            }\n        }\n        visited.add(node);\n        nodes.delete(node);\n        answer.push(node);\n    }\n}\nfunction releaseNode(store, treeState, node) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    } // Atom effects, in-closure caches, etc.:\n    cleanUpNode$1(store, node); // Delete from store state:\n    const storeState = store.getState();\n    storeState.knownAtoms.delete(node);\n    storeState.knownSelectors.delete(node);\n    storeState.nodeTransactionSubscriptions.delete(node);\n    storeState.retention.referenceCounts.delete(node);\n    const zones = zonesThatCouldRetainNode(node);\n    for (const zone of zones){\n        var _storeState$retention2;\n        (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n    } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n    // already happens when the last component that was retaining the node unmounts,\n    // and this could happen either before or after that.\n    // Delete from TreeState and dep graph:\n    treeState.atomValues.delete(node);\n    treeState.dirtyAtoms.delete(node);\n    treeState.nonvalidatedAtoms.delete(node);\n    const graph = storeState.graphsByVersion.get(treeState.version);\n    if (graph) {\n        const deps = graph.nodeDeps.get(node);\n        if (deps !== undefined) {\n            graph.nodeDeps.delete(node);\n            for (const dep of deps){\n                var _graph$nodeToNodeSubs;\n                (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n            }\n        } // No need to delete sub's deps as there should be no subs at this point.\n        // But an invariant would require deleting nodes in topological order.\n        graph.nodeToNodeSubscriptions.delete(node);\n    } // Node config (for family members only as their configs can be recreated, and\n    // only if they are not retained within any other Stores):\n    deleteNodeConfigIfPossible$1(node);\n}\nfunction nodesRetainedByZone(storeState, zone) {\n    var _storeState$retention3;\n    return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\nfunction zonesThatCouldRetainNode(node) {\n    const retainedBy = getNode$3(node).retainedBy;\n    if (retainedBy === undefined || retainedBy === \"components\" || retainedBy === \"recoilRoot\") {\n        return [];\n    } else if (retainedBy instanceof RetentionZone$2) {\n        return [\n            retainedBy\n        ];\n    } else {\n        return retainedBy; // it's an array of zones\n    }\n}\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n    const state = store.getState();\n    if (state.nextTree) {\n        state.retention.retainablesToCheckForRelease.add(retainable);\n    } else {\n        releaseRetainablesNowOnCurrentTree(store, new Set([\n            retainable\n        ]));\n    }\n}\nfunction updateRetainCount(store, retainable, delta) {\n    var _map$get;\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const map = store.getState().retention.referenceCounts;\n    const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n    if (newCount === 0) {\n        updateRetainCountToZero(store, retainable);\n    } else {\n        map.set(retainable, newCount);\n    }\n}\nfunction updateRetainCountToZero(store, retainable) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const map = store.getState().retention.referenceCounts;\n    map.delete(retainable);\n    scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\nfunction releaseScheduledRetainablesNow(store) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    }\n    const state = store.getState();\n    releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n    state.retention.retainablesToCheckForRelease.clear();\n}\nfunction retainedByOptionWithDefault(r) {\n    // The default will change from 'recoilRoot' to 'components' in the future.\n    return r === undefined ? \"recoilRoot\" : r;\n}\nvar Recoil_Retention = {\n    SUSPENSE_TIMEOUT_MS,\n    updateRetainCount,\n    updateRetainCountToZero,\n    releaseScheduledRetainablesNow,\n    retainedByOptionWithDefault\n};\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */ const { unstable_batchedUpdates  } = reactDom;\nvar ReactBatchedUpdates = {\n    unstable_batchedUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */ // @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\nconst { unstable_batchedUpdates: unstable_batchedUpdates$1  } = ReactBatchedUpdates; // @oss-only\nvar Recoil_ReactBatchedUpdates = {\n    unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ const { batchStart: batchStart$1  } = Recoil_RecoilValueInterface;\nconst { unstable_batchedUpdates: unstable_batchedUpdates$2  } = Recoil_ReactBatchedUpdates;\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */ const setBatcher = (newBatcher)=>{\n    batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */ const getBatcher = ()=>batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */ const batchUpdates = (callback)=>{\n    batcher(()=>{\n        let batchEnd = ()=>undefined;\n        try {\n            batchEnd = batchStart$1();\n            callback();\n        } finally{\n            batchEnd();\n        }\n    });\n};\nvar Recoil_Batching = {\n    getBatcher,\n    setBatcher,\n    batchUpdates\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */ function* concatIterables(iters) {\n    for (const iter of iters){\n        for (const val of iter){\n            yield val;\n        }\n    }\n}\nvar Recoil_concatIterables = concatIterables;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /* eslint-disable fb-www/typeof-undefined */ const isSSR = typeof Window === \"undefined\" || \"undefined\" === \"undefined\";\n/* eslint-enable fb-www/typeof-undefined */ const isWindow = (value)=>!isSSR && (value === window || value instanceof Window);\nconst isReactNative = typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"; // eslint-disable-line fb-www/typeof-undefined\nvar Recoil_Environment = {\n    isSSR,\n    isReactNative,\n    isWindow\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */ function memoizeWithArgsHash(fn, hashFunction) {\n    let cache;\n    const memoizedFn = (...args)=>{\n        if (!cache) {\n            cache = {};\n        }\n        const key = hashFunction(...args);\n        if (!Object.hasOwnProperty.call(cache, key)) {\n            cache[key] = fn(...args);\n        }\n        return cache[key];\n    };\n    return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */ function memoizeOneWithArgsHash(fn, hashFunction) {\n    let lastKey;\n    let lastResult; // breaking cache when arguments change\n    const memoizedFn = (...args)=>{\n        const key = hashFunction(...args);\n        if (lastKey === key) {\n            return lastResult;\n        }\n        lastKey = key;\n        lastResult = fn(...args);\n        return lastResult;\n    };\n    return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */ function memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n    let lastKey;\n    let lastResult; // breaking cache when arguments change\n    const memoizedFn = (...args)=>{\n        const key = hashFunction(...args);\n        if (lastKey === key) {\n            return lastResult;\n        }\n        lastKey = key;\n        lastResult = fn(...args);\n        return lastResult;\n    };\n    const invalidate = ()=>{\n        lastKey = null;\n    };\n    return [\n        memoizedFn,\n        invalidate\n    ];\n}\nvar Recoil_Memoize = {\n    memoizeWithArgsHash,\n    memoizeOneWithArgsHash,\n    memoizeOneWithArgsHashAndInvalidation\n};\nconst { batchUpdates: batchUpdates$1  } = Recoil_Batching;\nconst { initializeNode: initializeNode$1 , peekNodeInfo: peekNodeInfo$1  } = Recoil_FunctionalCore;\nconst { graph: graph$1  } = Recoil_Graph;\nconst { getNextStoreID: getNextStoreID$1  } = Recoil_Keys;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$1 , recoilValues: recoilValues$1 , recoilValuesForKeys: recoilValuesForKeys$2  } = Recoil_Node;\nconst { AbstractRecoilValue: AbstractRecoilValue$2 , getRecoilValueAsLoadable: getRecoilValueAsLoadable$1 , setRecoilValue: setRecoilValue$1 , setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1  } = Recoil_RecoilValueInterface;\nconst { updateRetainCount: updateRetainCount$1  } = Recoil_Retention;\nconst { setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1  } = Recoil_SnapshotCache;\nconst { getNextTreeStateVersion: getNextTreeStateVersion$2 , makeEmptyStoreState: makeEmptyStoreState$1  } = Recoil_State;\nconst { isSSR: isSSR$1  } = Recoil_Environment;\nconst { memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1  } = Recoil_Memoize;\n// Opaque at this surface because it's part of the public API from here.\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\nclass Snapshot {\n    // eslint-disable-next-line fb-www/no-uninitialized-properties\n    constructor(storeState, parentStoreID){\n        _defineProperty(this, \"_store\", void 0);\n        _defineProperty(this, \"_refCount\", 1);\n        _defineProperty(this, \"getLoadable\", (recoilValue)=>{\n            this.checkRefCount_INTERNAL();\n            return getRecoilValueAsLoadable$1(this._store, recoilValue);\n        });\n        _defineProperty(this, \"getPromise\", (recoilValue)=>{\n            this.checkRefCount_INTERNAL();\n            return this.getLoadable(recoilValue).toPromise();\n        });\n        _defineProperty(this, \"getNodes_UNSTABLE\", (opt)=>{\n            this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n            if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n                if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n                    return [];\n                }\n                const state = this._store.getState().currentTree;\n                return recoilValuesForKeys$2(state.dirtyAtoms);\n            }\n            const knownAtoms = this._store.getState().knownAtoms;\n            const knownSelectors = this._store.getState().knownSelectors;\n            return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([\n                knownAtoms,\n                knownSelectors\n            ])) : Recoil_filterIterable(recoilValues$1.values(), ({ key  })=>!knownAtoms.has(key) && !knownSelectors.has(key));\n        });\n        _defineProperty(this, \"getInfo_UNSTABLE\", ({ key  })=>{\n            this.checkRefCount_INTERNAL();\n            return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n        });\n        _defineProperty(this, \"map\", (mapper)=>{\n            this.checkRefCount_INTERNAL();\n            const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n            mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n            return mutableSnapshot;\n        });\n        _defineProperty(this, \"asyncMap\", async (mapper)=>{\n            this.checkRefCount_INTERNAL();\n            const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n            mutableSnapshot.retain(); // Retain new snapshot during async mapper\n            await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n            // after the next tick, the same as a new synchronous snapshot.\n            mutableSnapshot.autoRelease_INTERNAL();\n            return mutableSnapshot;\n        });\n        this._store = {\n            storeID: getNextStoreID$1(),\n            parentStoreID,\n            getState: ()=>storeState,\n            replaceState: (replacer)=>{\n                // no batching, so nextTree is never active\n                storeState.currentTree = replacer(storeState.currentTree);\n            },\n            getGraph: (version)=>{\n                const graphs = storeState.graphsByVersion;\n                if (graphs.has(version)) {\n                    return Recoil_nullthrows(graphs.get(version));\n                }\n                const newGraph = graph$1();\n                graphs.set(version, newGraph);\n                return newGraph;\n            },\n            subscribeToTransactions: ()=>({\n                    release: ()=>{}\n                }),\n            addTransactionMetadata: ()=>{\n                throw Recoil_err(\"Cannot subscribe to Snapshots\");\n            }\n        }; // Initialize any nodes that are live in the parent store (primarily so that\n        // this snapshot gets counted towards the node's live stores count).\n        // TODO Optimize this when cloning snapshots for callbacks\n        for (const nodeKey of this._store.getState().knownAtoms){\n            initializeNode$1(this._store, nodeKey, \"get\");\n            updateRetainCount$1(this._store, nodeKey, 1);\n        }\n        this.autoRelease_INTERNAL();\n    }\n    retain() {\n        if (this._refCount <= 0) {\n            if (true) {\n                throw Recoil_err(\"Snapshot has already been released.\");\n            } else {}\n        }\n        this._refCount++;\n        let released = false;\n        return ()=>{\n            if (!released) {\n                released = true;\n                this._release();\n            }\n        };\n    }\n    /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */ autoRelease_INTERNAL() {\n        if (!isSSR$1) {\n            // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n            window.setTimeout(()=>this._release(), 10);\n        }\n    }\n    _release() {\n        this._refCount--;\n        if (this._refCount === 0) {\n            this._store.getState().nodeCleanupFunctions.forEach((cleanup)=>cleanup());\n            this._store.getState().nodeCleanupFunctions.clear();\n            if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n                return;\n            } // Temporarily nerfing this to allow us to find broken call sites without\n        // actually breaking anybody yet.\n        // for (const k of this._store.getState().knownAtoms) {\n        //   updateRetainCountToZero(this._store, k);\n        // }\n        } else if (this._refCount < 0) {\n            if (true) {\n                Recoil_recoverableViolation(\"Snapshot released an extra time.\");\n            }\n        }\n    }\n    isRetained() {\n        return this._refCount > 0;\n    }\n    checkRefCount_INTERNAL() {\n        if (Recoil_gkx(\"recoil_memory_managament_2020\") && this._refCount <= 0) {\n            if (true) {\n                Recoil_recoverableViolation(retainWarning);\n            } // What we will ship later:\n        // throw err(retainWarning);\n        }\n    }\n    getStore_INTERNAL() {\n        this.checkRefCount_INTERNAL();\n        return this._store;\n    }\n    getID() {\n        this.checkRefCount_INTERNAL();\n        return this._store.getState().currentTree.stateID;\n    }\n    getStoreID() {\n        this.checkRefCount_INTERNAL();\n        return this._store.storeID;\n    }\n}\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n    const storeState = store.getState();\n    const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n    return {\n        // Always clone the TreeState to isolate stores from accidental mutations.\n        // For example, reading a selector from a cloned snapshot shouldn't cache\n        // in the original treestate which may cause the original to skip\n        // initialization of upstream atoms.\n        currentTree: {\n            // TODO snapshots shouldn't really have versions because a new version number\n            // is always assigned when the snapshot is gone to.\n            version: bumpVersion ? version : treeState.version,\n            stateID: bumpVersion ? version : treeState.stateID,\n            transactionMetadata: {\n                ...treeState.transactionMetadata\n            },\n            dirtyAtoms: new Set(treeState.dirtyAtoms),\n            atomValues: treeState.atomValues.clone(),\n            nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n        },\n        commitDepth: 0,\n        nextTree: null,\n        previousTree: null,\n        knownAtoms: new Set(storeState.knownAtoms),\n        // FIXME here's a copy\n        knownSelectors: new Set(storeState.knownSelectors),\n        // FIXME here's a copy\n        transactionSubscriptions: new Map(),\n        nodeTransactionSubscriptions: new Map(),\n        nodeToComponentSubscriptions: new Map(),\n        queuedComponentCallbacks_DEPRECATED: [],\n        suspendedComponentResolvers: new Set(),\n        graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n        retention: {\n            referenceCounts: new Map(),\n            nodesRetainedByZone: new Map(),\n            retainablesToCheckForRelease: new Set()\n        },\n        // FIXME here's a copy\n        // Create blank cleanup handlers for atoms so snapshots don't re-run\n        // atom effects.\n        nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key])=>[\n                key,\n                ()=>{}\n            ]))\n    };\n} // Factory to build a fresh snapshot\nfunction freshSnapshot(initializeState) {\n    const snapshot = new Snapshot(makeEmptyStoreState$1());\n    return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version)=>{\n    var _storeState$nextTree;\n    const storeState = store.getState();\n    const treeState = version === \"latest\" ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n    return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version)=>{\n    var _store$getState$nextT, _store$getState$previ;\n    return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\nfunction cloneSnapshot(store, version = \"latest\") {\n    const snapshot = memoizedCloneSnapshot(store, version);\n    if (!snapshot.isRetained()) {\n        invalidateMemoizedSnapshot$2();\n        return memoizedCloneSnapshot(store, version);\n    }\n    return snapshot;\n}\nclass MutableSnapshot extends Snapshot {\n    constructor(snapshot, batch){\n        super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n        _defineProperty(this, \"_batch\", void 0);\n        _defineProperty(this, \"set\", (recoilState, newValueOrUpdater)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n            // read the written value after calling `set`. I would like to remove this\n            // behavior and only batch in `Snapshot.map`, but this would be a breaking\n            // change potentially.\n            this._batch(()=>{\n                updateRetainCount$1(store, recoilState.key, 1);\n                setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n            });\n        });\n        _defineProperty(this, \"reset\", (recoilState)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n            this._batch(()=>{\n                updateRetainCount$1(store, recoilState.key, 1);\n                setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n            });\n        });\n        _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", (values)=>{\n            this.checkRefCount_INTERNAL();\n            const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n            batchUpdates$1(()=>{\n                for (const [k, v] of values.entries()){\n                    updateRetainCount$1(store, k, 1);\n                    setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n                }\n            });\n        });\n        this._batch = batch;\n    }\n}\nvar Recoil_Snapshot = {\n    Snapshot,\n    MutableSnapshot,\n    freshSnapshot,\n    cloneSnapshot\n};\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\nvar Recoil_Snapshot$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Snapshot: Recoil_Snapshot_1,\n    MutableSnapshot: Recoil_Snapshot_2,\n    freshSnapshot: Recoil_Snapshot_3,\n    cloneSnapshot: Recoil_Snapshot_4\n});\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function unionSets(...sets) {\n    const result = new Set();\n    for (const set of sets){\n        for (const value of set){\n            result.add(value);\n        }\n    }\n    return result;\n}\nvar Recoil_unionSets = unionSets;\nconst { useRef  } = react;\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */ function useRefInitOnce(initialValue) {\n    // $FlowExpectedError[incompatible-call]\n    const ref = useRef(initialValue);\n    if (ref.current === initialValue && typeof initialValue === \"function\") {\n        // $FlowExpectedError[incompatible-use]\n        ref.current = initialValue();\n    }\n    return ref;\n}\nvar Recoil_useRefInitOnce = useRefInitOnce;\n// @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\nconst { getNextTreeStateVersion: getNextTreeStateVersion$3 , makeEmptyStoreState: makeEmptyStoreState$2  } = Recoil_State;\nconst { cleanUpNode: cleanUpNode$2 , getDownstreamNodes: getDownstreamNodes$2 , initializeNode: initializeNode$2 , setNodeValue: setNodeValue$2 , setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1  } = Recoil_FunctionalCore;\nconst { graph: graph$2  } = Recoil_Graph;\nconst { cloneGraph: cloneGraph$1  } = Recoil_Graph;\nconst { getNextStoreID: getNextStoreID$2  } = Recoil_Keys;\nconst { createMutableSource: createMutableSource$1 , reactMode: reactMode$2  } = Recoil_ReactMode;\nconst { applyAtomValueWrites: applyAtomValueWrites$1  } = Recoil_RecoilValueInterface;\nconst { releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1  } = Recoil_Retention;\nconst { freshSnapshot: freshSnapshot$1  } = Recoil_Snapshot$1;\nconst { useCallback , useContext , useEffect , useMemo , useRef: useRef$1 , useState  } = react;\nfunction notInAContext() {\n    throw Recoil_err(\"This component must be used inside a <RecoilRoot> component.\");\n}\nconst defaultStore = Object.freeze({\n    storeID: getNextStoreID$2(),\n    getState: notInAContext,\n    replaceState: notInAContext,\n    getGraph: notInAContext,\n    subscribeToTransactions: notInAContext,\n    addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\nfunction startNextTreeIfNeeded(store) {\n    if (stateReplacerIsBeingExecuted) {\n        throw Recoil_err(\"An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.\");\n    }\n    const storeState = store.getState();\n    if (storeState.nextTree === null) {\n        if (Recoil_gkx(\"recoil_memory_managament_2020\") && Recoil_gkx(\"recoil_release_on_cascading_update_killswitch_2021\")) {\n            // If this is a cascading update (that is, rendering due to one state change\n            // invokes a second state change), we won't have cleaned up retainables yet\n            // because this normally happens after notifying components. Do it before\n            // proceeding with the cascading update so that it remains predictable:\n            if (storeState.commitDepth > 0) {\n                releaseScheduledRetainablesNow$1(store);\n            }\n        }\n        const version = storeState.currentTree.version;\n        const nextVersion = getNextTreeStateVersion$3();\n        storeState.nextTree = {\n            ...storeState.currentTree,\n            version: nextVersion,\n            stateID: nextVersion,\n            dirtyAtoms: new Set(),\n            transactionMetadata: {}\n        };\n        storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n    }\n}\nconst AppContext = react.createContext({\n    current: defaultStore\n});\nconst useStoreRef = ()=>useContext(AppContext); // $FlowExpectedError[incompatible-call]\nconst MutableSourceContext = react.createContext(null);\nfunction useRecoilMutableSource() {\n    const mutableSource = useContext(MutableSourceContext);\n    if (mutableSource == null) {\n        Recoil_expectationViolation(\"Attempted to use a Recoil hook outside of a <RecoilRoot>. \" + \"<RecoilRoot> must be an ancestor of any component that uses \" + \"Recoil hooks.\");\n    }\n    return mutableSource;\n}\nfunction notifyComponents(store, storeState, treeState) {\n    const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n    for (const key of dependentNodes){\n        const comps = storeState.nodeToComponentSubscriptions.get(key);\n        if (comps) {\n            for (const [_subID, [_debugName, callback]] of comps){\n                callback(treeState);\n            }\n        }\n    }\n}\nfunction sendEndOfBatchNotifications(store) {\n    const storeState = store.getState();\n    const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n    const dirtyAtoms = treeState.dirtyAtoms;\n    if (dirtyAtoms.size) {\n        // Execute Node-specific subscribers before global subscribers\n        for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions){\n            if (dirtyAtoms.has(key)) {\n                for (const [_, subscription] of subscriptions){\n                    subscription(store);\n                }\n            }\n        }\n        for (const [_, subscription] of storeState.transactionSubscriptions){\n            subscription(store);\n        }\n        if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n            // Notifying components is needed to wake from suspense, even when using\n            // early rendering.\n            notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n            // We need to wake up components not just when some asynchronous selector\n            // resolved, but also when changing synchronous values because this may cause\n            // a selector to change from asynchronous to synchronous, in which case there\n            // would be no follow-up asynchronous resolution to wake us up.\n            // TODO OPTIMIZATION Only wake up related downstream components\n            storeState.suspendedComponentResolvers.forEach((cb)=>cb());\n            storeState.suspendedComponentResolvers.clear();\n        }\n    } // Special behavior ONLY invoked by useInterface.\n    // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n    storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb)=>cb(treeState));\n    storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\nfunction endBatch(store) {\n    const storeState = store.getState();\n    storeState.commitDepth++;\n    try {\n        const { nextTree  } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n        // because something above RecoilRoot re-rendered:\n        if (nextTree == null) {\n            return;\n        } // nextTree is now committed -- note that copying and reset occurs when\n        // a transaction begins, in startNextTreeIfNeeded:\n        storeState.previousTree = storeState.currentTree;\n        storeState.currentTree = nextTree;\n        storeState.nextTree = null;\n        sendEndOfBatchNotifications(store);\n        if (storeState.previousTree != null) {\n            storeState.graphsByVersion.delete(storeState.previousTree.version);\n        } else {\n            Recoil_recoverableViolation(\"Ended batch with no previous state, which is unexpected\", \"recoil\");\n        }\n        storeState.previousTree = null;\n        if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            // Only release retainables if there were no writes during the end of the\n            // batch.  This avoids releasing something we might be about to use.\n            if (nextTree == null) {\n                releaseScheduledRetainablesNow$1(store);\n            }\n        }\n    } finally{\n        storeState.commitDepth--;\n    }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */ function Batcher({ setNotifyBatcherOfChange  }) {\n    const storeRef = useStoreRef();\n    const [, setState] = useState([]);\n    setNotifyBatcherOfChange(()=>setState({}));\n    useEffect(()=>{\n        setNotifyBatcherOfChange(()=>setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n        // notifyBatcherOfChange will still be called. An error gets thrown whenever\n        // setState is called after a component is already unmounted, so this sets\n        // notifyBatcherOfChange to be a no-op.\n        return ()=>{\n            setNotifyBatcherOfChange(()=>{});\n        };\n    }, [\n        setNotifyBatcherOfChange\n    ]);\n    useEffect(()=>{\n        // enqueueExecution runs this function immediately; it is only used to\n        // manipulate the order of useEffects during tests, since React seems to\n        // call useEffect in an unpredictable order sometimes.\n        Recoil_Queue.enqueueExecution(\"Batcher\", ()=>{\n            endBatch(storeRef.current);\n        });\n    });\n    return null;\n}\nif (true) {\n    if (false) {}\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n    const initial = makeEmptyStoreState$2();\n    initializeState({\n        set: (atom, value)=>{\n            const state = initial.currentTree;\n            const writes = setNodeValue$2(store, state, atom.key, value);\n            const writtenNodes = new Set(writes.keys());\n            const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n            for (const n of writtenNodes){\n                nonvalidatedAtoms.delete(n);\n            }\n            initial.currentTree = {\n                ...state,\n                dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n                atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n                // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n                nonvalidatedAtoms\n            };\n        },\n        setUnvalidatedAtomValues: (atomValues)=>{\n            // FIXME replace this with a mutative loop\n            atomValues.forEach((v, k)=>{\n                initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n            });\n        }\n    });\n    return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\nfunction initialStoreState(initializeState) {\n    // Initialize a snapshot and get its store\n    const snapshot = freshSnapshot$1(initializeState);\n    const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n    snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n    // they will re-initialize if used during rendering.  This allows atom effect\n    // initialization to take precedence over initializeState and be compatible\n    // with StrictMode semantics.\n    storeState.nodeCleanupFunctions.forEach((cleanup)=>cleanup());\n    storeState.nodeCleanupFunctions.clear();\n    return storeState;\n}\nlet nextID = 0;\nfunction RecoilRoot_INTERNAL({ initializeState_DEPRECATED , initializeState , store_INTERNAL: storeProp , // For use with React \"context bridging\"\nchildren  }) {\n    // prettier-ignore\n    // @fb-only: useEffect(() => {\n    // @fb-only: if (gkx('recoil_usage_logging')) {\n    // @fb-only: try {\n    // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n    // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n    // @fb-only: path: URI.getRequestURI().getPath(),\n    // @fb-only: }));\n    // @fb-only: } catch {\n    // @fb-only: recoverableViolation(\n    // @fb-only: 'Error when logging Recoil Usage event',\n    // @fb-only: 'recoil',\n    // @fb-only: );\n    // @fb-only: }\n    // @fb-only: }\n    // @fb-only: }, []);\n    let storeStateRef; // eslint-disable-line prefer-const\n    const getGraph = (version)=>{\n        const graphs = storeStateRef.current.graphsByVersion;\n        if (graphs.has(version)) {\n            return Recoil_nullthrows(graphs.get(version));\n        }\n        const newGraph = graph$2();\n        graphs.set(version, newGraph);\n        return newGraph;\n    };\n    const subscribeToTransactions = (callback, key)=>{\n        if (key == null) {\n            // Global transaction subscriptions\n            const { transactionSubscriptions  } = storeRef.current.getState();\n            const id = nextID++;\n            transactionSubscriptions.set(id, callback);\n            return {\n                release: ()=>{\n                    transactionSubscriptions.delete(id);\n                }\n            };\n        } else {\n            // Node-specific transaction subscriptions:\n            const { nodeTransactionSubscriptions  } = storeRef.current.getState();\n            if (!nodeTransactionSubscriptions.has(key)) {\n                nodeTransactionSubscriptions.set(key, new Map());\n            }\n            const id = nextID++;\n            Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n            return {\n                release: ()=>{\n                    const subs = nodeTransactionSubscriptions.get(key);\n                    if (subs) {\n                        subs.delete(id);\n                        if (subs.size === 0) {\n                            nodeTransactionSubscriptions.delete(key);\n                        }\n                    }\n                }\n            };\n        }\n    };\n    const addTransactionMetadata = (metadata)=>{\n        startNextTreeIfNeeded(storeRef.current);\n        for (const k of Object.keys(metadata)){\n            Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n        }\n    };\n    const replaceState = (replacer)=>{\n        startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n        const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n        let replaced;\n        try {\n            stateReplacerIsBeingExecuted = true;\n            replaced = replacer(nextTree);\n        } finally{\n            stateReplacerIsBeingExecuted = false;\n        }\n        if (replaced === nextTree) {\n            return;\n        }\n        if (true) {\n            if (false) {}\n        } // Save changes to nextTree and schedule a React update:\n        storeStateRef.current.nextTree = replaced;\n        if (reactMode$2().early) {\n            notifyComponents(storeRef.current, storeStateRef.current, replaced);\n        }\n        Recoil_nullthrows(notifyBatcherOfChange.current)();\n    };\n    const notifyBatcherOfChange = useRef$1(null);\n    const setNotifyBatcherOfChange = useCallback((x)=>{\n        notifyBatcherOfChange.current = x;\n    }, [\n        notifyBatcherOfChange\n    ]);\n    const storeRef = Recoil_useRefInitOnce(()=>storeProp !== null && storeProp !== void 0 ? storeProp : {\n            storeID: getNextStoreID$2(),\n            getState: ()=>storeStateRef.current,\n            replaceState,\n            getGraph,\n            subscribeToTransactions,\n            addTransactionMetadata\n        });\n    if (storeProp != null) {\n        storeRef.current = storeProp;\n    }\n    storeStateRef = Recoil_useRefInitOnce(()=>initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n    const mutableSource = useMemo(()=>createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, ()=>storeStateRef.current.currentTree.version), [\n        storeStateRef\n    ]); // Cleanup when the <RecoilRoot> is unmounted\n    useEffect(()=>{\n        // React is free to call effect cleanup handlers and effects at will, the\n        // deps array is only an optimization.  For example, React strict mode\n        // will execute each effect twice for testing.  Therefore, we need symmetry\n        // to re-initialize all known atoms after they were cleaned up.\n        const store = storeRef.current;\n        for (const atomKey of new Set(store.getState().knownAtoms)){\n            initializeNode$2(store, atomKey, \"get\");\n        }\n        return ()=>{\n            for (const atomKey of store.getState().knownAtoms){\n                cleanUpNode$2(store, atomKey);\n            }\n        };\n    }, [\n        storeRef\n    ]);\n    return /*#__PURE__*/ react.createElement(AppContext.Provider, {\n        value: storeRef\n    }, /*#__PURE__*/ react.createElement(MutableSourceContext.Provider, {\n        value: mutableSource\n    }, /*#__PURE__*/ react.createElement(Batcher, {\n        setNotifyBatcherOfChange: setNotifyBatcherOfChange\n    }), children));\n}\nfunction RecoilRoot(props) {\n    const { override , ...propsExceptOverride } = props;\n    const ancestorStoreRef = useStoreRef();\n    if (override === false && ancestorStoreRef.current !== defaultStore) {\n        // If ancestorStoreRef.current !== defaultStore, it means that this\n        // RecoilRoot is not nested within another.\n        return props.children;\n    }\n    return /*#__PURE__*/ react.createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\nfunction useRecoilStoreID() {\n    return useStoreRef().current.storeID;\n}\nvar Recoil_RecoilRoot = {\n    RecoilRoot,\n    useStoreRef,\n    useRecoilMutableSource,\n    useRecoilStoreID,\n    notifyComponents_FOR_TESTING: notifyComponents,\n    sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function shallowArrayEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0, l = a.length; i < l; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\nconst { useEffect: useEffect$1 , useRef: useRef$2  } = react;\nfunction usePrevious(value) {\n    const ref = useRef$2();\n    useEffect$1(()=>{\n        ref.current = value;\n    });\n    return ref.current;\n}\nvar Recoil_usePrevious = usePrevious;\nconst { useStoreRef: useStoreRef$1  } = Recoil_RecoilRoot;\nconst { SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1  } = Recoil_Retention;\nconst { updateRetainCount: updateRetainCount$2  } = Recoil_Retention;\nconst { RetentionZone: RetentionZone$3  } = Recoil_RetentionZone;\nconst { useEffect: useEffect$2 , useRef: useRef$3  } = react;\nconst { isSSR: isSSR$2  } = Recoil_Environment;\n// I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n// flowlint-line unclear-type:off\nfunction useRetain(toRetain) {\n    if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        return;\n    } // eslint-disable-next-line fb-www/react-hooks\n    return useRetain_ACTUAL(toRetain);\n}\nfunction useRetain_ACTUAL(toRetain) {\n    const array = Array.isArray(toRetain) ? toRetain : [\n        toRetain\n    ];\n    const retainables = array.map((a)=>a instanceof RetentionZone$3 ? a : a.key);\n    const storeRef = useStoreRef$1();\n    useEffect$2(()=>{\n        if (!Recoil_gkx(\"recoil_memory_managament_2020\")) {\n            return;\n        }\n        const store = storeRef.current;\n        if (timeoutID.current && !isSSR$2) {\n            // Already performed a temporary retain on render, simply cancel the release\n            // of that temporary retain.\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n        } else {\n            for (const r of retainables){\n                updateRetainCount$2(store, r, 1);\n            }\n        }\n        return ()=>{\n            for (const r of retainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }; // eslint-disable-next-line fb-www/react-hooks-deps\n    }, [\n        storeRef,\n        ...retainables\n    ]); // We want to retain if the component suspends. This is terrible but the Suspense\n    // API affords us no better option. If we suspend and never commit after some\n    // seconds, then release. The 'actual' retain/release in the effect above\n    // cancels this.\n    const timeoutID = useRef$3();\n    const previousRetainables = Recoil_usePrevious(retainables);\n    if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n        const store = storeRef.current;\n        for (const r of retainables){\n            updateRetainCount$2(store, r, 1);\n        }\n        if (previousRetainables) {\n            for (const r of previousRetainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }\n        if (timeoutID.current) {\n            window.clearTimeout(timeoutID.current);\n        }\n        timeoutID.current = window.setTimeout(()=>{\n            timeoutID.current = null;\n            for (const r of retainables){\n                updateRetainCount$2(store, r, -1);\n            }\n        }, SUSPENSE_TIMEOUT_MS$1);\n    }\n}\nvar Recoil_useRetain = useRetain;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */ // const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\nfunction useComponentName() {\n    // const nameRef = useRef();\n    // if (__DEV__) {\n    //   if (gkx('recoil_infer_component_names')) {\n    //     if (nameRef.current === undefined) {\n    //       // There is no blessed way to determine the calling React component from\n    //       // within a hook. This hack uses the fact that hooks must start with 'use'\n    //       // and that hooks are either called by React Components or other hooks. It\n    //       // follows therefore, that to find the calling component, you simply need\n    //       // to look down the stack and find the first function which doesn't start\n    //       // with 'use'. We are only enabling this in dev for now, since once the\n    //       // codebase is minified, the naming assumptions no longer hold true.\n    //       // eslint-disable-next-line fb-www/no-new-error\n    //       const frames = stackTraceParser(new Error().stack);\n    //       for (const {methodName} of frames) {\n    //         // I observed cases where the frame was of the form 'Object.useXXX'\n    //         // hence why I'm searching for hooks following a word boundary\n    //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n    //           return (nameRef.current = methodName);\n    //         }\n    //       }\n    //       nameRef.current = null;\n    //     }\n    //     return nameRef.current ?? '<unable to determine component name>';\n    //   }\n    // }\n    // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n    return \"<component name not available>\"; // @oss-only\n}\nvar Recoil_useComponentName = useComponentName;\nconst { batchUpdates: batchUpdates$2  } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$2  } = Recoil_Node;\nconst { currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1 , reactMode: reactMode$3 , useMutableSource: useMutableSource$1 , useSyncExternalStore: useSyncExternalStore$1  } = Recoil_ReactMode;\nconst { useRecoilMutableSource: useRecoilMutableSource$1 , useStoreRef: useStoreRef$2  } = Recoil_RecoilRoot;\nconst { isRecoilValue: isRecoilValue$2  } = Recoil_RecoilValue$1;\nconst { AbstractRecoilValue: AbstractRecoilValue$3 , getRecoilValueAsLoadable: getRecoilValueAsLoadable$2 , setRecoilValue: setRecoilValue$2 , setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2 , subscribeToRecoilValue: subscribeToRecoilValue$1  } = Recoil_RecoilValueInterface;\nconst { useCallback: useCallback$1 , useEffect: useEffect$3 , useMemo: useMemo$1 , useRef: useRef$4 , useState: useState$1  } = react;\nconst { setByAddingToSet: setByAddingToSet$2  } = Recoil_CopyOnWrite;\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n    // We can't just throw the promise we are waiting on to Suspense.  If the\n    // upstream dependencies change it may produce a state in which the component\n    // can render, but it would still be suspended on a Promise that may never resolve.\n    if (loadable.state === \"hasValue\") {\n        return loadable.contents;\n    } else if (loadable.state === \"loading\") {\n        const promise = new Promise((resolve)=>{\n            storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n        }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n        // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n        throw promise;\n    } else if (loadable.state === \"hasError\") {\n        throw loadable.contents;\n    } else {\n        throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n    }\n}\nfunction validateRecoilValue(recoilValue, hookName) {\n    if (!isRecoilValue$2(recoilValue)) {\n        throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n    }\n}\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */ function useRecoilInterface_DEPRECATED() {\n    const componentName = Recoil_useComponentName();\n    const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n    const [, forceUpdate] = useState$1([]);\n    const recoilValuesUsed = useRef$4(new Set());\n    recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n    const previousSubscriptions = useRef$4(new Set());\n    const subscriptions = useRef$4(new Map());\n    const unsubscribeFrom = useCallback$1((key)=>{\n        const sub = subscriptions.current.get(key);\n        if (sub) {\n            sub.release();\n            subscriptions.current.delete(key);\n        }\n    }, [\n        subscriptions\n    ]);\n    const updateState = useCallback$1((_state, key)=>{\n        if (subscriptions.current.has(key)) {\n            forceUpdate([]);\n        }\n    }, []); // Effect to add/remove subscriptions as nodes are used\n    useEffect$3(()=>{\n        const store = storeRef.current;\n        Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach((key)=>{\n            if (subscriptions.current.has(key)) {\n                Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n                return;\n            }\n            const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), (state)=>updateState(state, key), componentName);\n            subscriptions.current.set(key, sub);\n            /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */ // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n            const state = store.getState();\n            if (state.nextTree) {\n                store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{\n                    updateState(store.getState(), key);\n                });\n            } else {\n                updateState(store.getState(), key);\n            }\n        });\n        Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach((key)=>{\n            unsubscribeFrom(key);\n        });\n        previousSubscriptions.current = recoilValuesUsed.current;\n    }); // Effect to unsubscribe from all when unmounting\n    useEffect$3(()=>{\n        const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n        Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach((key)=>{\n            const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), (state)=>updateState(state, key), componentName);\n            currentSubscriptions.set(key, sub);\n        });\n        return ()=>currentSubscriptions.forEach((_, key)=>unsubscribeFrom(key));\n    }, [\n        componentName,\n        storeRef,\n        unsubscribeFrom,\n        updateState\n    ]);\n    return useMemo$1(()=>{\n        // eslint-disable-next-line no-shadow\n        function useSetRecoilState(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useSetRecoilState\");\n            }\n            return (newValueOrUpdater)=>{\n                setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n            };\n        } // eslint-disable-next-line no-shadow\n        function useResetRecoilState(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useResetRecoilState\");\n            }\n            return ()=>setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n        } // eslint-disable-next-line no-shadow\n        function useRecoilValueLoadable(recoilValue) {\n            var _storeState$nextTree;\n            if (true) {\n                validateRecoilValue(recoilValue, \"useRecoilValueLoadable\");\n            }\n            if (!recoilValuesUsed.current.has(recoilValue.key)) {\n                recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n            } // TODO Restore optimization to memoize lookup\n            const storeState = storeRef.current.getState();\n            return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n        } // eslint-disable-next-line no-shadow\n        function useRecoilValue(recoilValue) {\n            if (true) {\n                validateRecoilValue(recoilValue, \"useRecoilValue\");\n            }\n            const loadable = useRecoilValueLoadable(recoilValue);\n            return handleLoadable(loadable, recoilValue, storeRef);\n        } // eslint-disable-next-line no-shadow\n        function useRecoilState(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useRecoilState\");\n            }\n            return [\n                useRecoilValue(recoilState),\n                useSetRecoilState(recoilState)\n            ];\n        } // eslint-disable-next-line no-shadow\n        function useRecoilStateLoadable(recoilState) {\n            if (true) {\n                validateRecoilValue(recoilState, \"useRecoilStateLoadable\");\n            }\n            return [\n                useRecoilValueLoadable(recoilState),\n                useSetRecoilState(recoilState)\n            ];\n        }\n        return {\n            getRecoilValue: useRecoilValue,\n            getRecoilValueLoadable: useRecoilValueLoadable,\n            getRecoilState: useRecoilState,\n            getRecoilStateLoadable: useRecoilStateLoadable,\n            getSetRecoilState: useSetRecoilState,\n            getResetRecoilState: useResetRecoilState\n        };\n    }, [\n        recoilValuesUsed,\n        storeRef\n    ]);\n}\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n    current: 0\n};\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n    const storeRef = useStoreRef$2();\n    const componentName = Recoil_useComponentName();\n    const getSnapshot = useCallback$1(()=>{\n        var _storeState$nextTree2;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n        const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n        return {\n            loadable,\n            key: recoilValue.key\n        };\n    }, [\n        storeRef,\n        recoilValue\n    ]); // Memoize the state to avoid unnecessary rerenders\n    const memoizePreviousSnapshot = useCallback$1((getState)=>{\n        let prevState;\n        return ()=>{\n            var _prevState, _prevState2;\n            const nextState = getState();\n            if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n                return prevState;\n            }\n            prevState = nextState;\n            return nextState;\n        };\n    }, []);\n    const getMemoizedSnapshot = useMemo$1(()=>memoizePreviousSnapshot(getSnapshot), [\n        getSnapshot,\n        memoizePreviousSnapshot\n    ]);\n    const subscribe = useCallback$1((notify)=>{\n        const store = storeRef.current;\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n        return subscription.release;\n    }, [\n        storeRef,\n        recoilValue,\n        componentName\n    ]);\n    return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, getMemoizedSnapshot // getServerSnapshot() for SSR support\n    ).loadable;\n}\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n    const storeRef = useStoreRef$2();\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree3;\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const getLoadableWithTesting = useCallback$1(()=>{\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        return getLoadable();\n    }, [\n        getLoadable\n    ]);\n    const componentName = Recoil_useComponentName();\n    const subscribe = useCallback$1((_storeState, notify)=>{\n        const store = storeRef.current;\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, ()=>{\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return notify();\n            } // Only re-render if the value has changed.\n            // This will evaluate the atom/selector now as well as when the\n            // component renders, but that may help with prefetching.\n            const newLoadable = getLoadable();\n            if (!prevLoadableRef.current.is(newLoadable)) {\n                notify();\n            } // If the component is suspended then the effect setting prevLoadableRef\n            // will not run.  So, set the previous value here when its subscription\n            // is fired to wake it up.  We can't just rely on this, though, because\n            // this only executes when an atom/selector is dirty and the atom/selector\n            // passed to the hook can dynamically change.\n            prevLoadableRef.current = newLoadable;\n        }, componentName);\n        return subscription.release;\n    }, [\n        storeRef,\n        recoilValue,\n        componentName,\n        getLoadable\n    ]);\n    const source = useRecoilMutableSource$1();\n    if (source == null) {\n        throw Recoil_err(\"Recoil hooks must be used in components contained within a <RecoilRoot> component.\");\n    }\n    const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n    const prevLoadableRef = useRef$4(loadable);\n    useEffect$3(()=>{\n        prevLoadableRef.current = loadable;\n    });\n    return loadable;\n}\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n    const storeRef = useStoreRef$2();\n    const componentName = Recoil_useComponentName(); // Accessors to get the current state\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree4;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const getState = useCallback$1(()=>({\n            loadable: getLoadable(),\n            key: recoilValue.key\n        }), [\n        getLoadable,\n        recoilValue.key\n    ]); // Memoize state snapshots\n    const updateState = useCallback$1((prevState)=>{\n        const nextState = getState();\n        return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n    }, [\n        getState\n    ]); // Subscribe to Recoil state changes\n    useEffect$3(()=>{\n        const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, (_state)=>{\n            setState(updateState);\n        }, componentName); // Update state in case we are using a different key\n        setState(updateState);\n        return subscription.release;\n    }, [\n        componentName,\n        recoilValue,\n        storeRef,\n        updateState\n    ]); // Get the current state\n    const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n    // This is important in case the old key would cause the component to suspend.\n    // We don't have to set the new state here since the subscribing effect above\n    // will do that.\n    return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n    const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n    const [, forceUpdate] = useState$1([]);\n    const componentName = Recoil_useComponentName();\n    const getLoadable = useCallback$1(()=>{\n        var _storeState$nextTree5;\n        if (true) {\n            recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n        }\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n        return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    }, [\n        storeRef,\n        recoilValue\n    ]);\n    const loadable = getLoadable();\n    const prevLoadableRef = useRef$4(loadable);\n    useEffect$3(()=>{\n        prevLoadableRef.current = loadable;\n    });\n    useEffect$3(()=>{\n        const store = storeRef.current;\n        const storeState = store.getState();\n        const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state)=>{\n            var _prevLoadableRef$curr;\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return forceUpdate([]);\n            }\n            const newLoadable = getLoadable();\n            if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n                forceUpdate(newLoadable);\n            }\n            prevLoadableRef.current = newLoadable;\n        }, componentName);\n        /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */ if (storeState.nextTree) {\n            store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{\n                prevLoadableRef.current = null;\n                forceUpdate([]);\n            });\n        } else {\n            var _prevLoadableRef$curr2;\n            if (!Recoil_gkx(\"recoil_suppress_rerender_in_callback\")) {\n                return forceUpdate([]);\n            }\n            const newLoadable = getLoadable();\n            if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n                forceUpdate(newLoadable);\n            }\n            prevLoadableRef.current = newLoadable;\n        }\n        return subscription.release;\n    }, [\n        componentName,\n        getLoadable,\n        recoilValue,\n        storeRef\n    ]);\n    return loadable;\n}\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/ function useRecoilValueLoadable(recoilValue) {\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValueLoadable\");\n    }\n    if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        // eslint-disable-next-line fb-www/react-hooks\n        Recoil_useRetain(recoilValue);\n    }\n    return ({\n        TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n        // Recoil will attemp to detect if `useSyncExternalStore()` is supported with\n        // `reactMode()` before calling it.  However, sometimes the host React\n        // environment supports it but uses additional React renderers (such as with\n        // `react-three-fiber`) which do not.  While this is technically a user issue\n        // by using a renderer with React 18+ that doesn't fully support React 18 we\n        // don't want to break users if it can be avoided. As the current renderer can\n        // change at runtime, we need to dynamically check and fallback if necessary.\n        SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,\n        MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n        LEGACY: useRecoilValueLoadable_LEGACY\n    })[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */ function useRecoilValue(recoilValue) {\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValue\");\n    }\n    const storeRef = useStoreRef$2();\n    const loadable = useRecoilValueLoadable(recoilValue);\n    return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/ function useSetRecoilState(recoilState) {\n    if (true) {\n        validateRecoilValue(recoilState, \"useSetRecoilState\");\n    }\n    const storeRef = useStoreRef$2();\n    return useCallback$1((newValueOrUpdater)=>{\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n    }, [\n        storeRef,\n        recoilState\n    ]);\n}\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/ function useResetRecoilState(recoilState) {\n    if (true) {\n        validateRecoilValue(recoilState, \"useResetRecoilState\");\n    }\n    const storeRef = useStoreRef$2();\n    return useCallback$1(()=>{\n        setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    }, [\n        storeRef,\n        recoilState\n    ]);\n}\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/ function useRecoilState(recoilState) {\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilState\");\n    }\n    return [\n        useRecoilValue(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/ function useRecoilStateLoadable(recoilState) {\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilStateLoadable\");\n    }\n    return [\n        useRecoilValueLoadable(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\nfunction useSetUnvalidatedAtomValues() {\n    const storeRef = useStoreRef$2();\n    return (values, transactionMetadata = {})=>{\n        batchUpdates$2(()=>{\n            storeRef.current.addTransactionMetadata(transactionMetadata);\n            values.forEach((value, key)=>setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n        });\n    };\n}\n/**\n * Experimental variants of hooks with support for useTransition()\n */ function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\");\n        if (!reactMode$3().early) {\n            Recoil_recoverableViolation(\"Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.\");\n        }\n    }\n    if (Recoil_gkx(\"recoil_memory_managament_2020\")) {\n        // eslint-disable-next-line fb-www/react-hooks\n        Recoil_useRetain(recoilValue);\n    }\n    return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n    if (true) {\n        validateRecoilValue(recoilValue, \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\");\n    }\n    const storeRef = useStoreRef$2();\n    const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n    return handleLoadable(loadable, recoilValue, storeRef);\n}\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n    if (true) {\n        validateRecoilValue(recoilState, \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\");\n    }\n    return [\n        useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState),\n        useSetRecoilState(recoilState)\n    ];\n}\nvar Recoil_Hooks = {\n    recoilComponentGetRecoilValueCount_FOR_TESTING,\n    useRecoilInterface: useRecoilInterface_DEPRECATED,\n    useRecoilState,\n    useRecoilStateLoadable,\n    useRecoilValue,\n    useRecoilValueLoadable,\n    useResetRecoilState,\n    useSetRecoilState,\n    useSetUnvalidatedAtomValues,\n    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n    useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */ function filterMap(map, callback) {\n    const result = new Map();\n    for (const [key, value] of map){\n        if (callback(value, key)) {\n            result.set(key, value);\n        }\n    }\n    return result;\n}\nvar Recoil_filterMap = filterMap;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ /**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */ function filterSet(set, callback) {\n    const result = new Set();\n    for (const value of set){\n        if (callback(value)) {\n            result.add(value);\n        }\n    }\n    return result;\n}\nvar Recoil_filterSet = filterSet;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function mergeMaps(...maps) {\n    const result = new Map();\n    for(let i = 0; i < maps.length; i++){\n        const iterator = maps[i].keys();\n        let nextKey;\n        while(!(nextKey = iterator.next()).done){\n            // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n            result.set(nextKey.value, maps[i].get(nextKey.value));\n        }\n    }\n    return result;\n}\nvar Recoil_mergeMaps = mergeMaps;\nconst { batchUpdates: batchUpdates$3  } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$3 , getNode: getNode$4 , nodes: nodes$1  } = Recoil_Node;\nconst { useStoreRef: useStoreRef$3  } = Recoil_RecoilRoot;\nconst { AbstractRecoilValue: AbstractRecoilValue$4 , setRecoilValueLoadable: setRecoilValueLoadable$1  } = Recoil_RecoilValueInterface;\nconst { SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2  } = Recoil_Retention;\nconst { cloneSnapshot: cloneSnapshot$1  } = Recoil_Snapshot$1;\nconst { useCallback: useCallback$2 , useEffect: useEffect$4 , useRef: useRef$5 , useState: useState$2  } = react;\nconst { isSSR: isSSR$3  } = Recoil_Environment;\nfunction useTransactionSubscription(callback) {\n    const storeRef = useStoreRef$3();\n    useEffect$4(()=>{\n        const sub = storeRef.current.subscribeToTransactions(callback);\n        return sub.release;\n    }, [\n        callback,\n        storeRef\n    ]);\n}\nfunction externallyVisibleAtomValuesInState(state) {\n    const atomValues = state.atomValues.toMap();\n    const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k)=>{\n        const node = getNode$4(k);\n        const persistence = node.persistence_UNSTABLE;\n        return persistence != null && persistence.type !== \"none\" && v.state === \"hasValue\";\n    }), (v)=>v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n    // all have persistence on or they wouldn't be there in the first place.\n    return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/ function useTransactionObservation_DEPRECATED(callback) {\n    useTransactionSubscription(useCallback$2((store)=>{\n        let previousTree = store.getState().previousTree;\n        const currentTree = store.getState().currentTree;\n        if (!previousTree) {\n            Recoil_recoverableViolation(\"Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil\");\n            previousTree = store.getState().currentTree; // attempt to trundle on\n        }\n        const atomValues = externallyVisibleAtomValuesInState(currentTree);\n        const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n        const atomInfo = Recoil_mapMap(nodes$1, (node)=>{\n            var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n            return {\n                persistence_UNSTABLE: {\n                    type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : \"none\",\n                    backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n                }\n            };\n        }); // Filter on existance in atomValues so that externally-visible rules\n        // are also applied to modified atoms (specifically exclude selectors):\n        const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, (k)=>atomValues.has(k) || previousAtomValues.has(k));\n        callback({\n            atomValues,\n            previousAtomValues,\n            atomInfo,\n            modifiedAtoms,\n            transactionMetadata: {\n                ...currentTree.transactionMetadata\n            }\n        });\n    }, [\n        callback\n    ]));\n}\nfunction useRecoilTransactionObserver(callback) {\n    useTransactionSubscription(useCallback$2((store)=>{\n        const snapshot = cloneSnapshot$1(store, \"latest\");\n        const previousSnapshot = cloneSnapshot$1(store, \"previous\");\n        callback({\n            snapshot,\n            previousSnapshot\n        });\n    }, [\n        callback\n    ]));\n} // Return a snapshot of the current state and subscribe to all state changes\nfunction useRecoilSnapshot() {\n    const storeRef = useStoreRef$3();\n    const [snapshot, setSnapshot] = useState$2(()=>cloneSnapshot$1(storeRef.current));\n    const previousSnapshot = Recoil_usePrevious(snapshot);\n    const timeoutID = useRef$5();\n    const releaseRef = useRef$5();\n    useTransactionSubscription(useCallback$2((store)=>setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n    useEffect$4(()=>{\n        const release = snapshot.retain(); // Release the retain from the rendering call\n        if (timeoutID.current && !isSSR$3) {\n            var _releaseRef$current;\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n            (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n            releaseRef.current = null;\n        }\n        return ()=>{\n            // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n            // re-render with the same state.  The previous cleanup will then run and\n            // then the new effect will run. We don't want the snapshot to be released\n            // by that cleanup before the new effect has a chance to retain it again.\n            // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n            window.setTimeout(release, 10);\n        };\n    }, [\n        snapshot\n    ]); // Retain snapshot until above effect is run.\n    // Release after a threshold in case component is suspended.\n    if (previousSnapshot !== snapshot && !isSSR$3) {\n        // Release the previous snapshot\n        if (timeoutID.current) {\n            var _releaseRef$current2;\n            window.clearTimeout(timeoutID.current);\n            timeoutID.current = null;\n            (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n            releaseRef.current = null;\n        }\n        releaseRef.current = snapshot.retain();\n        timeoutID.current = window.setTimeout(()=>{\n            var _releaseRef$current3;\n            timeoutID.current = null;\n            (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n            releaseRef.current = null;\n        }, SUSPENSE_TIMEOUT_MS$2);\n    }\n    return snapshot;\n}\nfunction gotoSnapshot(store, snapshot) {\n    var _storeState$nextTree;\n    const storeState = store.getState();\n    const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n    const next = snapshot.getStore_INTERNAL().getState().currentTree;\n    batchUpdates$3(()=>{\n        const keysToUpdate = new Set();\n        for (const keys of [\n            prev.atomValues.keys(),\n            next.atomValues.keys()\n        ]){\n            for (const key of keys){\n                var _prev$atomValues$get, _next$atomValues$get;\n                if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n                    keysToUpdate.add(key);\n                }\n            }\n        }\n        keysToUpdate.forEach((key)=>{\n            setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n        });\n        store.replaceState((state)=>({\n                ...state,\n                stateID: snapshot.getID()\n            }));\n    });\n}\nfunction useGotoRecoilSnapshot() {\n    const storeRef = useStoreRef$3();\n    return useCallback$2((snapshot)=>gotoSnapshot(storeRef.current, snapshot), [\n        storeRef\n    ]);\n}\nvar Recoil_SnapshotHooks = {\n    useRecoilSnapshot,\n    gotoSnapshot,\n    useGotoRecoilSnapshot,\n    useRecoilTransactionObserver,\n    useTransactionObservation_DEPRECATED,\n    useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\nconst { peekNodeInfo: peekNodeInfo$2  } = Recoil_FunctionalCore;\nconst { useStoreRef: useStoreRef$4  } = Recoil_RecoilRoot;\nfunction useGetRecoilValueInfo() {\n    const storeRef = useStoreRef$4();\n    return ({ key  })=>peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\nconst { reactMode: reactMode$4  } = Recoil_ReactMode;\nconst { RecoilRoot: RecoilRoot$1 , useStoreRef: useStoreRef$5  } = Recoil_RecoilRoot;\nconst { useMemo: useMemo$2  } = react;\nfunction useRecoilBridgeAcrossReactRoots() {\n    // The test fails when using useMutableSource(), but only if act() is used\n    // for the nested root.  So, this may only be a testing environment issue.\n    if (reactMode$4().mode === \"MUTABLE_SOURCE\") {\n        // eslint-disable-next-line fb-www/no-console\n        console.warn(\"Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.\");\n    }\n    const store = useStoreRef$5().current;\n    return useMemo$2(()=>{\n        // eslint-disable-next-line no-shadow\n        function RecoilBridge({ children  }) {\n            return /*#__PURE__*/ react.createElement(RecoilRoot$1, {\n                store_INTERNAL: store\n            }, children);\n        }\n        return RecoilBridge;\n    }, [\n        store\n    ]);\n}\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\nconst { loadableWithValue: loadableWithValue$1  } = Recoil_Loadable$1;\nconst { initializeNode: initializeNode$3  } = Recoil_FunctionalCore;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$4 , getNode: getNode$5  } = Recoil_Node;\nconst { copyTreeState: copyTreeState$1 , getRecoilValueAsLoadable: getRecoilValueAsLoadable$3 , invalidateDownstreams: invalidateDownstreams$1 , writeLoadableToTreeState: writeLoadableToTreeState$1  } = Recoil_RecoilValueInterface;\nfunction isAtom(recoilValue) {\n    return getNode$5(recoilValue.key).nodeType === \"atom\";\n}\nclass TransactionInterfaceImpl {\n    constructor(store, treeState){\n        _defineProperty(this, \"_store\", void 0);\n        _defineProperty(this, \"_treeState\", void 0);\n        _defineProperty(this, \"_changes\", void 0);\n        _defineProperty(this, \"get\", (recoilValue)=>{\n            if (this._changes.has(recoilValue.key)) {\n                // $FlowIssue[incompatible-return]\n                return this._changes.get(recoilValue.key);\n            }\n            if (!isAtom(recoilValue)) {\n                throw Recoil_err(\"Reading selectors within atomicUpdate is not supported\");\n            }\n            const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n            if (loadable.state === \"hasValue\") {\n                return loadable.contents;\n            } else if (loadable.state === \"hasError\") {\n                throw loadable.contents;\n            } else {\n                throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n            }\n        });\n        _defineProperty(this, \"set\", (recoilState, valueOrUpdater)=>{\n            if (!isAtom(recoilState)) {\n                throw Recoil_err(\"Setting selectors within atomicUpdate is not supported\");\n            }\n            if (typeof valueOrUpdater === \"function\") {\n                const current = this.get(recoilState);\n                this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n            } else {\n                // Initialize atom and run effects if not initialized yet\n                initializeNode$3(this._store, recoilState.key, \"set\");\n                this._changes.set(recoilState.key, valueOrUpdater);\n            }\n        });\n        _defineProperty(this, \"reset\", (recoilState)=>{\n            this.set(recoilState, DEFAULT_VALUE$4);\n        });\n        this._store = store;\n        this._treeState = treeState;\n        this._changes = new Map();\n    }\n    // eslint-disable-next-line fb-www/extra-arrow-initializer\n    newTreeState_INTERNAL() {\n        if (this._changes.size === 0) {\n            return this._treeState;\n        }\n        const newState = copyTreeState$1(this._treeState);\n        for (const [k, v] of this._changes){\n            writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n        }\n        invalidateDownstreams$1(this._store, newState);\n        return newState;\n    }\n}\nfunction atomicUpdater(store) {\n    return (fn)=>{\n        store.replaceState((treeState)=>{\n            const changeset = new TransactionInterfaceImpl(store, treeState);\n            fn(changeset);\n            return changeset.newTreeState_INTERNAL();\n        });\n    };\n}\nvar Recoil_AtomicUpdates = {\n    atomicUpdater\n};\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    atomicUpdater: Recoil_AtomicUpdates_1\n});\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nvar invariant_1 = invariant;\n// @oss-only\nvar Recoil_invariant = invariant_1;\nconst { atomicUpdater: atomicUpdater$1  } = Recoil_AtomicUpdates$1;\nconst { batchUpdates: batchUpdates$4  } = Recoil_Batching;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$5  } = Recoil_Node;\nconst { useStoreRef: useStoreRef$6  } = Recoil_RecoilRoot;\nconst { refreshRecoilValue: refreshRecoilValue$1 , setRecoilValue: setRecoilValue$3  } = Recoil_RecoilValueInterface;\nconst { cloneSnapshot: cloneSnapshot$2  } = Recoil_Snapshot$1;\nconst { gotoSnapshot: gotoSnapshot$1  } = Recoil_SnapshotHooks;\nconst { useCallback: useCallback$3  } = react;\nclass Sentinel {\n}\nconst SENTINEL = new Sentinel();\nfunction recoilCallback(store, fn, args, extraInterface) {\n    let ret = SENTINEL;\n    let releaseSnapshot;\n    batchUpdates$4(()=>{\n        const errMsg = \"useRecoilCallback() expects a function that returns a function: \" + \"it accepts a function of the type (RecoilInterface) => (Args) => ReturnType \" + \"and returns a callback function (Args) => ReturnType, where RecoilInterface is \" + \"an object {snapshot, set, ...} and Args and ReturnType are the argument and return \" + \"types of the callback you want to create.  Please see the docs \" + \"at recoiljs.org for details.\";\n        if (typeof fn !== \"function\") {\n            throw Recoil_err(errMsg);\n        } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n        // Note that this means the snapshot may represent later state from when\n        // the callback was called if it first accesses the snapshot asynchronously.\n        const callbackInterface = Recoil_lazyProxy({\n            ...extraInterface !== null && extraInterface !== void 0 ? extraInterface : {},\n            // flowlint-line unclear-type:off\n            set: (node, newValue)=>setRecoilValue$3(store, node, newValue),\n            reset: (node)=>setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n            refresh: (node)=>refreshRecoilValue$1(store, node),\n            gotoSnapshot: (snapshot)=>gotoSnapshot$1(store, snapshot),\n            transact_UNSTABLE: (transaction)=>atomicUpdater$1(store)(transaction)\n        }, {\n            snapshot: ()=>{\n                const snapshot = cloneSnapshot$2(store);\n                releaseSnapshot = snapshot.retain();\n                return snapshot;\n            }\n        });\n        const callback = fn(callbackInterface);\n        if (typeof callback !== \"function\") {\n            throw Recoil_err(errMsg);\n        }\n        ret = callback(...args);\n    });\n    !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, \"batchUpdates should return immediately\") : 0 : void 0;\n    if (Recoil_isPromise(ret)) {\n        ret.finally(()=>{\n            var _releaseSnapshot;\n            (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n        });\n    } else {\n        var _releaseSnapshot2;\n        (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n    }\n    return ret;\n}\nfunction useRecoilCallback(fn, deps) {\n    const storeRef = useStoreRef$6();\n    return useCallback$3((...args)=>{\n        return recoilCallback(storeRef.current, fn, args);\n    }, deps != null ? [\n        ...deps,\n        storeRef\n    ] : undefined // eslint-disable-line fb-www/react-hooks-deps\n    );\n}\nvar Recoil_useRecoilCallback = {\n    recoilCallback,\n    useRecoilCallback\n};\nconst { useStoreRef: useStoreRef$7  } = Recoil_RecoilRoot;\nconst { refreshRecoilValue: refreshRecoilValue$2  } = Recoil_RecoilValueInterface;\nconst { useCallback: useCallback$4  } = react;\nfunction useRecoilRefresher(recoilValue) {\n    const storeRef = useStoreRef$7();\n    return useCallback$4(()=>{\n        const store = storeRef.current;\n        refreshRecoilValue$2(store, recoilValue);\n    }, [\n        recoilValue,\n        storeRef\n    ]);\n}\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\nconst { atomicUpdater: atomicUpdater$2  } = Recoil_AtomicUpdates$1;\nconst { useStoreRef: useStoreRef$8  } = Recoil_RecoilRoot;\nconst { useMemo: useMemo$3  } = react;\nfunction useRecoilTransaction(fn, deps) {\n    const storeRef = useStoreRef$8();\n    return useMemo$3(()=>(...args)=>{\n            const atomicUpdate = atomicUpdater$2(storeRef.current);\n            atomicUpdate((transactionInterface)=>{\n                fn(transactionInterface)(...args);\n            });\n        }, deps != null ? [\n        ...deps,\n        storeRef\n    ] : undefined // eslint-disable-line fb-www/react-hooks-deps\n    );\n}\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class WrappedValue {\n    constructor(value){\n        _defineProperty(this, \"value\", void 0);\n        this.value = value;\n    }\n}\nvar Recoil_Wrapper = {\n    WrappedValue\n};\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\nvar Recoil_Wrapper$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    WrappedValue: Recoil_Wrapper_1\n});\nconst { isFastRefreshEnabled: isFastRefreshEnabled$2  } = Recoil_ReactMode;\nclass ChangedPathError extends Error {\n}\nclass TreeCache {\n    // $FlowIssue[unclear-type]\n    constructor(options){\n        var _options$onHit, _options$onSet, _options$mapNodeValue;\n        _defineProperty(this, \"_name\", void 0);\n        _defineProperty(this, \"_numLeafs\", void 0);\n        _defineProperty(this, \"_root\", void 0);\n        _defineProperty(this, \"_onHit\", void 0);\n        _defineProperty(this, \"_onSet\", void 0);\n        _defineProperty(this, \"_mapNodeValue\", void 0);\n        this._name = options === null || options === void 0 ? void 0 : options.name;\n        this._numLeafs = 0;\n        this._root = null;\n        this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : ()=>{};\n        this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : ()=>{};\n        this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val)=>val;\n    }\n    size() {\n        return this._numLeafs;\n    }\n    root() {\n        return this._root;\n    }\n    get(getNodeValue, handlers) {\n        var _this$getLeafNode;\n        return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n    }\n    getLeafNode(getNodeValue, handlers) {\n        if (this._root == null) {\n            return undefined;\n        } // Iterate down the tree based on the current node values until we hit a leaf\n        // $FlowIssue[unclear-type]\n        let node = this._root;\n        while(node){\n            handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n            if (node.type === \"leaf\") {\n                this._onHit(node);\n                return node;\n            }\n            const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n            node = node.branches.get(nodeValue);\n        }\n        return undefined;\n    }\n    set(route, value, handlers) {\n        const addLeaf = ()=>{\n            var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;\n            // First, setup the branch nodes for the route:\n            // Iterate down the tree to find or add branch nodes following the route\n            let node;\n            let branchKey;\n            for (const [nodeKey, nodeValue] of route){\n                var _node, _handlers$onNodeVisit, _this$_root;\n                // If the previous root was a leaf, while we not have a get(), it means\n                // the selector has inconsistent values or implementation changed.\n                const root = this._root;\n                if ((root === null || root === void 0 ? void 0 : root.type) === \"leaf\") {\n                    throw this.invalidCacheError();\n                } // node now refers to the next node down in the tree\n                const parent = node; // $FlowFixMe[prop-missing]\n                // $FlowFixMe[incompatible-type]\n                node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n                // $FlowFixMe[incompatible-type]\n                node = (_node = node) !== null && _node !== void 0 ? _node : {\n                    type: \"branch\",\n                    nodeKey,\n                    parent,\n                    branches: new Map(),\n                    branchKey\n                }; // If we found an existing node, confirm it has a consistent value\n                if (node.type !== \"branch\" || node.nodeKey !== nodeKey) {\n                    throw this.invalidCacheError();\n                } // Add the branch node to the tree\n                parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n                handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n                branchKey = this._mapNodeValue(nodeValue);\n                this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n            } // Second, setup the leaf node:\n            // If there is an existing leaf for this route confirm it is consistent\n            const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n            if (oldLeaf != null && (oldLeaf.type !== \"leaf\" || oldLeaf.branchKey !== branchKey)) {\n                throw this.invalidCacheError();\n            } // Create a new or replacement leaf.\n            const leafNode = {\n                type: \"leaf\",\n                value,\n                parent: node,\n                branchKey\n            }; // Install the leaf and call handlers\n            (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n            this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n            this._numLeafs++;\n            this._onSet(leafNode);\n            handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n        };\n        try {\n            addLeaf();\n        } catch (error) {\n            // If the cache was stale or observed inconsistent values, such as with\n            // Fast Refresh, then clear it and rebuild with the new values.\n            if (error instanceof ChangedPathError) {\n                this.clear();\n                addLeaf();\n            } else {\n                throw error;\n            }\n        }\n    }\n    delete(leaf) {\n        const root = this.root();\n        if (!root) {\n            return false;\n        }\n        if (leaf === root) {\n            this._root = null;\n            this._numLeafs = 0;\n            return true;\n        } // Iterate up from the leaf deleteing it from it's parent's branches.\n        let node = leaf.parent;\n        let branchKey = leaf.branchKey;\n        while(node){\n            var _node4;\n            node.branches.delete(branchKey); // Stop iterating if we hit the root.\n            if (node === root) {\n                if (node.branches.size === 0) {\n                    this._root = null;\n                    this._numLeafs = 0;\n                } else {\n                    this._numLeafs--;\n                }\n                return true;\n            } // Stop iterating if there are other branches since we don't need to\n            // remove any more nodes.\n            if (node.branches.size > 0) {\n                break;\n            } // Iterate up to our parent\n            branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n            node = node.parent;\n        } // Confirm that the leaf we are deleting is actually attached to our tree\n        for(; node !== root; node = node.parent){\n            if (node == null) {\n                return false;\n            }\n        }\n        this._numLeafs--;\n        return true;\n    }\n    clear() {\n        this._numLeafs = 0;\n        this._root = null;\n    }\n    invalidCacheError() {\n        const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? \"Possible Fast Refresh module reload detected.  \" + \"This may also be caused by an selector returning inconsistent values. \" + \"Resetting cache.\" : \"Invalid cache values.  This happens when selectors do not return \" + \"consistent values for the same input dependency values.  That may also \" + \"be caused when using Fast Refresh to change a selector implementation.  \" + \"Resetting cache.\";\n        Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : \"\"));\n        throw new ChangedPathError();\n    }\n}\nvar Recoil_TreeCache = {\n    TreeCache\n};\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\nvar Recoil_TreeCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    TreeCache: Recoil_TreeCache_1\n});\nclass LRUCache {\n    constructor(options){\n        var _options$mapKey;\n        _defineProperty(this, \"_maxSize\", void 0);\n        _defineProperty(this, \"_size\", void 0);\n        _defineProperty(this, \"_head\", void 0);\n        _defineProperty(this, \"_tail\", void 0);\n        _defineProperty(this, \"_map\", void 0);\n        _defineProperty(this, \"_keyMapper\", void 0);\n        this._maxSize = options.maxSize;\n        this._size = 0;\n        this._head = null;\n        this._tail = null;\n        this._map = new Map();\n        this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v)=>v;\n    }\n    head() {\n        return this._head;\n    }\n    tail() {\n        return this._tail;\n    }\n    size() {\n        return this._size;\n    }\n    maxSize() {\n        return this._maxSize;\n    }\n    has(key) {\n        return this._map.has(this._keyMapper(key));\n    }\n    get(key) {\n        const mappedKey = this._keyMapper(key);\n        const node = this._map.get(mappedKey);\n        if (!node) {\n            return undefined;\n        }\n        this.set(key, node.value);\n        return node.value;\n    }\n    set(key, val) {\n        const mappedKey = this._keyMapper(key);\n        const existingNode = this._map.get(mappedKey);\n        if (existingNode) {\n            this.delete(key);\n        }\n        const head = this.head();\n        const node = {\n            key,\n            right: head,\n            left: null,\n            value: val\n        };\n        if (head) {\n            head.left = node;\n        } else {\n            this._tail = node;\n        }\n        this._map.set(mappedKey, node);\n        this._head = node;\n        this._size++;\n        this._maybeDeleteLRU();\n    }\n    _maybeDeleteLRU() {\n        if (this.size() > this.maxSize()) {\n            this.deleteLru();\n        }\n    }\n    deleteLru() {\n        const tail = this.tail();\n        if (tail) {\n            this.delete(tail.key);\n        }\n    }\n    delete(key) {\n        const mappedKey = this._keyMapper(key);\n        if (!this._size || !this._map.has(mappedKey)) {\n            return;\n        }\n        const node = Recoil_nullthrows(this._map.get(mappedKey));\n        const right = node.right;\n        const left = node.left;\n        if (right) {\n            right.left = node.left;\n        }\n        if (left) {\n            left.right = node.right;\n        }\n        if (node === this.head()) {\n            this._head = right;\n        }\n        if (node === this.tail()) {\n            this._tail = left;\n        }\n        this._map.delete(mappedKey);\n        this._size--;\n    }\n    clear() {\n        this._size = 0;\n        this._head = null;\n        this._tail = null;\n        this._map = new Map();\n    }\n}\nvar Recoil_LRUCache = {\n    LRUCache\n};\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\nvar Recoil_LRUCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    LRUCache: Recoil_LRUCache_1\n});\nconst { LRUCache: LRUCache$1  } = Recoil_LRUCache$1;\nconst { TreeCache: TreeCache$1  } = Recoil_TreeCache$1;\nfunction treeCacheLRU({ name , maxSize , mapNodeValue =(v)=>v  }) {\n    const lruCache = new LRUCache$1({\n        maxSize\n    });\n    const cache = new TreeCache$1({\n        name,\n        mapNodeValue,\n        onHit: (node)=>{\n            lruCache.set(node, true);\n        },\n        onSet: (node)=>{\n            const lruNode = lruCache.tail();\n            lruCache.set(node, true);\n            if (lruNode && cache.size() > maxSize) {\n                cache.delete(lruNode.key);\n            }\n        }\n    });\n    return cache;\n}\nvar Recoil_treeCacheLRU = treeCacheLRU;\nconst TIME_WARNING_THRESHOLD_MS = 15;\nfunction stringify(x, opt, key) {\n    // A optimization to avoid the more expensive JSON.stringify() for simple strings\n    // This may lose protection for u2028 and u2029, though.\n    if (typeof x === \"string\" && !x.includes('\"') && !x.includes(\"\\\\\")) {\n        return `\"${x}\"`;\n    } // Handle primitive types\n    switch(typeof x){\n        case \"undefined\":\n            return \"\";\n        // JSON.stringify(undefined) returns undefined, but we always want to return a string\n        case \"boolean\":\n            return x ? \"true\" : \"false\";\n        case \"number\":\n        case \"symbol\":\n            // case 'bigint': // BigInt is not supported in www\n            return String(x);\n        case \"string\":\n            // Add surrounding quotes and escape internal quotes\n            return JSON.stringify(x);\n        case \"function\":\n            if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n                throw Recoil_err(\"Attempt to serialize function in a Recoil cache key\");\n            }\n            return `__FUNCTION(${x.name})__`;\n    }\n    if (x === null) {\n        return \"null\";\n    } // Fallback case for unknown types\n    if (typeof x !== \"object\") {\n        var _JSON$stringify;\n        return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : \"\";\n    } // Deal with all promises as equivalent for now.\n    if (Recoil_isPromise(x)) {\n        return \"__PROMISE__\";\n    } // Arrays handle recursive stringification\n    if (Array.isArray(x)) {\n        return `[${x.map((v, i)=>stringify(v, opt, i.toString()))}]`;\n    } // If an object defines a toJSON() method, then use that to override the\n    // serialization.  This matches the behavior of JSON.stringify().\n    // Pass the key for compatibility.\n    // Immutable.js collections define this method to allow us to serialize them.\n    if (typeof x.toJSON === \"function\") {\n        // flowlint-next-line unclear-type: off\n        return stringify(x.toJSON(key), opt, key);\n    } // For built-in Maps, sort the keys in a stable order instead of the\n    // default insertion order.  Support non-string keys.\n    if (x instanceof Map) {\n        const obj = {};\n        for (const [k, v] of x){\n            // Stringify will escape any nested quotes\n            obj[typeof k === \"string\" ? k : stringify(k, opt)] = v;\n        }\n        return stringify(obj, opt, key);\n    } // For built-in Sets, sort the keys in a stable order instead of the\n    // default insertion order.\n    if (x instanceof Set) {\n        return stringify(Array.from(x).sort((a, b)=>stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n    } // Anything else that is iterable serialize as an Array.\n    if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === \"function\") {\n        // flowlint-next-line unclear-type: off\n        return stringify(Array.from(x), opt, key);\n    } // For all other Objects, sort the keys in a stable order.\n    return `{${Object.keys(x).filter((k)=>x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n    .map((k)=>`${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(\",\")}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\nfunction stableStringify(x, opt = {\n    allowFunctions: false\n}) {\n    if (true) {\n        if (false) {}\n    }\n    return stringify(x, opt);\n}\nvar Recoil_stableStringify = stableStringify;\nconst { TreeCache: TreeCache$2  } = Recoil_TreeCache$1;\nconst defaultPolicy = {\n    equality: \"reference\",\n    eviction: \"keep-all\",\n    maxSize: Infinity\n};\nfunction treeCacheFromPolicy({ equality =defaultPolicy.equality , eviction =defaultPolicy.eviction , maxSize =defaultPolicy.maxSize  } = defaultPolicy, name) {\n    const valueMapper = getValueMapper(equality);\n    return getTreeCache(eviction, maxSize, valueMapper, name);\n}\nfunction getValueMapper(equality) {\n    switch(equality){\n        case \"reference\":\n            return (val)=>val;\n        case \"value\":\n            return (val)=>Recoil_stableStringify(val);\n    }\n    throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n    switch(eviction){\n        case \"keep-all\":\n            return new TreeCache$2({\n                name,\n                mapNodeValue\n            });\n        case \"lru\":\n            return Recoil_treeCacheLRU({\n                name,\n                maxSize: Recoil_nullthrows(maxSize),\n                mapNodeValue\n            });\n        case \"most-recent\":\n            return Recoil_treeCacheLRU({\n                name,\n                maxSize: 1,\n                mapNodeValue\n            });\n    }\n    throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ function isNode(object) {\n    var _ownerDocument, _doc$defaultView;\n    if (true) {\n        return false;\n    }\n    const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n    const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n    return !!(object != null && (typeof defaultView.Node === \"function\" ? object instanceof defaultView.Node : typeof object === \"object\" && typeof object.nodeType === \"number\" && typeof object.nodeName === \"string\"));\n}\nvar Recoil_isNode = isNode;\nconst { isReactNative: isReactNative$1 , isWindow: isWindow$1  } = Recoil_Environment;\nfunction shouldNotBeFrozen(value) {\n    // Primitives and functions:\n    if (value === null || typeof value !== \"object\") {\n        return true;\n    } // React elements:\n    switch(typeof value.$$typeof){\n        case \"symbol\":\n            return true;\n        case \"number\":\n            return true;\n    } // Immutable structures:\n    if (value[\"@@__IMMUTABLE_ITERABLE__@@\"] != null || value[\"@@__IMMUTABLE_KEYED__@@\"] != null || value[\"@@__IMMUTABLE_INDEXED__@@\"] != null || value[\"@@__IMMUTABLE_ORDERED__@@\"] != null || value[\"@@__IMMUTABLE_RECORD__@@\"] != null) {\n        return true;\n    } // DOM nodes:\n    if (Recoil_isNode(value)) {\n        return true;\n    }\n    if (Recoil_isPromise(value)) {\n        return true;\n    }\n    if (value instanceof Error) {\n        return true;\n    }\n    if (ArrayBuffer.isView(value)) {\n        return true;\n    } // Some environments, just as Jest, don't work with the instanceof check\n    if (!isReactNative$1 && isWindow$1(value)) {\n        return true;\n    }\n    return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\nfunction deepFreezeValue(value) {\n    if (typeof value !== \"object\" || shouldNotBeFrozen(value)) {\n        return;\n    }\n    Object.freeze(value); // Make all properties read-only\n    for(const key in value){\n        // $FlowIssue[method-unbinding] added when improving typing for this parameters\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\n            const prop = value[key]; // Prevent infinite recurssion for circular references.\n            if (typeof prop === \"object\" && prop != null && !Object.isFrozen(prop)) {\n                deepFreezeValue(prop);\n            }\n        }\n    }\n    Object.seal(value); // This also makes existing properties non-configurable.\n}\nvar Recoil_deepFreezeValue = deepFreezeValue;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */ function startPerfBlock(_id) {\n    return ()=>null;\n}\nvar Recoil_PerformanceTimings = {\n    startPerfBlock\n};\nconst { isLoadable: isLoadable$1 , loadableWithError: loadableWithError$1 , loadableWithPromise: loadableWithPromise$1 , loadableWithValue: loadableWithValue$2  } = Recoil_Loadable$1;\nconst { WrappedValue: WrappedValue$1  } = Recoil_Wrapper$1;\nconst { getNodeLoadable: getNodeLoadable$2 , peekNodeLoadable: peekNodeLoadable$1 , setNodeValue: setNodeValue$3  } = Recoil_FunctionalCore;\nconst { saveDepsToStore: saveDepsToStore$1  } = Recoil_Graph;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$6 , getConfigDeletionHandler: getConfigDeletionHandler$1 , getNode: getNode$6 , registerNode: registerNode$1  } = Recoil_Node;\nconst { isRecoilValue: isRecoilValue$3  } = Recoil_RecoilValue$1;\nconst { markRecoilValueModified: markRecoilValueModified$1  } = Recoil_RecoilValueInterface;\nconst { retainedByOptionWithDefault: retainedByOptionWithDefault$1  } = Recoil_Retention;\nconst { recoilCallback: recoilCallback$1  } = Recoil_useRecoilCallback;\nconst { startPerfBlock: startPerfBlock$1  } = Recoil_PerformanceTimings;\nclass Canceled {\n}\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */ const dependencyStack = []; // for detecting circular dependencies.\nconst waitingStores = new Map();\nconst getNewExecutionID = (()=>{\n    let executionID = 0;\n    return ()=>executionID++;\n})();\n/* eslint-disable no-redeclare */ function selector(options) {\n    let recoilValue = null;\n    const { key , get , cachePolicy_UNSTABLE: cachePolicy  } = options;\n    const set = options.set != null ? options.set : undefined; // flow\n    if (true) {\n        if (typeof key !== \"string\") {\n            throw Recoil_err(\"A key option with a unique string value must be provided when creating a selector.\");\n        }\n        if (typeof get !== \"function\") {\n            throw Recoil_err(\"Selectors must specify a get callback option to get the selector value.\");\n        }\n    } // This is every discovered dependency across all executions\n    const discoveredDependencyNodeKeys = new Set();\n    const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n        equality: \"reference\",\n        eviction: \"keep-all\"\n    }, key);\n    const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n    const executionInfoMap = new Map();\n    let liveStoresCount = 0;\n    function selectorIsLive() {\n        return !Recoil_gkx(\"recoil_memory_managament_2020\") || liveStoresCount > 0;\n    }\n    function selectorInit(store) {\n        store.getState().knownSelectors.add(key);\n        liveStoresCount++;\n        return ()=>{\n            liveStoresCount--;\n        };\n    }\n    function selectorShouldDeleteConfigOnRelease() {\n        return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n    }\n    function resolveAsync(store, state, executionID, loadable, depValues) {\n        setCache(state, loadable, depValues);\n        notifyStoresOfResolvedAsync(store, executionID);\n    }\n    function notifyStoresOfResolvedAsync(store, executionID) {\n        if (isLatestExecution(store, executionID)) {\n            clearExecutionInfo(store);\n        }\n        notifyWaitingStores(executionID, true);\n    }\n    /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */ function notifyStoresOfNewAsyncDep(store, executionID) {\n        if (isLatestExecution(store, executionID)) {\n            const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n            executionInfo.stateVersions.clear();\n            notifyWaitingStores(executionID, false);\n        }\n    }\n    function notifyWaitingStores(executionID, clearWaitlist) {\n        const stores = waitingStores.get(executionID);\n        if (stores != null) {\n            for (const waitingStore of stores){\n                markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n            }\n            if (clearWaitlist) {\n                waitingStores.delete(executionID);\n            }\n        }\n    }\n    function markStoreWaitingForResolvedAsync(store, executionID) {\n        let stores = waitingStores.get(executionID);\n        if (stores == null) {\n            waitingStores.set(executionID, stores = new Set());\n        }\n        stores.add(store);\n    }\n    /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */ function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n        return promise.then((value)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            const loadable = loadableWithValue$2(value);\n            resolveAsync(store, state, executionID, loadable, depValues);\n            return value;\n        }).catch((errorOrPromise)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            if (Recoil_isPromise(errorOrPromise)) {\n                return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n            }\n            const loadable = loadableWithError$1(errorOrPromise);\n            resolveAsync(store, state, executionID, loadable, depValues);\n            throw errorOrPromise;\n        });\n    }\n    /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */ function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n        return promise.then((resolvedDep)=>{\n            if (!selectorIsLive()) {\n                // The selector was released since the request began; ignore the response.\n                clearExecutionInfo(store);\n                throw CANCELED;\n            } // Check if we are handling a pending Recoil dependency or if the user\n            // threw their own Promise to \"suspend\" a selector evaluation.  We need\n            // to check that the loadingDepPromise actually matches the promise that\n            // we caught in case the selector happened to catch the promise we threw\n            // for a pending Recoil dependency from `getRecoilValue()` and threw\n            // their own promise instead.\n            if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n                /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */ state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n            } else {\n                /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */ store.getState().knownSelectors.forEach((nodeKey)=>{\n                    state.atomValues.delete(nodeKey);\n                });\n            }\n            /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */ const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n            if (cachedLoadable && cachedLoadable.state !== \"loading\") {\n                /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */ if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n                    notifyStoresOfResolvedAsync(store, executionID);\n                }\n                if (cachedLoadable.state === \"hasValue\") {\n                    return cachedLoadable.contents;\n                } else {\n                    throw cachedLoadable.contents;\n                }\n            }\n            /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */ if (!isLatestExecution(store, executionID)) {\n                const executionInfo = getInProgressExecutionInfo(store, state);\n                if (executionInfo != null) {\n                    /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */ return executionInfo.loadingLoadable.contents;\n                }\n            } // Retry the selector evaluation now that the dependency has resolved\n            const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n            if (loadable.state !== \"loading\") {\n                resolveAsync(store, state, executionID, loadable, depValues);\n            }\n            if (loadable.state === \"hasError\") {\n                throw loadable.contents;\n            }\n            return loadable.contents;\n        }).catch((error)=>{\n            // The selector was released since the request began; ignore the response.\n            if (error instanceof Canceled) {\n                throw CANCELED;\n            }\n            if (!selectorIsLive()) {\n                clearExecutionInfo(store);\n                throw CANCELED;\n            }\n            const loadable = loadableWithError$1(error);\n            resolveAsync(store, state, executionID, loadable, existingDeps);\n            throw error;\n        });\n    }\n    function updateDeps(store, state, deps, executionID) {\n        var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n        if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n            var _store$getState$nextT, _store$getState3, _store$getState3$next;\n            saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n        }\n        for (const nodeKey of deps){\n            discoveredDependencyNodeKeys.add(nodeKey);\n        }\n    }\n    function evaluateSelectorGetter(store, state, executionID) {\n        const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n        let duringSynchronousExecution = true;\n        let duringAsynchronousExecution = true;\n        const finishEvaluation = ()=>{\n            endPerfBlock();\n            duringAsynchronousExecution = false;\n        };\n        let result;\n        let resultIsError = false;\n        let loadable;\n        const loadingDepsState = {\n            loadingDepKey: null,\n            loadingDepPromise: null\n        };\n        /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */ const depValues = new Map();\n        function getRecoilValue({ key: depKey  }) {\n            const depLoadable = getNodeLoadable$2(store, state, depKey);\n            depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n            // knows if it has to restart evaluation if one of them is updated before\n            // the asynchronous selector completely resolves.\n            if (!duringSynchronousExecution) {\n                updateDeps(store, state, new Set(depValues.keys()), executionID);\n                notifyStoresOfNewAsyncDep(store, executionID);\n            }\n            switch(depLoadable.state){\n                case \"hasValue\":\n                    return depLoadable.contents;\n                case \"hasError\":\n                    throw depLoadable.contents;\n                case \"loading\":\n                    loadingDepsState.loadingDepKey = depKey;\n                    loadingDepsState.loadingDepPromise = depLoadable.contents;\n                    throw depLoadable.contents;\n            }\n            throw Recoil_err(\"Invalid Loadable state\");\n        }\n        const getCallback = (fn)=>{\n            return (...args)=>{\n                if (duringAsynchronousExecution) {\n                    throw Recoil_err(\"Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.\");\n                }\n                !(recoilValue != null) ?  true ? Recoil_invariant(false, \"Recoil Value can never be null\") : 0 : void 0;\n                return recoilCallback$1(store, fn, args, {\n                    node: recoilValue\n                } // flowlint-line unclear-type:off\n                );\n            };\n        };\n        try {\n            result = get({\n                get: getRecoilValue,\n                getCallback\n            });\n            result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n            if (isLoadable$1(result)) {\n                if (result.state === \"hasError\") {\n                    resultIsError = true;\n                }\n                result = result.contents;\n            }\n            if (Recoil_isPromise(result)) {\n                result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n            } else {\n                finishEvaluation();\n            }\n            result = result instanceof WrappedValue$1 ? result.value : result;\n        } catch (errorOrDepPromise) {\n            result = errorOrDepPromise;\n            if (Recoil_isPromise(result)) {\n                result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n            } else {\n                resultIsError = true;\n                finishEvaluation();\n            }\n        }\n        if (resultIsError) {\n            loadable = loadableWithError$1(result);\n        } else if (Recoil_isPromise(result)) {\n            loadable = loadableWithPromise$1(result);\n        } else {\n            loadable = loadableWithValue$2(result);\n        }\n        duringSynchronousExecution = false;\n        updateExecutionInfoDepValues(store, executionID, depValues);\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        return [\n            loadable,\n            depValues\n        ];\n    }\n    function getLoadableFromCacheAndUpdateDeps(store, state) {\n        // First, look up in the state cache\n        // If it's here, then the deps in the store should already be valid.\n        let cachedLoadable = state.atomValues.get(key);\n        if (cachedLoadable != null) {\n            return cachedLoadable;\n        } // Second, look up in the selector cache and update the deps in the store\n        const depsAfterCacheLookup = new Set();\n        try {\n            cachedLoadable = cache.get((nodeKey)=>{\n                !(typeof nodeKey === \"string\") ?  true ? Recoil_invariant(false, \"Cache nodeKey is type string\") : 0 : void 0;\n                return getNodeLoadable$2(store, state, nodeKey).contents;\n            }, {\n                onNodeVisit: (node)=>{\n                    if (node.type === \"branch\" && node.nodeKey !== key) {\n                        depsAfterCacheLookup.add(node.nodeKey);\n                    }\n                }\n            });\n        } catch (error) {\n            throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n        }\n        if (cachedLoadable) {\n            var _getExecutionInfo;\n            // Cache the results in the state to allow for cheaper lookup than\n            // iterating the tree cache of dependencies.\n            state.atomValues.set(key, cachedLoadable);\n            /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */ updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n        }\n        return cachedLoadable;\n    }\n    /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */ function getSelectorLoadableAndUpdateDeps(store, state) {\n        // First, see if our current state is cached\n        const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n        if (cachedVal != null) {\n            clearExecutionInfo(store);\n            return cachedVal;\n        } // Second, check if there is already an ongoing execution based on the current state\n        const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n        if (inProgressExecutionInfo != null) {\n            var _inProgressExecutionI;\n            if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === \"loading\") {\n                markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n            } // FIXME: check after the fact to see if we made the right choice by waiting\n            return inProgressExecutionInfo.loadingLoadable;\n        } // Third, start a new evaluation of the selector\n        const newExecutionID = getNewExecutionID();\n        const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n        /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */ if (loadable.state === \"loading\") {\n            setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n            markStoreWaitingForResolvedAsync(store, newExecutionID);\n        } else {\n            clearExecutionInfo(store);\n            setCache(state, loadable, newDepValues);\n        }\n        return loadable;\n    }\n    /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */ function getInProgressExecutionInfo(store, state) {\n        // Sort the pending executions so that our current store is checked first.\n        const pendingExecutions = Recoil_concatIterables([\n            executionInfoMap.has(store) ? [\n                Recoil_nullthrows(executionInfoMap.get(store))\n            ] : [],\n            Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s])=>s !== store), ([, execInfo])=>execInfo)\n        ]);\n        function anyDepChanged(execDepValues) {\n            for (const [depKey, execLoadable] of execDepValues){\n                if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        for (const execInfo of pendingExecutions){\n            if (// of state, then let's use it!\n            execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n            !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n                execInfo.stateVersions.set(state.version, true);\n                return execInfo;\n            } else {\n                execInfo.stateVersions.set(state.version, false);\n            }\n        }\n        return undefined;\n    }\n    function getExecutionInfo(store) {\n        return executionInfoMap.get(store);\n    }\n    /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */ function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n        executionInfoMap.set(store, {\n            depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n            executionID: newExecutionID,\n            loadingLoadable: loadable,\n            stateVersions: new Map([\n                [\n                    state.version,\n                    true\n                ]\n            ])\n        });\n    }\n    function updateExecutionInfoDepValues(store, executionID, depValues) {\n        // We only need to bother updating the deps for the latest execution because\n        // that's all getInProgressExecutionInfo() will be looking for.\n        if (isLatestExecution(store, executionID)) {\n            const executionInfo = getExecutionInfo(store);\n            if (executionInfo != null) {\n                executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n            }\n        }\n    }\n    function clearExecutionInfo(store) {\n        executionInfoMap.delete(store);\n    }\n    function isLatestExecution(store, executionID) {\n        var _getExecutionInfo2;\n        return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n    }\n    /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */ function depValuesToDepRoute(depValues) {\n        return Array.from(depValues.entries()).map(([depKey, valLoadable])=>[\n                depKey,\n                valLoadable.contents\n            ]);\n    }\n    function setCache(state, loadable, depValues) {\n        if (true) {\n            if (loadable.state !== \"loading\" && Boolean(options.dangerouslyAllowMutability) === false) {\n                Recoil_deepFreezeValue(loadable.contents);\n            }\n        }\n        state.atomValues.set(key, loadable);\n        try {\n            cache.set(depValuesToDepRoute(depValues), loadable);\n        } catch (error) {\n            throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n        }\n    }\n    function detectCircularDependencies(fn) {\n        if (dependencyStack.includes(key)) {\n            const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(\" → \")}`;\n            return loadableWithError$1(Recoil_err(message));\n        }\n        dependencyStack.push(key);\n        try {\n            return fn();\n        } finally{\n            dependencyStack.pop();\n        }\n    }\n    function selectorPeek(store, state) {\n        const cachedLoadable = state.atomValues.get(key);\n        if (cachedLoadable != null) {\n            return cachedLoadable;\n        }\n        return cache.get((nodeKey)=>{\n            var _peekNodeLoadable;\n            !(typeof nodeKey === \"string\") ?  true ? Recoil_invariant(false, \"Cache nodeKey is type string\") : 0 : void 0;\n            return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n        });\n    }\n    function selectorGet(store, state) {\n        return detectCircularDependencies(()=>getSelectorLoadableAndUpdateDeps(store, state));\n    }\n    function invalidateSelector(state) {\n        state.atomValues.delete(key);\n    }\n    function clearSelectorCache(store, treeState) {\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, \"Recoil Value can never be null\") : 0 : void 0;\n        for (const nodeKey of discoveredDependencyNodeKeys){\n            var _node$clearCache;\n            const node = getNode$6(nodeKey);\n            (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n        }\n        discoveredDependencyNodeKeys.clear();\n        invalidateSelector(treeState);\n        cache.clear();\n        markRecoilValueModified$1(store, recoilValue);\n    }\n    if (set != null) {\n        /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */ const selectorSet = (store, state, newValue)=>{\n            let syncSelectorSetFinished = false;\n            const writes = new Map();\n            function getRecoilValue({ key: depKey  }) {\n                if (syncSelectorSetFinished) {\n                    throw Recoil_err(\"Recoil: Async selector sets are not currently supported.\");\n                }\n                const loadable = getNodeLoadable$2(store, state, depKey);\n                if (loadable.state === \"hasValue\") {\n                    return loadable.contents;\n                } else if (loadable.state === \"loading\") {\n                    const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n                    Recoil_recoverableViolation(msg);\n                    throw Recoil_err(msg);\n                } else {\n                    throw loadable.contents;\n                }\n            }\n            function setRecoilState(recoilState, valueOrUpdater) {\n                if (syncSelectorSetFinished) {\n                    const msg = \"Recoil: Async selector sets are not currently supported.\";\n                    Recoil_recoverableViolation(msg);\n                    throw Recoil_err(msg);\n                }\n                const setValue = typeof valueOrUpdater === \"function\" ? // flowlint-next-line unclear-type:off\n                valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n                const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n                upstreamWrites.forEach((v, k)=>writes.set(k, v));\n            }\n            function resetRecoilState(recoilState) {\n                setRecoilState(recoilState, DEFAULT_VALUE$6);\n            }\n            const ret = set({\n                set: setRecoilState,\n                get: getRecoilValue,\n                reset: resetRecoilState\n            }, newValue); // set should be a void method, but if the user makes it `async`, then it\n            // will return a Promise, which we don't currently support.\n            if (ret !== undefined) {\n                throw Recoil_isPromise(ret) ? Recoil_err(\"Recoil: Async selector sets are not currently supported.\") : Recoil_err(\"Recoil: selector set should be a void function.\");\n            }\n            syncSelectorSetFinished = true;\n            return writes;\n        };\n        return recoilValue = registerNode$1({\n            key,\n            nodeType: \"selector\",\n            peek: selectorPeek,\n            get: selectorGet,\n            set: selectorSet,\n            init: selectorInit,\n            invalidate: invalidateSelector,\n            clearCache: clearSelectorCache,\n            shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n            dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n            shouldRestoreFromSnapshots: false,\n            retainedBy\n        });\n    } else {\n        return recoilValue = registerNode$1({\n            key,\n            nodeType: \"selector\",\n            peek: selectorPeek,\n            get: selectorGet,\n            init: selectorInit,\n            invalidate: invalidateSelector,\n            clearCache: clearSelectorCache,\n            shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n            dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n            shouldRestoreFromSnapshots: false,\n            retainedBy\n        });\n    }\n}\n/* eslint-enable no-redeclare */ // $FlowIssue[incompatible-use]\n// $FlowFixMe[missing-local-annot]\nselector.value = (value)=>new WrappedValue$1(value);\nvar Recoil_selector = selector;\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\nconst { isLoadable: isLoadable$2 , loadableWithError: loadableWithError$2 , loadableWithPromise: loadableWithPromise$2 , loadableWithValue: loadableWithValue$3  } = Recoil_Loadable$1;\nconst { WrappedValue: WrappedValue$2  } = Recoil_Wrapper$1;\nconst { peekNodeInfo: peekNodeInfo$3  } = Recoil_FunctionalCore;\nconst { DEFAULT_VALUE: DEFAULT_VALUE$7 , DefaultValue: DefaultValue$2 , getConfigDeletionHandler: getConfigDeletionHandler$2 , registerNode: registerNode$2 , setConfigDeletionHandler: setConfigDeletionHandler$1  } = Recoil_Node;\nconst { isRecoilValue: isRecoilValue$4  } = Recoil_RecoilValue$1;\nconst { getRecoilValueAsLoadable: getRecoilValueAsLoadable$4 , markRecoilValueModified: markRecoilValueModified$2 , setRecoilValue: setRecoilValue$4 , setRecoilValueLoadable: setRecoilValueLoadable$2  } = Recoil_RecoilValueInterface;\nconst { retainedByOptionWithDefault: retainedByOptionWithDefault$2  } = Recoil_Retention;\nconst unwrap = (x)=>x instanceof WrappedValue$2 ? x.value : x;\nfunction baseAtom(options) {\n    const { key , persistence_UNSTABLE: persistence  } = options;\n    const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n    let liveStoresCount = 0;\n    function unwrapPromise(promise) {\n        return loadableWithPromise$2(promise.then((value)=>{\n            defaultLoadable = loadableWithValue$3(value);\n            return value;\n        }).catch((error)=>{\n            defaultLoadable = loadableWithError$2(error);\n            throw error;\n        }));\n    }\n    let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === \"loading\" ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n    maybeFreezeValueOrPromise(defaultLoadable.contents);\n    let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n    // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n    const cleanupEffectsByStore = new Map();\n    function maybeFreezeValueOrPromise(valueOrPromise) {\n        if (true) {\n            if (options.dangerouslyAllowMutability !== true) {\n                if (Recoil_isPromise(valueOrPromise)) {\n                    return valueOrPromise.then((value)=>{\n                        Recoil_deepFreezeValue(value);\n                        return value;\n                    });\n                } else {\n                    Recoil_deepFreezeValue(valueOrPromise);\n                    return valueOrPromise;\n                }\n            }\n        }\n        return valueOrPromise;\n    }\n    function wrapPendingPromise(store, promise) {\n        const wrappedPromise = promise.then((value)=>{\n            var _store$getState$nextT, _state$atomValues$get;\n            const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n            if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n                setRecoilValue$4(store, node, value);\n            }\n            return value;\n        }).catch((error)=>{\n            var _store$getState$nextT2, _state$atomValues$get2;\n            const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n            if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n                setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n            }\n            throw error;\n        });\n        return wrappedPromise;\n    }\n    function initAtom(store, initState, trigger) {\n        var _options$effects;\n        liveStoresCount++;\n        const cleanupAtom = ()=>{\n            var _cleanupEffectsByStor;\n            liveStoresCount--;\n            (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach((cleanup)=>cleanup());\n            cleanupEffectsByStore.delete(store);\n        };\n        store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n        if (defaultLoadable.state === \"loading\") {\n            const notifyDefaultSubscribers = ()=>{\n                var _store$getState$nextT3;\n                const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n                if (!state.atomValues.has(key)) {\n                    markRecoilValueModified$2(store, node);\n                }\n            };\n            defaultLoadable.contents.finally(notifyDefaultSubscribers);\n        } ///////////////////\n        // Run Atom Effects\n        ///////////////////\n        const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n        if (effects != null) {\n            // This state is scoped by Store, since this is in the initAtom() closure\n            let initValue = DEFAULT_VALUE$7;\n            let isDuringInit = true;\n            let isInitError = false;\n            let pendingSetSelf = null;\n            function getLoadable(recoilValue) {\n                // Normally we can just get the current value of another atom.\n                // But for our own value we need to check if there is a pending\n                // initialized value or get the fallback default value.\n                if (isDuringInit && recoilValue.key === key) {\n                    // Cast T to S\n                    const retValue = initValue; // flowlint-line unclear-type:off\n                    return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n                     : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then((v)=>v instanceof DefaultValue$2 ? defaultLoadable.toPromise() // flowlint-line unclear-type:off\n                         : v)) : loadableWithValue$3(retValue);\n                }\n                return getRecoilValueAsLoadable$4(store, recoilValue);\n            }\n            function getPromise(recoilValue) {\n                return getLoadable(recoilValue).toPromise();\n            }\n            function getInfo_UNSTABLE(recoilValue) {\n                var _store$getState$nextT4;\n                const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n                return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? {\n                    ...info,\n                    isSet: true,\n                    loadable: getLoadable(recoilValue)\n                } : info;\n            }\n            const setSelf = (effect)=>(valueOrUpdater)=>{\n                    if (isDuringInit) {\n                        const currentLoadable = getLoadable(node);\n                        const currentValue = currentLoadable.state === \"hasValue\" ? currentLoadable.contents : DEFAULT_VALUE$7;\n                        initValue = typeof valueOrUpdater === \"function\" ? valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n                         : valueOrUpdater;\n                        if (Recoil_isPromise(initValue)) {\n                            initValue = initValue.then((value)=>{\n                                // Avoid calling onSet() when setSelf() initializes with a Promise\n                                pendingSetSelf = {\n                                    effect,\n                                    value\n                                };\n                                return value;\n                            });\n                        }\n                    } else {\n                        if (Recoil_isPromise(valueOrUpdater)) {\n                            throw Recoil_err(\"Setting atoms to async values is not implemented.\");\n                        }\n                        if (typeof valueOrUpdater !== \"function\") {\n                            pendingSetSelf = {\n                                effect,\n                                value: unwrap(valueOrUpdater)\n                            };\n                        }\n                        setRecoilValue$4(store, node, typeof valueOrUpdater === \"function\" ? (currentValue)=>{\n                            const newValue = unwrap(valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n                            );\n                            pendingSetSelf = {\n                                effect,\n                                value: newValue\n                            };\n                            return newValue;\n                        } : unwrap(valueOrUpdater));\n                    }\n                };\n            const resetSelf = (effect)=>()=>setSelf(effect)(DEFAULT_VALUE$7);\n            const onSet = (effect)=>(handler)=>{\n                    var _cleanupEffectsByStor2;\n                    const { release  } = store.subscribeToTransactions((currentStore)=>{\n                        var _currentTree$atomValu;\n                        // eslint-disable-next-line prefer-const\n                        let { currentTree , previousTree  } = currentStore.getState();\n                        if (!previousTree) {\n                            Recoil_recoverableViolation(\"Transaction subscribers notified without a next tree being present -- this is a bug in Recoil\");\n                            previousTree = currentTree; // attempt to trundle on\n                        }\n                        const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n                        if (newLoadable.state === \"hasValue\") {\n                            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n                            const newValue = newLoadable.contents;\n                            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n                            const oldValue = oldLoadable.state === \"hasValue\" ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n                            // Ignore atom value changes that were set via setSelf() in the same effect.\n                            // We will still properly call the handler if there was a subsequent\n                            // set from something other than an atom effect which was batched\n                            // with the `setSelf()` call.  However, we may incorrectly ignore\n                            // the handler if the subsequent batched call happens to set the\n                            // atom to the exact same value as the `setSelf()`.   But, in that\n                            // case, it was kind of a noop, so the semantics are debatable..\n                            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n                                handler(newValue, oldValue, !currentTree.atomValues.has(key));\n                            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n                                pendingSetSelf = null;\n                            }\n                        }\n                    }, key);\n                    cleanupEffectsByStore.set(store, [\n                        ...(_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : [],\n                        release\n                    ]);\n                };\n            for (const effect of effects){\n                try {\n                    const cleanup = effect({\n                        node,\n                        storeID: store.storeID,\n                        parentStoreID_UNSTABLE: store.parentStoreID,\n                        trigger,\n                        setSelf: setSelf(effect),\n                        resetSelf: resetSelf(effect),\n                        onSet: onSet(effect),\n                        getPromise,\n                        getLoadable,\n                        getInfo_UNSTABLE\n                    });\n                    if (cleanup != null) {\n                        var _cleanupEffectsByStor3;\n                        cleanupEffectsByStore.set(store, [\n                            ...(_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : [],\n                            cleanup\n                        ]);\n                    }\n                } catch (error) {\n                    initValue = error;\n                    isInitError = true;\n                }\n            }\n            isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n            // since we are the ones initializing on first use.\n            if (!(initValue instanceof DefaultValue$2)) {\n                var _store$getState$nextT5;\n                const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n                maybeFreezeValueOrPromise(initLoadable.contents);\n                initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n                // This could happen if the atom was first initialized in an action that\n                // also updated some other atom's state.\n                (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n            }\n        }\n        return cleanupAtom;\n    }\n    function peekAtom(_store, state) {\n        var _ref, _state$atomValues$get3;\n        return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n    }\n    function getAtom(_store, state) {\n        if (state.atomValues.has(key)) {\n            // Atom value is stored in state:\n            return Recoil_nullthrows(state.atomValues.get(key));\n        } else if (state.nonvalidatedAtoms.has(key)) {\n            // Atom value is stored but needs validation before use.\n            // We might have already validated it and have a cached validated value:\n            if (cachedAnswerForUnvalidatedValue != null) {\n                return cachedAnswerForUnvalidatedValue;\n            }\n            if (persistence == null) {\n                Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n                return defaultLoadable;\n            }\n            const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n            const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n            const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n            cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n            return cachedAnswerForUnvalidatedValue;\n        } else {\n            return defaultLoadable;\n        }\n    }\n    function invalidateAtom() {\n        cachedAnswerForUnvalidatedValue = undefined;\n    }\n    function setAtom(_store, state, newValue) {\n        // Bail out if we're being set to the existing value, or if we're being\n        // reset but have no stored value (validated or unvalidated) to reset from:\n        if (state.atomValues.has(key)) {\n            const existing = Recoil_nullthrows(state.atomValues.get(key));\n            if (existing.state === \"hasValue\" && newValue === existing.contents) {\n                return new Map();\n            }\n        } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n            return new Map();\n        }\n        maybeFreezeValueOrPromise(newValue);\n        cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n        return new Map().set(key, loadableWithValue$3(newValue));\n    }\n    function shouldDeleteConfigOnReleaseAtom() {\n        return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n    }\n    const node = registerNode$2({\n        key,\n        nodeType: \"atom\",\n        peek: peekAtom,\n        get: getAtom,\n        set: setAtom,\n        init: initAtom,\n        invalidate: invalidateAtom,\n        shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n            type: options.persistence_UNSTABLE.type,\n            backButton: options.persistence_UNSTABLE.backButton\n        } : undefined,\n        shouldRestoreFromSnapshots: true,\n        retainedBy\n    });\n    return node;\n} // prettier-ignore\nfunction atom(options) {\n    if (true) {\n        if (typeof options.key !== \"string\") {\n            throw Recoil_err(\"A key option with a unique string value must be provided when creating an atom.\");\n        }\n    }\n    const { ...restOptions } = options;\n    const optionsDefault = \"default\" in options ? options.default : new Promise(()=>{});\n    if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n    ) {\n        return atomWithFallback({\n            ...restOptions,\n            default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n        }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n    } else {\n        return baseAtom({\n            ...restOptions,\n            default: optionsDefault\n        });\n    }\n}\nfunction atomWithFallback(options) {\n    const base = atom({\n        ...options,\n        default: DEFAULT_VALUE$7,\n        persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : {\n            ...options.persistence_UNSTABLE,\n            validator: (storedValue)=>storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n        },\n        // TODO Hack for now.\n        effects: options.effects,\n        // flowlint-line unclear-type: off\n        effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n    });\n    const sel = Recoil_selector({\n        key: `${options.key}__withFallback`,\n        get: ({ get  })=>{\n            const baseValue = get(base);\n            return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n        },\n        set: ({ set  }, newValue)=>set(base, newValue),\n        // This selector does not need to cache as it is a wrapper selector\n        // and the selector within the wrapper selector will have a cache\n        // option by default\n        cachePolicy_UNSTABLE: {\n            eviction: \"most-recent\"\n        },\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability\n    });\n    setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n    return sel;\n} // $FlowFixMe[missing-local-annot]\natom.value = (value)=>new WrappedValue$2(value);\nvar Recoil_atom = atom;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */ class MapCache {\n    constructor(options){\n        var _options$mapKey;\n        _defineProperty(this, \"_map\", void 0);\n        _defineProperty(this, \"_keyMapper\", void 0);\n        this._map = new Map();\n        this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v)=>v;\n    }\n    size() {\n        return this._map.size;\n    }\n    has(key) {\n        return this._map.has(this._keyMapper(key));\n    }\n    get(key) {\n        return this._map.get(this._keyMapper(key));\n    }\n    set(key, val) {\n        this._map.set(this._keyMapper(key), val);\n    }\n    delete(key) {\n        this._map.delete(this._keyMapper(key));\n    }\n    clear() {\n        this._map.clear();\n    }\n}\nvar Recoil_MapCache = {\n    MapCache\n};\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\nvar Recoil_MapCache$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    MapCache: Recoil_MapCache_1\n});\nconst { LRUCache: LRUCache$2  } = Recoil_LRUCache$1;\nconst { MapCache: MapCache$1  } = Recoil_MapCache$1;\nconst defaultPolicy$1 = {\n    equality: \"reference\",\n    eviction: \"none\",\n    maxSize: Infinity\n};\nfunction cacheFromPolicy({ equality =defaultPolicy$1.equality , eviction =defaultPolicy$1.eviction , maxSize =defaultPolicy$1.maxSize  } = defaultPolicy$1) {\n    const valueMapper = getValueMapper$1(equality);\n    const cache = getCache(eviction, maxSize, valueMapper);\n    return cache;\n}\nfunction getValueMapper$1(equality) {\n    switch(equality){\n        case \"reference\":\n            return (val)=>val;\n        case \"value\":\n            return (val)=>Recoil_stableStringify(val);\n    }\n    throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\nfunction getCache(eviction, maxSize, mapKey) {\n    switch(eviction){\n        case \"keep-all\":\n            return new MapCache$1({\n                mapKey\n            });\n        case \"lru\":\n            return new LRUCache$2({\n                mapKey,\n                maxSize: Recoil_nullthrows(maxSize)\n            });\n        case \"most-recent\":\n            return new LRUCache$2({\n                mapKey,\n                maxSize: 1\n            });\n    }\n    throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\nvar Recoil_cacheFromPolicy = cacheFromPolicy;\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\nconst { setConfigDeletionHandler: setConfigDeletionHandler$2  } = Recoil_Node;\n// Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/ function atomFamily(options) {\n    var _options$cachePolicyF, _options$cachePolicyF2;\n    const atomCache = Recoil_cacheFromPolicy({\n        equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : \"value\",\n        eviction: \"keep-all\"\n    }); // Simple atomFamily implementation to cache individual atoms based\n    // on the parameter value equality.\n    return (params)=>{\n        var _stableStringify, _options$effects;\n        const cachedAtom = atomCache.get(params);\n        if (cachedAtom != null) {\n            return cachedAtom;\n        }\n        const { cachePolicyForParams_UNSTABLE , ...atomOptions } = options;\n        const optionsDefault = \"default\" in options ? options.default : new Promise(()=>{});\n        const newAtom = Recoil_atom({\n            ...atomOptions,\n            key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : \"void\"}`,\n            default: typeof optionsDefault === \"function\" ? // Flow doesn't know that T isn't a function, so we need to case to any\n            // $FlowIssue[incompatible-use]\n            optionsDefault(params) : optionsDefault,\n            retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === \"function\" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n            effects: typeof options.effects === \"function\" ? options.effects(params) : typeof options.effects_UNSTABLE === \"function\" ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n        });\n        atomCache.set(params, newAtom);\n        setConfigDeletionHandler$2(newAtom.key, ()=>{\n            atomCache.delete(params);\n        });\n        return newAtom;\n    };\n}\nvar Recoil_atomFamily = atomFamily;\nconst { setConfigDeletionHandler: setConfigDeletionHandler$3  } = Recoil_Node;\n// Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */ // Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\nfunction selectorFamily(options) {\n    var _options$cachePolicyF, _options$cachePolicyF2;\n    const selectorCache = Recoil_cacheFromPolicy({\n        equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : \"value\",\n        eviction: \"keep-all\"\n    });\n    return (params)=>{\n        var _stableStringify;\n        // Throw an error with selector key so that it is clear which\n        // selector is causing an error\n        let cachedSelector;\n        try {\n            cachedSelector = selectorCache.get(params);\n        } catch (error) {\n            throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n        }\n        if (cachedSelector != null) {\n            return cachedSelector;\n        }\n        const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n            // It is possible to use functions in parameters if the user uses\n            // a cache with reference equality thanks to the incrementing index.\n            allowFunctions: true\n        })) !== null && _stableStringify !== void 0 ? _stableStringify : \"void\"}/${nextIndex++}`; // Append index in case values serialize to the same key string\n        const myGet = (callbacks)=>options.get(params)(callbacks);\n        const myCachePolicy = options.cachePolicy_UNSTABLE;\n        const retainedBy = typeof options.retainedBy_UNSTABLE === \"function\" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n        let newSelector;\n        if (options.set != null) {\n            const set = options.set;\n            const mySet = (callbacks, newValue)=>set(params)(callbacks, newValue);\n            newSelector = Recoil_selector({\n                key: myKey,\n                get: myGet,\n                set: mySet,\n                cachePolicy_UNSTABLE: myCachePolicy,\n                dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n                retainedBy_UNSTABLE: retainedBy\n            });\n        } else {\n            newSelector = Recoil_selector({\n                key: myKey,\n                get: myGet,\n                cachePolicy_UNSTABLE: myCachePolicy,\n                dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n                retainedBy_UNSTABLE: retainedBy\n            });\n        }\n        selectorCache.set(params, newSelector);\n        setConfigDeletionHandler$3(newSelector.key, ()=>{\n            selectorCache.delete(params);\n        });\n        return newSelector;\n    };\n}\n/* eslint-enable no-redeclare */ var Recoil_selectorFamily = selectorFamily;\n// flowlint-next-line unclear-type:off\nconst constantSelector = Recoil_selectorFamily({\n    key: \"__constant\",\n    get: (constant)=>()=>constant,\n    cachePolicyForParams_UNSTABLE: {\n        equality: \"reference\"\n    }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\nfunction constSelector(constant) {\n    return constantSelector(constant);\n}\nvar Recoil_constSelector = constSelector;\n// flowlint-next-line unclear-type:off\nconst throwingSelector = Recoil_selectorFamily({\n    key: \"__error\",\n    get: (message)=>()=>{\n            throw Recoil_err(message);\n        },\n    // TODO Why?\n    cachePolicyForParams_UNSTABLE: {\n        equality: \"reference\"\n    }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\nfunction errorSelector(message) {\n    return throwingSelector(message);\n}\nvar Recoil_errorSelector = errorSelector;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */ function readOnlySelector(atom) {\n    // flowlint-next-line unclear-type: off\n    return atom;\n}\nvar Recoil_readOnlySelector = readOnlySelector;\nconst { loadableWithError: loadableWithError$3 , loadableWithPromise: loadableWithPromise$3 , loadableWithValue: loadableWithValue$4  } = Recoil_Loadable$1;\n/////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\nfunction concurrentRequests(getRecoilValue, deps) {\n    const results = Array(deps.length).fill(undefined);\n    const exceptions = Array(deps.length).fill(undefined);\n    for (const [i, dep] of deps.entries()){\n        try {\n            results[i] = getRecoilValue(dep);\n        } catch (e) {\n            // exceptions can either be Promises of pending results or real errors\n            exceptions[i] = e;\n        }\n    }\n    return [\n        results,\n        exceptions\n    ];\n}\nfunction isError(exp) {\n    return exp != null && !Recoil_isPromise(exp);\n}\nfunction unwrapDependencies(dependencies) {\n    return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key)=>dependencies[key]);\n}\nfunction wrapResults(dependencies, /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */ results) {\n    return Array.isArray(dependencies) ? results : Object.getOwnPropertyNames(dependencies).reduce((out, key, idx)=>({\n            ...out,\n            [key]: results[idx]\n        }), {});\n}\nfunction wrapLoadables(dependencies, results, exceptions) {\n    const output = exceptions.map((exception, idx)=>exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    return wrapResults(dependencies, output);\n}\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n    return asyncResults.map((result, idx)=>/**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */ result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\nconst waitForNone = Recoil_selectorFamily({\n    key: \"__waitForNone\",\n    get: (dependencies)=>({ get  })=>{\n            // Issue requests for all dependencies in parallel.\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n            return wrapLoadables(dependencies, results, exceptions);\n        },\n    dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\nconst waitForAny = Recoil_selectorFamily({\n    key: \"__waitForAny\",\n    get: (dependencies)=>({ get  })=>{\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n            if (exceptions.some((exp)=>!Recoil_isPromise(exp))) {\n                return wrapLoadables(dependencies, results, exceptions);\n            } // Otherwise, return a promise that will resolve when the next result is\n            // available, whichever one happens to be next.  But, if all pending\n            // dependencies end up with errors, then reject the promise.\n            return new Promise((resolve)=>{\n                for (const [i, exp] of exceptions.entries()){\n                    if (Recoil_isPromise(exp)) {\n                        exp.then((result)=>{\n                            results[i] = result;\n                            exceptions[i] = undefined;\n                            resolve(wrapLoadables(dependencies, results, exceptions));\n                        }).catch((error)=>{\n                            exceptions[i] = error;\n                            resolve(wrapLoadables(dependencies, results, exceptions));\n                        });\n                    }\n                }\n            });\n        },\n    dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\nconst waitForAll = Recoil_selectorFamily({\n    key: \"__waitForAll\",\n    get: (dependencies)=>({ get  })=>{\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n            if (exceptions.every((exp)=>exp == null)) {\n                return wrapResults(dependencies, results);\n            } // If we have any errors, throw the first error\n            const error = exceptions.find(isError);\n            if (error != null) {\n                throw error;\n            } // Otherwise, return a promise that will resolve when all results are available\n            return Promise.all(exceptions).then((exceptionResults)=>wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n        },\n    dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n    key: \"__waitForAllSettled\",\n    get: (dependencies)=>({ get  })=>{\n            // Issue requests for all dependencies in parallel.\n            // Exceptions can either be Promises of pending results or real errors\n            const deps = unwrapDependencies(dependencies);\n            const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n            if (exceptions.every((exp)=>!Recoil_isPromise(exp))) {\n                return wrapLoadables(dependencies, results, exceptions);\n            } // Wait for all results to settle\n            return Promise.all(exceptions.map((exp, i)=>Recoil_isPromise(exp) ? exp.then((result)=>{\n                    results[i] = result;\n                    exceptions[i] = undefined;\n                }).catch((error)=>{\n                    results[i] = undefined;\n                    exceptions[i] = error;\n                }) : null)) // Then wrap them as loadables\n            .then(()=>wrapLoadables(dependencies, results, exceptions));\n        },\n    dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n    key: \"__noWait\",\n    get: (dependency)=>({ get  })=>{\n            try {\n                return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n            } catch (exception) {\n                return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n            }\n        },\n    dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n    waitForNone,\n    waitForAny,\n    waitForAll,\n    waitForAllSettled,\n    noWait\n};\nconst { RecoilLoadable  } = Recoil_Loadable$1;\nconst { DefaultValue: DefaultValue$3  } = Recoil_Node;\nconst { RecoilRoot: RecoilRoot$2 , useRecoilStoreID: useRecoilStoreID$1  } = Recoil_RecoilRoot;\nconst { isRecoilValue: isRecoilValue$5  } = Recoil_RecoilValue$1;\nconst { retentionZone: retentionZone$1  } = Recoil_RetentionZone;\nconst { freshSnapshot: freshSnapshot$2  } = Recoil_Snapshot$1;\nconst { useRecoilState: useRecoilState$1 , useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1 , useRecoilStateLoadable: useRecoilStateLoadable$1 , useRecoilValue: useRecoilValue$1 , useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1 , useRecoilValueLoadable: useRecoilValueLoadable$1 , useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1 , useResetRecoilState: useResetRecoilState$1 , useSetRecoilState: useSetRecoilState$1  } = Recoil_Hooks;\nconst { useGotoRecoilSnapshot: useGotoRecoilSnapshot$1 , useRecoilSnapshot: useRecoilSnapshot$1 , useRecoilTransactionObserver: useRecoilTransactionObserver$1  } = Recoil_SnapshotHooks;\nconst { useRecoilCallback: useRecoilCallback$1  } = Recoil_useRecoilCallback;\nconst { noWait: noWait$1 , waitForAll: waitForAll$1 , waitForAllSettled: waitForAllSettled$1 , waitForAny: waitForAny$1 , waitForNone: waitForNone$1  } = Recoil_WaitFor;\nvar Recoil_index = {\n    // Types\n    DefaultValue: DefaultValue$3,\n    isRecoilValue: isRecoilValue$5,\n    RecoilLoadable,\n    // Global Recoil environment settiongs\n    RecoilEnv: Recoil_RecoilEnv,\n    // Recoil Root\n    RecoilRoot: RecoilRoot$2,\n    useRecoilStoreID: useRecoilStoreID$1,\n    useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n    // Atoms/Selectors\n    atom: Recoil_atom,\n    selector: Recoil_selector,\n    // Convenience Atoms/Selectors\n    atomFamily: Recoil_atomFamily,\n    selectorFamily: Recoil_selectorFamily,\n    constSelector: Recoil_constSelector,\n    errorSelector: Recoil_errorSelector,\n    readOnlySelector: Recoil_readOnlySelector,\n    // Concurrency Helpers for Atoms/Selectors\n    noWait: noWait$1,\n    waitForNone: waitForNone$1,\n    waitForAny: waitForAny$1,\n    waitForAll: waitForAll$1,\n    waitForAllSettled: waitForAllSettled$1,\n    // Hooks for Atoms/Selectors\n    useRecoilValue: useRecoilValue$1,\n    useRecoilValueLoadable: useRecoilValueLoadable$1,\n    useRecoilState: useRecoilState$1,\n    useRecoilStateLoadable: useRecoilStateLoadable$1,\n    useSetRecoilState: useSetRecoilState$1,\n    useResetRecoilState: useResetRecoilState$1,\n    useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n    useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n    useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n    // Hooks for complex operations\n    useRecoilCallback: useRecoilCallback$1,\n    useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n    // Snapshots\n    useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n    useRecoilSnapshot: useRecoilSnapshot$1,\n    useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n    snapshot_UNSTABLE: freshSnapshot$2,\n    // Memory Management\n    useRetain: Recoil_useRetain,\n    retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilEnv;\nvar Recoil_index_5 = Recoil_index.RecoilRoot;\nvar Recoil_index_6 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_8 = Recoil_index.atom;\nvar Recoil_index_9 = Recoil_index.selector;\nvar Recoil_index_10 = Recoil_index.atomFamily;\nvar Recoil_index_11 = Recoil_index.selectorFamily;\nvar Recoil_index_12 = Recoil_index.constSelector;\nvar Recoil_index_13 = Recoil_index.errorSelector;\nvar Recoil_index_14 = Recoil_index.readOnlySelector;\nvar Recoil_index_15 = Recoil_index.noWait;\nvar Recoil_index_16 = Recoil_index.waitForNone;\nvar Recoil_index_17 = Recoil_index.waitForAny;\nvar Recoil_index_18 = Recoil_index.waitForAll;\nvar Recoil_index_19 = Recoil_index.waitForAllSettled;\nvar Recoil_index_20 = Recoil_index.useRecoilValue;\nvar Recoil_index_21 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_22 = Recoil_index.useRecoilState;\nvar Recoil_index_23 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_24 = Recoil_index.useSetRecoilState;\nvar Recoil_index_25 = Recoil_index.useResetRecoilState;\nvar Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_31 = Recoil_index.useRecoilCallback;\nvar Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_37 = Recoil_index.useRetain;\nvar Recoil_index_38 = Recoil_index.retentionZone;\nexports.DefaultValue = Recoil_index_1;\nexports.RecoilEnv = Recoil_index_4;\nexports.RecoilLoadable = Recoil_index_3;\nexports.RecoilRoot = Recoil_index_5;\nexports.atom = Recoil_index_8;\nexports.atomFamily = Recoil_index_10;\nexports.constSelector = Recoil_index_12;\nexports[\"default\"] = Recoil_index;\nexports.errorSelector = Recoil_index_13;\nexports.isRecoilValue = Recoil_index_2;\nexports.noWait = Recoil_index_15;\nexports.readOnlySelector = Recoil_index_14;\nexports.retentionZone = Recoil_index_38;\nexports.selector = Recoil_index_9;\nexports.selectorFamily = Recoil_index_11;\nexports.snapshot_UNSTABLE = Recoil_index_36;\nexports.useGetRecoilValueInfo_UNSTABLE = Recoil_index_26;\nexports.useGotoRecoilSnapshot = Recoil_index_33;\nexports.useRecoilBridgeAcrossReactRoots_UNSTABLE = Recoil_index_7;\nexports.useRecoilCallback = Recoil_index_31;\nexports.useRecoilRefresher_UNSTABLE = Recoil_index_27;\nexports.useRecoilSnapshot = Recoil_index_34;\nexports.useRecoilState = Recoil_index_22;\nexports.useRecoilStateLoadable = Recoil_index_23;\nexports.useRecoilState_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_30;\nexports.useRecoilStoreID = Recoil_index_6;\nexports.useRecoilTransactionObserver_UNSTABLE = Recoil_index_35;\nexports.useRecoilTransaction_UNSTABLE = Recoil_index_32;\nexports.useRecoilValue = Recoil_index_20;\nexports.useRecoilValueLoadable = Recoil_index_21;\nexports.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_28;\nexports.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_29;\nexports.useResetRecoilState = Recoil_index_25;\nexports.useRetain = Recoil_index_37;\nexports.useSetRecoilState = Recoil_index_24;\nexports.waitForAll = Recoil_index_18;\nexports.waitForAllSettled = Recoil_index_19;\nexports.waitForAny = Recoil_index_17;\nexports.waitForNone = Recoil_index_16;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2Nqcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTyxJQUFJO0FBQUMsQ0FBQyxFQUFDO0FBRTdELFNBQVNDLGdCQUFpQkMsRUFBRSxFQUFFO0lBQUUsT0FBTyxNQUFRLE9BQU9BLE9BQU8sWUFBYSxhQUFhQSxLQUFNQSxFQUFFLENBQUMsVUFBVSxHQUFHQSxFQUFFO0FBQUU7QUFFakgsSUFBSUMsUUFBUUYsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUNwQyxJQUFJQyxXQUFXSixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBRXZDOzs7Ozs7Ozs7Q0FTQyxHQUVELFNBQVNFLElBQUlDLE9BQU8sRUFBRTtJQUNwQixNQUFNQyxRQUFRLElBQUlDLE1BQU1GLFVBQVUsb0VBQW9FO0lBQ3RHLGtDQUFrQztJQUVsQyxJQUFJQyxNQUFNRSxLQUFLLEtBQUtDLFdBQVc7UUFDN0IsNENBQTRDO1FBQzVDLElBQUk7WUFDRixNQUFNSCxNQUFNO1FBQ2QsRUFBRSxPQUFPSSxHQUFHLENBQUMsRUFBRSxnRUFBZ0U7SUFFakYsQ0FBQztJQUVELE9BQU9KO0FBQ1Q7QUFFQSxJQUFJSyxRQUFRUDtBQUVaLFlBQVk7QUFHWixJQUFJUSxhQUFhRDtBQUVqQjs7Ozs7Ozs7O0NBU0MsR0FFRCw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLFVBQVU7QUFDVix3Q0FBd0M7QUFDeEMsU0FBU0UsVUFBVUMsQ0FBQyxFQUFFO0lBQ3BCLE9BQU8sQ0FBQyxDQUFDQSxLQUFLLE9BQU9BLEVBQUVDLElBQUksS0FBSztBQUNsQztBQUVBLElBQUlDLG1CQUFtQkg7QUFFdkIsU0FBU0ksV0FBV0MsQ0FBQyxFQUFFYixPQUFPLEVBQUU7SUFDOUIsSUFBSWEsS0FBSyxJQUFJLEVBQUU7UUFDYixPQUFPQTtJQUNULENBQUM7SUFFRCxNQUFNTixXQUFXUCxZQUFZLElBQUksSUFBSUEsWUFBWSxLQUFLLElBQUlB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QUc2N0M7QUFDckQ3N0MsMkJBQTJCLEdBQUd5N0M7QUFDOUJ6N0MsaUJBQWlCLEdBQUdxOEM7QUFDcEJyOEMseUJBQXlCLEdBQUd3N0M7QUFDNUJ4N0Msa0JBQWtCLEdBQUdrN0M7QUFDckJsN0MseUJBQXlCLEdBQUdtN0M7QUFDNUJuN0Msa0JBQWtCLEdBQUdpN0M7QUFDckJqN0MsbUJBQW1CLEdBQUdnN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL3JlY29pbC9janMvaW5kZXguanM/MTc0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgcmVhY3QgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmVhY3QnKSk7XG52YXIgcmVhY3REb20gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmVhY3QtZG9tJykpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGVycihtZXNzYWdlKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBJbiBWOCwgRXJyb3Igb2JqZWN0cyBrZWVwIHRoZSBjbG9zdXJlIHNjb3BlIGNoYWluIGFsaXZlIHVudGlsIHRoZVxuICAvLyBlcnIuc3RhY2sgcHJvcGVydHkgaXMgYWNjZXNzZWQuXG5cbiAgaWYgKGVycm9yLnN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBJRSBzZXRzIHRoZSBzdGFjayBvbmx5IGlmIGVycm9yIGlzIHRocm93blxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGNhdGNoIChfKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9uby11bnVzZWQtY2F0Y2gtYmluZGluZ3MsIG5vLWVtcHR5XG5cbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn1cblxudmFyIGVycl8xID0gZXJyO1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2VyciA9IGVycl8xO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG4vLyBTcGxpdCBkZWNsYXJhdGlvbiBhbmQgaW1wbGVtZW50YXRpb24gdG8gYWxsb3cgdGhpcyBmdW5jdGlvbiB0byBwcmV0ZW5kIHRvXG4vLyBjaGVjayBmb3IgYWN0dWFsIGluc3RhbmNlIG9mIFByb21pc2UgaW5zdGVhZCBvZiBzb21ldGhpbmcgd2l0aCBhIGB0aGVuYFxuLy8gbWV0aG9kLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuICEhcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgUmVjb2lsX2lzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gbnVsbHRocm93cyh4LCBtZXNzYWdlKSB7XG4gIGlmICh4ICE9IG51bGwpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ0dvdCB1bmV4cGVjdGVkIG51bGwgb3IgdW5kZWZpbmVkJyk7XG59XG5cbnZhciBSZWNvaWxfbnVsbHRocm93cyA9IG51bGx0aHJvd3M7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5jbGFzcyBCYXNlTG9hZGFibGUge1xuICBnZXRWYWx1ZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB2YWx1ZU9yVGhyb3coKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgdmFsdWUsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgcHJvbWlzZU1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgcHJvbWlzZU9yVGhyb3coKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgcHJvbWlzZSwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBlcnJvck1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgZXJyb3JPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIGVycm9yLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIGlzKG90aGVyKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgcmV0dXJuIG90aGVyLnN0YXRlID09PSB0aGlzLnN0YXRlICYmIG90aGVyLmNvbnRlbnRzID09PSB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgbWFwKF9tYXApIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG59XG5cbmNsYXNzIFZhbHVlTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzVmFsdWUnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gdmFsdWU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29udGVudHMpO1xuICB9XG5cbiAgdmFsdWVNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHZhbHVlT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbWFwKG1hcCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHRoaXMuY29udGVudHMpO1xuICAgICAgcmV0dXJuIFJlY29pbF9pc1Byb21pc2UobmV4dCkgPyBsb2FkYWJsZVdpdGhQcm9taXNlKG5leHQpIDogaXNMb2FkYWJsZShuZXh0KSA/IG5leHQgOiBsb2FkYWJsZVdpdGhWYWx1ZShuZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShlKSA/IC8vIElmIHdlIFwic3VzcGVuZGVkXCIsIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgLy8gZXJyb3JzIGFuZCBzdWJzZXF1ZW50IHJldHJpZXMgd2lsbCBiZSBoYW5kbGVkIGluICdsb2FkaW5nJyBjYXNlXG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIGxvYWRhYmxlV2l0aFByb21pc2UoZS5uZXh0KCgpID0+IHRoaXMubWFwKG1hcCkpKSA6IGxvYWRhYmxlV2l0aEVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIEVycm9yTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xuICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzRXJyb3InKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gZXJyb3I7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB0aHJvdyB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNvbnRlbnRzKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIGVycm9yT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIG1hcChfbWFwKSB7XG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cblxuY2xhc3MgTG9hZGluZ0xvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJvbWlzZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnbG9hZGluZycpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY29udGVudHMgPSBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHByb21pc2VPclRocm93KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbWFwKG1hcCkge1xuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlKHRoaXMuY29udGVudHMudGhlbih2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHZhbHVlKTtcblxuICAgICAgaWYgKGlzTG9hZGFibGUobmV4dCkpIHtcbiAgICAgICAgY29uc3QgbmV4dExvYWRhYmxlID0gbmV4dDtcblxuICAgICAgICBzd2l0Y2ggKG5leHRMb2FkYWJsZS5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ2hhc1ZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXh0TG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgICBjYXNlICdoYXNFcnJvcic6XG4gICAgICAgICAgICB0aHJvdyBuZXh0TG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgICBjYXNlICdsb2FkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXh0TG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZSkpIHtcbiAgICAgICAgLy8gd2Ugd2VyZSBcInN1c3BlbmRlZCxcIiB0cnkgYWdhaW5cbiAgICAgICAgcmV0dXJuIGUudGhlbigoKSA9PiB0aGlzLm1hcChtYXApLmNvbnRlbnRzKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9KSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgVmFsdWVMb2FkYWJsZSh2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgRXJyb3JMb2FkYWJsZShlcnJvcikpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhQcm9taXNlKHByb21pc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShwcm9taXNlKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlTG9hZGluZygpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShuZXcgUHJvbWlzZSgoKSA9PiB7fSkpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVBbGxBcnJheShpbnB1dHMpIHtcbiAgcmV0dXJuIGlucHV0cy5ldmVyeShpID0+IGkuc3RhdGUgPT09ICdoYXNWYWx1ZScpID8gbG9hZGFibGVXaXRoVmFsdWUoaW5wdXRzLm1hcChpID0+IGkuY29udGVudHMpKSA6IGlucHV0cy5zb21lKGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykgPyBsb2FkYWJsZVdpdGhFcnJvcihSZWNvaWxfbnVsbHRocm93cyhpbnB1dHMuZmluZChpID0+IGkuc3RhdGUgPT09ICdoYXNFcnJvcicpLCAnSW52YWxpZCBsb2FkYWJsZSBwYXNzZWQgdG8gbG9hZGFibGVBbGwnKS5jb250ZW50cykgOiBsb2FkYWJsZVdpdGhQcm9taXNlKFByb21pc2UuYWxsKGlucHV0cy5tYXAoaSA9PiBpLmNvbnRlbnRzKSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUFsbChpbnB1dHMpIHtcbiAgY29uc3QgdW53cmFwZWRJbnB1dHMgPSBBcnJheS5pc0FycmF5KGlucHV0cykgPyBpbnB1dHMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLm1hcChrZXkgPT4gaW5wdXRzW2tleV0pO1xuICBjb25zdCBub3JtYWxpemVkSW5wdXRzID0gdW53cmFwZWRJbnB1dHMubWFwKHggPT4gaXNMb2FkYWJsZSh4KSA/IHggOiBSZWNvaWxfaXNQcm9taXNlKHgpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh4KSA6IGxvYWRhYmxlV2l0aFZhbHVlKHgpKTtcbiAgY29uc3Qgb3V0cHV0ID0gbG9hZGFibGVBbGxBcnJheShub3JtYWxpemVkSW5wdXRzKTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgb3V0cHV0IDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgb3V0cHV0Lm1hcChvdXRwdXRzID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGlucHV0cykucmVkdWNlKChvdXQsIGtleSwgaWR4KSA9PiAoeyAuLi5vdXQsXG4gICAgW2tleV06IG91dHB1dHNbaWR4XVxuICB9KSwge30pKTtcbn1cblxuZnVuY3Rpb24gaXNMb2FkYWJsZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgQmFzZUxvYWRhYmxlO1xufVxuXG5jb25zdCBMb2FkYWJsZVN0YXRpY0ludGVyZmFjZSA9IHtcbiAgb2Y6IHZhbHVlID0+IFJlY29pbF9pc1Byb21pc2UodmFsdWUpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh2YWx1ZSkgOiBpc0xvYWRhYmxlKHZhbHVlKSA/IHZhbHVlIDogbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpLFxuICBlcnJvcjogZXJyb3IgPT4gbG9hZGFibGVXaXRoRXJyb3IoZXJyb3IpLFxuICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gIGxvYWRpbmc6ICgpID0+IGxvYWRhYmxlTG9hZGluZygpLFxuICAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cbiAgYWxsOiBsb2FkYWJsZUFsbCxcbiAgaXNMb2FkYWJsZVxufTtcbnZhciBSZWNvaWxfTG9hZGFibGUgPSB7XG4gIGxvYWRhYmxlV2l0aFZhbHVlLFxuICBsb2FkYWJsZVdpdGhFcnJvcixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZSxcbiAgbG9hZGFibGVMb2FkaW5nLFxuICBsb2FkYWJsZUFsbCxcbiAgaXNMb2FkYWJsZSxcbiAgUmVjb2lsTG9hZGFibGU6IExvYWRhYmxlU3RhdGljSW50ZXJmYWNlXG59O1xuXG52YXIgUmVjb2lsX0xvYWRhYmxlXzEgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVXaXRoVmFsdWU7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzIgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVXaXRoRXJyb3I7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzMgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVXaXRoUHJvbWlzZTtcbnZhciBSZWNvaWxfTG9hZGFibGVfNCA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUxvYWRpbmc7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzUgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVBbGw7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzYgPSBSZWNvaWxfTG9hZGFibGUuaXNMb2FkYWJsZTtcbnZhciBSZWNvaWxfTG9hZGFibGVfNyA9IFJlY29pbF9Mb2FkYWJsZS5SZWNvaWxMb2FkYWJsZTtcblxudmFyIFJlY29pbF9Mb2FkYWJsZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBSZWNvaWxfTG9hZGFibGVfMSxcbiAgbG9hZGFibGVXaXRoRXJyb3I6IFJlY29pbF9Mb2FkYWJsZV8yLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBSZWNvaWxfTG9hZGFibGVfMyxcbiAgbG9hZGFibGVMb2FkaW5nOiBSZWNvaWxfTG9hZGFibGVfNCxcbiAgbG9hZGFibGVBbGw6IFJlY29pbF9Mb2FkYWJsZV81LFxuICBpc0xvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfNixcbiAgUmVjb2lsTG9hZGFibGU6IFJlY29pbF9Mb2FkYWJsZV83XG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuY29uc3QgZ2tzID0gbmV3IE1hcCgpLnNldCgncmVjb2lsX2hhbXRfMjAyMCcsIHRydWUpLnNldCgncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnLCB0cnVlKS5zZXQoJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycsIHRydWUpLnNldCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnLCB0cnVlKTtcblxuZnVuY3Rpb24gUmVjb2lsX2dreF9PU1MoZ2spIHtcbiAgdmFyIF9na3MkZ2V0O1xuXG4gIHJldHVybiAoX2drcyRnZXQgPSBna3MuZ2V0KGdrKSkgIT09IG51bGwgJiYgX2drcyRnZXQgIT09IHZvaWQgMCA/IF9na3MkZ2V0IDogZmFsc2U7XG59XG5cblJlY29pbF9na3hfT1NTLnNldFBhc3MgPSBnayA9PiB7XG4gIGdrcy5zZXQoZ2ssIHRydWUpO1xufTtcblxuUmVjb2lsX2dreF9PU1Muc2V0RmFpbCA9IGdrID0+IHtcbiAgZ2tzLnNldChnaywgZmFsc2UpO1xufTtcblxuUmVjb2lsX2dreF9PU1MuY2xlYXIgPSAoKSA9PiB7XG4gIGdrcy5jbGVhcigpO1xufTtcblxudmFyIFJlY29pbF9na3ggPSBSZWNvaWxfZ2t4X09TUzsgLy8gQG9zcy1vbmx5XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XG4gIGVycm9yXG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZWNvdmVyYWJsZVZpb2xhdGlvbl8xID0gcmVjb3ZlcmFibGVWaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xuXG52YXIgX2NyZWF0ZU11dGFibGVTb3VyY2UsIF91c2VNdXRhYmxlU291cmNlLCBfdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cblxuXG5cblxuXG5cbmNvbnN0IGNyZWF0ZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF9jcmVhdGVNdXRhYmxlU291cmNlID0gcmVhY3QuY3JlYXRlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX2NyZWF0ZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF9jcmVhdGVNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfY3JlYXRlTXV0YWJsZVNvdXJjZTtcbmNvbnN0IHVzZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF91c2VNdXRhYmxlU291cmNlID0gcmVhY3QudXNlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX3VzZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF91c2VNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODZcblxuY29uc3QgdXNlU3luY0V4dGVybmFsU3RvcmUgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKSAhPT0gbnVsbCAmJiBfdXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5yZWFjdC51bnN0YWJsZV91c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbmxldCBSZWFjdFJlbmRlcmVyVmVyc2lvbk1pc21hdGNoV2Fybk9uY2UgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydHMgYHVzZVN5bmNFeHRlcm5hbFN0b3JlKClgLlxuLy8gU2luY2UgUmVhY3QgZ29lcyB0aHJvdWdoIGEgcHJveHkgZGlzcGF0Y2hlciBhbmQgdGhlIGN1cnJlbnQgcmVuZGVyZXIgY2FuXG4vLyBjaGFuZ2Ugd2UgY2FuJ3Qgc2ltcGx5IGNoZWNrIGlmIGBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSgpYCBpcyBkZWZpbmVkLlxuXG5mdW5jdGlvbiBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlKCkge1xuICB2YXIgX1JlYWN0Q3VycmVudERpc3BhdGNoO1xuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgY29uc3Qge1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXJcbiAgfSA9XG4gIC8qICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBUaGlzIHdvcmthcm91bmQgd2FzIGFwcHJvdmVkIGFzIGEgc2FmZXIgbWVjaGFuaXNtXG4gICAqIHRvIGRldGVjdCBpZiB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0cyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSgpXG4gICAqIGh0dHBzOi8vZmIud29ya3BsYWNlLmNvbS9ncm91cHMvcmVhY3Rqcy9wb3N0cy85NTU4NjgyMzMwODQ2OTYzLyAqL1xuICByZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IChfUmVhY3RDdXJyZW50RGlzcGF0Y2ggPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID09PSBudWxsIHx8IFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCkgIT09IG51bGwgJiYgX1JlYWN0Q3VycmVudERpc3BhdGNoICE9PSB2b2lkIDAgPyBfUmVhY3RDdXJyZW50RGlzcGF0Y2ggOiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50RGlzcGF0Y2hlcjtcbiAgY29uc3QgaXNVc2VTeW5jRXh0ZXJuYWxTdG9yZVN1cHBvcnRlZCA9IGRpc3BhdGNoZXIudXNlU3luY0V4dGVybmFsU3RvcmUgIT0gbnVsbDtcblxuICBpZiAodXNlU3luY0V4dGVybmFsU3RvcmUgJiYgIWlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQgJiYgIVJlYWN0UmVuZGVyZXJWZXJzaW9uTWlzbWF0Y2hXYXJuT25jZSkge1xuICAgIFJlYWN0UmVuZGVyZXJWZXJzaW9uTWlzbWF0Y2hXYXJuT25jZSA9IHRydWU7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBIFJlYWN0IHJlbmRlcmVyIHdpdGhvdXQgUmVhY3QgMTgrIEFQSSBzdXBwb3J0IGlzIGJlaW5nIHVzZWQgd2l0aCBSZWFjdCAxOCsuJyk7XG4gIH1cblxuICByZXR1cm4gaXNVc2VTeW5jRXh0ZXJuYWxTdG9yZVN1cHBvcnRlZDtcbn1cblxuLyoqXG4gKiBtb2RlOiBUaGUgUmVhY3QgQVBJIGFuZCBhcHByb2FjaCB0byB1c2UgZm9yIHN5bmNpbmcgc3RhdGUgd2l0aCBSZWFjdFxuICogZWFybHk6IFJlLXJlbmRlcnMgZnJvbSBSZWNvaWwgdXBkYXRlcyBvY2N1cjpcbiAqICAgIDEpIGVhcmxpZXJcbiAqICAgIDIpIGluIHN5bmMgd2l0aCBSZWFjdCB1cGRhdGVzIGluIHRoZSBzYW1lIGJhdGNoXG4gKiAgICAzKSBiZWZvcmUgdHJhbnNhY3Rpb24gb2JzZXJ2ZXJzIGluc3RlYWQgb2YgYWZ0ZXIuXG4gKiBjb25jdXJyZW50OiBJcyB0aGUgY3VycmVudCBtb2RlIGNvbXBhdGlibGUgd2l0aCBDb25jdXJyZW50IE1vZGUgYW5kIHVzZVRyYW5zaXRpb24oKVxuICovXG5mdW5jdGlvbiByZWFjdE1vZGUoKSB7XG4gIC8vIE5PVEU6IFRoaXMgbW9kZSBpcyBjdXJyZW50bHkgYnJva2VuIHdpdGggc29tZSBTdXNwZW5zZSBjYXNlc1xuICAvLyBzZWUgUmVjb2lsX3NlbGVjdG9yLXRlc3QuanNcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF90cmFuc2l0aW9uX3N1cHBvcnQnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlOiAnVFJBTlNJVElPTl9TVVBQT1JUJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnKSAmJiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdTWU5DX0VYVEVSTkFMX1NUT1JFJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tdXRhYmxlX3NvdXJjZScpICYmIHVzZU11dGFibGVTb3VyY2UgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFKSB7XG4gICAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xuICAgICAgbW9kZTogJ01VVEFCTEVfU09VUkNFJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxuICAgICAgZWFybHk6IGZhbHNlLFxuICAgICAgY29uY3VycmVudDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xuICAgIG1vZGU6ICdMRUdBQ1knLFxuICAgIGVhcmx5OiB0cnVlLFxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gIH0gOiB7XG4gICAgbW9kZTogJ0xFR0FDWScsXG4gICAgZWFybHk6IGZhbHNlLFxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gIH07XG59IC8vIFRPRE8gTmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZXJlIGlzIGEgc3RhbmRhcmQvb3Blbi1zb3VyY2UgZXF1aXZhbGVudCB0byBzZWUgaWYgaG90IG1vZHVsZSByZXBsYWNlbWVudCBpcyBoYXBwZW5pbmc6XG5cblxuZnVuY3Rpb24gaXNGYXN0UmVmcmVzaEVuYWJsZWQoKSB7XG4gIC8vIEBmYi1vbmx5OiBjb25zdCB7aXNBY2NlcHRpbmdVcGRhdGV9ID0gcmVxdWlyZSgnX19kZWJ1ZycpO1xuICAvLyBAZmItb25seTogcmV0dXJuIHR5cGVvZiBpc0FjY2VwdGluZ1VwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0FjY2VwdGluZ1VwZGF0ZSgpO1xuICByZXR1cm4gZmFsc2U7IC8vIEBvc3Mtb25seVxufVxuXG52YXIgUmVjb2lsX1JlYWN0TW9kZSA9IHtcbiAgY3JlYXRlTXV0YWJsZVNvdXJjZSxcbiAgdXNlTXV0YWJsZVNvdXJjZSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUsXG4gIGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUsXG4gIHJlYWN0TW9kZSxcbiAgaXNGYXN0UmVmcmVzaEVuYWJsZWRcbn07XG5cbmNvbnN0IGVudiA9IHtcbiAgUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEOiB0cnVlXG59O1xuLyoqXG4gKiBBbGxvdyBOb2RlSlMvTmV4dEpTL2V0YyB0byBzZXQgdGhlIGluaXRpYWwgc3RhdGUgdGhyb3VnaCBwcm9jZXNzLmVudiB2YXJpYWJsZVxuICogTm90ZTogIHdlIGRvbid0IGFzc3VtZSAncHJvY2VzcycgaXMgYXZhaWxhYmxlIGluIGFsbCBydW50aW1lIGVudmlyb25tZW50c1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvNzMzXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlQcm9jZXNzRW52RmxhZ092ZXJyaWRlcygpIHtcbiAgdmFyIF9wcm9jZXNzLCBfcHJvY2VzcyRlbnYkUkVDT0lMX0QsIF9wcm9jZXNzJGVudiRSRUNPSUxfRDI7XG5cbiAgLy8gbm90ZTogdGhpcyBjaGVjayBpcyBuZWVkZWQgaW4gYWRkaXRpb24gdG8gdGhlIGNoZWNrIGJlbG93LCBydW50aW1lIGVycm9yIHdpbGwgb2NjdXIgd2l0aG91dCBpdCFcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKChfcHJvY2VzcyA9IHByb2Nlc3MpID09PSBudWxsIHx8IF9wcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvY2Vzcy5lbnYpID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IChfcHJvY2VzcyRlbnYkUkVDT0lMX0QgPSBwcm9jZXNzLmVudi5SRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQpID09PSBudWxsIHx8IF9wcm9jZXNzJGVudiRSRUNPSUxfRCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wcm9jZXNzJGVudiRSRUNPSUxfRDIgPSBfcHJvY2VzcyRlbnYkUkVDT0lMX0QudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX3Byb2Nlc3MkZW52JFJFQ09JTF9EMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2Nlc3MkZW52JFJFQ09JTF9EMi50cmltKCk7XG5cbiAgaWYgKHNhbml0aXplZFZhbHVlID09IG51bGwgfHwgc2FuaXRpemVkVmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndHJ1ZScsICdmYWxzZSddO1xuXG4gIGlmICghYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhzYW5pdGl6ZWRWYWx1ZSkpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBwcm9jZXNzLmVudi5SRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQgdmFsdWUgbXVzdCBiZSAndHJ1ZScsICdmYWxzZScsIG9yIGVtcHR5OiAke3Nhbml0aXplZFZhbHVlfWApO1xuICB9XG5cbiAgZW52LlJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRCA9IHNhbml0aXplZFZhbHVlID09PSAndHJ1ZSc7XG59XG5cbmFwcGx5UHJvY2Vzc0VudkZsYWdPdmVycmlkZXMoKTtcbnZhciBSZWNvaWxfUmVjb2lsRW52ID0gZW52O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmNsYXNzIEFic3RyYWN0UmVjb2lsVmFsdWUge1xuICBjb25zdHJ1Y3RvcihuZXdLZXkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMua2V5ID0gbmV3S2V5O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IHRoaXMua2V5XG4gICAgfTtcbiAgfVxuXG59XG5cbmNsYXNzIFJlY29pbFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxuXG5jbGFzcyBSZWNvaWxWYWx1ZVJlYWRPbmx5IGV4dGVuZHMgQWJzdHJhY3RSZWNvaWxWYWx1ZSB7fVxuXG5mdW5jdGlvbiBpc1JlY29pbFZhbHVlKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWNvaWxTdGF0ZSB8fCB4IGluc3RhbmNlb2YgUmVjb2lsVmFsdWVSZWFkT25seTtcbn1cblxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZSA9IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZSxcbiAgUmVjb2lsU3RhdGUsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHksXG4gIGlzUmVjb2lsVmFsdWVcbn07XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMSA9IFJlY29pbF9SZWNvaWxWYWx1ZS5BYnN0cmFjdFJlY29pbFZhbHVlO1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV8yID0gUmVjb2lsX1JlY29pbFZhbHVlLlJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV8zID0gUmVjb2lsX1JlY29pbFZhbHVlLlJlY29pbFZhbHVlUmVhZE9ubHk7XG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzQgPSBSZWNvaWxfUmVjb2lsVmFsdWUuaXNSZWNvaWxWYWx1ZTtcblxudmFyIFJlY29pbF9SZWNvaWxWYWx1ZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IFJlY29pbF9SZWNvaWxWYWx1ZV8xLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsX1JlY29pbFZhbHVlXzIsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbF9SZWNvaWxWYWx1ZV8zLFxuICBpc1JlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfNFxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc3ByaW50Zihmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBTdHJpbmcoYXJnc1tpbmRleCsrXSkpO1xufVxuXG52YXIgc3ByaW50Zl8xID0gc3ByaW50ZjtcblxuZnVuY3Rpb24gZXhwZWN0YXRpb25WaW9sYXRpb24oZm9ybWF0LCAuLi5hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gc3ByaW50Zl8xLmNhbGwobnVsbCwgZm9ybWF0LCAuLi5hcmdzKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5uYW1lID0gJ0V4cGVjdGF0aW9uIFZpb2xhdGlvbic7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH1cbn1cblxudmFyIGV4cGVjdGF0aW9uVmlvbGF0aW9uXzEgPSBleHBlY3RhdGlvblZpb2xhdGlvbjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbiA9IGV4cGVjdGF0aW9uVmlvbGF0aW9uXzE7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxuICogaXRlcmFibGUncyB2YWx1ZXMgdGhyb3VnaCB0aGUgbWFwcGVyIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG1hcEl0ZXJhYmxlKGl0ZXJhYmxlLCBjYWxsYmFjaykge1xuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgeWllbGQgY2FsbGJhY2sodmFsdWUsIGluZGV4KyspO1xuICAgIH1cbiAgfSgpO1xufVxuXG52YXIgUmVjb2lsX21hcEl0ZXJhYmxlID0gbWFwSXRlcmFibGU7XG5cbmNvbnN0IHtcbiAgaXNGYXN0UmVmcmVzaEVuYWJsZWQ6IGlzRmFzdFJlZnJlc2hFbmFibGVkJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XG5cbmNvbnN0IERFRkFVTFRfVkFMVUUgPSBuZXcgRGVmYXVsdFZhbHVlKCk7XG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuY29uc3Qgbm9kZXMgPSBuZXcgTWFwKCk7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcbiAgcmV0dXJuIFJlY29pbF9tYXBJdGVyYWJsZShrZXlzLCBrZXkgPT4gUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWVzLmdldChrZXkpKSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yRHVwbGljYXRlQXRvbUtleShrZXkpIHtcbiAgaWYgKG5vZGVzLmhhcyhrZXkpKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke2tleX1cIi4gVGhpcyBpcyBhIEZBVEFMIEVSUk9SIGluXG4gICAgICBwcm9kdWN0aW9uLiBCdXQgaXQgaXMgc2FmZSB0byBpZ25vcmUgdGhpcyB3YXJuaW5nIGlmIGl0IG9jY3VycmVkIGJlY2F1c2Ugb2ZcbiAgICAgIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuYDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIFRPRE8gRmlndXJlIHRoaXMgb3V0IGZvciBvcGVuLXNvdXJjZVxuICAgICAgaWYgKCFpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxKCkpIHtcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKG1lc3NhZ2UsICdyZWNvaWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKG1lc3NhZ2UsICdyZWNvaWwnKTtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTsgLy8gQG9zcy1vbmx5XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTm9kZShub2RlKSB7XG4gIGlmIChSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRCkge1xuICAgIGNoZWNrRm9yRHVwbGljYXRlQXRvbUtleShub2RlLmtleSk7XG4gIH1cblxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xuICBjb25zdCByZWNvaWxWYWx1ZSA9IG5vZGUuc2V0ID09IG51bGwgPyBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsVmFsdWVSZWFkT25seShub2RlLmtleSkgOiBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsU3RhdGUobm9kZS5rZXkpO1xuICByZWNvaWxWYWx1ZXMuc2V0KG5vZGUua2V5LCByZWNvaWxWYWx1ZSk7XG4gIHJldHVybiByZWNvaWxWYWx1ZTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxuY2xhc3MgTm9kZU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHt9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZShrZXkpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5mdW5jdGlvbiBnZXROb2RlTWF5YmUoa2V5KSB7XG4gIHJldHVybiBub2Rlcy5nZXQoa2V5KTtcbn1cblxuY29uc3QgY29uZmlnRGVsZXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUoa2V5KSB7XG4gIHZhciBfbm9kZSRzaG91bGREZWxldGVDb247XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHZvaWQgMCAmJiAoX25vZGUkc2hvdWxkRGVsZXRlQ29uID0gbm9kZS5zaG91bGREZWxldGVDb25maWdPblJlbGVhc2UpICE9PSBudWxsICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbiAhPT0gdm9pZCAwICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbi5jYWxsKG5vZGUpKSB7XG4gICAgdmFyIF9nZXRDb25maWdEZWxldGlvbkhhbjtcblxuICAgIG5vZGVzLmRlbGV0ZShrZXkpO1xuICAgIChfZ2V0Q29uZmlnRGVsZXRpb25IYW4gPSBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSkgPT09IG51bGwgfHwgX2dldENvbmZpZ0RlbGV0aW9uSGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Q29uZmlnRGVsZXRpb25IYW4oKTtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXksIGZuKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSB7XG4gIHJldHVybiBjb25maWdEZWxldGlvbkhhbmRsZXJzLmdldChrZXkpO1xufVxuXG52YXIgUmVjb2lsX05vZGUgPSB7XG4gIG5vZGVzLFxuICByZWNvaWxWYWx1ZXMsXG4gIHJlZ2lzdGVyTm9kZSxcbiAgZ2V0Tm9kZSxcbiAgZ2V0Tm9kZU1heWJlLFxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSxcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIsXG4gIHJlY29pbFZhbHVlc0ZvcktleXMsXG4gIE5vZGVNaXNzaW5nRXJyb3IsXG4gIERlZmF1bHRWYWx1ZSxcbiAgREVGQVVMVF9WQUxVRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gZW5xdWV1ZUV4ZWN1dGlvbihzLCBmKSB7XG4gIGYoKTtcbn1cblxudmFyIFJlY29pbF9RdWV1ZSA9IHtcbiAgZW5xdWV1ZUV4ZWN1dGlvblxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBoYW10XzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuLyoqXG4gICAgQGZpbGVPdmVydmlldyBIYXNoIEFycmF5IE1hcHBlZCBUcmllLlxuXG4gICAgQ29kZSBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2xpcHkvcGRhdGFcbiovXG5cblxudmFyIGhhbXQgPSB7fTsgLy8gZXhwb3J0XG5cbi8qIENvbmZpZ3VyYXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBTSVpFID0gNTtcbnZhciBCVUNLRVRfU0laRSA9IE1hdGgucG93KDIsIFNJWkUpO1xudmFyIE1BU0sgPSBCVUNLRVRfU0laRSAtIDE7XG52YXIgTUFYX0lOREVYX05PREUgPSBCVUNLRVRfU0laRSAvIDI7XG52YXIgTUlOX0FSUkFZX05PREUgPSBCVUNLRVRfU0laRSAvIDQ7XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIG5vdGhpbmcgPSB7fTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcbi8qKlxuICAgIEdldCAzMiBiaXQgaGFzaCBvZiBzdHJpbmcuXG5cbiAgICBCYXNlZCBvbjpcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XG4qL1xuXG5cbnZhciBoYXNoID0gaGFtdC5oYXNoID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0cik7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuIHN0cjtcbiAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSBzdHIgKz0gJyc7XG4gIHZhciBoYXNoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgYyB8IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaDtcbn07XG4vKiBCaXQgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBIYW1taW5nIHdlaWdodC5cblxuICAgIFRha2VuIGZyb206IGh0dHA6Ly9qc3BlcmYuY29tL2hhbW1pbmctd2VpZ2h0XG4qL1xuXG5cbnZhciBwb3Bjb3VudCA9IGZ1bmN0aW9uIHBvcGNvdW50KHgpIHtcbiAgeCAtPSB4ID4+IDEgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICh4ID4+IDIgJiAweDMzMzMzMzMzKTtcbiAgeCA9IHggKyAoeCA+PiA0KSAmIDB4MGYwZjBmMGY7XG4gIHggKz0geCA+PiA4O1xuICB4ICs9IHggPj4gMTY7XG4gIHJldHVybiB4ICYgMHg3Zjtcbn07XG5cbnZhciBoYXNoRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpIHtcbiAgcmV0dXJuIGggPj4+IHNoaWZ0ICYgTUFTSztcbn07XG5cbnZhciB0b0JpdG1hcCA9IGZ1bmN0aW9uIHRvQml0bWFwKHgpIHtcbiAgcmV0dXJuIDEgPDwgeDtcbn07XG5cbnZhciBmcm9tQml0bWFwID0gZnVuY3Rpb24gZnJvbUJpdG1hcChiaXRtYXAsIGJpdCkge1xuICByZXR1cm4gcG9wY291bnQoYml0bWFwICYgYml0IC0gMSk7XG59O1xuLyogQXJyYXkgT3BzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBTZXQgYSB2YWx1ZSBpbiBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBjaGFuZ2UuXG4gICAgQHBhcmFtIHYgTmV3IHZhbHVlXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5VXBkYXRlID0gZnVuY3Rpb24gYXJyYXlVcGRhdGUobXV0YXRlLCBhdCwgdiwgYXJyKSB7XG4gIHZhciBvdXQgPSBhcnI7XG5cbiAgaWYgKCFtdXRhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBvdXQgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG91dFtpXSA9IGFycltpXTtcbiAgICB9XG4gIH1cblxuICBvdXRbYXRdID0gdjtcbiAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAgICBSZW1vdmUgYSB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XG4gICAgQHBhcmFtIGF0IEluZGV4IHRvIHJlbW92ZS5cbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlTcGxpY2VPdXQgPSBmdW5jdGlvbiBhcnJheVNwbGljZU91dChtdXRhdGUsIGF0LCBhcnIpIHtcbiAgdmFyIG5ld0xlbiA9IGFyci5sZW5ndGggLSAxO1xuICB2YXIgaSA9IDA7XG4gIHZhciBnID0gMDtcbiAgdmFyIG91dCA9IGFycjtcblxuICBpZiAobXV0YXRlKSB7XG4gICAgaSA9IGcgPSBhdDtcbiAgfSBlbHNlIHtcbiAgICBvdXQgPSBuZXcgQXJyYXkobmV3TGVuKTtcblxuICAgIHdoaWxlIChpIDwgYXQpIHtcbiAgICAgIG91dFtnKytdID0gYXJyW2krK107XG4gICAgfVxuICB9XG5cbiAgKytpO1xuXG4gIHdoaWxlIChpIDw9IG5ld0xlbikge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBpZiAobXV0YXRlKSB7XG4gICAgb3V0Lmxlbmd0aCA9IG5ld0xlbjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gICAgSW5zZXJ0IGEgdmFsdWUgaW50byBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byBpbnNlcnQgYXQuXG4gICAgQHBhcmFtIHYgVmFsdWUgdG8gaW5zZXJ0LFxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVNwbGljZUluID0gZnVuY3Rpb24gYXJyYXlTcGxpY2VJbihtdXRhdGUsIGF0LCB2LCBhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIHZhciBfaSA9IGxlbjtcblxuICAgIHdoaWxlIChfaSA+PSBhdCkge1xuICAgICAgYXJyW19pLS1dID0gYXJyW19pXTtcbiAgICB9XG5cbiAgICBhcnJbYXRdID0gdjtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgdmFyIGkgPSAwLFxuICAgICAgZyA9IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XG5cbiAgd2hpbGUgKGkgPCBhdCkge1xuICAgIG91dFtnKytdID0gYXJyW2krK107XG4gIH1cblxuICBvdXRbYXRdID0gdjtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIG91dFsrK2ddID0gYXJyW2krK107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qIE5vZGUgU3RydWN0dXJlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgTEVBRiA9IDE7XG52YXIgQ09MTElTSU9OID0gMjtcbnZhciBJTkRFWCA9IDM7XG52YXIgQVJSQVkgPSA0O1xuLyoqXG4gICAgRW1wdHkgbm9kZS5cbiovXG5cbnZhciBlbXB0eSA9IHtcbiAgX19oYW10X2lzRW1wdHk6IHRydWVcbn07XG5cbnZhciBpc0VtcHR5Tm9kZSA9IGZ1bmN0aW9uIGlzRW1wdHlOb2RlKHgpIHtcbiAgcmV0dXJuIHggPT09IGVtcHR5IHx8IHggJiYgeC5fX2hhbXRfaXNFbXB0eTtcbn07XG4vKipcbiAgICBMZWFmIGhvbGRpbmcgYSB2YWx1ZS5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGtleSBLZXkuXG4gICAgQG1lbWJlciB2YWx1ZSBWYWx1ZSBzdG9yZWQuXG4qL1xuXG5cbnZhciBMZWFmID0gZnVuY3Rpb24gTGVhZihlZGl0LCBoYXNoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogTEVBRixcbiAgICBlZGl0OiBlZGl0LFxuICAgIGhhc2g6IGhhc2gsXG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIF9tb2RpZnk6IExlYWZfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIExlYWYgaG9sZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBoYXNoIGJ1dCBkaWZmZXJlbnQga2V5cy5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgaGFzaCBIYXNoIG9mIGtleS5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNvbGxpc2lvbiBjaGlsZHJlbiBub2RlLlxuKi9cblxuXG52YXIgQ29sbGlzaW9uID0gZnVuY3Rpb24gQ29sbGlzaW9uKGVkaXQsIGhhc2gsIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ09MTElTSU9OLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgaGFzaDogaGFzaCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogQ29sbGlzaW9uX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggYSBzcGFyc2Ugc2V0IG9mIGNoaWxkcmVuLlxuXG4gICAgVXNlcyBhIGJpdG1hcCBhbmQgYXJyYXkgdG8gcGFjayBjaGlsZHJlbi5cblxuICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIG1hc2sgQml0bWFwIHRoYXQgZW5jb2RlIHRoZSBwb3NpdGlvbnMgb2YgY2hpbGRyZW4gaW4gdGhlIGFycmF5LlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlKGVkaXQsIG1hc2ssIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5ERVgsXG4gICAgZWRpdDogZWRpdCxcbiAgICBtYXNrOiBtYXNrLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBJbmRleGVkTm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSW50ZXJuYWwgbm9kZSB3aXRoIG1hbnkgY2hpbGRyZW4uXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIHNpemUgTnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuXG4qL1xuXG5cbnZhciBBcnJheU5vZGUgPSBmdW5jdGlvbiBBcnJheU5vZGUoZWRpdCwgc2l6ZSwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBUlJBWSxcbiAgICBlZGl0OiBlZGl0LFxuICAgIHNpemU6IHNpemUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IEFycmF5Tm9kZV9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSXMgYG5vZGVgIGEgbGVhZiBub2RlP1xuKi9cblxuXG52YXIgaXNMZWFmID0gZnVuY3Rpb24gaXNMZWFmKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgPT09IGVtcHR5IHx8IG5vZGUudHlwZSA9PT0gTEVBRiB8fCBub2RlLnR5cGUgPT09IENPTExJU0lPTjtcbn07XG4vKiBJbnRlcm5hbCBub2RlIG9wZXJhdGlvbnMuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBFeHBhbmQgYW4gaW5kZXhlZCBub2RlIGludG8gYW4gYXJyYXkgbm9kZS5cblxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXG4gICAgQHBhcmFtIGZyYWcgSW5kZXggb2YgYWRkZWQgY2hpbGQuXG4gICAgQHBhcmFtIGNoaWxkIEFkZGVkIGNoaWxkLlxuICAgIEBwYXJhbSBtYXNrIEluZGV4IG5vZGUgbWFzayBiZWZvcmUgY2hpbGQgYWRkZWQuXG4gICAgQHBhcmFtIHN1Yk5vZGVzIEluZGV4IG5vZGUgY2hpbGRyZW4gYmVmb3JlIGNoaWxkIGFkZGVkLlxuKi9cblxuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKGVkaXQsIGZyYWcsIGNoaWxkLCBiaXRtYXAsIHN1Yk5vZGVzKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGJpdCA9IGJpdG1hcDtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgYml0OyArK2kpIHtcbiAgICBpZiAoYml0ICYgMSkgYXJyW2ldID0gc3ViTm9kZXNbY291bnQrK107XG4gICAgYml0ID4+Pj0gMTtcbiAgfVxuXG4gIGFycltmcmFnXSA9IGNoaWxkO1xuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50ICsgMSwgYXJyKTtcbn07XG4vKipcbiAgICBDb2xsYXBzZSBhbiBhcnJheSBub2RlIGludG8gYSBpbmRleGVkIG5vZGUuXG5cbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgaW4gbmV3IGFycmF5LlxuICAgIEBwYXJhbSByZW1vdmVkIEluZGV4IG9mIHJlbW92ZWQgZWxlbWVudC5cbiAgICBAcGFyYW0gZWxlbWVudHMgQXJyYXkgbm9kZSBjaGlsZHJlbiBiZWZvcmUgcmVtb3ZlLlxuKi9cblxuXG52YXIgcGFjayA9IGZ1bmN0aW9uIHBhY2soZWRpdCwgY291bnQsIHJlbW92ZWQsIGVsZW1lbnRzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5ldyBBcnJheShjb3VudCAtIDEpO1xuICB2YXIgZyA9IDA7XG4gIHZhciBiaXRtYXAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChpICE9PSByZW1vdmVkKSB7XG4gICAgICB2YXIgZWxlbSA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoZWxlbSAmJiAhaXNFbXB0eU5vZGUoZWxlbSkpIHtcbiAgICAgICAgY2hpbGRyZW5bZysrXSA9IGVsZW07XG4gICAgICAgIGJpdG1hcCB8PSAxIDw8IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIGJpdG1hcCwgY2hpbGRyZW4pO1xufTtcbi8qKlxuICAgIE1lcmdlIHR3byBsZWFmIG5vZGVzLlxuXG4gICAgQHBhcmFtIHNoaWZ0IEN1cnJlbnQgc2hpZnQuXG4gICAgQHBhcmFtIGgxIE5vZGUgMSBoYXNoLlxuICAgIEBwYXJhbSBuMSBOb2RlIDEuXG4gICAgQHBhcmFtIGgyIE5vZGUgMiBoYXNoLlxuICAgIEBwYXJhbSBuMiBOb2RlIDIuXG4qL1xuXG5cbnZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCBoMSwgbjEsIGgyLCBuMikge1xuICBpZiAoaDEgPT09IGgyKSByZXR1cm4gQ29sbGlzaW9uKGVkaXQsIGgxLCBbbjIsIG4xXSk7XG4gIHZhciBzdWJIMSA9IGhhc2hGcmFnbWVudChzaGlmdCwgaDEpO1xuICB2YXIgc3ViSDIgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgyKTtcbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIHRvQml0bWFwKHN1YkgxKSB8IHRvQml0bWFwKHN1YkgyKSwgc3ViSDEgPT09IHN1YkgyID8gW21lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0ICsgU0laRSwgaDEsIG4xLCBoMiwgbjIpXSA6IHN1YkgxIDwgc3ViSDIgPyBbbjEsIG4yXSA6IFtuMiwgbjFdKTtcbn07XG4vKipcbiAgICBVcGRhdGUgYW4gZW50cnkgaW4gYSBjb2xsaXNpb24gbGlzdC5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIG11dGF0aW9uIGJlIHVzZWQ/XG4gICAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBrZXlFcSBLZXkgY29tcGFyZSBmdW5jdGlvbi5cbiAgICBAcGFyYW0gaGFzaCBIYXNoIG9mIGNvbGxpc2lvbi5cbiAgICBAcGFyYW0gbGlzdCBDb2xsaXNpb24gbGlzdC5cbiAgICBAcGFyYW0gZiBVcGRhdGUgZnVuY3Rpb24uXG4gICAgQHBhcmFtIGsgS2V5IHRvIHVwZGF0ZS5cbiAgICBAcGFyYW0gc2l6ZSBTaXplIHJlZi5cbiovXG5cblxudmFyIHVwZGF0ZUNvbGxpc2lvbkxpc3QgPSBmdW5jdGlvbiB1cGRhdGVDb2xsaXNpb25MaXN0KG11dGF0ZSwgZWRpdCwga2V5RXEsIGgsIGxpc3QsIGYsIGssIHNpemUpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXG4gICAgaWYgKGtleUVxKGssIGNoaWxkLmtleSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLnZhbHVlO1xuXG4gICAgICB2YXIgX25ld1ZhbHVlID0gZih2YWx1ZSk7XG5cbiAgICAgIGlmIChfbmV3VmFsdWUgPT09IHZhbHVlKSByZXR1cm4gbGlzdDtcblxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAtLXNpemUudmFsdWU7XG4gICAgICAgIHJldHVybiBhcnJheVNwbGljZU91dChtdXRhdGUsIGksIGxpc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBpLCBMZWFmKGVkaXQsIGgsIGssIF9uZXdWYWx1ZSksIGxpc3QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IGYoKTtcbiAgaWYgKG5ld1ZhbHVlID09PSBub3RoaW5nKSByZXR1cm4gbGlzdDtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gYXJyYXlVcGRhdGUobXV0YXRlLCBsZW4sIExlYWYoZWRpdCwgaCwgaywgbmV3VmFsdWUpLCBsaXN0KTtcbn07XG5cbnZhciBjYW5FZGl0Tm9kZSA9IGZ1bmN0aW9uIGNhbkVkaXROb2RlKGVkaXQsIG5vZGUpIHtcbiAgcmV0dXJuIGVkaXQgPT09IG5vZGUuZWRpdDtcbn07XG4vKiBFZGl0aW5nXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBMZWFmX19tb2RpZnkgPSBmdW5jdGlvbiBMZWFmX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIGlmIChrZXlFcShrLCB0aGlzLmtleSkpIHtcbiAgICB2YXIgX3YgPSBmKHRoaXMudmFsdWUpO1xuXG4gICAgaWYgKF92ID09PSB0aGlzLnZhbHVlKSByZXR1cm4gdGhpcztlbHNlIGlmIChfdiA9PT0gbm90aGluZykge1xuICAgICAgLS1zaXplLnZhbHVlO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIGlmIChjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IF92O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgX3YpO1xuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgQ29sbGlzaW9uX19tb2RpZnkgPSBmdW5jdGlvbiBDb2xsaXNpb25fX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgaWYgKGggPT09IHRoaXMuaGFzaCkge1xuICAgIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gICAgdmFyIGxpc3QgPSB1cGRhdGVDb2xsaXNpb25MaXN0KGNhbkVkaXQsIGVkaXQsIGtleUVxLCB0aGlzLmhhc2gsIHRoaXMuY2hpbGRyZW4sIGYsIGssIHNpemUpO1xuICAgIGlmIChsaXN0ID09PSB0aGlzLmNoaWxkcmVuKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gbGlzdC5sZW5ndGggPiAxID8gQ29sbGlzaW9uKGVkaXQsIHRoaXMuaGFzaCwgbGlzdCkgOiBsaXN0WzBdOyAvLyBjb2xsYXBzZSBzaW5nbGUgZWxlbWVudCBjb2xsaXNpb24gbGlzdFxuICB9XG5cbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gdGhpcztcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIHRoaXMuaGFzaCwgdGhpcywgaCwgTGVhZihlZGl0LCBoLCBrLCB2KSk7XG59O1xuXG52YXIgSW5kZXhlZE5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEluZGV4ZWROb2RlX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIHZhciBtYXNrID0gdGhpcy5tYXNrO1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XG4gIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcbiAgdmFyIGluZHggPSBmcm9tQml0bWFwKG1hc2ssIGJpdCk7XG4gIHZhciBleGlzdHMgPSBtYXNrICYgYml0O1xuICB2YXIgY3VycmVudCA9IGV4aXN0cyA/IGNoaWxkcmVuW2luZHhdIDogZW1wdHk7XG5cbiAgdmFyIGNoaWxkID0gY3VycmVudC5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjdXJyZW50ID09PSBjaGlsZCkgcmV0dXJuIHRoaXM7XG4gIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gIHZhciBiaXRtYXAgPSBtYXNrO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGV4aXN0cyAmJiBpc0VtcHR5Tm9kZShjaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICBiaXRtYXAgJj0gfmJpdDtcbiAgICBpZiAoIWJpdG1hcCkgcmV0dXJuIGVtcHR5O1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPD0gMiAmJiBpc0xlYWYoY2hpbGRyZW5baW5keCBeIDFdKSkgcmV0dXJuIGNoaWxkcmVuW2luZHggXiAxXTsgLy8gY29sbGFwc2VcblxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VPdXQoY2FuRWRpdCwgaW5keCwgY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKCFleGlzdHMgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkge1xuICAgIC8vIGFkZFxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPj0gTUFYX0lOREVYX05PREUpIHJldHVybiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIG1hc2ssIGNoaWxkcmVuKTtcbiAgICBiaXRtYXAgfD0gYml0O1xuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlTcGxpY2VJbihjYW5FZGl0LCBpbmR4LCBjaGlsZCwgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vZGlmeVxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChjYW5FZGl0KSB7XG4gICAgdGhpcy5tYXNrID0gYml0bWFwO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIG5ld0NoaWxkcmVuKTtcbn07XG5cbnZhciBBcnJheU5vZGVfX21vZGlmeSA9IGZ1bmN0aW9uIEFycmF5Tm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgY291bnQgPSB0aGlzLnNpemU7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKTtcbiAgdmFyIGNoaWxkID0gY2hpbGRyZW5bZnJhZ107XG5cbiAgdmFyIG5ld0NoaWxkID0gKGNoaWxkIHx8IGVtcHR5KS5fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCArIFNJWkUsIGYsIGgsIGssIHNpemUpO1xuXG4gIGlmIChjaGlsZCA9PT0gbmV3Q2hpbGQpIHJldHVybiB0aGlzO1xuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGlzRW1wdHlOb2RlKGNoaWxkKSAmJiAhaXNFbXB0eU5vZGUobmV3Q2hpbGQpKSB7XG4gICAgLy8gYWRkXG4gICAgKytjb3VudDtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAoIWlzRW1wdHlOb2RlKGNoaWxkKSAmJiBpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcbiAgICAvLyByZW1vdmVcbiAgICAtLWNvdW50O1xuICAgIGlmIChjb3VudCA8PSBNSU5fQVJSQVlfTk9ERSkgcmV0dXJuIHBhY2soZWRpdCwgY291bnQsIGZyYWcsIGNoaWxkcmVuKTtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIGVtcHR5LCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbW9kaWZ5XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGNhbkVkaXQpIHtcbiAgICB0aGlzLnNpemUgPSBjb3VudDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXlOb2RlKGVkaXQsIGNvdW50LCBuZXdDaGlsZHJlbik7XG59O1xuXG5lbXB0eS5fbW9kaWZ5ID0gZnVuY3Rpb24gKGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgdiA9IGYoKTtcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiBlbXB0eTtcbiAgKytzaXplLnZhbHVlO1xuICByZXR1cm4gTGVhZihlZGl0LCBoLCBrLCB2KTtcbn07XG4vKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5mdW5jdGlvbiBNYXAoZWRpdGFibGUsIGVkaXQsIGNvbmZpZywgcm9vdCwgc2l6ZSkge1xuICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICB0aGlzLl9lZGl0ID0gZWRpdDtcbiAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XG59XG5cbk1hcC5wcm90b3R5cGUuc2V0VHJlZSA9IGZ1bmN0aW9uIChuZXdSb290LCBuZXdTaXplKSB7XG4gIGlmICh0aGlzLl9lZGl0YWJsZSkge1xuICAgIHRoaXMuX3Jvb3QgPSBuZXdSb290O1xuICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ld1Jvb3QgPT09IHRoaXMuX3Jvb3QgPyB0aGlzIDogbmV3IE1hcCh0aGlzLl9lZGl0YWJsZSwgdGhpcy5fZWRpdCwgdGhpcy5fY29uZmlnLCBuZXdSb290LCBuZXdTaXplKTtcbn07XG4vKiBRdWVyaWVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBhIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgYWx0YCBpZiBub25lLlxuKi9cblxuXG52YXIgdHJ5R2V0SGFzaCA9IGhhbXQudHJ5R2V0SGFzaCA9IGZ1bmN0aW9uIChhbHQsIGhhc2gsIGtleSwgbWFwKSB7XG4gIHZhciBub2RlID0gbWFwLl9yb290O1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIga2V5RXEgPSBtYXAuX2NvbmZpZy5rZXlFcTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIExFQUY6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4ga2V5RXEoa2V5LCBub2RlLmtleSkgPyBub2RlLnZhbHVlIDogYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ09MTElTSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGhhc2ggPT09IG5vZGUuaGFzaCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICBpZiAoa2V5RXEoa2V5LCBjaGlsZC5rZXkpKSByZXR1cm4gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIElOREVYOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpO1xuICAgICAgICAgIHZhciBiaXQgPSB0b0JpdG1hcChmcmFnKTtcblxuICAgICAgICAgIGlmIChub2RlLm1hc2sgJiBiaXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2Zyb21CaXRtYXAobm9kZS5tYXNrLCBiaXQpXTtcbiAgICAgICAgICAgIHNoaWZ0ICs9IFNJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQVJSQVk6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltoYXNoRnJhZ21lbnQoc2hpZnQsIGhhc2gpXTtcblxuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYWx0O1xuICAgIH1cbiAgfVxufTtcblxuTWFwLnByb3RvdHlwZS50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgdHJ5R2V0SGFzaGBcbiovXG5cblxudmFyIHRyeUdldCA9IGhhbXQudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUudHJ5R2V0ID0gZnVuY3Rpb24gKGFsdCwga2V5KSB7XG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUuXG4qL1xuXG5cbnZhciBnZXRIYXNoID0gaGFtdC5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKHVuZGVmaW5lZCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gZ2V0SGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBnZXRgXG4qL1xuXG5cbnZhciBnZXQgPSBoYW10LmdldCA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBhbHQpIHtcbiAgcmV0dXJuIHRyeUdldChhbHQsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgY3VzdG9tIGBoYXNoYC5cbiovXG5cblxudmFyIGhhc0hhc2ggPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChub3RoaW5nLCBoYXNoLCBrZXksIG1hcCkgIT09IG5vdGhpbmc7XG59O1xuXG5NYXAucHJvdG90eXBlLmhhc0hhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XG4gIHJldHVybiBoYXNIYXNoKGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgRG9lcyBhbiBlbnRyeSBleGlzdCBmb3IgYGtleWAgaW4gYG1hcGA/IFVzZXMgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cbiovXG5cblxudmFyIGhhcyA9IGhhbXQuaGFzID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiBoYXNIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBoYXMoa2V5LCB0aGlzKTtcbn07XG5cbnZhciBkZWZLZXlDb21wYXJlID0gZnVuY3Rpb24gZGVmS2V5Q29tcGFyZSh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5O1xufTtcbi8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBtYXAuXG5cbiAgICBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24uXG4qL1xuXG5cbmhhbXQubWFrZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBNYXAoMCwgMCwge1xuICAgIGtleUVxOiBjb25maWcgJiYgY29uZmlnLmtleUVxIHx8IGRlZktleUNvbXBhcmUsXG4gICAgaGFzaDogY29uZmlnICYmIGNvbmZpZy5oYXNoIHx8IGhhc2hcbiAgfSwgZW1wdHksIDApO1xufTtcbi8qKlxuICAgIEVtcHR5IG1hcC5cbiovXG5cblxuaGFtdC5lbXB0eSA9IGhhbXQubWFrZSgpO1xuLyoqXG4gICAgRG9lcyBgbWFwYCBjb250YWluIGFueSBlbGVtZW50cz9cbiovXG5cbnZhciBpc0VtcHR5ID0gaGFtdC5pc0VtcHR5ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwICYmICEhaXNFbXB0eU5vZGUobWFwLl9yb290KTtcbn07XG5cbk1hcC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRW1wdHkodGhpcyk7XG59O1xuLyogVXBkYXRlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgY3VzdG9tIGhhc2guXG5cbiAgICBgZmAgaXMgaW52b2tlZCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGZvciBga2AgaWYgaXQgZXhpc3RzLFxuICAgIG9yIG5vIGFyZ3VtZW50cyBpZiBubyBzdWNoIHZhbHVlIGV4aXN0cy4gYG1vZGlmeWAgd2lsbCBhbHdheXMgZWl0aGVyXG4gICAgdXBkYXRlIG9yIGluc2VydCBhIHZhbHVlIGludG8gdGhlIG1hcC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgbW9kaWZ5SGFzaCA9IGhhbXQubW9kaWZ5SGFzaCA9IGZ1bmN0aW9uIChmLCBoYXNoLCBrZXksIG1hcCkge1xuICB2YXIgc2l6ZSA9IHtcbiAgICB2YWx1ZTogbWFwLl9zaXplXG4gIH07XG5cbiAgdmFyIG5ld1Jvb3QgPSBtYXAuX3Jvb3QuX21vZGlmeShtYXAuX2VkaXRhYmxlID8gbWFwLl9lZGl0IDogTmFOLCBtYXAuX2NvbmZpZy5rZXlFcSwgMCwgZiwgaGFzaCwga2V5LCBzaXplKTtcblxuICByZXR1cm4gbWFwLnNldFRyZWUobmV3Um9vdCwgc2l6ZS52YWx1ZSk7XG59O1xuXG5NYXAucHJvdG90eXBlLm1vZGlmeUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBmKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgQWx0ZXIgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgZnVuY3Rpb24gYGZgIHVzaW5nXG4gICAgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYG1vZGlmeUhhc2hgXG4qL1xuXG5cbnZhciBtb2RpZnkgPSBoYW10Lm1vZGlmeSA9IGZ1bmN0aW9uIChmLCBrZXksIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChmLCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGtleSwgZikge1xuICByZXR1cm4gbW9kaWZ5KGYsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgbW9kaWZpZWQgdmFsdWUuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgc2V0SGFzaCA9IGhhbXQuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlLCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goY29uc3RhbnQodmFsdWUpLCBoYXNoLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc2V0SGFzaChoYXNoLCBrZXksIHZhbHVlLCB0aGlzKTtcbn07XG4vKipcbiAgICBTdG9yZSBgdmFsdWVgIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgc2V0SGFzaGBcbiovXG5cblxudmFyIHNldCA9IGhhbXQuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1hcCkge1xuICByZXR1cm4gc2V0SGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgdmFsdWUsIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzZXQoa2V5LCB2YWx1ZSwgdGhpcyk7XG59O1xuLyoqXG4gICAgUmVtb3ZlIHRoZSBlbnRyeSBmb3IgYGtleWAgaW4gYG1hcGAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIHZhbHVlIHJlbW92ZWQuIERvZXMgbm90IGFsdGVyIGBtYXBgLlxuKi9cblxuXG52YXIgZGVsID0gY29uc3RhbnQobm90aGluZyk7XG5cbnZhciByZW1vdmVIYXNoID0gaGFtdC5yZW1vdmVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGRlbCwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZW1vdmVIYXNoID0gTWFwLnByb3RvdHlwZS5kZWxldGVIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gcmVtb3ZlSGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIFJlbW92ZSB0aGUgZW50cnkgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGByZW1vdmVIYXNoYFxuKi9cblxuXG52YXIgcmVtb3ZlID0gaGFtdC5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIHJlbW92ZUhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnJlbW92ZSA9IE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gcmVtb3ZlKGtleSwgdGhpcyk7XG59O1xuLyogTXV0YXRpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIE1hcmsgYG1hcGAgYXMgbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBiZWdpbk11dGF0aW9uID0gaGFtdC5iZWdpbk11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbmV3IE1hcChtYXAuX2VkaXRhYmxlICsgMSwgbWFwLl9lZGl0ICsgMSwgbWFwLl9jb25maWcsIG1hcC5fcm9vdCwgbWFwLl9zaXplKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGJlZ2luTXV0YXRpb24odGhpcyk7XG59O1xuLyoqXG4gICAgTWFyayBgbWFwYCBhcyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgZW5kTXV0YXRpb24gPSBoYW10LmVuZE11dGF0aW9uID0gZnVuY3Rpb24gKG1hcCkge1xuICBtYXAuX2VkaXRhYmxlID0gbWFwLl9lZGl0YWJsZSAmJiBtYXAuX2VkaXRhYmxlIC0gMTtcbiAgcmV0dXJuIG1hcDtcbn07XG5cbk1hcC5wcm90b3R5cGUuZW5kTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbmRNdXRhdGlvbih0aGlzKTtcbn07XG4vKipcbiAgICBNdXRhdGUgYG1hcGAgd2l0aGluIHRoZSBjb250ZXh0IG9mIGBmYC5cbiAgICBAcGFyYW0gZlxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgbXV0YXRlID0gaGFtdC5tdXRhdGUgPSBmdW5jdGlvbiAoZiwgbWFwKSB7XG4gIHZhciB0cmFuc2llbnQgPSBiZWdpbk11dGF0aW9uKG1hcCk7XG4gIGYodHJhbnNpZW50KTtcbiAgcmV0dXJuIGVuZE11dGF0aW9uKHRyYW5zaWVudCk7XG59O1xuXG5NYXAucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBtdXRhdGUoZiwgdGhpcyk7XG59O1xuLyogVHJhdmVyc2FsXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBBcHBseSBhIGNvbnRpbnVhdGlvbi5cbiovXG5cblxudmFyIGFwcGsgPSBmdW5jdGlvbiBhcHBrKGspIHtcbiAgcmV0dXJuIGsgJiYgbGF6eVZpc2l0Q2hpbGRyZW4oa1swXSwga1sxXSwga1syXSwga1szXSwga1s0XSk7XG59O1xuLyoqXG4gICAgUmVjdXJzaXZlbHkgdmlzaXQgYWxsIHZhbHVlcyBzdG9yZWQgaW4gYW4gYXJyYXkgb2Ygbm9kZXMgbGF6aWx5LlxuKi9cblxuXG52YXIgbGF6eVZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiBsYXp5VmlzaXRDaGlsZHJlbihsZW4sIGNoaWxkcmVuLCBpLCBmLCBrKSB7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baSsrXTtcbiAgICBpZiAoY2hpbGQgJiYgIWlzRW1wdHlOb2RlKGNoaWxkKSkgcmV0dXJuIGxhenlWaXNpdChjaGlsZCwgZiwgW2xlbiwgY2hpbGRyZW4sIGksIGYsIGtdKTtcbiAgfVxuXG4gIHJldHVybiBhcHBrKGspO1xufTtcbi8qKlxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGBub2RlYCBsYXppbHkuXG4qL1xuXG5cbnZhciBsYXp5VmlzaXQgPSBmdW5jdGlvbiBsYXp5VmlzaXQobm9kZSwgZiwgaykge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgTEVBRjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBmKG5vZGUpLFxuICAgICAgICByZXN0OiBrXG4gICAgICB9O1xuXG4gICAgY2FzZSBDT0xMSVNJT046XG4gICAgY2FzZSBBUlJBWTpcbiAgICBjYXNlIElOREVYOlxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIHJldHVybiBsYXp5VmlzaXRDaGlsZHJlbihjaGlsZHJlbi5sZW5ndGgsIGNoaWxkcmVuLCAwLCBmLCBrKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXBwayhrKTtcbiAgfVxufTtcblxudmFyIERPTkUgPSB7XG4gIGRvbmU6IHRydWVcbn07XG4vKipcbiAgICBKYXZhc2NyaXB0IGl0ZXJhdG9yIG92ZXIgYSBtYXAuXG4qL1xuXG5mdW5jdGlvbiBNYXBJdGVyYXRvcih2KSB7XG4gIHRoaXMudiA9IHY7XG59XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudikgcmV0dXJuIERPTkU7XG4gIHZhciB2MCA9IHRoaXMudjtcbiAgdGhpcy52ID0gYXBwayh2MC5yZXN0KTtcbiAgcmV0dXJuIHYwO1xufTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICAgIExhemlseSB2aXNpdCBlYWNoIHZhbHVlIGluIG1hcCB3aXRoIGZ1bmN0aW9uIGBmYC5cbiovXG5cblxudmFyIHZpc2l0ID0gZnVuY3Rpb24gdmlzaXQobWFwLCBmKSB7XG4gIHJldHVybiBuZXcgTWFwSXRlcmF0b3IobGF6eVZpc2l0KG1hcC5fcm9vdCwgZikpO1xufTtcbi8qKlxuICAgIEdldCBhIEphdmFzY3NyaXB0IGl0ZXJhdG9yIG9mIGBtYXBgLlxuXG4gICAgSXRlcmF0ZXMgb3ZlciBgW2tleSwgdmFsdWVdYCBhcnJheXMuXG4qL1xuXG5cbnZhciBidWlsZFBhaXJzID0gZnVuY3Rpb24gYnVpbGRQYWlycyh4KSB7XG4gIHJldHVybiBbeC5rZXksIHgudmFsdWVdO1xufTtcblxudmFyIGVudHJpZXMgPSBoYW10LmVudHJpZXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkUGFpcnMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW50cmllcyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIGtleXMgaW4gYG1hcGAuXG5cbiAgICBPcmRlciBpcyBub3QgZ3VhcmFudGVlZC5cbiovXG5cblxudmFyIGJ1aWxkS2V5cyA9IGZ1bmN0aW9uIGJ1aWxkS2V5cyh4KSB7XG4gIHJldHVybiB4LmtleTtcbn07XG5cbnZhciBrZXlzID0gaGFtdC5rZXlzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZEtleXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ga2V5cyh0aGlzKTtcbn07XG4vKipcbiAgICBHZXQgYXJyYXkgb2YgYWxsIHZhbHVlcyBpbiBgbWFwYC5cblxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLCBkdXBsaWNhdGVzIGFyZSBwcmVzZXJ2ZWQuXG4qL1xuXG5cbnZhciBidWlsZFZhbHVlcyA9IGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKHgpIHtcbiAgcmV0dXJuIHgudmFsdWU7XG59O1xuXG52YXIgdmFsdWVzID0gaGFtdC52YWx1ZXMgPSBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRWYWx1ZXMpO1xufTtcblxuTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB2YWx1ZXModGhpcyk7XG59O1xuLyogRm9sZFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cblxuICAgIE9yZGVyIG9mIG5vZGVzIGlzIG5vdCBndWFyYW50ZWVkLlxuXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gbWFwcGluZyBhY2N1bXVsYXRlZCB2YWx1ZSwgdmFsdWUsIGFuZCBrZXkgdG8gbmV3IHZhbHVlLlxuICAgIEBwYXJhbSB6IFN0YXJ0aW5nIHZhbHVlLlxuICAgIEBwYXJhbSBtIEhBTVRcbiovXG5cblxudmFyIGZvbGQgPSBoYW10LmZvbGQgPSBmdW5jdGlvbiAoZiwgeiwgbSkge1xuICB2YXIgcm9vdCA9IG0uX3Jvb3Q7XG4gIGlmIChyb290LnR5cGUgPT09IExFQUYpIHJldHVybiBmKHosIHJvb3QudmFsdWUsIHJvb3Qua2V5KTtcbiAgdmFyIHRvVmlzaXQgPSBbcm9vdC5jaGlsZHJlbl07XG4gIHZhciBjaGlsZHJlbiA9IHZvaWQgMDtcblxuICB3aGlsZSAoY2hpbGRyZW4gPSB0b1Zpc2l0LnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XG5cbiAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC50eXBlKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBMRUFGKSB6ID0gZih6LCBjaGlsZC52YWx1ZSwgY2hpbGQua2V5KTtlbHNlIHRvVmlzaXQucHVzaChjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHo7XG59O1xuXG5NYXAucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAoZiwgeikge1xuICByZXR1cm4gZm9sZChmLCB6LCB0aGlzKTtcbn07XG4vKipcbiAgICBWaXNpdCBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLCBhZ2dyZWdhdGluZyBkYXRhLlxuXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXG5cbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBpbnZva2VkIHdpdGggdmFsdWUgYW5kIGtleVxuICAgIEBwYXJhbSBtYXAgSEFNVFxuKi9cblxuXG52YXIgZm9yRWFjaCA9IGhhbXQuZm9yRWFjaCA9IGZ1bmN0aW9uIChmLCBtYXApIHtcbiAgcmV0dXJuIGZvbGQoZnVuY3Rpb24gKF8sIHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gZih2YWx1ZSwga2V5LCBtYXApO1xuICB9LCBudWxsLCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGZvckVhY2goZiwgdGhpcyk7XG59O1xuLyogQWdncmVnYXRlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBHZXQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIGBtYXBgLlxuKi9cblxuXG52YXIgY291bnQgPSBoYW10LmNvdW50ID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gbWFwLl9zaXplO1xufTtcblxuTWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNvdW50KHRoaXMpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IE1hcC5wcm90b3R5cGUuY291bnRcbn0pO1xuLyogRXhwb3J0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pZiAoIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaGFtdDtcbn0gZWxzZSB7XG4gIHVuZGVmaW5lZC5oYW10ID0gaGFtdDtcbn1cbn0pO1xuXG5jbGFzcyBCdWlsdEluTWFwIHtcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKGV4aXN0aW5nID09PSBudWxsIHx8IGV4aXN0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZy5lbnRyaWVzKCkpO1xuICB9XG5cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGspO1xuICB9XG5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrKTtcbiAgfVxuXG4gIHNldChrLCB2KSB7XG4gICAgdGhpcy5fbWFwLnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9tYXAuZGVsZXRlKGspO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX21hcCk7XG4gIH1cblxufVxuXG5jbGFzcyBIYXNoQXJyYXlNYXBwZWRUcmllTWFwIHtcbiAgLy8gQmVjYXVzZSBoYW10LmVtcHR5IGlzIG5vdCBhIGZ1bmN0aW9uIHRoZXJlIGlzIG5vIHdheSB0byBpbnRyb2R1Y2UgdHlwZVxuICAvLyBwYXJhbWV0ZXJzIG9uIGl0LCBzbyBlbXB0eSBpcyB0eXBlZCBhcyBIQU1UUGx1c01hcDxzdHJpbmcsIG1peGVkPi5cbiAgLy8gJEZsb3dJc3N1ZVxuICBjb25zdHJ1Y3RvcihleGlzdGluZykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYW10XCIsIGhhbXRfMS5lbXB0eS5iZWdpbk11dGF0aW9uKCkpO1xuXG4gICAgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgSGFzaEFycmF5TWFwcGVkVHJpZU1hcCkge1xuICAgICAgY29uc3QgaCA9IGV4aXN0aW5nLl9oYW10LmVuZE11dGF0aW9uKCk7XG5cbiAgICAgIGV4aXN0aW5nLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgICB0aGlzLl9oYW10ID0gaC5iZWdpbk11dGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZykge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZXhpc3RpbmcuZW50cmllcygpKSB7XG4gICAgICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQua2V5cygpO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5lbnRyaWVzKCk7XG4gIH1cblxuICBnZXQoaykge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmdldChrKTtcbiAgfVxuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuaGFzKGspO1xuICB9XG5cbiAgc2V0KGssIHYpIHtcbiAgICB0aGlzLl9oYW10LnNldChrLCB2KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICB0aGlzLl9oYW10LmRlbGV0ZShrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRNYXAodGhpcyk7XG4gIH1cblxuICB0b01hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9oYW10KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBlcnNpc3RlbnRNYXAoZXhpc3RpbmcpIHtcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9oYW10XzIwMjAnKSkge1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwcGVkVHJpZU1hcChleGlzdGluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWlsdEluTWFwKGV4aXN0aW5nKTtcbiAgfVxufVxuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAgPSB7XG4gIHBlcnNpc3RlbnRNYXBcbn07XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcF8xID0gUmVjb2lsX1BlcnNpc3RlbnRNYXAucGVyc2lzdGVudE1hcDtcblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcGVyc2lzdGVudE1hcDogUmVjb2lsX1BlcnNpc3RlbnRNYXBfMVxufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBmaXJzdCBzZXQgdGhhdCBhcmUgbm90XG4gKiBwcmVzZW50IGluIGFueSBvZiB0aGUgc3Vic2VxdWVudCBzZXRzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgd3JpdHRlbiBwcm9jZWR1cmFsbHkgKGkuZS4sIHdpdGhvdXQgZmlsdGVyU2V0KSBmb3IgcGVyZm9ybWFudFxuICogdXNlIGluIHRpZ2h0IGxvb3BzLlxuICovXG5cbmZ1bmN0aW9uIGRpZmZlcmVuY2VTZXRzKHNldCwgLi4uc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG5cbiAgRklSU1Q6IGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgZm9yIChjb25zdCBvdGhlclNldCBvZiBzZXRzV2l0aFZhbHVlc1RvUmVtb3ZlKSB7XG4gICAgICBpZiAob3RoZXJTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZSBGSVJTVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXQuYWRkKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBSZWNvaWxfZGlmZmVyZW5jZVNldHMgPSBkaWZmZXJlbmNlU2V0cztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG5ldyBNYXAgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgb3JpZ2luYWwsIGJ1dCB3aXRoIHRoZVxuICogdmFsdWVzIHJlcGxhY2VkIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdC5zZXQoa2V5LCBjYWxsYmFjayh2YWx1ZSwga2V5KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX21hcE1hcCA9IG1hcE1hcDtcblxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGVEZXBzOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZUdyYXBoKGdyYXBoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMsIHMgPT4gbmV3IFNldChzKSlcbiAgfTtcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcbi8vIHRoZSBuZXcgZGVwcyB3aXRoIHRoZSBvbGQgZGVwcy5cblxuXG5mdW5jdGlvbiBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBuZXdEZXBzLCBncmFwaCwgLy8gSWYgb2xkZXJHcmFwaCBpcyBnaXZlbiB0aGVuIHdlIHdpbGwgbm90IG92ZXJ3cml0ZSBjaGFuZ2VzIG1hZGUgdG8gdGhlIGdpdmVuXG4vLyBncmFwaCBjb21wYXJlZCB3aXRoIG9sZGVyR3JhcGg6XG5vbGRlckdyYXBoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlRGVwcyxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xuICB9ID0gZ3JhcGg7XG4gIGNvbnN0IG9sZERlcHMgPSBub2RlRGVwcy5nZXQoa2V5KTtcblxuICBpZiAob2xkRGVwcyAmJiBvbGRlckdyYXBoICYmIG9sZERlcHMgIT09IG9sZGVyR3JhcGgubm9kZURlcHMuZ2V0KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxuXG5cbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcblxuICBjb25zdCBhZGRlZERlcHMgPSBvbGREZXBzID09IG51bGwgPyBuZXdEZXBzIDogUmVjb2lsX2RpZmZlcmVuY2VTZXRzKG5ld0RlcHMsIG9sZERlcHMpO1xuXG4gIGZvciAoY29uc3QgZGVwIG9mIGFkZGVkRGVwcykge1xuICAgIGlmICghbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuaGFzKGRlcCkpIHtcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgZXhpc3RpbmcuYWRkKGtleSk7XG4gIH0gLy8gUmVtb3ZlIHJlbW92ZWQgZGVwcyBmcm9tIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOlxuXG5cbiAgaWYgKG9sZERlcHMpIHtcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIHJlbW92ZWREZXBzKSB7XG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgICBleGlzdGluZy5kZWxldGUoa2V5KTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVEZXBzVG9TdG9yZShrZXksIGRlcHMsIHN0b3JlLCB2ZXJzaW9uKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbiB8fCB2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlLnZlcnNpb24pIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gc2F2ZSBkZXBlbmRlbmNpZXMgdG8gYSBkaXNjYXJkZWQgdHJlZScpO1xuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXG4gIC8vIGZvciB0aGUgdmVyc2lvbiB0aGF0IHdhcyByZWFkOlxuXG5cbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh2ZXJzaW9uKTtcbiAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgZ3JhcGgpOyAvLyBJZiB0aGlzIHZlcnNpb24gaXMgbm90IHRoZSBsYXRlc3QgdmVyc2lvbiwgYWxzbyB3cml0ZSB0aGVzZSBkZXBlbmRlbmNpZXNcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XG5cbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLnZlcnNpb24pKSB7XG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBjdXJyZW50R3JhcGgsIGdyYXBoKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDMgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMy52ZXJzaW9uKSB8fCB2ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24pIHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgY29uc3QgbmV4dFZlcnNpb24gPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIudmVyc2lvbjtcblxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXh0R3JhcGggPSBzdG9yZS5nZXRHcmFwaChuZXh0VmVyc2lvbik7XG4gICAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBuZXh0R3JhcGgsIGdyYXBoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9HcmFwaCA9IHtcbiAgY2xvbmVHcmFwaCxcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcbiAgc2F2ZURlcHNUb1N0b3JlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5sZXQgbmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAwO1xuXG5jb25zdCBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiA9ICgpID0+IG5leHRUcmVlU3RhdGVWZXJzaW9uKys7XG5cbmxldCBuZXh0U3RvcmVJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRTdG9yZUlEID0gKCkgPT4gbmV4dFN0b3JlSUQrKztcblxubGV0IG5leHRDb21wb25lbnRJRCA9IDA7XG5cbmNvbnN0IGdldE5leHRDb21wb25lbnRJRCA9ICgpID0+IG5leHRDb21wb25lbnRJRCsrO1xuXG52YXIgUmVjb2lsX0tleXMgPSB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uLFxuICBnZXROZXh0U3RvcmVJRCxcbiAgZ2V0TmV4dENvbXBvbmVudElEXG59O1xuXG5jb25zdCB7XG4gIHBlcnNpc3RlbnRNYXA6IHBlcnNpc3RlbnRNYXAkMVxufSA9IFJlY29pbF9QZXJzaXN0ZW50TWFwJDE7XG5cbmNvbnN0IHtcbiAgZ3JhcGhcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuZnVuY3Rpb24gbWFrZUVtcHR5VHJlZVN0YXRlKCkge1xuICBjb25zdCB2ZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMSgpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgc3RhdGVJRDogdmVyc2lvbixcbiAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7fSxcbiAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXG4gICAgYXRvbVZhbHVlczogcGVyc2lzdGVudE1hcCQxKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHBlcnNpc3RlbnRNYXAkMSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eVN0b3JlU3RhdGUoKSB7XG4gIGNvbnN0IGN1cnJlbnRUcmVlID0gbWFrZUVtcHR5VHJlZVN0YXRlKCk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFRyZWUsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGNvbW1pdERlcHRoOiAwLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoKSxcbiAgICBrbm93blNlbGVjdG9yczogbmV3IFNldCgpLFxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldChjdXJyZW50VHJlZS52ZXJzaW9uLCBncmFwaCgpKSxcbiAgICByZXRlbnRpb246IHtcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxuICAgICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZTogbmV3IE1hcCgpLFxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXG4gICAgfSxcbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcCgpXG4gIH07XG59XG5cbnZhciBSZWNvaWxfU3RhdGUgPSB7XG4gIG1ha2VFbXB0eVRyZWVTdGF0ZSxcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZSxcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFJldGVudGlvblpvbmUge31cblxuZnVuY3Rpb24gcmV0ZW50aW9uWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyBSZXRlbnRpb25ab25lKCk7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uWm9uZSA9IHtcbiAgUmV0ZW50aW9uWm9uZSxcbiAgcmV0ZW50aW9uWm9uZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBVdGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCBidWlsdC1pbiBNYXBzIGFuZCBTZXRzIHdpdGhvdXQgbXV0YXRpbmcgdGhlbS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc2V0QnlBZGRpbmdUb1NldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5hZGQodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRCeURlbGV0aW5nRnJvbVNldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5kZWxldGUodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVNldHRpbmdJbk1hcChtYXAsIGssIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5zZXQoaywgdik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVVwZGF0aW5nSW5NYXAobWFwLCBrLCB1cGRhdGVyKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuc2V0KGssIHVwZGF0ZXIobmV4dC5nZXQoaykpKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdGcm9tTWFwKG1hcCwgaykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LmRlbGV0ZShrKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAobWFwLCBrcykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBrcy5mb3JFYWNoKGsgPT4gbmV4dC5kZWxldGUoaykpO1xuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIFJlY29pbF9Db3B5T25Xcml0ZSA9IHtcbiAgc2V0QnlBZGRpbmdUb1NldCxcbiAgc2V0QnlEZWxldGluZ0Zyb21TZXQsXG4gIG1hcEJ5U2V0dGluZ0luTWFwLFxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXG4gIG1hcEJ5RGVsZXRpbmdGcm9tTWFwLFxuICBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGl0ZXJhYmxlIHdob3NlIG91dHB1dCBpcyBnZW5lcmF0ZWQgYnkgcGFzc2luZyB0aGUgaW5wdXRcbiAqIGl0ZXJhYmxlJ3MgdmFsdWVzIHRocm91Z2ggdGhlIGZpbHRlciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiogZmlsdGVySXRlcmFibGUoaXRlcmFibGUsIHByZWRpY2F0ZSkge1xuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxuICBsZXQgaW5kZXggPSAwO1xuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCsrKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfZmlsdGVySXRlcmFibGUgPSBmaWx0ZXJJdGVyYWJsZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJuIGEgcHJveHkgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBiYXNlIGFuZCBmYWN0b3JpZXMgb2JqZWN0cy5cbiAqIFRoZSBwcm94eSB3aWxsIGluY2x1ZGUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2Ugb2JqZWN0IGFzLWlzLlxuICogVGhlIGZhY3RvcmllcyBvYmplY3QgY29udGFpbnMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJpZXNcbiAqIGZvciBpdHMga2V5cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJvdmlkaW5nIHVzZXJzIGFuIG9iamVjdCB3aGVyZSBzb21lIHByb3BlcnRpZXMgbWF5IGJlXG4gKiBsYXppbHkgY29tcHV0ZWQgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gKi9cbi8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5mdW5jdGlvbiBsYXp5UHJveHkoYmFzZSwgZmFjdG9yaWVzKSB7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGJhc2UsIHtcbiAgICAvLyBDb21wdXRlIGFuZCBjYWNoZSBsYXp5IHByb3BlcnR5IGlmIG5vdCBhbHJlYWR5IGRvbmUuXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkgJiYgcHJvcCBpbiBmYWN0b3JpZXMpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZmFjdG9yaWVzW3Byb3BdKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfSxcbiAgICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgdXNlciB0byBpdGVyYXRlIGtleXMgYXMgbm9ybWFsXG4gICAgb3duS2V5czogdGFyZ2V0ID0+IHtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgfVxuICB9KTsgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gIHJldHVybiBwcm94eTtcbn1cblxudmFyIFJlY29pbF9sYXp5UHJveHkgPSBsYXp5UHJveHk7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQxLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQxLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICBzZXRCeUFkZGluZ1RvU2V0OiBzZXRCeUFkZGluZ1RvU2V0JDFcbn0gPSBSZWNvaWxfQ29weU9uV3JpdGU7XG5cblxuXG5cblxuXG5cbiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGVtcHR5U2V0ID0gT2JqZWN0LmZyZWV6ZShuZXcgU2V0KCkpO1xuXG5jbGFzcyBSZWFkT25seVJlY29pbFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwgbm9kZUtleSwgcmV0YWluZWRCeSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG5vZGVzUmV0YWluZWRCeVpvbmVcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uO1xuXG4gIGZ1bmN0aW9uIGFkZFRvWm9uZSh6b25lKSB7XG4gICAgbGV0IHNldCA9IG5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuXG4gICAgaWYgKCFzZXQpIHtcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmUuc2V0KHpvbmUsIHNldCA9IG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgc2V0LmFkZChub2RlS2V5KTtcbiAgfVxuXG4gIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQxKSB7XG4gICAgYWRkVG9ab25lKHJldGFpbmVkQnkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0YWluZWRCeSkpIHtcbiAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgYWRkVG9ab25lKHpvbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcmV0ZW50aW9uXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tWm9uZSh6b25lKSB7XG4gICAgICBjb25zdCBzZXQgPSByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSk7XG4gICAgICBzZXQgPT09IG51bGwgfHwgc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXQuZGVsZXRlKG5vZGVLZXkpO1xuXG4gICAgICBpZiAoc2V0ICYmIHNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmRlbGV0ZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgICAgZGVsZXRlRnJvbVpvbmUocmV0YWluZWRCeSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgICBmb3IgKGNvbnN0IHpvbmUgb2YgcmV0YWluZWRCeSkge1xuICAgICAgICBkZWxldGVGcm9tWm9uZSh6b25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCB0cmVlU3RhdGUsIGtleSwgdHJpZ2dlcikge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5oYXMoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoa2V5KTtcbiAgY29uc3QgcmV0ZW50aW9uQ2xlYW51cCA9IGluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlKHN0b3JlLCBrZXksIG5vZGUucmV0YWluZWRCeSk7XG4gIGNvbnN0IG5vZGVDbGVhbnVwID0gbm9kZS5pbml0KHN0b3JlLCB0cmVlU3RhdGUsIHRyaWdnZXIpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLnNldChrZXksICgpID0+IHtcbiAgICBub2RlQ2xlYW51cCgpO1xuICAgIHJldGVudGlvbkNsZWFudXAoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlKHN0b3JlLCBrZXksIHRyaWdnZXIpIHtcbiAgaW5pdGlhbGl6ZU5vZGVJZk5ld1RvU3RvcmUoc3RvcmUsIHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSwgdHJpZ2dlcik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXBOb2RlKHN0b3JlLCBrZXkpIHtcbiAgdmFyIF9zdGF0ZSRub2RlQ2xlYW51cEZ1bjtcblxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIChfc3RhdGUkbm9kZUNsZWFudXBGdW4gPSBzdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJG5vZGVDbGVhbnVwRnVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkbm9kZUNsZWFudXBGdW4oKTtcbiAgc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG59IC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBvZiBhIG5vZGUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4vLyBVcGRhdGUgZGVwZW5kZW5jaWVzIGFuZCBzdWJzY3JpcHRpb25zIGZvciBzZWxlY3RvcnMuXG4vLyBVcGRhdGUgc2F2ZWQgdmFsdWUgdmFsaWRhdGlvbiBmb3IgYXRvbXMuXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnZ2V0Jyk7XG4gIHJldHVybiBnZXROb2RlJDEoa2V5KS5nZXQoc3RvcmUsIHN0YXRlKTtcbn0gLy8gUGVlayBhdCB0aGUgY3VycmVudCB2YWx1ZSBsb2FkYWJsZSBmb3IgYSBub2RlIHdpdGhvdXQgYW55IGV2YWx1YXRpb24gb3Igc3RhdGUgY2hhbmdlXG5cblxuZnVuY3Rpb24gcGVla05vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkucGVlayhzdG9yZSwgc3RhdGUpO1xufSAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4vLyBkZWZpbml0aW9ucyBtYXkgbm90IGhhdmUgYmVlbiBsb2FkZWQgeWV0IHdoZW4gcHJvY2Vzc2luZyB0aGUgaW5pdGlhbCBzbmFwc2hvdC5cblxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEKHN0YXRlLCBrZXksIG5ld1ZhbHVlKSB7XG4gIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xuXG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMShrZXkpO1xuICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRpbnZhbGlkYXRlID0gbm9kZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRpbnZhbGlkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRpbnZhbGlkYXRlLmNhbGwobm9kZSwgc3RhdGUpO1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCkuZGVsZXRlKGtleSksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCkuc2V0KGtleSwgbmV3VmFsdWUpLFxuICAgIGRpcnR5QXRvbXM6IHNldEJ5QWRkaW5nVG9TZXQkMShzdGF0ZS5kaXJ0eUF0b21zLCBrZXkpXG4gIH07XG59IC8vIFJldHVybiB0aGUgZGlzY292ZXJlZCBkZXBlbmRlbmNpZXMgYW5kIHZhbHVlcyB0byBiZSB3cml0dGVuIGJ5IHNldHRpbmdcbi8vIGEgbm9kZSB2YWx1ZS4gKE11bHRpcGxlIHZhbHVlcyBtYXkgYmUgd3JpdHRlbiBkdWUgdG8gc2VsZWN0b3JzIGdldHRpbmcgdG9cbi8vIHNldCB1cHN0cmVhbXM7IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgYmVjYXVzZSBvZiByZWFkcyBpbiB1cGRhdGVyIGZ1bmN0aW9ucy4pXG5cblxuZnVuY3Rpb24gc2V0Tm9kZVZhbHVlKHN0b3JlLCBzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG5cbiAgaWYgKG5vZGUuc2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yKGBBdHRlbXB0IHRvIHNldCByZWFkLW9ubHkgUmVjb2lsVmFsdWU6ICR7a2V5fWApO1xuICB9XG5cbiAgY29uc3Qgc2V0ID0gbm9kZS5zZXQ7IC8vIHNvIGZsb3cgZG9lc24ndCBsb3NlIHRoZSBhYm92ZSByZWZpbmVtZW50LlxuXG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdGF0ZSwga2V5LCAnc2V0Jyk7XG4gIHJldHVybiBzZXQoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBlZWtOb2RlSW5mbyhzdG9yZSwgc3RhdGUsIGtleSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGUkMShrZXkpLm5vZGVUeXBlO1xuICByZXR1cm4gUmVjb2lsX2xhenlQcm94eSh7XG4gICAgdHlwZVxuICB9LCB7XG4gICAgbG9hZGFibGU6ICgpID0+IHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpLFxuICAgIGlzQWN0aXZlOiAoKSA9PiBzdG9yZVN0YXRlLmtub3duQXRvbXMuaGFzKGtleSkgfHwgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5oYXMoa2V5KSxcbiAgICBpc1NldDogKCkgPT4gdHlwZSA9PT0gJ3NlbGVjdG9yJyA/IGZhbHNlIDogc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSxcbiAgICBpc01vZGlmaWVkOiAoKSA9PiBzdGF0ZS5kaXJ0eUF0b21zLmhhcyhrZXkpLFxuICAgIC8vIFJlcG9ydCBjdXJyZW50IGRlcGVuZGVuY2llcy4gIElmIHRoZSBub2RlIGhhc24ndCBiZWVuIGV2YWx1YXRlZCwgdGhlblxuICAgIC8vIGRlcGVuZGVuY2llcyBtYXkgYmUgbWlzc2luZyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICBkZXBzOiAoKSA9PiB7XG4gICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMSgoX2dyYXBoJG5vZGVEZXBzJGdldCA9IGdyYXBoLm5vZGVEZXBzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogW10pO1xuICAgIH0sXG4gICAgLy8gUmVwb3J0cyBhbGwgXCJjdXJyZW50XCIgc3Vic2NyaWJlcnMuICBFdmFsdWF0aW5nIG90aGVyIG5vZGVzIG9yXG4gICAgLy8gcHJldmlvdXMgaW4tcHJvZ3Jlc3MgYXN5bmMgZXZhbHVhdGlvbnMgbWF5IGludHJvZHVjZSBuZXcgc3Vic2NyaWJlcnMuXG4gICAgc3Vic2NyaWJlcnM6ICgpID0+IHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRub2RlVG9Db20sIF9zdG9yZVN0YXRlJG5vZGVUb0NvbTI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoW2tleV0pKSwgbm9kZUtleSA9PiBub2RlS2V5ICE9PSBrZXkpKSxcbiAgICAgICAgY29tcG9uZW50czogUmVjb2lsX21hcEl0ZXJhYmxlKChfc3RvcmVTdGF0ZSRub2RlVG9Db20gPSAoX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbm9kZVRvQ29tMi52YWx1ZXMoKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbm9kZVRvQ29tICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRub2RlVG9Db20gOiBbXSwgKFtuYW1lXSkgPT4gKHtcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSAvLyBGaW5kIGFsbCBvZiB0aGUgcmVjdXJzaXZlbHkgZGVwZW5kZW50IG5vZGVzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzKHN0b3JlLCBzdGF0ZSwga2V5cykge1xuICBjb25zdCB2aXNpdGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHZpc2l0aW5nTm9kZXMgPSBBcnJheS5mcm9tKGtleXMpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pO1xuXG4gIGZvciAobGV0IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCk7IGtleTsga2V5ID0gdmlzaXRpbmdOb2Rlcy5wb3AoKSkge1xuICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICB2aXNpdGVkTm9kZXMuYWRkKGtleSk7XG4gICAgY29uc3Qgc3Vic2NyaWJlZE5vZGVzID0gKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlVG9Ob2RlU3VicyA6IGVtcHR5U2V0O1xuXG4gICAgZm9yIChjb25zdCBkb3duc3RyZWFtTm9kZSBvZiBzdWJzY3JpYmVkTm9kZXMpIHtcbiAgICAgIGlmICghdmlzaXRlZE5vZGVzLmhhcyhkb3duc3RyZWFtTm9kZSkpIHtcbiAgICAgICAgdmlzaXRpbmdOb2Rlcy5wdXNoKGRvd25zdHJlYW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlzaXRlZE5vZGVzO1xufVxuXG52YXIgUmVjb2lsX0Z1bmN0aW9uYWxDb3JlID0ge1xuICBnZXROb2RlTG9hZGFibGUsXG4gIHBlZWtOb2RlTG9hZGFibGUsXG4gIHNldE5vZGVWYWx1ZSxcbiAgaW5pdGlhbGl6ZU5vZGUsXG4gIGNsZWFuVXBOb2RlLFxuICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVELFxuICBwZWVrTm9kZUluZm8sXG4gIGdldERvd25zdHJlYW1Ob2Rlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KGludmFsaWRhdGUpIHtcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XG4gIHZhciBfaW52YWxpZGF0ZU1lbW9pemVkU247XG5cbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xuICBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCxcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Rcbn07XG5cbmNvbnN0IHtcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQyLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XG4gIGtleVxufSwgdHJlZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcblxuICAvLyBSZWFkaW5nIGZyb20gYW4gb2xkZXIgdHJlZSBjYW4gY2F1c2UgYnVncyBiZWNhdXNlIHRoZSBkZXBlbmRlbmNpZXMgdGhhdCB3ZVxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gcmVhZCBmcm9tIGEgZGlzY2FyZGVkIHRyZWUnKTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDEoc3RvcmUsIHRyZWVTdGF0ZSwga2V5KTtcblxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGxvYWRhYmxlLmNvbnRlbnRzLmNhdGNoKCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXG4gICAgICAgKiBleGVjdXRpb24gKHBlcmhhcHMgaW50cm9kdWNpbmcgYSBuZXcgRVJST1IgY2xhc3MgdG8gYmUgcmVzb2x2ZWQgYnkgYXN5bmMgc2VsZWN0b3JzIHRoYXQgYXJlIGluIGFuIGVycm9yIHN0YXRlKVxuICAgICAgICovXG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXRvbVZhbHVlV3JpdGVzKGF0b21WYWx1ZXMsIHdyaXRlcykge1xuICBjb25zdCByZXN1bHQgPSBhdG9tVmFsdWVzLmNsb25lKCk7XG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgaWYgKHYuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgdi5jb250ZW50cyBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICByZXN1bHQuZGVsZXRlKGspO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGssIHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwge1xuICBrZXlcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVcGRhdGVyIGZvcm06IHBhc3MgaW4gdGhlIGN1cnJlbnQgdmFsdWUuIFRocm93IGlmIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xuICAgIC8vIHBlbmRpbmcgb3IgZXJyb3JlZCk6XG4gICAgY29uc3QgY3VycmVudCA9IGdldE5vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwga2V5KTtcblxuICAgIGlmIChjdXJyZW50LnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBUcmllZCB0byBzZXQgYXRvbSBvciBzZWxlY3RvciBcIiR7a2V5fVwiIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gd2hpbGUgdGhlIGN1cnJlbnQgc3RhdGUgaXMgcGVuZGluZywgdGhpcyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5gO1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xuICAgIH0gLy8gVCBpdHNlbGYgbWF5IGJlIGEgZnVuY3Rpb24sIHNvIG91ciByZWZpbmVtZW50IGlzIG5vdCBzdWZmaWNpZW50OlxuXG5cbiAgICByZXR1cm4gdmFsdWVPclVwZGF0ZXIoY3VycmVudC5jb250ZW50cyk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFjdGlvbihzdG9yZSwgc3RhdGUsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWUsXG4gICAgICB2YWx1ZU9yVXBkYXRlclxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlcihzdG9yZSwgc3RhdGUsIHJlY29pbFZhbHVlLCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgY29uc3Qgd3JpdGVzID0gc2V0Tm9kZVZhbHVlJDEoc3RvcmUsIHN0YXRlLCByZWNvaWxWYWx1ZS5rZXksIG5ld1ZhbHVlKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbG9hZGFibGVdIG9mIHdyaXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0TG9hZGFibGUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbG9hZGFibGVcbiAgICB9ID0gYWN0aW9uO1xuICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9XG4gICAgfSA9IGFjdGlvbjtcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0VW52YWxpZGF0ZWQnKSB7XG4gICAgdmFyIF9ub2RlJGludmFsaWRhdGU7XG5cbiAgICAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4gICAgLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgdW52YWxpZGF0ZWRWYWx1ZVxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XG4gICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xuICAgIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSkge1xuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbG9hZGFibGUuY29udGVudHMgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG4gIH1cblxuICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xuICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZShzdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICBhcHBseUFjdGlvbihzdG9yZSwgbmV3U3RhdGUsIGFjdGlvbik7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zKHN0b3JlLCBuZXdTdGF0ZSk7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIGFjdGlvbikge1xuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IGJhdGNoU3RhY2tbYmF0Y2hTdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgYWN0aW9ucyA9IGFjdGlvbnNCeVN0b3JlLmdldChzdG9yZSk7XG5cbiAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgIGFjdGlvbnNCeVN0b3JlLnNldChzdG9yZSwgYWN0aW9ucyA9IFtdKTtcbiAgICB9XG5cbiAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBbYWN0aW9uXSk7XG4gIH1cbn1cblxuY29uc3QgYmF0Y2hTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBiYXRjaFN0YXJ0KCkge1xuICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IG5ldyBNYXAoKTtcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtzdG9yZSwgYWN0aW9uc10gb2YgYWN0aW9uc0J5U3RvcmUpIHtcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocG9wcGVkICE9PSBhY3Rpb25zQnlTdG9yZSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weVRyZWVTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCksXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG93bnN0cmVhbXMoc3RvcmUsIHN0YXRlKSB7XG4gIC8vIEluZm9ybSBhbnkgbm9kZXMgdGhhdCB3ZXJlIGNoYW5nZWQgb3IgZG93bnN0cmVhbSBvZiBjaGFuZ2VzIHNvIHRoYXQgdGhleVxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxuICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2RlcyQxKHN0b3JlLCBzdGF0ZSwgc3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcbiAgICB2YXIgX2dldE5vZGVNYXliZSwgX2dldE5vZGVNYXliZSRpbnZhbGlkO1xuXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB2YWx1ZU9yVXBkYXRlclxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XG4gIGlmIChsb2FkYWJsZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgcmV0dXJuIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgbG9hZGFibGUpO1xuICB9XG5cbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgbG9hZGFibGU6IGxvYWRhYmxlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdtYXJrTW9kaWZpZWQnLFxuICAgIHJlY29pbFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdW52YWxpZGF0ZWRWYWx1ZSkge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB1bnZhbGlkYXRlZFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XG4gIGtleVxufSwgY2FsbGJhY2ssIGNvbXBvbmVudERlYnVnTmFtZSA9IG51bGwpIHtcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgIHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoc3ViSUQsIFtjb21wb25lbnREZWJ1Z05hbWUgIT09IG51bGwgJiYgY29tcG9uZW50RGVidWdOYW1lICE9PSB2b2lkIDAgPyBjb21wb25lbnREZWJ1Z05hbWUgOiAnPG5vdCBjYXB0dXJlZD4nLCBjYWxsYmFja10pOyAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCwgZHVyaW5nIHRoZSBzYW1lIHRpY2sgdGhhdCB3ZSBhcmUgc3Vic2NyaWJpbmcsIGFuIGF0b21cbiAgLy8gaGFzIGJlZW4gdXBkYXRlZCBieSBzb21lIGVmZmVjdCBoYW5kbGVyLiBPdGhlcndpc2Ugd2Ugd2lsbCBtaXNzIHRoZSB1cGRhdGUuXG5cbiAgY29uc3QgbW9kZSA9IHJlYWN0TW9kZSQxKCk7XG5cbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xuICAgIGNvbnN0IG5leHRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZTtcblxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XG4gICAgICBjYWxsYmFjayhuZXh0VHJlZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICBjb25zdCByZWxlYXNlU3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBzdWJzID0gcmVsZWFzZVN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCB8fCAhc3Vicy5oYXMoc3ViSUQpKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihgU3Vic2NyaXB0aW9uIG1pc3NpbmcgYXQgcmVsZWFzZSB0aW1lIGZvciBhdG9tICR7a2V5fS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xuXG4gICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XG4gIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gIGNvbnN0IHtcbiAgICBjdXJyZW50VHJlZVxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xuICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCBjdXJyZW50VHJlZSk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UgPSB7XG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlLFxuICBzZXRSZWNvaWxWYWx1ZSxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWUsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMSxcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cG9ydCB3aGVuIGRlcHJlY2F0aW5nIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQgaW4gUmVjb2lsUm9vdFxuICBiYXRjaFN0YXJ0LFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtcyxcbiAgY29weVRyZWVTdGF0ZSxcbiAgcmVmcmVzaFJlY29pbFZhbHVlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUaGUgc29tZVNldCgpIG1ldGhvZCB0ZXN0cyB3aGV0aGVyIHNvbWUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIFNldCBwYXNzIHRoZVxuICogdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gc29tZVNldChzZXQsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gc2V0LmVudHJpZXMoKTtcbiAgbGV0IGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjdXJyZW50LmRvbmUpIHtcbiAgICBjb25zdCBlbnRyeSA9IGN1cnJlbnQudmFsdWU7XG5cbiAgICBpZiAoY2FsbGJhY2suY2FsbChjb250ZXh0LCBlbnRyeVsxXSwgZW50cnlbMF0sIHNldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBSZWNvaWxfc29tZVNldCA9IHNvbWVTZXQ7XG5cbmNvbnN0IHtcbiAgY2xlYW5VcE5vZGU6IGNsZWFuVXBOb2RlJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGU6IGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEsXG4gIGdldE5vZGU6IGdldE5vZGUkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkMlxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5cblxuXG5cblxuXG4gLy8gQ29tcG9uZW50cyB0aGF0IGFyZW4ndCBtb3VudGVkIGFmdGVyIHN1c3BlbmRpbmcgZm9yIHRoaXMgbG9uZyB3aWxsIGJlIGFzc3VtZWRcbi8vIHRvIGJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzb3VyY2VzIHJlbGVhc2VkLlxuXG5cbmNvbnN0IFNVU1BFTlNFX1RJTUVPVVRfTVMgPSAxMjAwMDA7XG5jb25zdCBlbXB0eVNldCQxID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCByZXRhaW5hYmxlcykge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbigncmVsZWFzZU5vZGVzTm93T25DdXJyZW50VHJlZSBzaG91bGQgb25seSBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhIGJhdGNoJyk7XG4gICAgcmV0dXJuOyAvLyBsZWFrIG1lbW9yeSByYXRoZXIgdGhhbiBlcmFzZSBzb21ldGhpbmcgdGhhdCdzIGFib3V0IHRvIGJlIHVzZWQuXG4gIH1cblxuICBjb25zdCBub2RlcyA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICBpZiAociBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgcikpIHtcbiAgICAgICAgbm9kZXMuYWRkKG4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5hZGQocik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgbm9kZXMpO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiByZWxlYXNhYmxlTm9kZXMpIHtcbiAgICByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzKHN0b3JlLCBzZWFyY2hGcm9tTm9kZXMpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCByZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7IC8vIG11dGF0ZWQgdG8gY29sbGVjdCBhbnN3ZXJcblxuICBjb25zdCBub25SZWxlYXNhYmxlTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpO1xuICByZXR1cm4gcmVsZWFzYWJsZU5vZGVzO1xuXG4gIGZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihzZWFyY2hGcm9tTm9kZXMpIHtcbiAgICBjb25zdCByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZG93bnN0cmVhbXMgPSBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgc2VhcmNoRnJvbU5vZGVzLCByZWxlYXNhYmxlTm9kZXMsIC8vIGRvbid0IGRlc2NlbmQgaW50byB0aGVzZVxuICAgIG5vblJlbGVhc2FibGVOb2RlcyAvLyBkb24ndCBkZXNjZW5kIGludG8gdGhlc2VcbiAgICApOyAvLyBGaW5kIHdoaWNoIG9mIHRoZSBkb3duc3RyZWFtIG5vZGVzIGFyZSByZWxlYXNhYmxlIGFuZCB3aGljaCBhcmUgbm90OlxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGRvd25zdHJlYW1zKSB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uO1xuXG4gICAgICAvLyBOb3QgcmVsZWFzYWJsZSBpZiBjb25maWd1cmVkIHRvIGJlIHJldGFpbmVkIGZvcmV2ZXI6XG4gICAgICBpZiAoZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgZGlyZWN0bHkgYnkgYSBjb21wb25lbnQ6XG5cblxuICAgICAgaWYgKCgoX3N0b3JlU3RhdGUkcmV0ZW50aW9uID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldChub2RlKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gOiAwKSA+IDApIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGJ5IGEgem9uZTpcblxuXG4gICAgICBpZiAoem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpLnNvbWUoeiA9PiBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KHopKSkge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgaXQgaGFzIGEgbm9uLXJlbGVhc2FibGUgY2hpbGQgKHdoaWNoIHdpbGwgYWxyZWFkeSBiZSBpblxuICAgICAgLy8gbm9uUmVsZWFzYWJsZU5vZGVzIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIGluIHRvcG9sb2dpY2FsIG9yZGVyKTpcblxuXG4gICAgICBjb25zdCBub2RlQ2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlQ2hpbGRyZW4gJiYgUmVjb2lsX3NvbWVTZXQobm9kZUNoaWxkcmVuLCBjaGlsZCA9PiBub25SZWxlYXNhYmxlTm9kZXMuaGFzKGNoaWxkKSkpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24uYWRkKG5vZGUpO1xuICAgIH0gLy8gSWYgd2UgZm91bmQgYW55IHJlbGVhc2FibGUgbm9kZXMsIHdlIG5lZWQgdG8gd2FsayBVUCBmcm9tIHRob3NlIG5vZGVzIHRvXG4gICAgLy8gZmluZCB3aGV0aGVyIHRoZWlyIHBhcmVudHMgY2FuIG5vdyBiZSByZWxlYXNlZCBhcyB3ZWxsOlxuXG5cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSkpICE9PSBudWxsICYmIF9ncmFwaCRub2RlRGVwcyRnZXQgIT09IHZvaWQgMCA/IF9ncmFwaCRub2RlRGVwcyRnZXQgOiBlbXB0eVNldCQxKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZURlcHMkZ2V0O1xuXG4gICAgICAgIGlmICghcmVsZWFzYWJsZU5vZGVzLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgcGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnRzLnNpemUpIHtcbiAgICAgIGZpbmRSZWxlYXNhYmxlTm9kZXNJbm5lcihwYXJlbnRzKTtcbiAgICB9XG4gIH1cbn0gLy8gQ2hpbGRyZW4gYmVmb3JlIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZXMsIC8vIE11dGFibGUgc2V0IGlzIGRlc3Ryb3llZCBpbiBwbGFjZVxuZG9Ob3REZXNjZW5kSW50bzEsIGRvTm90RGVzY2VuZEludG8yKSB7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pO1xuICBjb25zdCBhbnN3ZXIgPSBbXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICB3aGlsZSAobm9kZXMuc2l6ZSA+IDApIHtcbiAgICB2aXNpdChSZWNvaWxfbnVsbHRocm93cyhub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBhbnN3ZXI7XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChkb05vdERlc2NlbmRJbnRvMS5oYXMobm9kZSkgfHwgZG9Ob3REZXNjZW5kSW50bzIuaGFzKG5vZGUpKSB7XG4gICAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQobm9kZSk7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgIG5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICBhbnN3ZXIucHVzaChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlTm9kZShzdG9yZSwgdHJlZVN0YXRlLCBub2RlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdG9tIGVmZmVjdHMsIGluLWNsb3N1cmUgY2FjaGVzLCBldGMuOlxuXG5cbiAgY2xlYW5VcE5vZGUkMShzdG9yZSwgbm9kZSk7IC8vIERlbGV0ZSBmcm9tIHN0b3JlIHN0YXRlOlxuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmtub3duQXRvbXMuZGVsZXRlKG5vZGUpO1xuICBzdG9yZVN0YXRlLmtub3duU2VsZWN0b3JzLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmRlbGV0ZShub2RlKTtcbiAgY29uc3Qgem9uZXMgPSB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSk7XG5cbiAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjI7XG5cbiAgICAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yLmRlbGV0ZShub2RlKTtcbiAgfSAvLyBOb3RlIHRoYXQgd2UgRE8gTk9UIGRlbGV0ZSBmcm9tIG5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMgYmVjYXVzZSB0aGlzXG4gIC8vIGFscmVhZHkgaGFwcGVucyB3aGVuIHRoZSBsYXN0IGNvbXBvbmVudCB0aGF0IHdhcyByZXRhaW5pbmcgdGhlIG5vZGUgdW5tb3VudHMsXG4gIC8vIGFuZCB0aGlzIGNvdWxkIGhhcHBlbiBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoYXQuXG4gIC8vIERlbGV0ZSBmcm9tIFRyZWVTdGF0ZSBhbmQgZGVwIGdyYXBoOlxuXG5cbiAgdHJlZVN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGUpO1xuICB0cmVlU3RhdGUuZGlydHlBdG9tcy5kZWxldGUobm9kZSk7XG4gIHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHRyZWVTdGF0ZS52ZXJzaW9uKTtcblxuICBpZiAoZ3JhcGgpIHtcbiAgICBjb25zdCBkZXBzID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JhcGgubm9kZURlcHMuZGVsZXRlKG5vZGUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgIHZhciBfZ3JhcGgkbm9kZVRvTm9kZVN1YnM7XG5cbiAgICAgICAgKF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChkZXApKSA9PT0gbnVsbCB8fCBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ncmFwaCRub2RlVG9Ob2RlU3Vicy5kZWxldGUobm9kZSk7XG4gICAgICB9XG4gICAgfSAvLyBObyBuZWVkIHRvIGRlbGV0ZSBzdWIncyBkZXBzIGFzIHRoZXJlIHNob3VsZCBiZSBubyBzdWJzIGF0IHRoaXMgcG9pbnQuXG4gICAgLy8gQnV0IGFuIGludmFyaWFudCB3b3VsZCByZXF1aXJlIGRlbGV0aW5nIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuXG5cbiAgICBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gIH0gLy8gTm9kZSBjb25maWcgKGZvciBmYW1pbHkgbWVtYmVycyBvbmx5IGFzIHRoZWlyIGNvbmZpZ3MgY2FuIGJlIHJlY3JlYXRlZCwgYW5kXG4gIC8vIG9ubHkgaWYgdGhleSBhcmUgbm90IHJldGFpbmVkIHdpdGhpbiBhbnkgb3RoZXIgU3RvcmVzKTpcblxuXG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlJDEobm9kZSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVzUmV0YWluZWRCeVpvbmUoc3RvcmVTdGF0ZSwgem9uZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMztcblxuICByZXR1cm4gKF9zdG9yZVN0YXRlJHJldGVudGlvbjMgPSBzdG9yZVN0YXRlLnJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyA6IGVtcHR5U2V0JDE7XG59XG5cbmZ1bmN0aW9uIHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKSB7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSBnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeTtcblxuICBpZiAocmV0YWluZWRCeSA9PT0gdW5kZWZpbmVkIHx8IHJldGFpbmVkQnkgPT09ICdjb21wb25lbnRzJyB8fCByZXRhaW5lZEJ5ID09PSAncmVjb2lsUm9vdCcpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMikge1xuICAgIHJldHVybiBbcmV0YWluZWRCeV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJldGFpbmVkQnk7IC8vIGl0J3MgYW4gYXJyYXkgb2Ygem9uZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZShzdG9yZSwgcmV0YWluYWJsZSkge1xuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0YXRlLm5leHRUcmVlKSB7XG4gICAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuYWRkKHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUoc3RvcmUsIG5ldyBTZXQoW3JldGFpbmFibGVdKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnQoc3RvcmUsIHJldGFpbmFibGUsIGRlbHRhKSB7XG4gIHZhciBfbWFwJGdldDtcblxuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXAgPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHM7XG4gIGNvbnN0IG5ld0NvdW50ID0gKChfbWFwJGdldCA9IG1hcC5nZXQocmV0YWluYWJsZSkpICE9PSBudWxsICYmIF9tYXAkZ2V0ICE9PSB2b2lkIDAgPyBfbWFwJGdldCA6IDApICsgZGVsdGE7XG5cbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8oc3RvcmUsIHJldGFpbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIG1hcC5zZXQocmV0YWluYWJsZSwgbmV3Q291bnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcbiAgbWFwLmRlbGV0ZShyZXRhaW5hYmxlKTtcbiAgc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3coc3RvcmUpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZSk7XG4gIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdChyKSB7XG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgY2hhbmdlIGZyb20gJ3JlY29pbFJvb3QnIHRvICdjb21wb25lbnRzJyBpbiB0aGUgZnV0dXJlLlxuICByZXR1cm4gciA9PT0gdW5kZWZpbmVkID8gJ3JlY29pbFJvb3QnIDogcjtcbn1cblxudmFyIFJlY29pbF9SZXRlbnRpb24gPSB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVMsXG4gIHVwZGF0ZVJldGFpbkNvdW50LFxuICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyxcbiAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93LFxuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHRcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBUaGlzIGlzIHRvIGV4cG9ydCBlc3N0aWVudGlhbCBmdW5jdGlvbnMgZnJvbSByZWFjdC1kb21cbiAqIGZvciBvdXIgd2ViIGJ1aWxkXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5jb25zdCB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXG59ID0gcmVhY3REb207XG5cbnZhciBSZWFjdEJhdGNoZWRVcGRhdGVzID0ge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBUaGlzIGlzIHRvIGV4cG9ydCBlc3N0aWVudGlhbCBmdW5jdGlvbnMgZnJvbSByZWFjdC1kb21cbiAqIGZvciBvdXIgd2ViIGJ1aWxkXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vLyBAZmItb25seTogY29uc3Qge3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzfSA9IHJlcXVpcmUoJ1JlYWN0RE9NQ29tZXQnKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMVxufSA9IFJlYWN0QmF0Y2hlZFVwZGF0ZXM7IC8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5jb25zdCB7XG4gIGJhdGNoU3RhcnQ6IGJhdGNoU3RhcnQkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMlxufSA9IFJlY29pbF9SZWFjdEJhdGNoZWRVcGRhdGVzO1xuXG5sZXQgYmF0Y2hlciA9IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDI7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbi8qKlxuICogU2V0cyB0aGUgcHJvdmlkZWQgYmF0Y2hlciBmdW5jdGlvbiBhcyB0aGUgYmF0Y2hlciBmdW5jdGlvbiB1c2VkIGJ5IFJlY29pbC5cbiAqXG4gKiBTZXQgdGhlIGJhdGNoZXIgdG8gYSBjdXN0b20gYmF0Y2hlciBmb3IgeW91ciByZW5kZXJlcixcbiAqIGlmIHlvdSB1c2UgYSByZW5kZXJlciBvdGhlciB0aGFuIFJlYWN0IERPTSBvciBSZWFjdCBOYXRpdmUuXG4gKi9cbmNvbnN0IHNldEJhdGNoZXIgPSBuZXdCYXRjaGVyID0+IHtcbiAgYmF0Y2hlciA9IG5ld0JhdGNoZXI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24uXG4gKi9cblxuXG5jb25zdCBnZXRCYXRjaGVyID0gKCkgPT4gYmF0Y2hlcjtcbi8qKlxuICogQ2FsbHMgdGhlIGN1cnJlbnQgYmF0Y2hlciBmdW5jdGlvbiBhbmQgcGFzc2VzIHRoZVxuICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuXG5jb25zdCBiYXRjaFVwZGF0ZXMgPSBjYWxsYmFjayA9PiB7XG4gIGJhdGNoZXIoKCkgPT4ge1xuICAgIGxldCBiYXRjaEVuZCA9ICgpID0+IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBiYXRjaEVuZCA9IGJhdGNoU3RhcnQkMSgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYmF0Y2hFbmQoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFJlY29pbF9CYXRjaGluZyA9IHtcbiAgZ2V0QmF0Y2hlcixcbiAgc2V0QmF0Y2hlcixcbiAgYmF0Y2hVcGRhdGVzXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBJdGVyYWJsZXMgaW50byBhIHNpbmdsZSBJdGVyYWJsZS5cbiAqIFRyYXZlcnNlcyB0aGUgaW5wdXQgSXRlcmFibGVzIGluIHRoZSBvcmRlciBwcm92aWRlZCBhbmQgbWFpbnRhaW5zIHRoZSBvcmRlclxuICogb2YgdGhlaXIgZWxlbWVudHMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogY29uc3QgciA9IEFycmF5LmZyb20oY29uY2F0SXRlcmFibGVzKFsnYScsICdiJ10sIFsnYyddLCBbJ2QnLCAnZScsICdmJ10pKTtcbiAqIHIgPT0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZiddO1xuICogYGBgXG4gKi9cblxuZnVuY3Rpb24qIGNvbmNhdEl0ZXJhYmxlcyhpdGVycykge1xuICBmb3IgKGNvbnN0IGl0ZXIgb2YgaXRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBpdGVyKSB7XG4gICAgICB5aWVsZCB2YWw7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfY29uY2F0SXRlcmFibGVzID0gY29uY2F0SXRlcmFibGVzO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuY29uc3QgaXNTU1IgPSAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcbnR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuLyogZXNsaW50LWVuYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG5jb25zdCBpc1dpbmRvdyA9IHZhbHVlID0+ICFpc1NTUiAmJiAoIC8vICRGbG93Rml4TWUoc2l0ZT1yZWNvaWwpIFdpbmRvdyBkb2VzIG5vdCBoYXZlIGEgRmxvd1R5cGUgZGVmaW5pdGlvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNjcwOVxudmFsdWUgPT09IHdpbmRvdyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFdpbmRvdyk7XG5cbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZFxuXG52YXIgUmVjb2lsX0Vudmlyb25tZW50ID0ge1xuICBpc1NTUixcbiAgaXNSZWFjdE5hdGl2ZSxcbiAgaXNXaW5kb3dcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiB0aGUga2V5IHJldHVybmVkIGJ5IHRoZSBwYXNzZWRcbiAqIGhhc2hGdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplV2l0aEFyZ3NIYXNoKGZuLCBoYXNoRnVuY3Rpb24pIHtcbiAgbGV0IGNhY2hlO1xuXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIGNhY2hlID0ge307XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KSkge1xuICAgICAgY2FjaGVba2V5XSA9IGZuKC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZEZuO1xufVxuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gYSBjb21wYXJpc29uIG9mIHRoZSBhcmd1bWVudHMuXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxuICogRGVmYXVsdHMgdG8gcmVmZXJlbmNlIGVxdWFsaXR5XG4gKi9cblxuXG5mdW5jdGlvbiBtZW1vaXplT25lV2l0aEFyZ3NIYXNoKGZuLCBoYXNoRnVuY3Rpb24pIHtcbiAgbGV0IGxhc3RLZXk7XG4gIGxldCBsYXN0UmVzdWx0OyAvLyBicmVha2luZyBjYWNoZSB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcblxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBrZXkgPSBoYXNoRnVuY3Rpb24oLi4uYXJncyk7XG5cbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9XG5cbiAgICBsYXN0S2V5ID0ga2V5O1xuICAgIGxhc3RSZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cbi8qKlxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxuICogT25seSBjYWNoZXMgdGhlIGxhc3QgcmV0dXJuIG9mIHRoZSBmdW5jdGlvbi5cbiAqIERlZmF1bHRzIHRvIHJlZmVyZW5jZSBlcXVhbGl0eVxuICovXG5cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbihmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBsYXN0S2V5O1xuICBsZXQgbGFzdFJlc3VsdDsgLy8gYnJlYWtpbmcgY2FjaGUgd2hlbiBhcmd1bWVudHMgY2hhbmdlXG5cbiAgY29uc3QgbWVtb2l6ZWRGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGxhc3RLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdEtleSA9IGtleTtcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgY29uc3QgaW52YWxpZGF0ZSA9ICgpID0+IHtcbiAgICBsYXN0S2V5ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gW21lbW9pemVkRm4sIGludmFsaWRhdGVdO1xufVxuXG52YXIgUmVjb2lsX01lbW9pemUgPSB7XG4gIG1lbW9pemVXaXRoQXJnc0hhc2gsXG4gIG1lbW9pemVPbmVXaXRoQXJnc0hhc2gsXG4gIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb25cbn07XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkMVxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBpbml0aWFsaXplTm9kZTogaW5pdGlhbGl6ZU5vZGUkMSxcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBncmFwaDogZ3JhcGgkMVxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBnZXROZXh0U3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMVxufSA9IFJlY29pbF9LZXlzO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkMSxcbiAgcmVjb2lsVmFsdWVzOiByZWNvaWxWYWx1ZXMkMSxcbiAgcmVjb2lsVmFsdWVzRm9yS2V5czogcmVjb2lsVmFsdWVzRm9yS2V5cyQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQyLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkMSxcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZTogc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQxXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdDogc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdENhY2hlO1xuXG5jb25zdCB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyLFxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDFcbn0gPSBSZWNvaWxfU3RhdGU7XG5cblxuXG5jb25zdCB7XG4gIGlzU1NSOiBpc1NTUiQxXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uOiBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDFcbn0gPSBSZWNvaWxfTWVtb2l6ZTtcblxuXG5cbiAvLyBPcGFxdWUgYXQgdGhpcyBzdXJmYWNlIGJlY2F1c2UgaXQncyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIGZyb20gaGVyZS5cblxuXG5jb25zdCByZXRhaW5XYXJuaW5nID0gYFxuUmVjb2lsIFNuYXBzaG90cyBvbmx5IGxhc3QgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgY2FsbGJhY2sgdGhleSBhcmUgcHJvdmlkZWQgdG8uIFRvIGtlZXAgYSBTbmFwc2hvdCBsb25nZXIsIGRvIHRoaXM6XG5cbiAgY29uc3QgcmVsZWFzZSA9IHNuYXBzaG90LnJldGFpbigpO1xuICB0cnkge1xuICAgIGF3YWl0IGRvU29tZXRoaW5nV2l0aFNuYXBzaG90KHNuYXBzaG90KTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlKCk7XG4gIH1cblxuVGhpcyBpcyBjdXJyZW50bHkgYSBERVYtb25seSB3YXJuaW5nIGJ1dCB3aWxsIGJlY29tZSBhIHRocm93biBleGNlcHRpb24gaW4gdGhlIG5leHQgcmVsZWFzZSBvZiBSZWNvaWwuXG5gOyAvLyBBIFwiU25hcHNob3RcIiBpcyBcInJlYWQtb25seVwiIGFuZCBjYXB0dXJlcyBhIHNwZWNpZmljIHNldCBvZiB2YWx1ZXMgb2YgYXRvbXMuXG4vLyBIb3dldmVyLCB0aGUgZGF0YS1mbG93LWdyYXBoIGFuZCBzZWxlY3RvciB2YWx1ZXMgbWF5IGV2b2x2ZSBhcyBzZWxlY3RvclxuLy8gZXZhbHVhdGlvbiBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkIGFuZCBhc3luYyBzZWxlY3RvcnMgcmVzb2x2ZS5cblxuY2xhc3MgU25hcHNob3Qge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLXVuaW5pdGlhbGl6ZWQtcHJvcGVydGllc1xuICBjb25zdHJ1Y3RvcihzdG9yZVN0YXRlLCBwYXJlbnRTdG9yZUlEKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVmQ291bnRcIiwgMSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRMb2FkYWJsZVwiLCByZWNvaWxWYWx1ZSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMSh0aGlzLl9zdG9yZSwgcmVjb2lsVmFsdWUpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0UHJvbWlzZVwiLCByZWNvaWxWYWx1ZSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldExvYWRhYmxlKHJlY29pbFZhbHVlKS50b1Byb21pc2UoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldE5vZGVzX1VOU1RBQkxFXCIsIG9wdCA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTsgLy8gVE9ETyBEZWFsIHdpdGggbW9kaWZpZWQgc2VsZWN0b3JzXG5cbiAgICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmlzTW9kaWZpZWQpID09PSB0cnVlKSB7XG4gICAgICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmlzSW5pdGlhbGl6ZWQpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgICByZXR1cm4gcmVjb2lsVmFsdWVzRm9yS2V5cyQyKHN0YXRlLmRpcnR5QXRvbXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrbm93bkF0b21zID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zO1xuXG4gICAgICBjb25zdCBrbm93blNlbGVjdG9ycyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnM7XG5cbiAgICAgIHJldHVybiAob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmlzSW5pdGlhbGl6ZWQpID09IG51bGwgPyByZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSA6IG9wdC5pc0luaXRpYWxpemVkID09PSB0cnVlID8gcmVjb2lsVmFsdWVzRm9yS2V5cyQyKFJlY29pbF9jb25jYXRJdGVyYWJsZXMoW2tub3duQXRvbXMsIGtub3duU2VsZWN0b3JzXSkpIDogUmVjb2lsX2ZpbHRlckl0ZXJhYmxlKHJlY29pbFZhbHVlcyQxLnZhbHVlcygpLCAoe1xuICAgICAgICBrZXlcbiAgICAgIH0pID0+ICFrbm93bkF0b21zLmhhcyhrZXkpICYmICFrbm93blNlbGVjdG9ycy5oYXMoa2V5KSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRJbmZvX1VOU1RBQkxFXCIsICh7XG4gICAgICBrZXlcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIHJldHVybiBwZWVrTm9kZUluZm8kMSh0aGlzLl9zdG9yZSwgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcFwiLCBtYXBwZXIgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBtdXRhYmxlU25hcHNob3QgPSBuZXcgTXV0YWJsZVNuYXBzaG90KHRoaXMsIGJhdGNoVXBkYXRlcyQxKTtcbiAgICAgIG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBpZiByZW1vdmluZyBiYXRjaFVwZGF0ZXMgZnJvbSBgc2V0YCBhZGQgaXQgaGVyZVxuXG4gICAgICByZXR1cm4gbXV0YWJsZVNuYXBzaG90O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXN5bmNNYXBcIiwgYXN5bmMgbWFwcGVyID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XG4gICAgICBtdXRhYmxlU25hcHNob3QucmV0YWluKCk7IC8vIFJldGFpbiBuZXcgc25hcHNob3QgZHVyaW5nIGFzeW5jIG1hcHBlclxuXG4gICAgICBhd2FpdCBtYXBwZXIobXV0YWJsZVNuYXBzaG90KTsgLy8gQ29udGludWUgdG8gcmV0YWluIHRoZSBuZXcgc25hcHNob3QgZm9yIHRoZSB1c2VyLCBidXQgYXV0by1yZWxlYXNlIGl0XG4gICAgICAvLyBhZnRlciB0aGUgbmV4dCB0aWNrLCB0aGUgc2FtZSBhcyBhIG5ldyBzeW5jaHJvbm91cyBzbmFwc2hvdC5cblxuICAgICAgbXV0YWJsZVNuYXBzaG90LmF1dG9SZWxlYXNlX0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gbXV0YWJsZVNuYXBzaG90O1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3RvcmUgPSB7XG4gICAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxKCksXG4gICAgICBwYXJlbnRTdG9yZUlELFxuICAgICAgZ2V0U3RhdGU6ICgpID0+IHN0b3JlU3RhdGUsXG4gICAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VyID0+IHtcbiAgICAgICAgLy8gbm8gYmF0Y2hpbmcsIHNvIG5leHRUcmVlIGlzIG5ldmVyIGFjdGl2ZVxuICAgICAgICBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlID0gcmVwbGFjZXIoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSk7XG4gICAgICB9LFxuICAgICAgZ2V0R3JhcGg6IHZlcnNpb24gPT4ge1xuICAgICAgICBjb25zdCBncmFwaHMgPSBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbjtcblxuICAgICAgICBpZiAoZ3JhcGhzLmhhcyh2ZXJzaW9uKSkge1xuICAgICAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhncmFwaHMuZ2V0KHZlcnNpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld0dyYXBoID0gZ3JhcGgkMSgpO1xuICAgICAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcbiAgICAgICAgcmV0dXJuIG5ld0dyYXBoO1xuICAgICAgfSxcbiAgICAgIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiAoKSA9PiAoe1xuICAgICAgICByZWxlYXNlOiAoKSA9PiB7fVxuICAgICAgfSksXG4gICAgICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhOiAoKSA9PiB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gU25hcHNob3RzJyk7XG4gICAgICB9XG4gICAgfTsgLy8gSW5pdGlhbGl6ZSBhbnkgbm9kZXMgdGhhdCBhcmUgbGl2ZSBpbiB0aGUgcGFyZW50IHN0b3JlIChwcmltYXJpbHkgc28gdGhhdFxuICAgIC8vIHRoaXMgc25hcHNob3QgZ2V0cyBjb3VudGVkIHRvd2FyZHMgdGhlIG5vZGUncyBsaXZlIHN0b3JlcyBjb3VudCkuXG4gICAgLy8gVE9ETyBPcHRpbWl6ZSB0aGlzIHdoZW4gY2xvbmluZyBzbmFwc2hvdHMgZm9yIGNhbGxiYWNrc1xuXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xuICAgICAgaW5pdGlhbGl6ZU5vZGUkMSh0aGlzLl9zdG9yZSwgbm9kZUtleSwgJ2dldCcpO1xuICAgICAgdXBkYXRlUmV0YWluQ291bnQkMSh0aGlzLl9zdG9yZSwgbm9kZUtleSwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xuICB9XG5cbiAgcmV0YWluKCkge1xuICAgIGlmICh0aGlzLl9yZWZDb3VudCA8PSAwKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NuYXBzaG90IGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0F0dGVtcHQgdG8gcmV0YWluKCkgU25hcHNob3QgdGhhdCB3YXMgYWxyZWFkeSByZWxlYXNlZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZWZDb3VudCsrO1xuICAgIGxldCByZWxlYXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJlbGVhc2VkKSB7XG4gICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgc25hcHNob3Qgb24gdGhlIG5leHQgdGljay4gIFRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IGlzIHJldGFpbmVkXG4gICAqIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHVzaW5nIGl0LlxuICAgKi9cblxuXG4gIGF1dG9SZWxlYXNlX0lOVEVSTkFMKCkge1xuICAgIGlmICghaXNTU1IkMSkge1xuICAgICAgLy8gVXNlIHRpbWVvdXQgb2YgMTAgdG8gd29ya2Fyb3VuZCBGaXJlZm94IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy8xOTM2XG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9yZWxlYXNlKCksIDEwKTtcbiAgICB9XG4gIH1cblxuICBfcmVsZWFzZSgpIHtcbiAgICB0aGlzLl9yZWZDb3VudC0tO1xuXG4gICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuXG4gICAgICB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmNsZWFyKCk7XG5cbiAgICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFRlbXBvcmFyaWx5IG5lcmZpbmcgdGhpcyB0byBhbGxvdyB1cyB0byBmaW5kIGJyb2tlbiBjYWxsIHNpdGVzIHdpdGhvdXRcbiAgICAgIC8vIGFjdHVhbGx5IGJyZWFraW5nIGFueWJvZHkgeWV0LlxuICAgICAgLy8gZm9yIChjb25zdCBrIG9mIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xuICAgICAgLy8gICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyh0aGlzLl9zdG9yZSwgayk7XG4gICAgICAvLyB9XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlZkNvdW50IDwgMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1NuYXBzaG90IHJlbGVhc2VkIGFuIGV4dHJhIHRpbWUuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNSZXRhaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmQ291bnQgPiAwO1xuICB9XG5cbiAgY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpIHtcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiB0aGlzLl9yZWZDb3VudCA8PSAwKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihyZXRhaW5XYXJuaW5nKTtcbiAgICAgIH0gLy8gV2hhdCB3ZSB3aWxsIHNoaXAgbGF0ZXI6XG4gICAgICAvLyB0aHJvdyBlcnIocmV0YWluV2FybmluZyk7XG5cbiAgICB9XG4gIH1cblxuICBnZXRTdG9yZV9JTlRFUk5BTCgpIHtcbiAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmU7XG4gIH1cblxuICBnZXRJRCgpIHtcbiAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS5zdGF0ZUlEO1xuICB9XG5cbiAgZ2V0U3RvcmVJRCgpIHtcbiAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuc3RvcmVJRDtcbiAgfSAvLyBXZSB3YW50IHRvIGFsbG93IHRoZSBtZXRob2RzIHRvIGJlIGRlc3RydWN0dXJlZCBhbmQgdXNlZCBhcyBhY2Nlc3NvcnNcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cblxuICAvKiBlc2xpbnQtZW5hYmxlIGZiLXd3dy9leHRyYS1hcnJvdy1pbml0aWFsaXplciAqL1xuXG5cbn1cblxuZnVuY3Rpb24gY2xvbmVTdG9yZVN0YXRlKHN0b3JlLCB0cmVlU3RhdGUsIGJ1bXBWZXJzaW9uID0gZmFsc2UpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHZlcnNpb24gPSBidW1wVmVyc2lvbiA/IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDIoKSA6IHRyZWVTdGF0ZS52ZXJzaW9uO1xuICByZXR1cm4ge1xuICAgIC8vIEFsd2F5cyBjbG9uZSB0aGUgVHJlZVN0YXRlIHRvIGlzb2xhdGUgc3RvcmVzIGZyb20gYWNjaWRlbnRhbCBtdXRhdGlvbnMuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHJlYWRpbmcgYSBzZWxlY3RvciBmcm9tIGEgY2xvbmVkIHNuYXBzaG90IHNob3VsZG4ndCBjYWNoZVxuICAgIC8vIGluIHRoZSBvcmlnaW5hbCB0cmVlc3RhdGUgd2hpY2ggbWF5IGNhdXNlIHRoZSBvcmlnaW5hbCB0byBza2lwXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gb2YgdXBzdHJlYW0gYXRvbXMuXG4gICAgY3VycmVudFRyZWU6IHtcbiAgICAgIC8vIFRPRE8gc25hcHNob3RzIHNob3VsZG4ndCByZWFsbHkgaGF2ZSB2ZXJzaW9ucyBiZWNhdXNlIGEgbmV3IHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyBpcyBhbHdheXMgYXNzaWduZWQgd2hlbiB0aGUgc25hcHNob3QgaXMgZ29uZSB0by5cbiAgICAgIHZlcnNpb246IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS52ZXJzaW9uLFxuICAgICAgc3RhdGVJRDogYnVtcFZlcnNpb24gPyB2ZXJzaW9uIDogdHJlZVN0YXRlLnN0YXRlSUQsXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7IC4uLnRyZWVTdGF0ZS50cmFuc2FjdGlvbk1ldGFkYXRhXG4gICAgICB9LFxuICAgICAgZGlydHlBdG9tczogbmV3IFNldCh0cmVlU3RhdGUuZGlydHlBdG9tcyksXG4gICAgICBhdG9tVmFsdWVzOiB0cmVlU3RhdGUuYXRvbVZhbHVlcy5jbG9uZSgpLFxuICAgICAgbm9udmFsaWRhdGVkQXRvbXM6IHRyZWVTdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpXG4gICAgfSxcbiAgICBjb21taXREZXB0aDogMCxcbiAgICBuZXh0VHJlZTogbnVsbCxcbiAgICBwcmV2aW91c1RyZWU6IG51bGwsXG4gICAga25vd25BdG9tczogbmV3IFNldChzdG9yZVN0YXRlLmtub3duQXRvbXMpLFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICBrbm93blNlbGVjdG9yczogbmV3IFNldChzdG9yZVN0YXRlLmtub3duU2VsZWN0b3JzKSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRDogW10sXG4gICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzOiBuZXcgU2V0KCksXG4gICAgZ3JhcGhzQnlWZXJzaW9uOiBuZXcgTWFwKCkuc2V0KHZlcnNpb24sIHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKSksXG4gICAgcmV0ZW50aW9uOiB7XG4gICAgICByZWZlcmVuY2VDb3VudHM6IG5ldyBNYXAoKSxcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmU6IG5ldyBNYXAoKSxcbiAgICAgIHJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2U6IG5ldyBTZXQoKVxuICAgIH0sXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIC8vIENyZWF0ZSBibGFuayBjbGVhbnVwIGhhbmRsZXJzIGZvciBhdG9tcyBzbyBzbmFwc2hvdHMgZG9uJ3QgcmUtcnVuXG4gICAgLy8gYXRvbSBlZmZlY3RzLlxuICAgIG5vZGVDbGVhbnVwRnVuY3Rpb25zOiBuZXcgTWFwKFJlY29pbF9tYXBJdGVyYWJsZShzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmVudHJpZXMoKSwgKFtrZXldKSA9PiBba2V5LCAoKSA9PiB7fV0pKVxuICB9O1xufSAvLyBGYWN0b3J5IHRvIGJ1aWxkIGEgZnJlc2ggc25hcHNob3RcblxuXG5mdW5jdGlvbiBmcmVzaFNuYXBzaG90KGluaXRpYWxpemVTdGF0ZSkge1xuICBjb25zdCBzbmFwc2hvdCA9IG5ldyBTbmFwc2hvdChtYWtlRW1wdHlTdG9yZVN0YXRlJDEoKSk7XG4gIHJldHVybiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IHNuYXBzaG90Lm1hcChpbml0aWFsaXplU3RhdGUpIDogc25hcHNob3Q7XG59IC8vIEZhY3RvcnkgdG8gY2xvbmUgYSBzbmFwc2hvdCBzdGF0ZVxuXG5cbmNvbnN0IFttZW1vaXplZENsb25lU25hcHNob3QsIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDJdID0gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiQxKChzdG9yZSwgdmVyc2lvbikgPT4ge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHZlcnNpb24gPT09ICdsYXRlc3QnID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKTtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSksIHN0b3JlLnN0b3JlSUQpO1xufSwgKHN0b3JlLCB2ZXJzaW9uKSA9PiB7XG4gIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdG9yZSRnZXRTdGF0ZSRwcmV2aTtcblxuICByZXR1cm4gU3RyaW5nKHZlcnNpb24pICsgU3RyaW5nKHN0b3JlLnN0b3JlSUQpICsgU3RyaW5nKChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VC52ZXJzaW9uKSArIFN0cmluZyhzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnZlcnNpb24pICsgU3RyaW5nKChfc3RvcmUkZ2V0U3RhdGUkcHJldmkgPSBzdG9yZS5nZXRTdGF0ZSgpLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJHByZXZpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkcHJldmkudmVyc2lvbik7XG59KTsgLy8gQXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbnNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEoaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMik7XG5cbmZ1bmN0aW9uIGNsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24gPSAnbGF0ZXN0Jykge1xuICBjb25zdCBzbmFwc2hvdCA9IG1lbW9pemVkQ2xvbmVTbmFwc2hvdChzdG9yZSwgdmVyc2lvbik7XG5cbiAgaWYgKCFzbmFwc2hvdC5pc1JldGFpbmVkKCkpIHtcbiAgICBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyKCk7XG4gICAgcmV0dXJuIG1lbW9pemVkQ2xvbmVTbmFwc2hvdChzdG9yZSwgdmVyc2lvbik7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmNsYXNzIE11dGFibGVTbmFwc2hvdCBleHRlbmRzIFNuYXBzaG90IHtcbiAgY29uc3RydWN0b3Ioc25hcHNob3QsIGJhdGNoKSB7XG4gICAgc3VwZXIoY2xvbmVTdG9yZVN0YXRlKHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCksIHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCkuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgdHJ1ZSksIHNuYXBzaG90LmdldFN0b3JlSUQoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYmF0Y2hcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCAocmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBUaGlzIGJhdGNoVXBkYXRlcyBlbnN1cmVzIHRoaXMgYHNldGAgaXMgYXBwbGllZCBpbW1lZGlhdGVseSBhbmQgeW91IGNhblxuICAgICAgLy8gcmVhZCB0aGUgd3JpdHRlbiB2YWx1ZSBhZnRlciBjYWxsaW5nIGBzZXRgLiBJIHdvdWxkIGxpa2UgdG8gcmVtb3ZlIHRoaXNcbiAgICAgIC8vIGJlaGF2aW9yIGFuZCBvbmx5IGJhdGNoIGluIGBTbmFwc2hvdC5tYXBgLCBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nXG4gICAgICAvLyBjaGFuZ2UgcG90ZW50aWFsbHkuXG5cbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMSh0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCksIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFNlZSBub3RlIGF0IGBzZXRgIGFib3V0IGJhdGNoZWQgdXBkYXRlcy5cblxuICAgICAgdGhpcy5fYmF0Y2goKCkgPT4ge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCByZWNvaWxTdGF0ZS5rZXksIDEpO1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQxKHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKSwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFVudmFsaWRhdGVkQXRvbVZhbHVlc19ERVBSRUNBVEVEXCIsIHZhbHVlcyA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXG5cbiAgICAgIGJhdGNoVXBkYXRlcyQxKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIGssIDEpO1xuICAgICAgICAgIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMShzdG9yZSwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMihrKSwgdik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYmF0Y2ggPSBiYXRjaDtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfU25hcHNob3QgPSB7XG4gIFNuYXBzaG90LFxuICBNdXRhYmxlU25hcHNob3QsXG4gIGZyZXNoU25hcHNob3QsXG4gIGNsb25lU25hcHNob3Rcbn07XG5cbnZhciBSZWNvaWxfU25hcHNob3RfMSA9IFJlY29pbF9TbmFwc2hvdC5TbmFwc2hvdDtcbnZhciBSZWNvaWxfU25hcHNob3RfMiA9IFJlY29pbF9TbmFwc2hvdC5NdXRhYmxlU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzMgPSBSZWNvaWxfU25hcHNob3QuZnJlc2hTbmFwc2hvdDtcbnZhciBSZWNvaWxfU25hcHNob3RfNCA9IFJlY29pbF9TbmFwc2hvdC5jbG9uZVNuYXBzaG90O1xuXG52YXIgUmVjb2lsX1NuYXBzaG90JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8xLFxuICBNdXRhYmxlU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8yLFxuICBmcmVzaFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMyxcbiAgY2xvbmVTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiB1bmlvblNldHMoLi4uc2V0cykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChjb25zdCBzZXQgb2Ygc2V0cykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgICByZXN1bHQuYWRkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX3VuaW9uU2V0cyA9IHVuaW9uU2V0cztcblxuY29uc3Qge1xuICB1c2VSZWZcbn0gPSByZWFjdDtcbi8qKlxuICogVGhlIHNhbWUgYXMgYHVzZVJlZigpYCBleGNlcHQgdGhhdCBpZiBhIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCB0aGVuIGl0IHdpbGxcbiAqIGNhbGwgdGhhdCBmdW5jdGlvbiB0byBnZXQgdGhlIHZhbHVlIHRvIGluaXRpYWxpemUgdGhlIHJlZmVyZW5jZSB3aXRoLlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBgdXNlU3RhdGUoKWAgYmVoYXZlcyB3aGVuIGdpdmVuIGEgZnVuY3Rpb24uICBJdCBhbGxvd3NcbiAqIHRoZSB1c2VyIHRvIGF2b2lkIGdlbmVyYXRpbmcgdGhlIGluaXRpYWwgdmFsdWUgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAqIFRoZSB0cmFkZW9mZiBpcyB0aGF0IHRvIHNldCB0aGUgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gaXRzZWxmIHlvdSBuZWVkIHRvXG4gKiBuZXN0IGl0OiB1c2VSZWZJbml0T25jZSgoKSA9PiAoKSA9PiB7Li4ufSk7XG4gKi9cblxuXG5mdW5jdGlvbiB1c2VSZWZJbml0T25jZShpbml0aWFsVmFsdWUpIHtcbiAgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS1jYWxsXVxuICBjb25zdCByZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcblxuICBpZiAocmVmLmN1cnJlbnQgPT09IGluaXRpYWxWYWx1ZSAmJiB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS11c2VdXG4gICAgcmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWUoKTtcbiAgfVxuXG4gIHJldHVybiByZWY7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVmSW5pdE9uY2UgPSB1c2VSZWZJbml0T25jZTtcblxuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbHVzYWdlbG9nRXZlbnQgPSByZXF1aXJlKCdSZWNvaWx1c2FnZWxvZ0V2ZW50Jyk7XG4vLyBAZmItb25seTogY29uc3QgUmVjb2lsVXNhZ2VMb2dGYWxjb0V2ZW50ID0gcmVxdWlyZSgnUmVjb2lsVXNhZ2VMb2dGYWxjb0V2ZW50Jyk7XG4vLyBAZmItb25seTogY29uc3QgVVJJID0gcmVxdWlyZSgnVVJJJyk7XG5cblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMyxcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZTogbWFrZUVtcHR5U3RvcmVTdGF0ZSQyXG59ID0gUmVjb2lsX1N0YXRlO1xuXG5jb25zdCB7XG4gIGNsZWFuVXBOb2RlOiBjbGVhblVwTm9kZSQyLFxuICBnZXREb3duc3RyZWFtTm9kZXM6IGdldERvd25zdHJlYW1Ob2RlcyQyLFxuICBpbml0aWFsaXplTm9kZTogaW5pdGlhbGl6ZU5vZGUkMixcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkMixcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRDogc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIGdyYXBoOiBncmFwaCQyXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIGNsb25lR3JhcGg6IGNsb25lR3JhcGgkMVxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBnZXROZXh0U3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMlxufSA9IFJlY29pbF9LZXlzO1xuXG5jb25zdCB7XG4gIGNyZWF0ZU11dGFibGVTb3VyY2U6IGNyZWF0ZU11dGFibGVTb3VyY2UkMSxcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkMlxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cbmNvbnN0IHtcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXM6IGFwcGx5QXRvbVZhbHVlV3JpdGVzJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93OiByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgZnJlc2hTbmFwc2hvdDogZnJlc2hTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cblxuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZjogdXNlUmVmJDEsXG4gIHVzZVN0YXRlXG59ID0gcmVhY3Q7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBub3RJbkFDb250ZXh0KCkge1xuICB0aHJvdyBSZWNvaWxfZXJyKCdUaGlzIGNvbXBvbmVudCBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgPFJlY29pbFJvb3Q+IGNvbXBvbmVudC4nKTtcbn1cblxuY29uc3QgZGVmYXVsdFN0b3JlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDIoKSxcbiAgZ2V0U3RhdGU6IG5vdEluQUNvbnRleHQsXG4gIHJlcGxhY2VTdGF0ZTogbm90SW5BQ29udGV4dCxcbiAgZ2V0R3JhcGg6IG5vdEluQUNvbnRleHQsXG4gIHN1YnNjcmliZVRvVHJhbnNhY3Rpb25zOiBub3RJbkFDb250ZXh0LFxuICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhOiBub3RJbkFDb250ZXh0XG59KTtcbmxldCBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZChzdG9yZSkge1xuICBpZiAoc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0FuIGF0b20gdXBkYXRlIHdhcyB0cmlnZ2VyZWQgd2l0aGluIHRoZSBleGVjdXRpb24gb2YgYSBzdGF0ZSB1cGRhdGVyIGZ1bmN0aW9uLiBTdGF0ZSB1cGRhdGVyIGZ1bmN0aW9ucyBwcm92aWRlZCB0byBSZWNvaWwgbXVzdCBiZSBwdXJlIGZ1bmN0aW9ucy4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlID09PSBudWxsKSB7XG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgJiYgUmVjb2lsX2dreCgncmVjb2lsX3JlbGVhc2Vfb25fY2FzY2FkaW5nX3VwZGF0ZV9raWxsc3dpdGNoXzIwMjEnKSkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNhc2NhZGluZyB1cGRhdGUgKHRoYXQgaXMsIHJlbmRlcmluZyBkdWUgdG8gb25lIHN0YXRlIGNoYW5nZVxuICAgICAgLy8gaW52b2tlcyBhIHNlY29uZCBzdGF0ZSBjaGFuZ2UpLCB3ZSB3b24ndCBoYXZlIGNsZWFuZWQgdXAgcmV0YWluYWJsZXMgeWV0XG4gICAgICAvLyBiZWNhdXNlIHRoaXMgbm9ybWFsbHkgaGFwcGVucyBhZnRlciBub3RpZnlpbmcgY29tcG9uZW50cy4gRG8gaXQgYmVmb3JlXG4gICAgICAvLyBwcm9jZWVkaW5nIHdpdGggdGhlIGNhc2NhZGluZyB1cGRhdGUgc28gdGhhdCBpdCByZW1haW5zIHByZWRpY3RhYmxlOlxuICAgICAgaWYgKHN0b3JlU3RhdGUuY29tbWl0RGVwdGggPiAwKSB7XG4gICAgICAgIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxKHN0b3JlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2ZXJzaW9uID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uO1xuICAgIGNvbnN0IG5leHRWZXJzaW9uID0gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMygpO1xuICAgIHN0b3JlU3RhdGUubmV4dFRyZWUgPSB7IC4uLnN0b3JlU3RhdGUuY3VycmVudFRyZWUsXG4gICAgICB2ZXJzaW9uOiBuZXh0VmVyc2lvbixcbiAgICAgIHN0YXRlSUQ6IG5leHRWZXJzaW9uLFxuICAgICAgZGlydHlBdG9tczogbmV3IFNldCgpLFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YToge31cbiAgICB9O1xuICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLnNldChuZXh0VmVyc2lvbiwgY2xvbmVHcmFwaCQxKFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmdldCh2ZXJzaW9uKSkpKTtcbiAgfVxufVxuXG5jb25zdCBBcHBDb250ZXh0ID0gcmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGN1cnJlbnQ6IGRlZmF1bHRTdG9yZVxufSk7XG5cbmNvbnN0IHVzZVN0b3JlUmVmID0gKCkgPT4gdXNlQ29udGV4dChBcHBDb250ZXh0KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yW2luY29tcGF0aWJsZS1jYWxsXVxuXG5cbmNvbnN0IE11dGFibGVTb3VyY2VDb250ZXh0ID0gcmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSgpIHtcbiAgY29uc3QgbXV0YWJsZVNvdXJjZSA9IHVzZUNvbnRleHQoTXV0YWJsZVNvdXJjZUNvbnRleHQpO1xuXG4gIGlmIChtdXRhYmxlU291cmNlID09IG51bGwpIHtcbiAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oJ0F0dGVtcHRlZCB0byB1c2UgYSBSZWNvaWwgaG9vayBvdXRzaWRlIG9mIGEgPFJlY29pbFJvb3Q+LiAnICsgJzxSZWNvaWxSb290PiBtdXN0IGJlIGFuIGFuY2VzdG9yIG9mIGFueSBjb21wb25lbnQgdGhhdCB1c2VzICcgKyAnUmVjb2lsIGhvb2tzLicpO1xuICB9XG5cbiAgcmV0dXJuIG11dGFibGVTb3VyY2U7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSkge1xuICBjb25zdCBkZXBlbmRlbnROb2RlcyA9IGdldERvd25zdHJlYW1Ob2RlcyQyKHN0b3JlLCB0cmVlU3RhdGUsIHRyZWVTdGF0ZS5kaXJ0eUF0b21zKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBkZXBlbmRlbnROb2Rlcykge1xuICAgIGNvbnN0IGNvbXBzID0gc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpO1xuXG4gICAgaWYgKGNvbXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtfc3ViSUQsIFtfZGVidWdOYW1lLCBjYWxsYmFja11dIG9mIGNvbXBzKSB7XG4gICAgICAgIGNhbGxiYWNrKHRyZWVTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9ucyhzdG9yZSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTsgLy8gSW5mb3JtIHRyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG9mIHRoZSB0cmFuc2FjdGlvbjpcblxuICBjb25zdCBkaXJ0eUF0b21zID0gdHJlZVN0YXRlLmRpcnR5QXRvbXM7XG5cbiAgaWYgKGRpcnR5QXRvbXMuc2l6ZSkge1xuICAgIC8vIEV4ZWN1dGUgTm9kZS1zcGVjaWZpYyBzdWJzY3JpYmVycyBiZWZvcmUgZ2xvYmFsIHN1YnNjcmliZXJzXG4gICAgZm9yIChjb25zdCBba2V5LCBzdWJzY3JpcHRpb25zXSBvZiBzdG9yZVN0YXRlLm5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGlmIChkaXJ0eUF0b21zLmhhcyhrZXkpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW18sIHN1YnNjcmlwdGlvbl0gb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN0b3JlU3RhdGUudHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XG4gICAgICBzdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIH1cblxuICAgIGlmICghcmVhY3RNb2RlJDIoKS5lYXJseSB8fCBzdG9yZVN0YXRlLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5zaXplID4gMCkge1xuICAgICAgLy8gTm90aWZ5aW5nIGNvbXBvbmVudHMgaXMgbmVlZGVkIHRvIHdha2UgZnJvbSBzdXNwZW5zZSwgZXZlbiB3aGVuIHVzaW5nXG4gICAgICAvLyBlYXJseSByZW5kZXJpbmcuXG4gICAgICBub3RpZnlDb21wb25lbnRzKHN0b3JlLCBzdG9yZVN0YXRlLCB0cmVlU3RhdGUpOyAvLyBXYWtlIGFsbCBzdXNwZW5kZWQgY29tcG9uZW50cyBzbyB0aGUgcmlnaHQgb25lKHMpIGNhbiB0cnkgdG8gcmUtcmVuZGVyLlxuICAgICAgLy8gV2UgbmVlZCB0byB3YWtlIHVwIGNvbXBvbmVudHMgbm90IGp1c3Qgd2hlbiBzb21lIGFzeW5jaHJvbm91cyBzZWxlY3RvclxuICAgICAgLy8gcmVzb2x2ZWQsIGJ1dCBhbHNvIHdoZW4gY2hhbmdpbmcgc3luY2hyb25vdXMgdmFsdWVzIGJlY2F1c2UgdGhpcyBtYXkgY2F1c2VcbiAgICAgIC8vIGEgc2VsZWN0b3IgdG8gY2hhbmdlIGZyb20gYXN5bmNocm9ub3VzIHRvIHN5bmNocm9ub3VzLCBpbiB3aGljaCBjYXNlIHRoZXJlXG4gICAgICAvLyB3b3VsZCBiZSBubyBmb2xsb3ctdXAgYXN5bmNocm9ub3VzIHJlc29sdXRpb24gdG8gd2FrZSB1cyB1cC5cbiAgICAgIC8vIFRPRE8gT1BUSU1JWkFUSU9OIE9ubHkgd2FrZSB1cCByZWxhdGVkIGRvd25zdHJlYW0gY29tcG9uZW50c1xuXG4gICAgICBzdG9yZVN0YXRlLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5mb3JFYWNoKGNiID0+IGNiKCkpO1xuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuY2xlYXIoKTtcbiAgICB9XG4gIH0gLy8gU3BlY2lhbCBiZWhhdmlvciBPTkxZIGludm9rZWQgYnkgdXNlSW50ZXJmYWNlLlxuICAvLyBGSVhNRSBkZWxldGUgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQgd2hlbiBkZWxldGluZyB1c2VJbnRlcmZhY2UuXG5cblxuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmZvckVhY2goY2IgPT4gY2IodHJlZVN0YXRlKSk7XG4gIHN0b3JlU3RhdGUucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQuc3BsaWNlKDAsIHN0b3JlU3RhdGUucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZW5kQmF0Y2goc3RvcmUpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIHN0b3JlU3RhdGUuY29tbWl0RGVwdGgrKztcblxuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRUcmVlXG4gICAgfSA9IHN0b3JlU3RhdGU7IC8vIElnbm9yZSBjb21taXRzIHRoYXQgYXJlIG5vdCBiZWNhdXNlIG9mIFJlY29pbCB0cmFuc2FjdGlvbnMgLS0gbmFtZWx5LFxuICAgIC8vIGJlY2F1c2Ugc29tZXRoaW5nIGFib3ZlIFJlY29pbFJvb3QgcmUtcmVuZGVyZWQ6XG5cbiAgICBpZiAobmV4dFRyZWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbmV4dFRyZWUgaXMgbm93IGNvbW1pdHRlZCAtLSBub3RlIHRoYXQgY29weWluZyBhbmQgcmVzZXQgb2NjdXJzIHdoZW5cbiAgICAvLyBhIHRyYW5zYWN0aW9uIGJlZ2lucywgaW4gc3RhcnROZXh0VHJlZUlmTmVlZGVkOlxuXG5cbiAgICBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IG5leHRUcmVlO1xuICAgIHN0b3JlU3RhdGUubmV4dFRyZWUgPSBudWxsO1xuICAgIHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9ucyhzdG9yZSk7XG5cbiAgICBpZiAoc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgIT0gbnVsbCkge1xuICAgICAgc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZGVsZXRlKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlLnZlcnNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ0VuZGVkIGJhdGNoIHdpdGggbm8gcHJldmlvdXMgc3RhdGUsIHdoaWNoIGlzIHVuZXhwZWN0ZWQnLCAncmVjb2lsJyk7XG4gICAgfVxuXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBudWxsO1xuXG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgIC8vIE9ubHkgcmVsZWFzZSByZXRhaW5hYmxlcyBpZiB0aGVyZSB3ZXJlIG5vIHdyaXRlcyBkdXJpbmcgdGhlIGVuZCBvZiB0aGVcbiAgICAgIC8vIGJhdGNoLiAgVGhpcyBhdm9pZHMgcmVsZWFzaW5nIHNvbWV0aGluZyB3ZSBtaWdodCBiZSBhYm91dCB0byB1c2UuXG4gICAgICBpZiAobmV4dFRyZWUgPT0gbnVsbCkge1xuICAgICAgICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMShzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHN0b3JlU3RhdGUuY29tbWl0RGVwdGgtLTtcbiAgfVxufVxuLypcbiAqIFRoZSBwdXJwb3NlIG9mIHRoZSBCYXRjaGVyIGlzIHRvIG9ic2VydmUgd2hlbiBSZWFjdCBiYXRjaGVzIGVuZCBzbyB0aGF0XG4gKiBSZWNvaWwgc3RhdGUgY2hhbmdlcyBjYW4gYmUgYmF0Y2hlZC4gV2hlbmV2ZXIgUmVjb2lsIHN0YXRlIGNoYW5nZXMsIHdlIGNhbGxcbiAqIHNldFN0YXRlIG9uIHRoZSBiYXRjaGVyLiBUaGVuIHdlIHdhaXQgZm9yIHRoYXQgY2hhbmdlIHRvIGJlIGNvbW1pdHRlZCwgd2hpY2hcbiAqIHNpZ25pZmllcyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhhdCdzIHdoZW4gd2UgcmVzcG9uZCB0byB0aGUgUmVjb2lsIGNoYW5nZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIEJhdGNoZXIoe1xuICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2Vcbn0pIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZigpO1xuICBjb25zdCBbLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShbXSk7XG4gIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpOyAvLyBJZiBhbiBhc3luY2hyb25vdXMgc2VsZWN0b3IgcmVzb2x2ZXMgYWZ0ZXIgdGhlIEJhdGNoZXIgaXMgdW5tb3VudGVkLFxuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB3aWxsIHN0aWxsIGJlIGNhbGxlZC4gQW4gZXJyb3IgZ2V0cyB0aHJvd24gd2hlbmV2ZXJcbiAgICAvLyBzZXRTdGF0ZSBpcyBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaXMgYWxyZWFkeSB1bm1vdW50ZWQsIHNvIHRoaXMgc2V0c1xuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB0byBiZSBhIG5vLW9wLlxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiB7fSk7XG4gICAgfTtcbiAgfSwgW3NldE5vdGlmeUJhdGNoZXJPZkNoYW5nZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIGVucXVldWVFeGVjdXRpb24gcnVucyB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5OyBpdCBpcyBvbmx5IHVzZWQgdG9cbiAgICAvLyBtYW5pcHVsYXRlIHRoZSBvcmRlciBvZiB1c2VFZmZlY3RzIGR1cmluZyB0ZXN0cywgc2luY2UgUmVhY3Qgc2VlbXMgdG9cbiAgICAvLyBjYWxsIHVzZUVmZmVjdCBpbiBhbiB1bnByZWRpY3RhYmxlIG9yZGVyIHNvbWV0aW1lcy5cbiAgICBSZWNvaWxfUXVldWUuZW5xdWV1ZUV4ZWN1dGlvbignQmF0Y2hlcicsICgpID0+IHtcbiAgICAgIGVuZEJhdGNoKHN0b3JlUmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzKSB7XG4gICAgd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcyA9IFtdO1xuICB9XG59IC8vIFdoZW4gcmVtb3ZpbmcgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uLCByZW1vdmUgc3RhdGVCeVNldHRpbmdSZWNvaWxWYWx1ZVxuLy8gd2hpY2ggd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkLlxuXG5cbmZ1bmN0aW9uIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQoc3RvcmUsIGluaXRpYWxpemVTdGF0ZSkge1xuICBjb25zdCBpbml0aWFsID0gbWFrZUVtcHR5U3RvcmVTdGF0ZSQyKCk7XG4gIGluaXRpYWxpemVTdGF0ZSh7XG4gICAgc2V0OiAoYXRvbSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gaW5pdGlhbC5jdXJyZW50VHJlZTtcbiAgICAgIGNvbnN0IHdyaXRlcyA9IHNldE5vZGVWYWx1ZSQyKHN0b3JlLCBzdGF0ZSwgYXRvbS5rZXksIHZhbHVlKTtcbiAgICAgIGNvbnN0IHdyaXR0ZW5Ob2RlcyA9IG5ldyBTZXQod3JpdGVzLmtleXMoKSk7XG4gICAgICBjb25zdCBub252YWxpZGF0ZWRBdG9tcyA9IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCk7XG5cbiAgICAgIGZvciAoY29uc3QgbiBvZiB3cml0dGVuTm9kZXMpIHtcbiAgICAgICAgbm9udmFsaWRhdGVkQXRvbXMuZGVsZXRlKG4pO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0geyAuLi5zdGF0ZSxcbiAgICAgICAgZGlydHlBdG9tczogUmVjb2lsX3VuaW9uU2V0cyhzdGF0ZS5kaXJ0eUF0b21zLCB3cml0dGVuTm9kZXMpLFxuICAgICAgICBhdG9tVmFsdWVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxKHN0YXRlLmF0b21WYWx1ZXMsIHdyaXRlcyksXG4gICAgICAgIC8vIE5COiBQTEVBU0UgdW4tZXhwb3J0IGFwcGx5QXRvbVZhbHVlV3JpdGVzIHdoZW4gZGVsZXRpbmcgdGhpcyBjb2RlXG4gICAgICAgIG5vbnZhbGlkYXRlZEF0b21zXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzOiBhdG9tVmFsdWVzID0+IHtcbiAgICAgIC8vIEZJWE1FIHJlcGxhY2UgdGhpcyB3aXRoIGEgbXV0YXRpdmUgbG9vcFxuICAgICAgYXRvbVZhbHVlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICAgIGluaXRpYWwuY3VycmVudFRyZWUgPSBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDEoaW5pdGlhbC5jdXJyZW50VHJlZSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5pdGlhbDtcbn0gLy8gSW5pdGlhbGl6ZSBzdGF0ZSBzbmFwc2hvdCBmb3IgPFJlY29pbFJvb3Q+IGZvciB0aGUgaW5pdGlhbGl6ZVN0YXRlIHByb3AuXG4vLyBBdG9tIGVmZmVjdCBpbml0aWFsaXphdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyBwcm9wLlxuLy8gQW55IGF0b20gZWZmZWN0cyB3aWxsIGJlIHJ1biBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIGJ1dCB0aGVuIGNsZWFuZWQgdXAsXG4vLyB0aGV5IGFyZSB0aGVuIHJlLXJ1biB3aGVuIHVzZWQgYXMgcGFydCBvZiByZW5kZXJpbmcuICBUaGVzZSBzZW1hbnRpY3MgYXJlXG4vLyBjb21wYXRpYmxlIHdpdGggUmVhY3QgU3RyaWN0TW9kZSB3aGVyZSBlZmZlY3RzIG1heSBiZSByZS1ydW4gbXVsdGlwbGUgdGltZXNcbi8vIGJ1dCBzdGF0ZSBpbml0aWFsaXphdGlvbiBvbmx5IGhhcHBlbnMgb25jZSB0aGUgZmlyc3QgdGltZS5cblxuXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZShpbml0aWFsaXplU3RhdGUpIHtcbiAgLy8gSW5pdGlhbGl6ZSBhIHNuYXBzaG90IGFuZCBnZXQgaXRzIHN0b3JlXG4gIGNvbnN0IHNuYXBzaG90ID0gZnJlc2hTbmFwc2hvdCQxKGluaXRpYWxpemVTdGF0ZSk7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCk7IC8vIENvdW50ZXJhY3QgdGhlIHNuYXBzaG90IGF1dG8tcmVsZWFzZVxuXG4gIHNuYXBzaG90LnJldGFpbigpOyAvLyBDbGVhbnVwIGFueSBlZmZlY3RzIHJ1biBkdXJpbmcgaW5pdGlhbGl6YXRpb24gYW5kIGNsZWFyIHRoZSBoYW5kbGVycyBzb1xuICAvLyB0aGV5IHdpbGwgcmUtaW5pdGlhbGl6ZSBpZiB1c2VkIGR1cmluZyByZW5kZXJpbmcuICBUaGlzIGFsbG93cyBhdG9tIGVmZmVjdFxuICAvLyBpbml0aWFsaXphdGlvbiB0byB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbml0aWFsaXplU3RhdGUgYW5kIGJlIGNvbXBhdGlibGVcbiAgLy8gd2l0aCBTdHJpY3RNb2RlIHNlbWFudGljcy5cblxuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmNsZWFyKCk7XG4gIHJldHVybiBzdG9yZVN0YXRlO1xufVxuXG5sZXQgbmV4dElEID0gMDtcblxuZnVuY3Rpb24gUmVjb2lsUm9vdF9JTlRFUk5BTCh7XG4gIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVELFxuICBpbml0aWFsaXplU3RhdGUsXG4gIHN0b3JlX0lOVEVSTkFMOiBzdG9yZVByb3AsXG4gIC8vIEZvciB1c2Ugd2l0aCBSZWFjdCBcImNvbnRleHQgYnJpZGdpbmdcIlxuICBjaGlsZHJlblxufSkge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgLy8gQGZiLW9ubHk6IHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vIEBmYi1vbmx5OiBpZiAoZ2t4KCdyZWNvaWxfdXNhZ2VfbG9nZ2luZycpKSB7XG4gIC8vIEBmYi1vbmx5OiB0cnkge1xuICAvLyBAZmItb25seTogUmVjb2lsVXNhZ2VMb2dGYWxjb0V2ZW50LmxvZygoKSA9PiAoe1xuICAvLyBAZmItb25seTogdHlwZTogUmVjb2lsdXNhZ2Vsb2dFdmVudC5SRUNPSUxfUk9PVF9NT1VOVEVELFxuICAvLyBAZmItb25seTogcGF0aDogVVJJLmdldFJlcXVlc3RVUkkoKS5nZXRQYXRoKCksXG4gIC8vIEBmYi1vbmx5OiB9KSk7XG4gIC8vIEBmYi1vbmx5OiB9IGNhdGNoIHtcbiAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKFxuICAvLyBAZmItb25seTogJ0Vycm9yIHdoZW4gbG9nZ2luZyBSZWNvaWwgVXNhZ2UgZXZlbnQnLFxuICAvLyBAZmItb25seTogJ3JlY29pbCcsXG4gIC8vIEBmYi1vbmx5OiApO1xuICAvLyBAZmItb25seTogfVxuICAvLyBAZmItb25seTogfVxuICAvLyBAZmItb25seTogfSwgW10pO1xuICBsZXQgc3RvcmVTdGF0ZVJlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcblxuICBjb25zdCBnZXRHcmFwaCA9IHZlcnNpb24gPT4ge1xuICAgIGNvbnN0IGdyYXBocyA9IHN0b3JlU3RhdGVSZWYuY3VycmVudC5ncmFwaHNCeVZlcnNpb247XG5cbiAgICBpZiAoZ3JhcGhzLmhhcyh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKGdyYXBocy5nZXQodmVyc2lvbikpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0dyYXBoID0gZ3JhcGgkMigpO1xuICAgIGdyYXBocy5zZXQodmVyc2lvbiwgbmV3R3JhcGgpO1xuICAgIHJldHVybiBuZXdHcmFwaDtcbiAgfTtcblxuICBjb25zdCBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyA9IChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAvLyBHbG9iYWwgdHJhbnNhY3Rpb24gc3Vic2NyaXB0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnNcbiAgICAgIH0gPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xuICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLnNldChpZCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlLXNwZWNpZmljIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnM6XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnNcbiAgICAgIH0gPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCk7XG5cbiAgICAgIGlmICghbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLnNldChrZXksIG5ldyBNYXAoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkID0gbmV4dElEKys7XG4gICAgICBSZWNvaWxfbnVsbHRocm93cyhub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJzID0gbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBzdWJzLmRlbGV0ZShpZCk7XG5cbiAgICAgICAgICAgIGlmIChzdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFkZFRyYW5zYWN0aW9uTWV0YWRhdGEgPSBtZXRhZGF0YSA9PiB7XG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpO1xuXG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG1ldGFkYXRhKSkge1xuICAgICAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLm5leHRUcmVlKS50cmFuc2FjdGlvbk1ldGFkYXRhW2tdID0gbWV0YWRhdGFba107XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlcGxhY2VTdGF0ZSA9IHJlcGxhY2VyID0+IHtcbiAgICBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmVSZWYuY3VycmVudCk7IC8vIFVzZSByZXBsYWNlciB0byBnZXQgdGhlIG5leHQgc3RhdGU6XG5cbiAgICBjb25zdCBuZXh0VHJlZSA9IFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGVSZWYuY3VycmVudC5uZXh0VHJlZSk7XG4gICAgbGV0IHJlcGxhY2VkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQgPSB0cnVlO1xuICAgICAgcmVwbGFjZWQgPSByZXBsYWNlcihuZXh0VHJlZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZWQgPT09IG5leHRUcmVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMucHVzaChyZXBsYWNlZCk7IC8vIFRPRE8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuIGhlcmUgYmVjYXVzZSBpdCdzIG5vdCBiYXRjaGVkXG4gICAgICB9XG4gICAgfSAvLyBTYXZlIGNoYW5nZXMgdG8gbmV4dFRyZWUgYW5kIHNjaGVkdWxlIGEgUmVhY3QgdXBkYXRlOlxuXG5cbiAgICBzdG9yZVN0YXRlUmVmLmN1cnJlbnQubmV4dFRyZWUgPSByZXBsYWNlZDtcblxuICAgIGlmIChyZWFjdE1vZGUkMigpLmVhcmx5KSB7XG4gICAgICBub3RpZnlDb21wb25lbnRzKHN0b3JlUmVmLmN1cnJlbnQsIHN0b3JlU3RhdGVSZWYuY3VycmVudCwgcmVwbGFjZWQpO1xuICAgIH1cblxuICAgIFJlY29pbF9udWxsdGhyb3dzKG5vdGlmeUJhdGNoZXJPZkNoYW5nZS5jdXJyZW50KSgpO1xuICB9O1xuXG4gIGNvbnN0IG5vdGlmeUJhdGNoZXJPZkNoYW5nZSA9IHVzZVJlZiQxKG51bGwpO1xuICBjb25zdCBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UgPSB1c2VDYWxsYmFjayh4ID0+IHtcbiAgICBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCA9IHg7XG4gIH0sIFtub3RpZnlCYXRjaGVyT2ZDaGFuZ2VdKTtcbiAgY29uc3Qgc3RvcmVSZWYgPSBSZWNvaWxfdXNlUmVmSW5pdE9uY2UoKCkgPT4gc3RvcmVQcm9wICE9PSBudWxsICYmIHN0b3JlUHJvcCAhPT0gdm9pZCAwID8gc3RvcmVQcm9wIDoge1xuICAgIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDIoKSxcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LFxuICAgIHJlcGxhY2VTdGF0ZSxcbiAgICBnZXRHcmFwaCxcbiAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyxcbiAgICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhXG4gIH0pO1xuXG4gIGlmIChzdG9yZVByb3AgIT0gbnVsbCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZVByb3A7XG4gIH1cblxuICBzdG9yZVN0YXRlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEICE9IG51bGwgPyBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlUmVmLmN1cnJlbnQsIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEKSA6IGluaXRpYWxpemVTdGF0ZSAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSA6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpKTtcbiAgY29uc3QgbXV0YWJsZVNvdXJjZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlTXV0YWJsZVNvdXJjZSQxID09PSBudWxsIHx8IGNyZWF0ZU11dGFibGVTb3VyY2UkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRlTXV0YWJsZVNvdXJjZSQxKHN0b3JlU3RhdGVSZWYsICgpID0+IHN0b3JlU3RhdGVSZWYuY3VycmVudC5jdXJyZW50VHJlZS52ZXJzaW9uKSwgW3N0b3JlU3RhdGVSZWZdKTsgLy8gQ2xlYW51cCB3aGVuIHRoZSA8UmVjb2lsUm9vdD4gaXMgdW5tb3VudGVkXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBSZWFjdCBpcyBmcmVlIHRvIGNhbGwgZWZmZWN0IGNsZWFudXAgaGFuZGxlcnMgYW5kIGVmZmVjdHMgYXQgd2lsbCwgdGhlXG4gICAgLy8gZGVwcyBhcnJheSBpcyBvbmx5IGFuIG9wdGltaXphdGlvbi4gIEZvciBleGFtcGxlLCBSZWFjdCBzdHJpY3QgbW9kZVxuICAgIC8vIHdpbGwgZXhlY3V0ZSBlYWNoIGVmZmVjdCB0d2ljZSBmb3IgdGVzdGluZy4gIFRoZXJlZm9yZSwgd2UgbmVlZCBzeW1tZXRyeVxuICAgIC8vIHRvIHJlLWluaXRpYWxpemUgYWxsIGtub3duIGF0b21zIGFmdGVyIHRoZXkgd2VyZSBjbGVhbmVkIHVwLlxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcblxuICAgIGZvciAoY29uc3QgYXRvbUtleSBvZiBuZXcgU2V0KHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDIoc3RvcmUsIGF0b21LZXksICdnZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xuICAgICAgICBjbGVhblVwTm9kZSQyKHN0b3JlLCBhdG9tS2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc3RvcmVSZWZdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmVSZWZcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoTXV0YWJsZVNvdXJjZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbXV0YWJsZVNvdXJjZVxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChCYXRjaGVyLCB7XG4gICAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlOiBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2VcbiAgfSksIGNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIFJlY29pbFJvb3QocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJyaWRlLFxuICAgIC4uLnByb3BzRXhjZXB0T3ZlcnJpZGVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhbmNlc3RvclN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcblxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlICYmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlKSB7XG4gICAgLy8gSWYgYW5jZXN0b3JTdG9yZVJlZi5jdXJyZW50ICE9PSBkZWZhdWx0U3RvcmUsIGl0IG1lYW5zIHRoYXQgdGhpc1xuICAgIC8vIFJlY29pbFJvb3QgaXMgbm90IG5lc3RlZCB3aXRoaW4gYW5vdGhlci5cbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdF9JTlRFUk5BTCwgcHJvcHNFeGNlcHRPdmVycmlkZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0b3JlSUQoKSB7XG4gIHJldHVybiB1c2VTdG9yZVJlZigpLmN1cnJlbnQuc3RvcmVJRDtcbn1cblxudmFyIFJlY29pbF9SZWNvaWxSb290ID0ge1xuICBSZWNvaWxSb290LFxuICB1c2VTdG9yZVJlZixcbiAgdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSxcbiAgdXNlUmVjb2lsU3RvcmVJRCxcbiAgbm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORzogbm90aWZ5Q29tcG9uZW50cyxcbiAgc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zX0ZPUl9URVNUSU5HOiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dBcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFJlY29pbF9zaGFsbG93QXJyYXlFcXVhbCA9IHNoYWxsb3dBcnJheUVxdWFsO1xuXG5jb25zdCB7XG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDEsXG4gIHVzZVJlZjogdXNlUmVmJDJcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmJDIoKTtcbiAgdXNlRWZmZWN0JDEoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbnZhciBSZWNvaWxfdXNlUHJldmlvdXMgPSB1c2VQcmV2aW91cztcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIFNVU1BFTlNFX1RJTUVPVVRfTVM6IFNVU1BFTlNFX1RJTUVPVVRfTVMkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgdXBkYXRlUmV0YWluQ291bnQ6IHVwZGF0ZVJldGFpbkNvdW50JDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIFJldGVudGlvblpvbmU6IFJldGVudGlvblpvbmUkM1xufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0JDIsXG4gIHVzZVJlZjogdXNlUmVmJDNcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMlxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG4gLy8gSSBkb24ndCBzZWUgYSB3YXkgdG8gYXZvaWQgdGhlIGFueSB0eXBlIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvIGFjY2VwdCByZWFkYWJsZVxuLy8gYW5kIHdyaXRhYmxlIHZhbHVlcyB3aXRoIGFueSB0eXBlIHBhcmFtZXRlciwgYnV0IG5vcm1hbGx5IHdpdGggd3JpdGFibGUgb25lc1xuLy8gUmVjb2lsU3RhdGU8U29tZVQ+IGlzIG5vdCBhIHN1YnR5cGUgb2YgUmVjb2lsU3RhdGU8bWl4ZWQ+LlxuXG5cbi8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuZnVuY3Rpb24gdXNlUmV0YWluKHRvUmV0YWluKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG5cblxuICByZXR1cm4gdXNlUmV0YWluX0FDVFVBTCh0b1JldGFpbik7XG59XG5cbmZ1bmN0aW9uIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pIHtcbiAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KHRvUmV0YWluKSA/IHRvUmV0YWluIDogW3RvUmV0YWluXTtcbiAgY29uc3QgcmV0YWluYWJsZXMgPSBhcnJheS5tYXAoYSA9PiBhIGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQzID8gYSA6IGEua2V5KTtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQxKCk7XG4gIHVzZUVmZmVjdCQyKCgpID0+IHtcbiAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAodGltZW91dElELmN1cnJlbnQgJiYgIWlzU1NSJDIpIHtcbiAgICAgIC8vIEFscmVhZHkgcGVyZm9ybWVkIGEgdGVtcG9yYXJ5IHJldGFpbiBvbiByZW5kZXIsIHNpbXBseSBjYW5jZWwgdGhlIHJlbGVhc2VcbiAgICAgIC8vIG9mIHRoYXQgdGVtcG9yYXJ5IHJldGFpbi5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gIH0sIFtzdG9yZVJlZiwgLi4ucmV0YWluYWJsZXNdKTsgLy8gV2Ugd2FudCB0byByZXRhaW4gaWYgdGhlIGNvbXBvbmVudCBzdXNwZW5kcy4gVGhpcyBpcyB0ZXJyaWJsZSBidXQgdGhlIFN1c3BlbnNlXG4gIC8vIEFQSSBhZmZvcmRzIHVzIG5vIGJldHRlciBvcHRpb24uIElmIHdlIHN1c3BlbmQgYW5kIG5ldmVyIGNvbW1pdCBhZnRlciBzb21lXG4gIC8vIHNlY29uZHMsIHRoZW4gcmVsZWFzZS4gVGhlICdhY3R1YWwnIHJldGFpbi9yZWxlYXNlIGluIHRoZSBlZmZlY3QgYWJvdmVcbiAgLy8gY2FuY2VscyB0aGlzLlxuXG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQzKCk7XG4gIGNvbnN0IHByZXZpb3VzUmV0YWluYWJsZXMgPSBSZWNvaWxfdXNlUHJldmlvdXMocmV0YWluYWJsZXMpO1xuXG4gIGlmICghaXNTU1IkMiAmJiAocHJldmlvdXNSZXRhaW5hYmxlcyA9PT0gdW5kZWZpbmVkIHx8ICFSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwocHJldmlvdXNSZXRhaW5hYmxlcywgcmV0YWluYWJsZXMpKSkge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcblxuICAgIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xuICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzUmV0YWluYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgciBvZiBwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGltZW91dElELmN1cnJlbnQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgIH1cblxuICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH0sIFNVU1BFTlNFX1RJTUVPVVRfTVMkMSk7XG4gIH1cbn1cblxudmFyIFJlY29pbF91c2VSZXRhaW4gPSB1c2VSZXRhaW47XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFRISVMgQ09ERSBIQVMgQkVFTiBDT01NRU5URUQgT1VUIElOVEVOVElPTkFMTFlcbiAqXG4gKiBUaGlzIHRlY2huaXF1ZSBvZiBnZXR0aW5nIHRoZSBjb21wb25lbnQgbmFtZSBpcyBpbXBlcmZlY3QsIHNpbmNlIGl0IGJvdGggb25seVxuICogd29ya3MgaW4gYSBub24tbWluaWZpZWQgY29kZSBiYXNlLCBhbmQgbW9yZSBpbXBvcnRhbnRseSBpbnRyb2R1Y2VzIHBlcmZvcm1hbmNlXG4gKiBwcm9ibGVtcyBzaW5jZSBpdCByZWxpZXMgaW4gdGhyb3dpbmcgZXJyb3JzIHdoaWNoIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBtYXkgd2FudCB0byByZWV2YWx1YXRlIHRoaXMgdGVjaG5pcXVlIGhlbmNlIHdoeSB3ZSBoYXZlIGNvbW1lbnRlZFxuICogdGhpcyBjb2RlIG91dCwgcmF0aGVyIHRoYW4gZGVsZXRlIGl0IGFsbCB0b2dldGhlci5cbiAqL1xuLy8gY29uc3Qge3VzZVJlZn0gPSByZXF1aXJlKCdyZWFjdCcpO1xuLy8gY29uc3QgZ2t4ID0gcmVxdWlyZSgncmVjb2lsLXNoYXJlZC91dGlsL1JlY29pbF9na3gnKTtcbi8vIGNvbnN0IHN0YWNrVHJhY2VQYXJzZXIgPSByZXF1aXJlKCdyZWNvaWwtc2hhcmVkL3V0aWwvUmVjb2lsX3N0YWNrVHJhY2VQYXJzZXInKTtcblxuZnVuY3Rpb24gdXNlQ29tcG9uZW50TmFtZSgpIHtcbiAgLy8gY29uc3QgbmFtZVJlZiA9IHVzZVJlZigpO1xuICAvLyBpZiAoX19ERVZfXykge1xuICAvLyAgIGlmIChna3goJ3JlY29pbF9pbmZlcl9jb21wb25lbnRfbmFtZXMnKSkge1xuICAvLyAgICAgaWYgKG5hbWVSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gIC8vICAgICAgIC8vIFRoZXJlIGlzIG5vIGJsZXNzZWQgd2F5IHRvIGRldGVybWluZSB0aGUgY2FsbGluZyBSZWFjdCBjb21wb25lbnQgZnJvbVxuICAvLyAgICAgICAvLyB3aXRoaW4gYSBob29rLiBUaGlzIGhhY2sgdXNlcyB0aGUgZmFjdCB0aGF0IGhvb2tzIG11c3Qgc3RhcnQgd2l0aCAndXNlJ1xuICAvLyAgICAgICAvLyBhbmQgdGhhdCBob29rcyBhcmUgZWl0aGVyIGNhbGxlZCBieSBSZWFjdCBDb21wb25lbnRzIG9yIG90aGVyIGhvb2tzLiBJdFxuICAvLyAgICAgICAvLyBmb2xsb3dzIHRoZXJlZm9yZSwgdGhhdCB0byBmaW5kIHRoZSBjYWxsaW5nIGNvbXBvbmVudCwgeW91IHNpbXBseSBuZWVkXG4gIC8vICAgICAgIC8vIHRvIGxvb2sgZG93biB0aGUgc3RhY2sgYW5kIGZpbmQgdGhlIGZpcnN0IGZ1bmN0aW9uIHdoaWNoIGRvZXNuJ3Qgc3RhcnRcbiAgLy8gICAgICAgLy8gd2l0aCAndXNlJy4gV2UgYXJlIG9ubHkgZW5hYmxpbmcgdGhpcyBpbiBkZXYgZm9yIG5vdywgc2luY2Ugb25jZSB0aGVcbiAgLy8gICAgICAgLy8gY29kZWJhc2UgaXMgbWluaWZpZWQsIHRoZSBuYW1pbmcgYXNzdW1wdGlvbnMgbm8gbG9uZ2VyIGhvbGQgdHJ1ZS5cbiAgLy8gICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby1uZXctZXJyb3JcbiAgLy8gICAgICAgY29uc3QgZnJhbWVzID0gc3RhY2tUcmFjZVBhcnNlcihuZXcgRXJyb3IoKS5zdGFjayk7XG4gIC8vICAgICAgIGZvciAoY29uc3Qge21ldGhvZE5hbWV9IG9mIGZyYW1lcykge1xuICAvLyAgICAgICAgIC8vIEkgb2JzZXJ2ZWQgY2FzZXMgd2hlcmUgdGhlIGZyYW1lIHdhcyBvZiB0aGUgZm9ybSAnT2JqZWN0LnVzZVhYWCdcbiAgLy8gICAgICAgICAvLyBoZW5jZSB3aHkgSSdtIHNlYXJjaGluZyBmb3IgaG9va3MgZm9sbG93aW5nIGEgd29yZCBib3VuZGFyeVxuICAvLyAgICAgICAgIGlmICghbWV0aG9kTmFtZS5tYXRjaCgvXFxidXNlW15cXGJdKyQvKSkge1xuICAvLyAgICAgICAgICAgcmV0dXJuIChuYW1lUmVmLmN1cnJlbnQgPSBtZXRob2ROYW1lKTtcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgbmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgLy8gICAgIH1cbiAgLy8gICAgIHJldHVybiBuYW1lUmVmLmN1cnJlbnQgPz8gJzx1bmFibGUgdG8gZGV0ZXJtaW5lIGNvbXBvbmVudCBuYW1lPic7XG4gIC8vICAgfVxuICAvLyB9XG4gIC8vIEBmYi1vbmx5OiByZXR1cm4gXCI8Y29tcG9uZW50IG5hbWUgb25seSBhdmFpbGFibGUgd2hlbiBib3RoIGluIGRldiBtb2RlIGFuZCB3aGVuIHBhc3NpbmcgR0sgJ3JlY29pbF9pbmZlcl9jb21wb25lbnRfbmFtZXMnPlwiO1xuICByZXR1cm4gJzxjb21wb25lbnQgbmFtZSBub3QgYXZhaWxhYmxlPic7IC8vIEBvc3Mtb25seVxufVxuXG52YXIgUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUgPSB1c2VDb21wb25lbnROYW1lO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZTogY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSQxLFxuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQzLFxuICB1c2VNdXRhYmxlU291cmNlOiB1c2VNdXRhYmxlU291cmNlJDEsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlOiB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEsXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQzLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkMixcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZTogc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyLFxuICBzdWJzY3JpYmVUb1JlY29pbFZhbHVlOiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cblxuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQxLFxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQzLFxuICB1c2VNZW1vOiB1c2VNZW1vJDEsXG4gIHVzZVJlZjogdXNlUmVmJDQsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSQxXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQyXG59ID0gUmVjb2lsX0NvcHlPbldyaXRlO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKSB7XG4gIC8vIFdlIGNhbid0IGp1c3QgdGhyb3cgdGhlIHByb21pc2Ugd2UgYXJlIHdhaXRpbmcgb24gdG8gU3VzcGVuc2UuICBJZiB0aGVcbiAgLy8gdXBzdHJlYW0gZGVwZW5kZW5jaWVzIGNoYW5nZSBpdCBtYXkgcHJvZHVjZSBhIHN0YXRlIGluIHdoaWNoIHRoZSBjb21wb25lbnRcbiAgLy8gY2FuIHJlbmRlciwgYnV0IGl0IHdvdWxkIHN0aWxsIGJlIHN1c3BlbmRlZCBvbiBhIFByb21pc2UgdGhhdCBtYXkgbmV2ZXIgcmVzb2x2ZS5cbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmFkZChyZXNvbHZlKTtcbiAgICB9KTsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIEZsb3cocHJvcC1taXNzaW5nKSBmb3IgaW50ZWdyYXRpbmcgd2l0aCB0b29scyB0aGF0IGluc3BlY3QgdGhyb3duIHByb21pc2VzIEBmYi1vbmx5XG4gICAgLy8gQGZiLW9ubHk6IHByb21pc2UuZGlzcGxheU5hbWUgPSBgUmVjb2lsIFN0YXRlOiAke3JlY29pbFZhbHVlLmtleX1gO1xuXG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFJlY29pbF9lcnIoYEludmFsaWQgdmFsdWUgb2YgbG9hZGFibGUgYXRvbSBcIiR7cmVjb2lsVmFsdWUua2V5fVwiYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgaG9va05hbWUpIHtcbiAgaWYgKCFpc1JlY29pbFZhbHVlJDIocmVjb2lsVmFsdWUpKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCBhcmd1bWVudCB0byAke2hvb2tOYW1lfTogZXhwZWN0ZWQgYW4gYXRvbSBvciBzZWxlY3RvciBidXQgZ290ICR7U3RyaW5nKHJlY29pbFZhbHVlKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhcmlvdXMgdGhpbmdzIGFyZSBicm9rZW4gd2l0aCB1c2VSZWNvaWxJbnRlcmZhY2UsIHBhcnRpY3VsYXJseSBjb25jdXJyZW50XG4gKiBtb2RlLCBSZWFjdCBzdHJpY3QgbW9kZSwgYW5kIG1lbW9yeSBtYW5hZ2VtZW50LiBUaGV5IHdpbGwgbm90IGJlIGZpeGVkLlxuICogKi9cbmZ1bmN0aW9uIHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEKCkge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3Qtbm8tdW51c2VkLXN0YXRlLWhvb2tcblxuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgcmVjb2lsVmFsdWVzVXNlZCA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XG4gIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgdGhlIFJlY29pbFZhbHVlcyB1c2VkIGp1c3QgZHVyaW5nIHRoaXMgcmVuZGVyXG5cbiAgY29uc3QgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gdXNlUmVmJDQobmV3IFNldCgpKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlRnJvbSA9IHVzZUNhbGxiYWNrJDEoa2V5ID0+IHtcbiAgICBjb25zdCBzdWIgPSBzdWJzY3JpcHRpb25zLmN1cnJlbnQuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3ViKSB7XG4gICAgICBzdWIucmVsZWFzZSgpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSwgW3N1YnNjcmlwdGlvbnNdKTtcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKChfc3RhdGUsIGtleSkgPT4ge1xuICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcbiAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gRWZmZWN0IHRvIGFkZC9yZW1vdmUgc3Vic2NyaXB0aW9ucyBhcyBub2RlcyBhcmUgdXNlZFxuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCwgcHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKGBEb3VibGUgc3Vic2NyaXB0aW9uIHRvIFJlY29pbFZhbHVlIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgc3RhdGUgPT4gdXBkYXRlU3RhdGUoc3RhdGUsIGtleSksIGNvbXBvbmVudE5hbWUpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LnNldChrZXksIHN1Yik7XG4gICAgICAvKipcbiAgICAgICAqIFNpbmNlIHdlJ3JlIHN1YnNjcmliaW5nIGluIGFuIGVmZmVjdCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgbGF0ZXN0XG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgICAqIGdvIGFoZWFkIGFuZCBkbyB0aGF0IG5vdywgdW5sZXNzIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBiYXRjaCAtLVxuICAgICAgICogaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgZG8gaXQgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2gsIGR1ZSB0byB0aGVcbiAgICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICAgKiBvZiB0aGlzIHNhbWUgY29tcG9uZW50LiBUaGVuIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2Ugb2YgZXZlbnRzIG9jY3VyOlxuICAgICAgICogMS4gQXRvbSBpcyB1cGRhdGVkIGFuZCBzdWJzIGZpcmVkIChidXQgd2UgbWF5IG5vdCBiZSBzdWJzY3JpYmVkXG4gICAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAgICogICAgaXMgbm93IGluIG5leHRUcmVlLCBidXQgbm90IGN1cnJlbnRUcmVlLlxuICAgICAgICogMi4gVGhpcyBlZmZlY3QgaGFwcGVucy4gV2Ugc3Vic2NyaWJlIGFuZCB1cGRhdGUuXG4gICAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgICAqIDQuIEJhdGNoZXIncyBlZmZlY3Qgc2V0cyBjdXJyZW50VHJlZSB0byBuZXh0VHJlZS5cbiAgICAgICAqIEluIHRoaXMgc2VxdWVuY2Ugd2UgbWlzcyB0aGUgdXBkYXRlLiBUbyBhdm9pZCB0aGF0LCBhZGQgdGhlIHVwZGF0ZVxuICAgICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAqL1xuICAgICAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG4gICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBSZWNvaWxfZGlmZmVyZW5jZVNldHMocHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQsIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmVGcm9tKGtleSk7XG4gICAgfSk7XG4gICAgcHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQgPSByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQ7XG4gIH0pOyAvLyBFZmZlY3QgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgd2hlbiB1bm1vdW50aW5nXG5cbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50OyAvLyBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgdGhhdCB3ZXJlIGNsZWFyZWQgZHVlIHRvIFN0cmljdE1vZGUgcnVubmluZyB0aGlzIGVmZmVjdCB0d2ljZVxuXG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCwgbmV3IFNldChjdXJyZW50U3Vic2NyaXB0aW9ucy5rZXlzKCkpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCBzdGF0ZSA9PiB1cGRhdGVTdGF0ZShzdGF0ZSwga2V5KSwgY29tcG9uZW50TmFtZSk7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBzdWIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBjdXJyZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKChfLCBrZXkpID0+IHVuc3Vic2NyaWJlRnJvbShrZXkpKTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHN0b3JlUmVmLCB1bnN1YnNjcmliZUZyb20sIHVwZGF0ZVN0YXRlXSk7XG4gIHJldHVybiB1c2VNZW1vJDEoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBmdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlU2V0UmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVzZXRSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCkgPT4gc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQyKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICAgICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XG4gICAgICAgIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IHNldEJ5QWRkaW5nVG9TZXQkMihyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHJlY29pbFZhbHVlLmtleSk7XG4gICAgICB9IC8vIFRPRE8gUmVzdG9yZSBvcHRpbWl6YXRpb24gdG8gbWVtb2l6ZSBsb29rdXBcblxuXG4gICAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFZhbHVlLCByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcbiAgICAgIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdXNlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSxcbiAgICAgIGdldFJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXG4gICAgICBnZXRSZWNvaWxTdGF0ZTogdXNlUmVjb2lsU3RhdGUsXG4gICAgICBnZXRSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxuICAgICAgZ2V0U2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlLFxuICAgICAgZ2V0UmVzZXRSZWNvaWxTdGF0ZTogdXNlUmVzZXRSZWNvaWxTdGF0ZVxuICAgIH07XG4gIH0sIFtyZWNvaWxWYWx1ZXNVc2VkLCBzdG9yZVJlZl0pO1xufVxuXG5jb25zdCByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HID0ge1xuICBjdXJyZW50OiAwXG59O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTI7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlMiA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkYWJsZSxcbiAgICAgIGtleTogcmVjb2lsVmFsdWUua2V5XG4gICAgfTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pOyAvLyBNZW1vaXplIHRoZSBzdGF0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXJlbmRlcnNcblxuICBjb25zdCBtZW1vaXplUHJldmlvdXNTbmFwc2hvdCA9IHVzZUNhbGxiYWNrJDEoZ2V0U3RhdGUgPT4ge1xuICAgIGxldCBwcmV2U3RhdGU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHZhciBfcHJldlN0YXRlLCBfcHJldlN0YXRlMjtcblxuICAgICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAgICAgaWYgKChfcHJldlN0YXRlID0gcHJldlN0YXRlKSAhPT0gbnVsbCAmJiBfcHJldlN0YXRlICE9PSB2b2lkIDAgJiYgX3ByZXZTdGF0ZS5sb2FkYWJsZS5pcyhuZXh0U3RhdGUubG9hZGFibGUpICYmICgoX3ByZXZTdGF0ZTIgPSBwcmV2U3RhdGUpID09PSBudWxsIHx8IF9wcmV2U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldlN0YXRlMi5rZXkpID09PSBuZXh0U3RhdGUua2V5KSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHByZXZTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gdXNlTWVtbyQxKCgpID0+IG1lbW9pemVQcmV2aW91c1NuYXBzaG90KGdldFNuYXBzaG90KSwgW2dldFNuYXBzaG90LCBtZW1vaXplUHJldmlvdXNTbmFwc2hvdF0pO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayQxKG5vdGlmeSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIG5vdGlmeSwgY29tcG9uZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lXSk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0TWVtb2l6ZWRTbmFwc2hvdCwgLy8gZ2V0U25hcHNob3QoKVxuICBnZXRNZW1vaXplZFNuYXBzaG90IC8vIGdldFNlcnZlclNuYXBzaG90KCkgZm9yIFNTUiBzdXBwb3J0XG4gICkubG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMztcblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlMyA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlMyAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUzIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBnZXRMb2FkYWJsZVdpdGhUZXN0aW5nID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldExvYWRhYmxlKCk7XG4gIH0sIFtnZXRMb2FkYWJsZV0pO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMSgoX3N0b3JlU3RhdGUsIG5vdGlmeSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCAoKSA9PiB7XG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBub3RpZnkoKTtcbiAgICAgIH0gLy8gT25seSByZS1yZW5kZXIgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyB3aWxsIGV2YWx1YXRlIHRoZSBhdG9tL3NlbGVjdG9yIG5vdyBhcyB3ZWxsIGFzIHdoZW4gdGhlXG4gICAgICAvLyBjb21wb25lbnQgcmVuZGVycywgYnV0IHRoYXQgbWF5IGhlbHAgd2l0aCBwcmVmZXRjaGluZy5cblxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQuaXMobmV3TG9hZGFibGUpKSB7XG4gICAgICAgIG5vdGlmeSgpO1xuICAgICAgfSAvLyBJZiB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZCB0aGVuIHRoZSBlZmZlY3Qgc2V0dGluZyBwcmV2TG9hZGFibGVSZWZcbiAgICAgIC8vIHdpbGwgbm90IHJ1bi4gIFNvLCBzZXQgdGhlIHByZXZpb3VzIHZhbHVlIGhlcmUgd2hlbiBpdHMgc3Vic2NyaXB0aW9uXG4gICAgICAvLyBpcyBmaXJlZCB0byB3YWtlIGl0IHVwLiAgV2UgY2FuJ3QganVzdCByZWx5IG9uIHRoaXMsIHRob3VnaCwgYmVjYXVzZVxuICAgICAgLy8gdGhpcyBvbmx5IGV4ZWN1dGVzIHdoZW4gYW4gYXRvbS9zZWxlY3RvciBpcyBkaXJ0eSBhbmQgdGhlIGF0b20vc2VsZWN0b3JcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgaG9vayBjYW4gZHluYW1pY2FsbHkgY2hhbmdlLlxuXG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZV0pO1xuICBjb25zdCBzb3VyY2UgPSB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEoKTtcblxuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWwgaG9va3MgbXVzdCBiZSB1c2VkIGluIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpbiBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG4gIH1cblxuICBjb25zdCBsb2FkYWJsZSA9IHVzZU11dGFibGVTb3VyY2UkMShzb3VyY2UsIGdldExvYWRhYmxlV2l0aFRlc3RpbmcsIHN1YnNjcmliZSk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTsgLy8gQWNjZXNzb3JzIHRvIGdldCB0aGUgY3VycmVudCBzdGF0ZVxuXG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNCA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNCAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU0IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBnZXRTdGF0ZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4gKHtcbiAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUoKSxcbiAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxuICB9KSwgW2dldExvYWRhYmxlLCByZWNvaWxWYWx1ZS5rZXldKTsgLy8gTWVtb2l6ZSBzdGF0ZSBzbmFwc2hvdHNcblxuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrJDEocHJldlN0YXRlID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIHJldHVybiBwcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiBwcmV2U3RhdGUua2V5ID09PSBuZXh0U3RhdGUua2V5ID8gcHJldlN0YXRlIDogbmV4dFN0YXRlO1xuICB9LCBbZ2V0U3RhdGVdKTsgLy8gU3Vic2NyaWJlIHRvIFJlY29pbCBzdGF0ZSBjaGFuZ2VzXG5cbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgX3N0YXRlID0+IHtcbiAgICAgIHNldFN0YXRlKHVwZGF0ZVN0YXRlKTtcbiAgICB9LCBjb21wb25lbnROYW1lKTsgLy8gVXBkYXRlIHN0YXRlIGluIGNhc2Ugd2UgYXJlIHVzaW5nIGEgZGlmZmVyZW50IGtleVxuXG4gICAgc2V0U3RhdGUodXBkYXRlU3RhdGUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZiwgdXBkYXRlU3RhdGVdKTsgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlXG5cbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSQxKGdldFN0YXRlKTsgLy8gSWYgd2UgY2hhbmdlZCBrZXlzLCB0aGVuIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSBuZXcga2V5LlxuICAvLyBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBvbGQga2V5IHdvdWxkIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gc3VzcGVuZC5cbiAgLy8gV2UgZG9uJ3QgaGF2ZSB0byBzZXQgdGhlIG5ldyBzdGF0ZSBoZXJlIHNpbmNlIHRoZSBzdWJzY3JpYmluZyBlZmZlY3QgYWJvdmVcbiAgLy8gd2lsbCBkbyB0aGF0LlxuXG4gIHJldHVybiBzdGF0ZS5rZXkgIT09IHJlY29pbFZhbHVlLmtleSA/IGdldFN0YXRlKCkubG9hZGFibGUgOiBzdGF0ZS5sb2FkYWJsZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1kocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3Qtbm8tdW51c2VkLXN0YXRlLWhvb2tcblxuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCEoKF9wcmV2TG9hZGFibGVSZWYkY3VyciA9IHByZXZMb2FkYWJsZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIuaXMobmV3TG9hZGFibGUpKSkge1xuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxuICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcbiAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cbiAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXG4gICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cblxuICAgIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XG4gICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMjtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcbiAgICAgICAgZm9yY2VVcGRhdGUobmV3TG9hZGFibGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIGdldExvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuLyoqXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcbiAganVzdCB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZSBmb3IgYW55IHJlYXNvbiwgc3VjaCBhcyBwZW5kaW5nIG9yIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFRSQU5TSVRJT05fU1VQUE9SVDogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQsXG4gICAgLy8gUmVjb2lsIHdpbGwgYXR0ZW1wIHRvIGRldGVjdCBpZiBgdXNlU3luY0V4dGVybmFsU3RvcmUoKWAgaXMgc3VwcG9ydGVkIHdpdGhcbiAgICAvLyBgcmVhY3RNb2RlKClgIGJlZm9yZSBjYWxsaW5nIGl0LiAgSG93ZXZlciwgc29tZXRpbWVzIHRoZSBob3N0IFJlYWN0XG4gICAgLy8gZW52aXJvbm1lbnQgc3VwcG9ydHMgaXQgYnV0IHVzZXMgYWRkaXRpb25hbCBSZWFjdCByZW5kZXJlcnMgKHN1Y2ggYXMgd2l0aFxuICAgIC8vIGByZWFjdC10aHJlZS1maWJlcmApIHdoaWNoIGRvIG5vdC4gIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYSB1c2VyIGlzc3VlXG4gICAgLy8gYnkgdXNpbmcgYSByZW5kZXJlciB3aXRoIFJlYWN0IDE4KyB0aGF0IGRvZXNuJ3QgZnVsbHkgc3VwcG9ydCBSZWFjdCAxOCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gYnJlYWsgdXNlcnMgaWYgaXQgY2FuIGJlIGF2b2lkZWQuIEFzIHRoZSBjdXJyZW50IHJlbmRlcmVyIGNhblxuICAgIC8vIGNoYW5nZSBhdCBydW50aW1lLCB3ZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGNoZWNrIGFuZCBmYWxsYmFjayBpZiBuZWNlc3NhcnkuXG4gICAgU1lOQ19FWFRFUk5BTF9TVE9SRTogY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSQxKCkgPyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUgOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCxcbiAgICBNVVRBQkxFX1NPVVJDRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9NVVRBQkxFX1NPVVJDRSxcbiAgICBMRUdBQ1k6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZXG4gIH1bcmVhY3RNb2RlJDMoKS5tb2RlXShyZWNvaWxWYWx1ZSk7XG59XG4vKipcbiAgUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIFJlY29pbFZhbHVlLlxuICBJZiB0aGUgdmFsdWUgaXMgcGVuZGluZywgaXQgd2lsbCB0aHJvdyBhIFByb21pc2UgdG8gc3VzcGVuZCB0aGUgY29tcG9uZW50LFxuICBpZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IgaXQgd2lsbCB0aHJvdyBpdCBmb3IgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkuXG4gIFRoaXMgd2lsbCBhbHNvIHN1YnNjcmliZSB0aGUgY29tcG9uZW50IGZvciBhbnkgdXBkYXRlcyBpbiB0aGUgdmFsdWUuXG4gICovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSk7XG4gIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcbn1cbi8qKlxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIHZhbHVlIG9mIGEgUmVjb2lsU3RhdGUgdG8gYmUgdXBkYXRlZCwgYnV0IGRvZXNcbiAgbm90IHN1YnNjcmliZSB0aGUgY29tcG9uZW50IHRvIGNoYW5nZXMgdG8gdGhhdCBSZWNvaWxTdGF0ZS5cbiovXG5cblxuZnVuY3Rpb24gdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VTZXRSZWNvaWxTdGF0ZScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQxKG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcbn1cbi8qKlxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc2V0IHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGl0cyBkZWZhdWx0XG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZXNldFJlY29pbFN0YXRlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcbn1cbi8qKlxuICBFcXVpdmFsZW50IHRvIHVzZVN0YXRlKCkuIEFsbG93cyB0aGUgdmFsdWUgb2YgdGhlIFJlY29pbFN0YXRlIHRvIGJlIHJlYWQgYW5kIHdyaXR0ZW4uXG4gIFN1YnNlcXVlbnQgdXBkYXRlcyB0byB0aGUgUmVjb2lsU3RhdGUgd2lsbCBjYXVzZSB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlci4gSWYgdGhlXG4gIFJlY29pbFN0YXRlIGlzIHBlbmRpbmcsIHRoaXMgd2lsbCBzdXNwZW5kIHRoZSBjb21wb25lbnQgYW5kIGluaXRpYXRlIHRoZVxuICByZXRyaWV2YWwgb2YgdGhlIHZhbHVlLiBJZiBldmFsdWF0aW5nIHRoZSBSZWNvaWxTdGF0ZSByZXN1bHRlZCBpbiBhbiBlcnJvciwgdGhpcyB3aWxsXG4gIHRocm93IHRoZSBlcnJvciBzbyB0aGF0IHRoZSBuZWFyZXN0IFJlYWN0IGVycm9yIGJvdW5kYXJ5IGNhbiBjYXRjaCBpdC5cbiovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG59XG4vKipcbiAgTGlrZSB1c2VSZWNvaWxTdGF0ZSgpLCBidXQgZG9lcyBub3QgY2F1c2UgU3VzcGVuc2Ugb3IgUmVhY3QgZXJyb3IgaGFuZGxpbmcuIFJldHVybnNcbiAgYW4gb2JqZWN0IHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIFJlY29pbFN0YXRlIGlzIGF2YWlsYWJsZSwgcGVuZGluZywgb3JcbiAgdW5hdmFpbGFibGUgZHVlIHRvIGFuIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzKCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuICh2YWx1ZXMsIHRyYW5zYWN0aW9uTWV0YWRhdGEgPSB7fSkgPT4ge1xuICAgIGJhdGNoVXBkYXRlcyQyKCgpID0+IHtcbiAgICAgIHN0b3JlUmVmLmN1cnJlbnQuYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSh0cmFuc2FjdGlvbk1ldGFkYXRhKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBFeHBlcmltZW50YWwgdmFyaWFudHMgb2YgaG9va3Mgd2l0aCBzdXBwb3J0IGZvciB1c2VUcmFuc2l0aW9uKClcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcblxuICAgIGlmICghcmVhY3RNb2RlJDMoKS5lYXJseSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlcG10IHRvIHVzZSBhIGhvb2sgd2l0aCBVTlNUQUJMRV9UUkFOU0lUSU9OX1NVUFBPUlQgaW4gYSByZW5kZXJpbmcgbW9kZSBpbmNvbXBhdGlibGUgd2l0aCBjb25jdXJyZW50IHJlbmRlcmluZy4gIFRyeSBlbmFibGluZyB0aGUgcmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUgb3IgcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBHS3MuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQocmVjb2lsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcbiAgfVxuXG4gIHJldHVybiBbdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cblxudmFyIFJlY29pbF9Ib29rcyA9IHtcbiAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyxcbiAgdXNlUmVjb2lsSW50ZXJmYWNlOiB1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCxcbiAgdXNlUmVjb2lsU3RhdGUsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGUsXG4gIHVzZVJlY29pbFZhbHVlLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICB1c2VSZXNldFJlY29pbFN0YXRlLFxuICB1c2VTZXRSZWNvaWxTdGF0ZSxcbiAgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSxcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBtYXAgY29udGFpbmluZyBhbGwgb2YgdGhlIGtleXMgKyB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWFwIHdoZXJlXG4gKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJNYXAobWFwLCBjYWxsYmFjaykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfZmlsdGVyTWFwID0gZmlsdGVyTWFwO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgc2V0IHdoZXJlXG4gKiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJTZXQoc2V0LCBjYWxsYmFjaykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBzZXQpIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUpKSB7XG4gICAgICByZXN1bHQuYWRkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX2ZpbHRlclNldCA9IGZpbHRlclNldDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VNYXBzKC4uLm1hcHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gbWFwc1tpXS5rZXlzKCk7XG4gICAgbGV0IG5leHRLZXk7XG5cbiAgICB3aGlsZSAoIShuZXh0S2V5ID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXSAtIG1hcC9pdGVyYXRvciBrbm93cyBub3RoaW5nIGFib3V0IGZsb3cgdHlwZXNcbiAgICAgIHJlc3VsdC5zZXQobmV4dEtleS52YWx1ZSwgbWFwc1tpXS5nZXQobmV4dEtleS52YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfbWVyZ2VNYXBzID0gbWVyZ2VNYXBzO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDNcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQzLFxuICBnZXROb2RlOiBnZXROb2RlJDQsXG4gIG5vZGVzOiBub2RlcyQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDNcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDQsXG4gIHNldFJlY29pbFZhbHVlTG9hZGFibGU6IHNldFJlY29pbFZhbHVlTG9hZGFibGUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQyLFxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQ0LFxuICB1c2VSZWY6IHVzZVJlZiQ1LFxuICB1c2VTdGF0ZTogdXNlU3RhdGUkMlxufSA9IHJlYWN0O1xuXG5jb25zdCB7XG4gIGlzU1NSOiBpc1NTUiQzXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24oY2FsbGJhY2spIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XG4gIHVzZUVmZmVjdCQ0KCgpID0+IHtcbiAgICBjb25zdCBzdWIgPSBzdG9yZVJlZi5jdXJyZW50LnN1YnNjcmliZVRvVHJhbnNhY3Rpb25zKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gc3ViLnJlbGVhc2U7XG4gIH0sIFtjYWxsYmFjaywgc3RvcmVSZWZdKTtcbn1cblxuZnVuY3Rpb24gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBhdG9tVmFsdWVzID0gc3RhdGUuYXRvbVZhbHVlcy50b01hcCgpO1xuICBjb25zdCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMgPSBSZWNvaWxfbWFwTWFwKFJlY29pbF9maWx0ZXJNYXAoYXRvbVZhbHVlcywgKHYsIGspID0+IHtcbiAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ0KGspO1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gbm9kZS5wZXJzaXN0ZW5jZV9VTlNUQUJMRTtcbiAgICByZXR1cm4gcGVyc2lzdGVuY2UgIT0gbnVsbCAmJiBwZXJzaXN0ZW5jZS50eXBlICE9PSAnbm9uZScgJiYgdi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJztcbiAgfSksIHYgPT4gdi5jb250ZW50cyk7IC8vIE1lcmdlIGluIG5vbnZhbGlkYXRlZCBhdG9tczsgd2UgbWF5IG5vdCBoYXZlIGRlZnMgZm9yIHRoZW0gYnV0IHRoZXkgd2lsbFxuICAvLyBhbGwgaGF2ZSBwZXJzaXN0ZW5jZSBvbiBvciB0aGV5IHdvdWxkbid0IGJlIHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cblxuICByZXR1cm4gUmVjb2lsX21lcmdlTWFwcyhzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy50b01hcCgpLCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMpO1xufVxuXG4vKipcbiAgQ2FsbHMgdGhlIGdpdmVuIGNhbGxiYWNrIGFmdGVyIGFueSBhdG9tcyBoYXZlIGJlZW4gbW9kaWZpZWQgYW5kIHRoZSBjb25zZXF1ZW50XG4gIGNvbXBvbmVudCByZS1yZW5kZXJzIGhhdmUgYmVlbiBjb21taXR0ZWQuIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHBlcnNpc3RpbmdcbiAgdGhlIHZhbHVlcyBvZiB0aGUgYXRvbXMgdG8gc3RvcmFnZS4gVGhlIHN0b3JlZCB2YWx1ZXMgY2FuIHRoZW4gYmUgcmVzdG9yZWRcbiAgdXNpbmcgdGhlIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyBob29rLlxuXG4gIFRoZSBjYWxsYmFjayByZWNlaXZlcyB0aGUgZm9sbG93aW5nIGluZm86XG5cbiAgYXRvbVZhbHVlczogVGhlIGN1cnJlbnQgdmFsdWUgb2YgZXZlcnkgYXRvbSB0aGF0IGlzIGJvdGggcGVyc2lzdGFibGUgKHBlcnNpc3RlbmNlXG4gICAgICAgICAgICAgIHR5cGUgbm90IHNldCB0byAnbm9uZScpIGFuZCB3aG9zZSB2YWx1ZSBpcyBhdmFpbGFibGUgKG5vdCBpbiBhblxuICAgICAgICAgICAgICBlcnJvciBvciBsb2FkaW5nIHN0YXRlKS5cblxuICBwcmV2aW91c0F0b21WYWx1ZXM6IFRoZSB2YWx1ZSBvZiBldmVyeSBwZXJzaXN0YWJsZSBhbmQgYXZhaWxhYmxlIGF0b20gYmVmb3JlXG4gICAgICAgICAgICAgICB0aGUgdHJhbnNhY3Rpb24gYmVnYW4uXG5cbiAgYXRvbUluZm86IEEgbWFwIGNvbnRhaW5pbmcgdGhlIHBlcnNpc3RlbmNlIHNldHRpbmdzIGZvciBlYWNoIGF0b20uIEV2ZXJ5IGtleVxuICAgICAgICAgICAgdGhhdCBleGlzdHMgaW4gYXRvbVZhbHVlcyB3aWxsIGFsc28gZXhpc3QgaW4gYXRvbUluZm8uXG5cbiAgbW9kaWZpZWRBdG9tczogVGhlIHNldCBvZiBhdG9tcyB0aGF0IHdlcmUgd3JpdHRlbiB0byBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuXG4gIHRyYW5zYWN0aW9uTWV0YWRhdGE6IEFyYml0cmFyeSBpbmZvcm1hdGlvbiB0aGF0IHdhcyBhZGRlZCB2aWEgdGhlXG4gICAgICAgICAgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIGhvb2suIFVzZWZ1bCBmb3IgaWdub3JpbmcgdGhlIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlc1xuICAgICAgICAgIHRyYW5zYWN0aW9uLCB0byBhdm9pZCBsb29wcy5cbiovXG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQoY2FsbGJhY2spIHtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiB7XG4gICAgbGV0IHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlO1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgIGlmICghcHJldmlvdXNUcmVlKSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG5vdGlmaWVkIHdpdGhvdXQgYSBwcmV2aW91cyB0cmVlIGJlaW5nIHByZXNlbnQgLS0gdGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwnKTtcbiAgICAgIHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7IC8vIGF0dGVtcHQgdG8gdHJ1bmRsZSBvblxuICAgIH1cblxuICAgIGNvbnN0IGF0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKGN1cnJlbnRUcmVlKTtcbiAgICBjb25zdCBwcmV2aW91c0F0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHByZXZpb3VzVHJlZSk7XG4gICAgY29uc3QgYXRvbUluZm8gPSBSZWNvaWxfbWFwTWFwKG5vZGVzJDEsIG5vZGUgPT4ge1xuICAgICAgdmFyIF9ub2RlJHBlcnNpc3RlbmNlX1VOUywgX25vZGUkcGVyc2lzdGVuY2VfVU5TMiwgX25vZGUkcGVyc2lzdGVuY2VfVU5TMywgX25vZGUkcGVyc2lzdGVuY2VfVU5TNDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IHtcbiAgICAgICAgICB0eXBlOiAoX25vZGUkcGVyc2lzdGVuY2VfVU5TID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLnR5cGUpICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TIDogJ25vbmUnLFxuICAgICAgICAgIGJhY2tCdXR0b246IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0LmJhY2tCdXR0b24pICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgIT09IHZvaWQgMCA/IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pOyAvLyBGaWx0ZXIgb24gZXhpc3RhbmNlIGluIGF0b21WYWx1ZXMgc28gdGhhdCBleHRlcm5hbGx5LXZpc2libGUgcnVsZXNcbiAgICAvLyBhcmUgYWxzbyBhcHBsaWVkIHRvIG1vZGlmaWVkIGF0b21zIChzcGVjaWZpY2FsbHkgZXhjbHVkZSBzZWxlY3RvcnMpOlxuXG4gICAgY29uc3QgbW9kaWZpZWRBdG9tcyA9IFJlY29pbF9maWx0ZXJTZXQoY3VycmVudFRyZWUuZGlydHlBdG9tcywgayA9PiBhdG9tVmFsdWVzLmhhcyhrKSB8fCBwcmV2aW91c0F0b21WYWx1ZXMuaGFzKGspKTtcbiAgICBjYWxsYmFjayh7XG4gICAgICBhdG9tVmFsdWVzLFxuICAgICAgcHJldmlvdXNBdG9tVmFsdWVzLFxuICAgICAgYXRvbUluZm8sXG4gICAgICBtb2RpZmllZEF0b21zLFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi5jdXJyZW50VHJlZS50cmFuc2FjdGlvbk1ldGFkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtjYWxsYmFja10pKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ2xhdGVzdCcpO1xuICAgIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDEoc3RvcmUsICdwcmV2aW91cycpO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgcHJldmlvdXNTbmFwc2hvdFxuICAgIH0pO1xuICB9LCBbY2FsbGJhY2tdKSk7XG59IC8vIFJldHVybiBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBzdWJzY3JpYmUgdG8gYWxsIHN0YXRlIGNoYW5nZXNcblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTbmFwc2hvdCgpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XG4gIGNvbnN0IFtzbmFwc2hvdCwgc2V0U25hcHNob3RdID0gdXNlU3RhdGUkMigoKSA9PiBjbG9uZVNuYXBzaG90JDEoc3RvcmVSZWYuY3VycmVudCkpO1xuICBjb25zdCBwcmV2aW91c1NuYXBzaG90ID0gUmVjb2lsX3VzZVByZXZpb3VzKHNuYXBzaG90KTtcbiAgY29uc3QgdGltZW91dElEID0gdXNlUmVmJDUoKTtcbiAgY29uc3QgcmVsZWFzZVJlZiA9IHVzZVJlZiQ1KCk7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4gc2V0U25hcHNob3QoY2xvbmVTbmFwc2hvdCQxKHN0b3JlKSksIFtdKSk7IC8vIFJldGFpbiBzbmFwc2hvdCBmb3IgZHVyYXRpb24gY29tcG9uZW50IGlzIG1vdW50ZWRcblxuICB1c2VFZmZlY3QkNCgoKSA9PiB7XG4gICAgY29uc3QgcmVsZWFzZSA9IHNuYXBzaG90LnJldGFpbigpOyAvLyBSZWxlYXNlIHRoZSByZXRhaW4gZnJvbSB0aGUgcmVuZGVyaW5nIGNhbGxcblxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCAmJiAhaXNTU1IkMykge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQ7XG5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQuY2FsbChyZWxlYXNlUmVmKTtcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIERlZmVyIHRoZSByZWxlYXNlLiAgSWYgXCJGYXN0IFJlZnJlc2hcIlwiIGlzIHVzZWQgdGhlbiB0aGUgY29tcG9uZW50IG1heVxuICAgICAgLy8gcmUtcmVuZGVyIHdpdGggdGhlIHNhbWUgc3RhdGUuICBUaGUgcHJldmlvdXMgY2xlYW51cCB3aWxsIHRoZW4gcnVuIGFuZFxuICAgICAgLy8gdGhlbiB0aGUgbmV3IGVmZmVjdCB3aWxsIHJ1bi4gV2UgZG9uJ3Qgd2FudCB0aGUgc25hcHNob3QgdG8gYmUgcmVsZWFzZWRcbiAgICAgIC8vIGJ5IHRoYXQgY2xlYW51cCBiZWZvcmUgdGhlIG5ldyBlZmZlY3QgaGFzIGEgY2hhbmNlIHRvIHJldGFpbiBpdCBhZ2Fpbi5cbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQocmVsZWFzZSwgMTApO1xuICAgIH07XG4gIH0sIFtzbmFwc2hvdF0pOyAvLyBSZXRhaW4gc25hcHNob3QgdW50aWwgYWJvdmUgZWZmZWN0IGlzIHJ1bi5cbiAgLy8gUmVsZWFzZSBhZnRlciBhIHRocmVzaG9sZCBpbiBjYXNlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQuXG5cbiAgaWYgKHByZXZpb3VzU25hcHNob3QgIT09IHNuYXBzaG90ICYmICFpc1NTUiQzKSB7XG4gICAgLy8gUmVsZWFzZSB0aGUgcHJldmlvdXMgc25hcHNob3RcbiAgICBpZiAodGltZW91dElELmN1cnJlbnQpIHtcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MjtcblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SUQuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDIgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50Mi5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MztcblxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQzID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudDMuY2FsbChyZWxlYXNlUmVmKTtcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfSwgU1VTUEVOU0VfVElNRU9VVF9NUyQyKTtcbiAgfVxuXG4gIHJldHVybiBzbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gZ290b1NuYXBzaG90KHN0b3JlLCBzbmFwc2hvdCkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHByZXYgPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICBjb25zdCBuZXh0ID0gc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuICBiYXRjaFVwZGF0ZXMkMygoKSA9PiB7XG4gICAgY29uc3Qga2V5c1RvVXBkYXRlID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBrZXlzIG9mIFtwcmV2LmF0b21WYWx1ZXMua2V5cygpLCBuZXh0LmF0b21WYWx1ZXMua2V5cygpXSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICB2YXIgX3ByZXYkYXRvbVZhbHVlcyRnZXQsIF9uZXh0JGF0b21WYWx1ZXMkZ2V0O1xuXG4gICAgICAgIGlmICgoKF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID0gcHJldi5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfcHJldiRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXYkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICE9PSAoKF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID0gbmV4dC5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfbmV4dCRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25leHQkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICYmIGdldE5vZGUkNChrZXkpLnNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzKSB7XG4gICAgICAgICAga2V5c1RvVXBkYXRlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5c1RvVXBkYXRlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHNldFJlY29pbFZhbHVlTG9hZGFibGUkMShzdG9yZSwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkNChrZXkpLCBuZXh0LmF0b21WYWx1ZXMuaGFzKGtleSkgPyBSZWNvaWxfbnVsbHRocm93cyhuZXh0LmF0b21WYWx1ZXMuZ2V0KGtleSkpIDogREVGQVVMVF9WQUxVRSQzKTtcbiAgICB9KTtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4gKHsgLi4uc3RhdGUsXG4gICAgICBzdGF0ZUlEOiBzbmFwc2hvdC5nZXRJRCgpXG4gICAgfSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlR290b1JlY29pbFNuYXBzaG90KCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDIoc25hcHNob3QgPT4gZ290b1NuYXBzaG90KHN0b3JlUmVmLmN1cnJlbnQsIHNuYXBzaG90KSwgW3N0b3JlUmVmXSk7XG59XG5cbnZhciBSZWNvaWxfU25hcHNob3RIb29rcyA9IHtcbiAgdXNlUmVjb2lsU25hcHNob3QsXG4gIGdvdG9TbmFwc2hvdCxcbiAgdXNlR290b1JlY29pbFNuYXBzaG90LFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyLFxuICB1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQsXG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uX0RFUFJFQ0FURUQ6IHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uXG59O1xuXG5jb25zdCB7XG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDRcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuZnVuY3Rpb24gdXNlR2V0UmVjb2lsVmFsdWVJbmZvKCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDQoKTtcbiAgcmV0dXJuICh7XG4gICAga2V5XG4gIH0pID0+IHBlZWtOb2RlSW5mbyQyKHN0b3JlUmVmLmN1cnJlbnQsIHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwga2V5KTtcbn1cblxudmFyIFJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8gPSB1c2VHZXRSZWNvaWxWYWx1ZUluZm87XG5cbmNvbnN0IHtcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkNFxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cbmNvbnN0IHtcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQxLFxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5cblxuY29uc3Qge1xuICB1c2VNZW1vOiB1c2VNZW1vJDJcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cygpIHtcbiAgLy8gVGhlIHRlc3QgZmFpbHMgd2hlbiB1c2luZyB1c2VNdXRhYmxlU291cmNlKCksIGJ1dCBvbmx5IGlmIGFjdCgpIGlzIHVzZWRcbiAgLy8gZm9yIHRoZSBuZXN0ZWQgcm9vdC4gIFNvLCB0aGlzIG1heSBvbmx5IGJlIGEgdGVzdGluZyBlbnZpcm9ubWVudCBpc3N1ZS5cbiAgaWYgKHJlYWN0TW9kZSQ0KCkubW9kZSA9PT0gJ01VVEFCTEVfU09VUkNFJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignV2FybmluZzogVGhlcmUgYXJlIGtub3duIGlzc3VlcyB1c2luZyB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzKCkgaW4gcmVjb2lsX211dGFibGVfc291cmNlIHJlbmRlcmluZyBtb2RlLiAgUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byByZWNvaWxfc3luY19leHRlcm5hbF9zdG9yZSBtb2RlLicpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZVJlZiQ1KCkuY3VycmVudDtcbiAgcmV0dXJuIHVzZU1lbW8kMigoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICAgIGZ1bmN0aW9uIFJlY29pbEJyaWRnZSh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChSZWNvaWxSb290JDEsIHtcbiAgICAgICAgc3RvcmVfSU5URVJOQUw6IHN0b3JlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlY29pbEJyaWRnZTtcbiAgfSwgW3N0b3JlXSk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyA9IHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHM7XG5cbmNvbnN0IHtcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDFcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBpbml0aWFsaXplTm9kZTogaW5pdGlhbGl6ZU5vZGUkM1xufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDQsXG4gIGdldE5vZGU6IGdldE5vZGUkNVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGNvcHlUcmVlU3RhdGU6IGNvcHlUcmVlU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMyxcbiAgaW52YWxpZGF0ZURvd25zdHJlYW1zOiBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSxcbiAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlOiB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuXG5cbmZ1bmN0aW9uIGlzQXRvbShyZWNvaWxWYWx1ZSkge1xuICByZXR1cm4gZ2V0Tm9kZSQ1KHJlY29pbFZhbHVlLmtleSkubm9kZVR5cGUgPT09ICdhdG9tJztcbn1cblxuY2xhc3MgVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsIHtcbiAgY29uc3RydWN0b3Ioc3RvcmUsIHRyZWVTdGF0ZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RyZWVTdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYW5nZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCByZWNvaWxWYWx1ZSA9PiB7XG4gICAgICBpZiAodGhpcy5fY2hhbmdlcy5oYXMocmVjb2lsVmFsdWUua2V5KSkge1xuICAgICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmdldChyZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQXRvbShyZWNvaWxWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignUmVhZGluZyBzZWxlY3RvcnMgd2l0aGluIGF0b21pY1VwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDModGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlLCB0aGlzLl90cmVlU3RhdGUpO1xuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoYEV4cGVjdGVkIFJlY29pbCBhdG9tICR7cmVjb2lsVmFsdWUua2V5fSB0byBoYXZlIGEgdmFsdWUsIGJ1dCBpdCBpcyBpbiBhIGxvYWRpbmcgc3RhdGUuYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlcikgPT4ge1xuICAgICAgaWYgKCFpc0F0b20ocmVjb2lsU3RhdGUpKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NldHRpbmcgc2VsZWN0b3JzIHdpdGhpbiBhdG9taWNVcGRhdGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldChyZWNvaWxTdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlcy5zZXQocmVjb2lsU3RhdGUua2V5LCB2YWx1ZU9yVXBkYXRlcihjdXJyZW50KSk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIGF0b20gYW5kIHJ1biBlZmZlY3RzIGlmIG5vdCBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgaW5pdGlhbGl6ZU5vZGUkMyh0aGlzLl9zdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAnc2V0Jyk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlcy5zZXQocmVjb2lsU3RhdGUua2V5LCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XG4gICAgICB0aGlzLnNldChyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ0KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5fdHJlZVN0YXRlID0gdHJlZVN0YXRlO1xuICAgIHRoaXMuX2NoYW5nZXMgPSBuZXcgTWFwKCk7XG4gIH0gLy8gQWxsb3cgZGVzdHJ1Y3RpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9leHRyYS1hcnJvdy1pbml0aWFsaXplclxuXG5cbiAgbmV3VHJlZVN0YXRlX0lOVEVSTkFMKCkge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmVlU3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3U3RhdGUgPSBjb3B5VHJlZVN0YXRlJDEodGhpcy5fdHJlZVN0YXRlKTtcblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuX2NoYW5nZXMpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZSQxKG5ld1N0YXRlLCBrLCBsb2FkYWJsZVdpdGhWYWx1ZSQxKHYpKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkYXRlRG93bnN0cmVhbXMkMSh0aGlzLl9zdG9yZSwgbmV3U3RhdGUpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGF0b21pY1VwZGF0ZXIoc3RvcmUpIHtcbiAgcmV0dXJuIGZuID0+IHtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodHJlZVN0YXRlID0+IHtcbiAgICAgIGNvbnN0IGNoYW5nZXNldCA9IG5ldyBUcmFuc2FjdGlvbkludGVyZmFjZUltcGwoc3RvcmUsIHRyZWVTdGF0ZSk7XG4gICAgICBmbihjaGFuZ2VzZXQpO1xuICAgICAgcmV0dXJuIGNoYW5nZXNldC5uZXdUcmVlU3RhdGVfSU5URVJOQUwoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzID0ge1xuICBhdG9taWNVcGRhdGVyXG59O1xuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXNfMSA9IFJlY29pbF9BdG9taWNVcGRhdGVzLmF0b21pY1VwZGF0ZXI7XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGF0b21pY1VwZGF0ZXI6IFJlY29pbF9BdG9taWNVcGRhdGVzXzFcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX2ludmFyaWFudCA9IGludmFyaWFudF8xO1xuXG5jb25zdCB7XG4gIGF0b21pY1VwZGF0ZXI6IGF0b21pY1VwZGF0ZXIkMVxufSA9IFJlY29pbF9BdG9taWNVcGRhdGVzJDE7XG5cbmNvbnN0IHtcbiAgYmF0Y2hVcGRhdGVzOiBiYXRjaFVwZGF0ZXMkNFxufSA9IFJlY29pbF9CYXRjaGluZztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkNlxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDEsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIGdvdG9TbmFwc2hvdDogZ290b1NuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skM1xufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgU2VudGluZWwge31cblxuY29uc3QgU0VOVElORUwgPSBuZXcgU2VudGluZWwoKTtcblxuZnVuY3Rpb24gcmVjb2lsQ2FsbGJhY2soc3RvcmUsIGZuLCBhcmdzLCBleHRyYUludGVyZmFjZSkge1xuICBsZXQgcmV0ID0gU0VOVElORUw7XG4gIGxldCByZWxlYXNlU25hcHNob3Q7XG4gIGJhdGNoVXBkYXRlcyQ0KCgpID0+IHtcbiAgICBjb25zdCBlcnJNc2cgPSAndXNlUmVjb2lsQ2FsbGJhY2soKSBleHBlY3RzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb246ICcgKyAnaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIG9mIHRoZSB0eXBlIChSZWNvaWxJbnRlcmZhY2UpID0+IChBcmdzKSA9PiBSZXR1cm5UeXBlICcgKyAnYW5kIHJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbiAoQXJncykgPT4gUmV0dXJuVHlwZSwgd2hlcmUgUmVjb2lsSW50ZXJmYWNlIGlzICcgKyAnYW4gb2JqZWN0IHtzbmFwc2hvdCwgc2V0LCAuLi59IGFuZCBBcmdzIGFuZCBSZXR1cm5UeXBlIGFyZSB0aGUgYXJndW1lbnQgYW5kIHJldHVybiAnICsgJ3R5cGVzIG9mIHRoZSBjYWxsYmFjayB5b3Ugd2FudCB0byBjcmVhdGUuICBQbGVhc2Ugc2VlIHRoZSBkb2NzICcgKyAnYXQgcmVjb2lsanMub3JnIGZvciBkZXRhaWxzLic7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGVyck1zZyk7XG4gICAgfSAvLyBDbG9uZSB0aGUgc25hcHNob3QgbGF6aWx5IHRvIGF2b2lkIG92ZXJoZWFkIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCB1c2UgaXQuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlIHNuYXBzaG90IG1heSByZXByZXNlbnQgbGF0ZXIgc3RhdGUgZnJvbSB3aGVuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHdhcyBjYWxsZWQgaWYgaXQgZmlyc3QgYWNjZXNzZXMgdGhlIHNuYXBzaG90IGFzeW5jaHJvbm91c2x5LlxuXG5cbiAgICBjb25zdCBjYWxsYmFja0ludGVyZmFjZSA9IFJlY29pbF9sYXp5UHJveHkoeyAuLi4oZXh0cmFJbnRlcmZhY2UgIT09IG51bGwgJiYgZXh0cmFJbnRlcmZhY2UgIT09IHZvaWQgMCA/IGV4dHJhSW50ZXJmYWNlIDoge30pLFxuICAgICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICBzZXQ6IChub2RlLCBuZXdWYWx1ZSkgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgbmV3VmFsdWUpLFxuICAgICAgcmVzZXQ6IG5vZGUgPT4gc2V0UmVjb2lsVmFsdWUkMyhzdG9yZSwgbm9kZSwgREVGQVVMVF9WQUxVRSQ1KSxcbiAgICAgIHJlZnJlc2g6IG5vZGUgPT4gcmVmcmVzaFJlY29pbFZhbHVlJDEoc3RvcmUsIG5vZGUpLFxuICAgICAgZ290b1NuYXBzaG90OiBzbmFwc2hvdCA9PiBnb3RvU25hcHNob3QkMShzdG9yZSwgc25hcHNob3QpLFxuICAgICAgdHJhbnNhY3RfVU5TVEFCTEU6IHRyYW5zYWN0aW9uID0+IGF0b21pY1VwZGF0ZXIkMShzdG9yZSkodHJhbnNhY3Rpb24pXG4gICAgfSwge1xuICAgICAgc25hcHNob3Q6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDIoc3RvcmUpO1xuICAgICAgICByZWxlYXNlU25hcHNob3QgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZm4oY2FsbGJhY2tJbnRlcmZhY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9KTtcbiAgISEocmV0IGluc3RhbmNlb2YgU2VudGluZWwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ2JhdGNoVXBkYXRlcyBzaG91bGQgcmV0dXJuIGltbWVkaWF0ZWx5JykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXQpKSB7XG4gICAgcmV0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdmFyIF9yZWxlYXNlU25hcHNob3Q7XG5cbiAgICAgIChfcmVsZWFzZVNuYXBzaG90ID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZWxlYXNlU25hcHNob3QyO1xuXG4gICAgKF9yZWxlYXNlU25hcHNob3QyID0gcmVsZWFzZVNuYXBzaG90KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVNuYXBzaG90MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdDIoKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbENhbGxiYWNrKGZuLCBkZXBzKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMyggLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVjb2lsQ2FsbGJhY2soc3RvcmVSZWYuY3VycmVudCwgZm4sIGFyZ3MpO1xuICB9LCBkZXBzICE9IG51bGwgPyBbLi4uZGVwcywgc3RvcmVSZWZdIDogdW5kZWZpbmVkIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzLWRlcHNcbiAgKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxDYWxsYmFjayA9IHtcbiAgcmVjb2lsQ2FsbGJhY2ssXG4gIHVzZVJlY29pbENhbGxiYWNrXG59O1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ3XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgcmVmcmVzaFJlY29pbFZhbHVlOiByZWZyZXNoUmVjb2lsVmFsdWUkMlxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skNFxufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxSZWZyZXNoZXIocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ3KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQ0KCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgcmVmcmVzaFJlY29pbFZhbHVlJDIoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgfSwgW3JlY29pbFZhbHVlLCBzdG9yZVJlZl0pO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciA9IHVzZVJlY29pbFJlZnJlc2hlcjtcblxuY29uc3Qge1xuICBhdG9taWNVcGRhdGVyOiBhdG9taWNVcGRhdGVyJDJcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ4XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgdXNlTWVtbzogdXNlTWVtbyQzXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFRyYW5zYWN0aW9uKGZuLCBkZXBzKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkOCgpO1xuICByZXR1cm4gdXNlTWVtbyQzKCgpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgYXRvbWljVXBkYXRlID0gYXRvbWljVXBkYXRlciQyKHN0b3JlUmVmLmN1cnJlbnQpO1xuICAgIGF0b21pY1VwZGF0ZSh0cmFuc2FjdGlvbkludGVyZmFjZSA9PiB7XG4gICAgICBmbih0cmFuc2FjdGlvbkludGVyZmFjZSkoLi4uYXJncyk7XG4gICAgfSk7XG4gIH0sIGRlcHMgIT0gbnVsbCA/IFsuLi5kZXBzLCBzdG9yZVJlZl0gOiB1bmRlZmluZWQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICApO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uID0gdXNlUmVjb2lsVHJhbnNhY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFdyYXBwZWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfV3JhcHBlciA9IHtcbiAgV3JhcHBlZFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1dyYXBwZXJfMSA9IFJlY29pbF9XcmFwcGVyLldyYXBwZWRWYWx1ZTtcblxudmFyIFJlY29pbF9XcmFwcGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgV3JhcHBlZFZhbHVlOiBSZWNvaWxfV3JhcHBlcl8xXG59KTtcblxuY29uc3Qge1xuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZDogaXNGYXN0UmVmcmVzaEVuYWJsZWQkMlxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cblxuXG5jbGFzcyBDaGFuZ2VkUGF0aEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgVHJlZUNhY2hlIHtcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkb25IaXQsIF9vcHRpb25zJG9uU2V0LCBfb3B0aW9ucyRtYXBOb2RlVmFsdWU7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX251bUxlYWZzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcm9vdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uSGl0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25TZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBOb2RlVmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX25hbWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fb25IaXQgPSAoX29wdGlvbnMkb25IaXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IaXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uSGl0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvbkhpdCA6ICgpID0+IHt9O1xuICAgIHRoaXMuX29uU2V0ID0gKF9vcHRpb25zJG9uU2V0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uU2V0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRvblNldCAhPT0gdm9pZCAwID8gX29wdGlvbnMkb25TZXQgOiAoKSA9PiB7fTtcbiAgICB0aGlzLl9tYXBOb2RlVmFsdWUgPSAoX29wdGlvbnMkbWFwTm9kZVZhbHVlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcE5vZGVWYWx1ZSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwTm9kZVZhbHVlICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBOb2RlVmFsdWUgOiB2YWwgPT4gdmFsO1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtTGVhZnM7XG4gIH0gLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG5cblxuICByb290KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9XG5cbiAgZ2V0KGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpIHtcbiAgICB2YXIgX3RoaXMkZ2V0TGVhZk5vZGU7XG5cbiAgICByZXR1cm4gKF90aGlzJGdldExlYWZOb2RlID0gdGhpcy5nZXRMZWFmTm9kZShnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0TGVhZk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldExlYWZOb2RlLnZhbHVlO1xuICB9XG5cbiAgZ2V0TGVhZk5vZGUoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykge1xuICAgIGlmICh0aGlzLl9yb290ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBJdGVyYXRlIGRvd24gdGhlIHRyZWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgbm9kZSB2YWx1ZXMgdW50aWwgd2UgaGl0IGEgbGVhZlxuICAgIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5cbiAgICBsZXQgbm9kZSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uTm9kZVZpc2l0KG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09PSAnbGVhZicpIHtcbiAgICAgICAgdGhpcy5fb25IaXQobm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuX21hcE5vZGVWYWx1ZShnZXROb2RlVmFsdWUobm9kZS5ub2RlS2V5KSk7XG5cbiAgICAgIG5vZGUgPSBub2RlLmJyYW5jaGVzLmdldChub2RlVmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQocm91dGUsIHZhbHVlLCBoYW5kbGVycykge1xuICAgIGNvbnN0IGFkZExlYWYgPSAoKSA9PiB7XG4gICAgICB2YXIgX25vZGUyLCBfbm9kZTMsIF90aGlzJF9yb290MiwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MjtcblxuICAgICAgLy8gRmlyc3QsIHNldHVwIHRoZSBicmFuY2ggbm9kZXMgZm9yIHRoZSByb3V0ZTpcbiAgICAgIC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSB0byBmaW5kIG9yIGFkZCBicmFuY2ggbm9kZXMgZm9sbG93aW5nIHRoZSByb3V0ZVxuICAgICAgbGV0IG5vZGU7XG4gICAgICBsZXQgYnJhbmNoS2V5O1xuXG4gICAgICBmb3IgKGNvbnN0IFtub2RlS2V5LCBub2RlVmFsdWVdIG9mIHJvdXRlKSB7XG4gICAgICAgIHZhciBfbm9kZSwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0LCBfdGhpcyRfcm9vdDtcblxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcm9vdCB3YXMgYSBsZWFmLCB3aGlsZSB3ZSBub3QgaGF2ZSBhIGdldCgpLCBpdCBtZWFuc1xuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaGFzIGluY29uc2lzdGVudCB2YWx1ZXMgb3IgaW1wbGVtZW50YXRpb24gY2hhbmdlZC5cbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICAgICAgaWYgKChyb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QudHlwZSkgPT09ICdsZWFmJykge1xuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgICAgfSAvLyBub2RlIG5vdyByZWZlcnMgdG8gdGhlIG5leHQgbm9kZSBkb3duIGluIHRoZSB0cmVlXG5cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICBub2RlID0gcGFyZW50ID8gcGFyZW50LmJyYW5jaGVzLmdldChicmFuY2hLZXkpIDogcm9vdDsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG5cbiAgICAgICAgbm9kZSA9IChfbm9kZSA9IG5vZGUpICE9PSBudWxsICYmIF9ub2RlICE9PSB2b2lkIDAgPyBfbm9kZSA6IHtcbiAgICAgICAgICB0eXBlOiAnYnJhbmNoJyxcbiAgICAgICAgICBub2RlS2V5LFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBicmFuY2hlczogbmV3IE1hcCgpLFxuICAgICAgICAgIGJyYW5jaEtleVxuICAgICAgICB9OyAvLyBJZiB3ZSBmb3VuZCBhbiBleGlzdGluZyBub2RlLCBjb25maXJtIGl0IGhhcyBhIGNvbnNpc3RlbnQgdmFsdWVcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnYnJhbmNoJyB8fCBub2RlLm5vZGVLZXkgIT09IG5vZGVLZXkpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICAgIH0gLy8gQWRkIHRoZSBicmFuY2ggbm9kZSB0byB0aGUgdHJlZVxuXG5cbiAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJyYW5jaGVzLnNldChicmFuY2hLZXksIG5vZGUpO1xuICAgICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9IGhhbmRsZXJzLm9uTm9kZVZpc2l0KSA9PT0gbnVsbCB8fCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdC5jYWxsKGhhbmRsZXJzLCBub2RlKTsgLy8gUHJlcGFyZSBmb3IgbmV4dCBpdGVyYXRpb24gYW5kIGluc3RhbGwgcm9vdCBpZiBpdCBpcyBuZXcuXG5cbiAgICAgICAgYnJhbmNoS2V5ID0gdGhpcy5fbWFwTm9kZVZhbHVlKG5vZGVWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdCAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QgOiBub2RlO1xuICAgICAgfSAvLyBTZWNvbmQsIHNldHVwIHRoZSBsZWFmIG5vZGU6XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBsZWFmIGZvciB0aGlzIHJvdXRlIGNvbmZpcm0gaXQgaXMgY29uc2lzdGVudFxuXG5cbiAgICAgIGNvbnN0IG9sZExlYWYgPSBub2RlID8gKF9ub2RlMiA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUyLmJyYW5jaGVzLmdldChicmFuY2hLZXkpIDogdGhpcy5fcm9vdDtcblxuICAgICAgaWYgKG9sZExlYWYgIT0gbnVsbCAmJiAob2xkTGVhZi50eXBlICE9PSAnbGVhZicgfHwgb2xkTGVhZi5icmFuY2hLZXkgIT09IGJyYW5jaEtleSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgb3IgcmVwbGFjZW1lbnQgbGVhZi5cblxuXG4gICAgICBjb25zdCBsZWFmTm9kZSA9IHtcbiAgICAgICAgdHlwZTogJ2xlYWYnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICBicmFuY2hLZXlcbiAgICAgIH07IC8vIEluc3RhbGwgdGhlIGxlYWYgYW5kIGNhbGwgaGFuZGxlcnNcblxuICAgICAgKF9ub2RlMyA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUzLmJyYW5jaGVzLnNldChicmFuY2hLZXksIGxlYWZOb2RlKTtcbiAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QyID0gdGhpcy5fcm9vdCkgIT09IG51bGwgJiYgX3RoaXMkX3Jvb3QyICE9PSB2b2lkIDAgPyBfdGhpcyRfcm9vdDIgOiBsZWFmTm9kZTtcbiAgICAgIHRoaXMuX251bUxlYWZzKys7XG5cbiAgICAgIHRoaXMuX29uU2V0KGxlYWZOb2RlKTtcblxuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaGFuZGxlcnMkb25Ob2RlVmlzaXQyID0gaGFuZGxlcnMub25Ob2RlVmlzaXQpID09PSBudWxsIHx8IF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdDIuY2FsbChoYW5kbGVycywgbGVhZk5vZGUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYWRkTGVhZigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgY2FjaGUgd2FzIHN0YWxlIG9yIG9ic2VydmVkIGluY29uc2lzdGVudCB2YWx1ZXMsIHN1Y2ggYXMgd2l0aFxuICAgICAgLy8gRmFzdCBSZWZyZXNoLCB0aGVuIGNsZWFyIGl0IGFuZCByZWJ1aWxkIHdpdGggdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDaGFuZ2VkUGF0aEVycm9yKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgYWRkTGVhZigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJldHVybnMgdHJ1ZSBpZiBsZWFmIHdhcyBhY3R1YWxseSBkZWxldGVkIGZyb20gdGhlIHRyZWVcblxuXG4gIGRlbGV0ZShsZWFmKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdCgpO1xuXG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxlYWYgPT09IHJvb3QpIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJdGVyYXRlIHVwIGZyb20gdGhlIGxlYWYgZGVsZXRlaW5nIGl0IGZyb20gaXQncyBwYXJlbnQncyBicmFuY2hlcy5cblxuXG4gICAgbGV0IG5vZGUgPSBsZWFmLnBhcmVudDtcbiAgICBsZXQgYnJhbmNoS2V5ID0gbGVhZi5icmFuY2hLZXk7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgdmFyIF9ub2RlNDtcblxuICAgICAgbm9kZS5icmFuY2hlcy5kZWxldGUoYnJhbmNoS2V5KTsgLy8gU3RvcCBpdGVyYXRpbmcgaWYgd2UgaGl0IHRoZSByb290LlxuXG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX251bUxlYWZzLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gU3RvcCBpdGVyYXRpbmcgaWYgdGhlcmUgYXJlIG90aGVyIGJyYW5jaGVzIHNpbmNlIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZSBhbnkgbW9yZSBub2Rlcy5cblxuXG4gICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSXRlcmF0ZSB1cCB0byBvdXIgcGFyZW50XG5cblxuICAgICAgYnJhbmNoS2V5ID0gKF9ub2RlNCA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGU0LmJyYW5jaEtleTtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9IC8vIENvbmZpcm0gdGhhdCB0aGUgbGVhZiB3ZSBhcmUgZGVsZXRpbmcgaXMgYWN0dWFsbHkgYXR0YWNoZWQgdG8gb3VyIHRyZWVcblxuXG4gICAgZm9yICg7IG5vZGUgIT09IHJvb3Q7IG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbnVtTGVhZnMtLTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgfVxuXG4gIGludmFsaWRDYWNoZUVycm9yKCkge1xuICAgIGNvbnN0IENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFID0gaXNGYXN0UmVmcmVzaEVuYWJsZWQkMigpID8gJ1Bvc3NpYmxlIEZhc3QgUmVmcmVzaCBtb2R1bGUgcmVsb2FkIGRldGVjdGVkLiAgJyArICdUaGlzIG1heSBhbHNvIGJlIGNhdXNlZCBieSBhbiBzZWxlY3RvciByZXR1cm5pbmcgaW5jb25zaXN0ZW50IHZhbHVlcy4gJyArICdSZXNldHRpbmcgY2FjaGUuJyA6ICdJbnZhbGlkIGNhY2hlIHZhbHVlcy4gIFRoaXMgaGFwcGVucyB3aGVuIHNlbGVjdG9ycyBkbyBub3QgcmV0dXJuICcgKyAnY29uc2lzdGVudCB2YWx1ZXMgZm9yIHRoZSBzYW1lIGlucHV0IGRlcGVuZGVuY3kgdmFsdWVzLiAgVGhhdCBtYXkgYWxzbyAnICsgJ2JlIGNhdXNlZCB3aGVuIHVzaW5nIEZhc3QgUmVmcmVzaCB0byBjaGFuZ2UgYSBzZWxlY3RvciBpbXBsZW1lbnRhdGlvbi4gICcgKyAnUmVzZXR0aW5nIGNhY2hlLic7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFICsgKHRoaXMuX25hbWUgIT0gbnVsbCA/IGAgLSAke3RoaXMuX25hbWV9YCA6ICcnKSk7XG4gICAgdGhyb3cgbmV3IENoYW5nZWRQYXRoRXJyb3IoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfVHJlZUNhY2hlID0ge1xuICBUcmVlQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfVHJlZUNhY2hlXzEgPSBSZWNvaWxfVHJlZUNhY2hlLlRyZWVDYWNoZTtcblxudmFyIFJlY29pbF9UcmVlQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBUcmVlQ2FjaGU6IFJlY29pbF9UcmVlQ2FjaGVfMVxufSk7XG5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRtYXBLZXk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWF4U2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NpemVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oZWFkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFpbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleU1hcHBlclwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fa2V5TWFwcGVyID0gKF9vcHRpb25zJG1hcEtleSA9IG9wdGlvbnMubWFwS2V5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBLZXkgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcEtleSA6IHYgPT4gdjtcbiAgfVxuXG4gIGhlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gIH1cblxuICB0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl90YWlsO1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIG1heFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heFNpemU7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IG1hcHBlZEtleSA9IHRoaXMuX2tleU1hcHBlcihrZXkpO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLnNldChrZXksIG5vZGUudmFsdWUpO1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsKSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSB0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSk7XG5cbiAgICBpZiAoZXhpc3RpbmdOb2RlKSB7XG4gICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQoKTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAga2V5LFxuICAgICAgcmlnaHQ6IGhlYWQsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgdmFsdWU6IHZhbFxuICAgIH07XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5sZWZ0ID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwLnNldChtYXBwZWRLZXksIG5vZGUpO1xuXG4gICAgdGhpcy5faGVhZCA9IG5vZGU7XG4gICAgdGhpcy5fc2l6ZSsrO1xuXG4gICAgdGhpcy5fbWF5YmVEZWxldGVMUlUoKTtcbiAgfVxuXG4gIF9tYXliZURlbGV0ZUxSVSgpIHtcbiAgICBpZiAodGhpcy5zaXplKCkgPiB0aGlzLm1heFNpemUoKSkge1xuICAgICAgdGhpcy5kZWxldGVMcnUoKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVMcnUoKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMudGFpbCgpO1xuXG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIHRoaXMuZGVsZXRlKHRhaWwua2V5KTtcbiAgICB9XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBpZiAoIXRoaXMuX3NpemUgfHwgIXRoaXMuX21hcC5oYXMobWFwcGVkS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBSZWNvaWxfbnVsbHRocm93cyh0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSkpO1xuICAgIGNvbnN0IHJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICBjb25zdCBsZWZ0ID0gbm9kZS5sZWZ0O1xuXG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICByaWdodC5sZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChsZWZ0KSB7XG4gICAgICBsZWZ0LnJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKCkpIHtcbiAgICAgIHRoaXMuX2hlYWQgPSByaWdodDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKCkpIHtcbiAgICAgIHRoaXMuX3RhaWwgPSBsZWZ0O1xuICAgIH1cblxuICAgIHRoaXMuX21hcC5kZWxldGUobWFwcGVkS2V5KTtcblxuICAgIHRoaXMuX3NpemUtLTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGUgPSB7XG4gIExSVUNhY2hlXG59O1xuXG52YXIgUmVjb2lsX0xSVUNhY2hlXzEgPSBSZWNvaWxfTFJVQ2FjaGUuTFJVQ2FjaGU7XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBMUlVDYWNoZTogUmVjb2lsX0xSVUNhY2hlXzFcbn0pO1xuXG5jb25zdCB7XG4gIExSVUNhY2hlOiBMUlVDYWNoZSQxXG59ID0gUmVjb2lsX0xSVUNhY2hlJDE7XG5cbmNvbnN0IHtcbiAgVHJlZUNhY2hlOiBUcmVlQ2FjaGUkMVxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcblxuZnVuY3Rpb24gdHJlZUNhY2hlTFJVKHtcbiAgbmFtZSxcbiAgbWF4U2l6ZSxcbiAgbWFwTm9kZVZhbHVlID0gdiA9PiB2XG59KSB7XG4gIGNvbnN0IGxydUNhY2hlID0gbmV3IExSVUNhY2hlJDEoe1xuICAgIG1heFNpemVcbiAgfSk7XG4gIGNvbnN0IGNhY2hlID0gbmV3IFRyZWVDYWNoZSQxKHtcbiAgICBuYW1lLFxuICAgIG1hcE5vZGVWYWx1ZSxcbiAgICBvbkhpdDogbm9kZSA9PiB7XG4gICAgICBscnVDYWNoZS5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBvblNldDogbm9kZSA9PiB7XG4gICAgICBjb25zdCBscnVOb2RlID0gbHJ1Q2FjaGUudGFpbCgpO1xuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xuXG4gICAgICBpZiAobHJ1Tm9kZSAmJiBjYWNoZS5zaXplKCkgPiBtYXhTaXplKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShscnVOb2RlLmtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuXG52YXIgUmVjb2lsX3RyZWVDYWNoZUxSVSA9IHRyZWVDYWNoZUxSVTtcblxuY29uc3QgVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUyA9IDE1O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkoeCwgb3B0LCBrZXkpIHtcbiAgLy8gQSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIG1vcmUgZXhwZW5zaXZlIEpTT04uc3RyaW5naWZ5KCkgZm9yIHNpbXBsZSBzdHJpbmdzXG4gIC8vIFRoaXMgbWF5IGxvc2UgcHJvdGVjdGlvbiBmb3IgdTIwMjggYW5kIHUyMDI5LCB0aG91Z2guXG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgIXguaW5jbHVkZXMoJ1wiJykgJiYgIXguaW5jbHVkZXMoJ1xcXFwnKSkge1xuICAgIHJldHVybiBgXCIke3h9XCJgO1xuICB9IC8vIEhhbmRsZSBwcmltaXRpdmUgdHlwZXNcblxuXG4gIHN3aXRjaCAodHlwZW9mIHgpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIC8vIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQsIGJ1dCB3ZSBhbHdheXMgd2FudCB0byByZXR1cm4gYSBzdHJpbmdcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHggPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgLy8gY2FzZSAnYmlnaW50JzogLy8gQmlnSW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gd3d3XG4gICAgICByZXR1cm4gU3RyaW5nKHgpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIEFkZCBzdXJyb3VuZGluZyBxdW90ZXMgYW5kIGVzY2FwZSBpbnRlcm5hbCBxdW90ZXNcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmFsbG93RnVuY3Rpb25zKSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdBdHRlbXB0IHRvIHNlcmlhbGl6ZSBmdW5jdGlvbiBpbiBhIFJlY29pbCBjYWNoZSBrZXknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBfX0ZVTkNUSU9OKCR7eC5uYW1lfSlfX2A7XG4gIH1cblxuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gLy8gRmFsbGJhY2sgY2FzZSBmb3IgdW5rbm93biB0eXBlc1xuXG5cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgIHZhciBfSlNPTiRzdHJpbmdpZnk7XG5cbiAgICByZXR1cm4gKF9KU09OJHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5KHgpKSAhPT0gbnVsbCAmJiBfSlNPTiRzdHJpbmdpZnkgIT09IHZvaWQgMCA/IF9KU09OJHN0cmluZ2lmeSA6ICcnO1xuICB9IC8vIERlYWwgd2l0aCBhbGwgcHJvbWlzZXMgYXMgZXF1aXZhbGVudCBmb3Igbm93LlxuXG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UoeCkpIHtcbiAgICByZXR1cm4gJ19fUFJPTUlTRV9fJztcbiAgfSAvLyBBcnJheXMgaGFuZGxlIHJlY3Vyc2l2ZSBzdHJpbmdpZmljYXRpb25cblxuXG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIGBbJHt4Lm1hcCgodiwgaSkgPT4gc3RyaW5naWZ5KHYsIG9wdCwgaS50b1N0cmluZygpKSl9XWA7XG4gIH0gLy8gSWYgYW4gb2JqZWN0IGRlZmluZXMgYSB0b0pTT04oKSBtZXRob2QsIHRoZW4gdXNlIHRoYXQgdG8gb3ZlcnJpZGUgdGhlXG4gIC8vIHNlcmlhbGl6YXRpb24uICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIEpTT04uc3RyaW5naWZ5KCkuXG4gIC8vIFBhc3MgdGhlIGtleSBmb3IgY29tcGF0aWJpbGl0eS5cbiAgLy8gSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zIGRlZmluZSB0aGlzIG1ldGhvZCB0byBhbGxvdyB1cyB0byBzZXJpYWxpemUgdGhlbS5cblxuXG4gIGlmICh0eXBlb2YgeC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgICByZXR1cm4gc3RyaW5naWZ5KHgudG9KU09OKGtleSksIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYnVpbHQtaW4gTWFwcywgc29ydCB0aGUga2V5cyBpbiBhIHN0YWJsZSBvcmRlciBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkZWZhdWx0IGluc2VydGlvbiBvcmRlci4gIFN1cHBvcnQgbm9uLXN0cmluZyBrZXlzLlxuXG5cbiAgaWYgKHggaW5zdGFuY2VvZiBNYXApIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHgpIHtcbiAgICAgIC8vIFN0cmluZ2lmeSB3aWxsIGVzY2FwZSBhbnkgbmVzdGVkIHF1b3Rlc1xuICAgICAgb2JqW3R5cGVvZiBrID09PSAnc3RyaW5nJyA/IGsgOiBzdHJpbmdpZnkoaywgb3B0KV0gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkob2JqLCBvcHQsIGtleSk7XG4gIH0gLy8gRm9yIGJ1aWx0LWluIFNldHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIgaW5zdGVhZCBvZiB0aGVcbiAgLy8gZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuXG5cblxuICBpZiAoeCBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiBzdHJpbmdpZnkoQXJyYXkuZnJvbSh4KS5zb3J0KChhLCBiKSA9PiBzdHJpbmdpZnkoYSwgb3B0KS5sb2NhbGVDb21wYXJlKHN0cmluZ2lmeShiLCBvcHQpKSksIG9wdCwga2V5KTtcbiAgfSAvLyBBbnl0aGluZyBlbHNlIHRoYXQgaXMgaXRlcmFibGUgc2VyaWFsaXplIGFzIGFuIEFycmF5LlxuXG5cbiAgaWYgKFN5bWJvbCAhPT0gdW5kZWZpbmVkICYmIHhbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgICByZXR1cm4gc3RyaW5naWZ5KEFycmF5LmZyb20oeCksIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYWxsIG90aGVyIE9iamVjdHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIuXG5cblxuICByZXR1cm4gYHske09iamVjdC5rZXlzKHgpLmZpbHRlcihrID0+IHhba10gIT09IHVuZGVmaW5lZCkuc29ydCgpIC8vIHN0cmluZ2lmeSB0aGUga2V5IHRvIGFkZCBxdW90ZXMgYW5kIGVzY2FwZSBhbnkgbmVzdGVkIHNsYXNoZXMgb3IgcXVvdGVzLlxuICAubWFwKGsgPT4gYCR7c3RyaW5naWZ5KGssIG9wdCl9OiR7c3RyaW5naWZ5KHhba10sIG9wdCwgayl9YCkuam9pbignLCcpfX1gO1xufSAvLyBVdGlsaXR5IHNpbWlsYXIgdG8gSlNPTi5zdHJpbmdpZnkoKSBleGNlcHQ6XG4vLyAqIFNlcmlhbGl6ZSBidWlsdC1pbiBTZXRzIGFzIGFuIEFycmF5XG4vLyAqIFNlcmlhbGl6ZSBidWlsdC1pbiBNYXBzIGFzIGFuIE9iamVjdC4gIFN1cHBvcnRzIG5vbi1zdHJpbmcga2V5cy5cbi8vICogU2VyaWFsaXplIG90aGVyIGl0ZXJhYmxlcyBhcyBhcnJheXNcbi8vICogU29ydCB0aGUga2V5cyBvZiBPYmplY3RzIGFuZCBNYXBzIHRvIGhhdmUgYSBzdGFibGUgb3JkZXIgYmFzZWQgb24gc3RyaW5nIGNvbnZlcnNpb24uXG4vLyAgICBUaGlzIG92ZXJyaWRlcyB0aGVpciBkZWZhdWx0IGluc2VydGlvbiBvcmRlci5cbi8vICogU3RpbGwgdXNlcyB0b0pTT04oKSBvZiBhbnkgb2JqZWN0IHRvIG92ZXJyaWRlIHNlcmlhbGl6YXRpb25cbi8vICogU3VwcG9ydCBTeW1ib2xzICh0aG91Z2ggZG9uJ3QgZ3VhcmFudGVlIHVuaXF1ZW5lc3MpXG4vLyAqIFdlIGNvdWxkIHN1cHBvcnQgQmlnSW50LCBidXQgRmxvdyBkb2Vzbid0IHNlZW0gdG8gbGlrZSBpdC5cbi8vIFNlZSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5LXRlc3QuanMgZm9yIGV4YW1wbGVzXG5cblxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHgsIG9wdCA9IHtcbiAgYWxsb3dGdW5jdGlvbnM6IGZhbHNlXG59KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XG4gICAgICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoeCwgb3B0KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAwO1xuXG4gICAgICBpZiAoZW5kVGltZSAtIHN0YXJ0VGltZSA+IFRJTUVfV0FSTklOR19USFJFU0hPTERfTVMpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L25vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgUmVjb2lsOiBTcGVudCAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXMgY29tcHV0aW5nIGEgY2FjaGUga2V5YCk7XG4gICAgICAgIGNvbnNvbGUud2Fybih4LCBzdHIpO1xuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgZmItd3d3L25vLWNvbnNvbGUgKi9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHgsIG9wdCk7XG59XG5cbnZhciBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5ID0gc3RhYmxlU3RyaW5naWZ5O1xuXG5jb25zdCB7XG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDJcbn0gPSBSZWNvaWxfVHJlZUNhY2hlJDE7XG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBkZWZhdWx0UG9saWN5ID0ge1xuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gIGV2aWN0aW9uOiAna2VlcC1hbGwnLFxuICBtYXhTaXplOiBJbmZpbml0eVxufTtcblxuZnVuY3Rpb24gdHJlZUNhY2hlRnJvbVBvbGljeSh7XG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeS5lcXVhbGl0eSxcbiAgZXZpY3Rpb24gPSBkZWZhdWx0UG9saWN5LmV2aWN0aW9uLFxuICBtYXhTaXplID0gZGVmYXVsdFBvbGljeS5tYXhTaXplXG59ID0gZGVmYXVsdFBvbGljeSwgbmFtZSkge1xuICBjb25zdCB2YWx1ZU1hcHBlciA9IGdldFZhbHVlTWFwcGVyKGVxdWFsaXR5KTtcbiAgcmV0dXJuIGdldFRyZWVDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgdmFsdWVNYXBwZXIsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU1hcHBlcihlcXVhbGl0eSkge1xuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XG4gICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xuXG4gICAgY2FzZSAndmFsdWUnOlxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgbWFwTm9kZVZhbHVlLCBuYW1lKSB7XG4gIHN3aXRjaCAoZXZpY3Rpb24pIHtcbiAgICBjYXNlICdrZWVwLWFsbCc6XG4gICAgICByZXR1cm4gbmV3IFRyZWVDYWNoZSQyKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWFwTm9kZVZhbHVlXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gUmVjb2lsX3RyZWVDYWNoZUxSVSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbW9zdC1yZWNlbnQnOlxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXhTaXplOiAxLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGV2aWN0aW9uIHBvbGljeSAke2V2aWN0aW9ufWApO1xufVxuXG52YXIgUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3kgPSB0cmVlQ2FjaGVGcm9tUG9saWN5O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBfb3duZXJEb2N1bWVudCwgX2RvYyRkZWZhdWx0VmlldztcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBkb2MgPSBvYmplY3QgIT0gbnVsbCA/IChfb3duZXJEb2N1bWVudCA9IG9iamVjdC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwID8gX293bmVyRG9jdW1lbnQgOiBvYmplY3QgOiBkb2N1bWVudDtcbiAgY29uc3QgZGVmYXVsdFZpZXcgPSAoX2RvYyRkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldykgIT09IG51bGwgJiYgX2RvYyRkZWZhdWx0VmlldyAhPT0gdm9pZCAwID8gX2RvYyRkZWZhdWx0VmlldyA6IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAhPSBudWxsICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG52YXIgUmVjb2lsX2lzTm9kZSA9IGlzTm9kZTtcblxuY29uc3Qge1xuICBpc1JlYWN0TmF0aXZlOiBpc1JlYWN0TmF0aXZlJDEsXG4gIGlzV2luZG93OiBpc1dpbmRvdyQxXG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xuXG5cblxuXG5cbmZ1bmN0aW9uIHNob3VsZE5vdEJlRnJvemVuKHZhbHVlKSB7XG4gIC8vIFByaW1pdGl2ZXMgYW5kIGZ1bmN0aW9uczpcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBSZWFjdCBlbGVtZW50czpcblxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEltbXV0YWJsZSBzdHJ1Y3R1cmVzOlxuXG5cbiAgaWYgKHZhbHVlWydAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX1JFQ09SRF9fQEAnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gRE9NIG5vZGVzOlxuXG5cbiAgaWYgKFJlY29pbF9pc05vZGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFNvbWUgZW52aXJvbm1lbnRzLCBqdXN0IGFzIEplc3QsIGRvbid0IHdvcmsgd2l0aCB0aGUgaW5zdGFuY2VvZiBjaGVja1xuXG5cbiAgaWYgKCFpc1JlYWN0TmF0aXZlJDEgJiYgaXNXaW5kb3ckMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gUmVjdXJzaXZlbHkgZnJlZXplIGEgdmFsdWUgdG8gZW5mb3JjZSBpdCBpcyByZWFkLW9ubHkuXG4vLyBUaGlzIG1heSBhbHNvIGhhdmUgbWluaW1hbCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMgZm9yIGVudW1lcmF0aW5nXG4vLyBvYmplY3RzIChiYXNlZCBvbiBicm93c2VyIGltcGxlbWVudGF0aW9ucywgb2YgY291cnNlKVxuXG5cbmZ1bmN0aW9uIGRlZXBGcmVlemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCBzaG91bGROb3RCZUZyb3plbih2YWx1ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZnJlZXplKHZhbHVlKTsgLy8gTWFrZSBhbGwgcHJvcGVydGllcyByZWFkLW9ubHlcblxuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIC8vICRGbG93SXNzdWVbbWV0aG9kLXVuYmluZGluZ10gYWRkZWQgd2hlbiBpbXByb3ZpbmcgdHlwaW5nIGZvciB0aGlzIHBhcmFtZXRlcnNcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICBjb25zdCBwcm9wID0gdmFsdWVba2V5XTsgLy8gUHJldmVudCBpbmZpbml0ZSByZWN1cnNzaW9uIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLlxuXG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmIHByb3AgIT0gbnVsbCAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgIGRlZXBGcmVlemVWYWx1ZShwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBPYmplY3Quc2VhbCh2YWx1ZSk7IC8vIFRoaXMgYWxzbyBtYWtlcyBleGlzdGluZyBwcm9wZXJ0aWVzIG5vbi1jb25maWd1cmFibGUuXG59XG5cbnZhciBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlID0gZGVlcEZyZWV6ZVZhbHVlO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFRoaXMgaXMgYSBzdHViIGZvciBzb21lIGludGVncmF0aW9uIGludG8gRkIgaW50ZXJuYWwgc3R1ZmZcbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0UGVyZkJsb2NrKF9pZCkge1xuICByZXR1cm4gKCkgPT4gbnVsbDtcbn1cblxudmFyIFJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3MgPSB7XG4gIHN0YXJ0UGVyZkJsb2NrXG59O1xuXG5jb25zdCB7XG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMSxcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDEsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMSxcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDJcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBXcmFwcGVkVmFsdWU6IFdyYXBwZWRWYWx1ZSQxXG59ID0gUmVjb2lsX1dyYXBwZXIkMTtcblxuXG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMixcbiAgcGVla05vZGVMb2FkYWJsZTogcGVla05vZGVMb2FkYWJsZSQxLFxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIHNhdmVEZXBzVG9TdG9yZTogc2F2ZURlcHNUb1N0b3JlJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ2LFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxLFxuICBnZXROb2RlOiBnZXROb2RlJDYsXG4gIHJlZ2lzdGVyTm9kZTogcmVnaXN0ZXJOb2RlJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDNcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZDogbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQ6IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICByZWNvaWxDYWxsYmFjazogcmVjb2lsQ2FsbGJhY2skMVxufSA9IFJlY29pbF91c2VSZWNvaWxDYWxsYmFjaztcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBzdGFydFBlcmZCbG9jazogc3RhcnRQZXJmQmxvY2skMVxufSA9IFJlY29pbF9QZXJmb3JtYW5jZVRpbWluZ3M7XG5cblxuXG5jbGFzcyBDYW5jZWxlZCB7fVxuXG5jb25zdCBDQU5DRUxFRCA9IG5ldyBDYW5jZWxlZCgpO1xuLyoqXG4gKiBBbiBFeGVjdXRpb25JRCBpcyBhbiBhcmJpdHJhcnkgSUQgdGhhdCBsZXRzIHVzIGRpc3Rpbmd1aXNoIGV4ZWN1dGlvbnMgZnJvbVxuICogZWFjaCBvdGhlci4gVGhpcyBpcyBuZWNlc3NhcnkgYXMgd2UgbmVlZCBhIHdheSBvZiBzb2x2aW5nIHRoaXMgcHJvYmxlbTpcbiAqIFwiZ2l2ZW4gMyBhc3luYyBleGVjdXRpb25zLCBvbmx5IHVwZGF0ZSBzdGF0ZSBmb3IgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbiB3aGVuXG4gKiBpdCBmaW5pc2hlcyBydW5uaW5nIHJlZ2FyZGxlc3Mgb2Ygd2hlbiB0aGUgb3RoZXIgMiBmaW5pc2hcIi4gRXhlY3V0aW9uSURzXG4gKiBwcm92aWRlIGEgY29udmVuaWVudCB3YXkgb2YgaWRlbnRpZnlpbmcgZXhlY3V0aW9ucyBzbyB0aGF0IHdlIGNhbiB0cmFjayBhbmRcbiAqIG1hbmFnZSB0aGVtIG92ZXIgdGltZS5cbiAqL1xuXG5jb25zdCBkZXBlbmRlbmN5U3RhY2sgPSBbXTsgLy8gZm9yIGRldGVjdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5cbmNvbnN0IHdhaXRpbmdTdG9yZXMgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGdldE5ld0V4ZWN1dGlvbklEID0gKCgpID0+IHtcbiAgbGV0IGV4ZWN1dGlvbklEID0gMDtcbiAgcmV0dXJuICgpID0+IGV4ZWN1dGlvbklEKys7XG59KSgpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cblxuZnVuY3Rpb24gc2VsZWN0b3Iob3B0aW9ucykge1xuICBsZXQgcmVjb2lsVmFsdWUgPSBudWxsO1xuICBjb25zdCB7XG4gICAga2V5LFxuICAgIGdldCxcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRTogY2FjaGVQb2xpY3lcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0ICE9IG51bGwgPyBvcHRpb25zLnNldCA6IHVuZGVmaW5lZDsgLy8gZmxvd1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0Ega2V5IG9wdGlvbiB3aXRoIGEgdW5pcXVlIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYSBzZWxlY3Rvci4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycignU2VsZWN0b3JzIG11c3Qgc3BlY2lmeSBhIGdldCBjYWxsYmFjayBvcHRpb24gdG8gZ2V0IHRoZSBzZWxlY3RvciB2YWx1ZS4nKTtcbiAgICB9XG4gIH0gLy8gVGhpcyBpcyBldmVyeSBkaXNjb3ZlcmVkIGRlcGVuZGVuY3kgYWNyb3NzIGFsbCBleGVjdXRpb25zXG5cblxuICBjb25zdCBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzID0gbmV3IFNldCgpO1xuICBjb25zdCBjYWNoZSA9IFJlY29pbF90cmVlQ2FjaGVGcm9tUG9saWN5KGNhY2hlUG9saWN5ICE9PSBudWxsICYmIGNhY2hlUG9saWN5ICE9PSB2b2lkIDAgPyBjYWNoZVBvbGljeSA6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSwga2V5KTtcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XG4gIGNvbnN0IGV4ZWN1dGlvbkluZm9NYXAgPSBuZXcgTWFwKCk7XG4gIGxldCBsaXZlU3RvcmVzQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySXNMaXZlKCkge1xuICAgIHJldHVybiAhUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSB8fCBsaXZlU3RvcmVzQ291bnQgPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JJbml0KHN0b3JlKSB7XG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5hZGQoa2V5KTtcbiAgICBsaXZlU3RvcmVzQ291bnQrKztcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGl2ZVN0b3Jlc0NvdW50LS07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlKCkge1xuICAgIHJldHVybiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShrZXkpICE9PSB1bmRlZmluZWQgJiYgIXNlbGVjdG9ySXNMaXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcykge1xuICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICB9XG5cbiAgICBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogTm90aWZ5IHN0b3JlcyB0byBwdWxsIHRoZSBzZWxlY3RvciBhZ2FpbiBpZiBhIG5ldyBhc3luYyBkZXAgd2FzIGRpc2NvdmVyZWQuXG4gICAqIDEpIEFzeW5jIHNlbGVjdG9yIGFkZHMgYSBuZXcgZGVwIGJ1dCBkb2Vzbid0IHJlc29sdmUgeWV0LlxuICAgKiAgICBOb3RlIHRoYXQgZGVwcyBmb3IgYW4gYXN5bmMgc2VsZWN0b3IgYXJlIGJhc2VkIG9uIHRoZSBzdGF0ZSB3aGVuIHRoZVxuICAgKiAgICBldmFsdWF0aW9uIHN0YXJ0ZWQsIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb25zaXN0ZW50IHBpY3R1cmUgb2Ygc3RhdGUuXG4gICAqIDIpIEJ1dCwgbmV3IHZhbHVlIG9mIGRlcCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBtaWdodCBjYXVzZSB0aGUgc2VsZWN0b3JcbiAgICogICAgdG8gcmVzb2x2ZSBvciByZXNvbHZlIGRpZmZlcmVudGx5LlxuICAgKiAzKSBUaGVyZWZvcmUsIHRoaXMgbm90aWZpY2F0aW9uIHdpbGwgcHVsbCB0aGUgc2VsZWN0b3IgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICogICAgc3RhdGUgZm9yIHRoZSBjb21wb25lbnRzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcChzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IFJlY29pbF9udWxsdGhyb3dzKGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKTtcbiAgICAgIGV4ZWN1dGlvbkluZm8uc3RhdGVWZXJzaW9ucy5jbGVhcigpO1xuICAgICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIGNsZWFyV2FpdGxpc3QpIHtcbiAgICBjb25zdCBzdG9yZXMgPSB3YWl0aW5nU3RvcmVzLmdldChleGVjdXRpb25JRCk7XG5cbiAgICBpZiAoc3RvcmVzICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qgd2FpdGluZ1N0b3JlIG9mIHN0b3Jlcykge1xuICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHdhaXRpbmdTdG9yZSwgUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsZWFyV2FpdGxpc3QpIHtcbiAgICAgICAgd2FpdGluZ1N0b3Jlcy5kZWxldGUoZXhlY3V0aW9uSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIGxldCBzdG9yZXMgPSB3YWl0aW5nU3RvcmVzLmdldChleGVjdXRpb25JRCk7XG5cbiAgICBpZiAoc3RvcmVzID09IG51bGwpIHtcbiAgICAgIHdhaXRpbmdTdG9yZXMuc2V0KGV4ZWN1dGlvbklELCBzdG9yZXMgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIHN0b3Jlcy5hZGQoc3RvcmUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGF0dGFjaGVzIGEgdGhlbigpIGFuZCBhIGNhdGNoKCkgdG8gYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHJldHVybmVkIGZyb20gYSBzZWxlY3RvcidzIGdldCgpIChlaXRoZXIgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IGJ5XG4gICAqIHJ1bm5pbmcgYSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIFwiYXN5bmNcIiBrZXl3b3JkKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpXG4gICAqIHJldHVybnMgYSBwcm9taXNlLCB3ZSBoYXZlIHR3byBwb3NzaWJpbGl0aWVzOlxuICAgKlxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBoYXZlIGNvbXBsZXRlbHkgZmluaXNoZWRcbiAgICogICAgZXhlY3V0aW5nIHdpdGhvdXQgYW55IHJlbWFpbmluZyBwZW5kaW5nIGRlcGVuZGVuY2llcy4gTm8gbW9yZSByZXRyaWVzXG4gICAqICAgIGFyZSBuZWVkZWQgYW5kIHdlIGNhbiBwcm9jZWVkIHdpdGggdXBkYXRpbmcgdGhlIGNhY2hlIGFuZCBub3RpZnlpbmdcbiAgICogICAgc3Vic2NyaWJlcnMgKGlmIGl0IGlzIHRoZSBsYXRlc3QgZXhlY3V0aW9uLCBvdGhlcndpc2Ugb25seSB0aGUgY2FjaGVcbiAgICogICAgd2lsbCBiZSB1cGRhdGVkIGFuZCBzdWJzY3JpcHRpb25zIHdpbGwgbm90IGJlIGZpcmVkKS4gVGhpcyBpcyB0aGUgY2FzZVxuICAgKiAgICBoYW5kbGVkIGJ5IHRoZSBhdHRhY2hlZCB0aGVuKCkgaGFuZGxlci5cbiAgICpcbiAgICogMi4gVGhlIHByb21pc2Ugd2lsbCB0aHJvdyBiZWNhdXNlIGl0IGVpdGhlciBoYXMgYW4gZXJyb3Igb3IgaXQgY2FtZSBhY3Jvc3NcbiAgICogICAgYW4gYXN5bmMgZGVwZW5kZW5jeSB0aGF0IGhhcyBub3QgeWV0IHJlc29sdmVkLCBpbiB3aGljaCBjYXNlIHdlIHdpbGxcbiAgICogICAgY2FsbCB3cmFwRGVwZGVuY3lQcm9taXNlKCksIHdob3NlIHJlc3BvbnNpYmlsaXR5IGlzIHRvIGhhbmRsZSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2VzLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgY2F0Y2goKSBoYW5kbGVyLlxuICAgKlxuICAgKiBCb3RoIGJyYW5jaGVzIHdpbGwgZXZlbnR1YWxseSByZXNvbHZlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2YgdGhlIHNlbGVjdG9yXG4gICAqIChvciBhbiBlcnJvciBpZiBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLlxuICAgKlxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcbiAgICogZXhlY3V0aW9uSW5mbyBhcyB0aGF0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHRocm93bi0tQUtBIGFcbiAgICogZGVwZW5kZW5jeSBwcm9taXNlLiBEZXBlbmRlbmN5IHByb21pc2VzIHNob3VsZCBiZSBwYXNzZWQgdG9cbiAgICogd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZSgpKS5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwUmVzdWx0UHJvbWlzZShzdG9yZSwgcHJvbWlzZSwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQyKHZhbHVlKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KS5jYXRjaChlcnJvck9yUHJvbWlzZSA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGVycm9yT3JQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgZXJyb3JPclByb21pc2UsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKGVycm9yT3JQcm9taXNlKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzKTtcbiAgICAgIHRocm93IGVycm9yT3JQcm9taXNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGF0dGFjaGVzIGEgdGhlbigpIGFuZCBhIGNhdGNoKCkgdG8gYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHRocm93biBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKS4gSWYgYSBzZWxlY3RvcidzIGdldCgpIHRocm93cyBhIHByb21pc2UsXG4gICAqIHdlIGhhdmUgdHdvIHBvc3NpYmlsaXRpZXM6XG4gICAqXG4gICAqIDEuIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgbWVhbmluZyBvbmUgb2Ygb3VyIHNlbGVjdG9yJ3MgZGVwZW5kZW5jaWVzIGlzXG4gICAqICAgIG5vdyBhdmFpbGFibGUgYW5kIHdlIHNob3VsZCBcInJldHJ5XCIgb3VyIGdldCgpIGJ5IHJ1bm5pbmcgaXQgYWdhaW4uIFRoaXNcbiAgICogICAgaXMgdGhlIGNhc2UgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXG4gICAqXG4gICAqIDIuIFRoZSBwcm9taXNlIHdpbGwgdGhyb3cgYmVjYXVzZSBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2UgKGluIG90aGVyIHdvcmRzIGEgcmVhbCBlcnJvciBvY2N1cnJlZCkuIFRoaXMgY2FzZSBpcyBoYW5kbGVkIGJ5XG4gICAqICAgIHRoZSBhdHRhY2hlZCBjYXRjaCgpIGhhbmRsZXIuIElmIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgdGhyb3dzLCBpdCBpc1xuICAgKiAgICBfYWx3YXlzXyBhIHJlYWwgZXJyb3IgYW5kIG5vdCBhbm90aGVyIGRlcGVuZGVuY3kgcHJvbWlzZSAoYW55IGRlcGVuZGVuY3lcbiAgICogICAgcHJvbWlzZXMgd291bGQgaGF2ZSBiZWVuIGhhbmRsZWQgdXBzdHJlYW0pLlxuICAgKlxuICAgKiBUaGUgdGhlbigpIGJyYW5jaCB3aWxsIGV2ZW50dWFsbHkgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZVxuICAgKiBzZWxlY3RvciAob3IgYW4gZXJyb3IgaWYgYSByZWFsIGVycm9yIG9jY3VycyksIGFuZCB0aGUgY2F0Y2goKSB3aWxsIGFsd2F5c1xuICAgKiByZXNvbHZlIHRvIGFuIGVycm9yIGJlY2F1c2UgdGhlIGRlcGVuZGVuY3kgcHJvbWlzZSBpcyBhIHByb21pc2UgdGhhdCB3YXNcbiAgICogd3JhcHBlZCB1cHN0cmVhbSwgbWVhbmluZyBpdCB3aWxsIG9ubHkgcmVzb2x2ZSB0byBpdHMgcmVhbCB2YWx1ZSBvciB0byBhXG4gICAqIHJlYWwgZXJyb3IuXG4gICAqXG4gICAqIFRoZSBleGVjdXRpb24gd2lsbCBydW4gdG8gY29tcGxldGlvbiBldmVuIGlmIGl0IGlzIHN0YWxlLCBhbmQgaXRzIHZhbHVlXG4gICAqIHdpbGwgYmUgY2FjaGVkLiBCdXQgc3RhbGUgZXhlY3V0aW9ucyB3aWxsIG5vdCB1cGRhdGUgZ2xvYmFsIHN0YXRlIG9yIHVwZGF0ZVxuICAgKiBleGVjdXRpb25JbmZvIGFzIHRoYXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHBhc3NlZCBhIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbVxuICAgKiBnZXQoKS4gVGhlIGludGVudGlvbiBpcyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBwYXNzZWQgcHJvbWlzZXMgdGhhdFxuICAgKiB3ZXJlIHRocm93biBkdWUgdG8gYSBwZW5kaW5nIGRlcGVuZGVuY3kuIFByb21pc2VzIHJldHVybmVkIGJ5IGdldCgpIHNob3VsZFxuICAgKiBiZSBwYXNzZWQgdG8gd3JhcFJlc3VsdFByb21pc2UoKSBpbnN0ZWFkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBleGlzdGluZ0RlcHMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlZERlcCA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBoYW5kbGluZyBhIHBlbmRpbmcgUmVjb2lsIGRlcGVuZGVuY3kgb3IgaWYgdGhlIHVzZXJcbiAgICAgIC8vIHRocmV3IHRoZWlyIG93biBQcm9taXNlIHRvIFwic3VzcGVuZFwiIGEgc2VsZWN0b3IgZXZhbHVhdGlvbi4gIFdlIG5lZWRcbiAgICAgIC8vIHRvIGNoZWNrIHRoYXQgdGhlIGxvYWRpbmdEZXBQcm9taXNlIGFjdHVhbGx5IG1hdGNoZXMgdGhlIHByb21pc2UgdGhhdFxuICAgICAgLy8gd2UgY2F1Z2h0IGluIGNhc2UgdGhlIHNlbGVjdG9yIGhhcHBlbmVkIHRvIGNhdGNoIHRoZSBwcm9taXNlIHdlIHRocmV3XG4gICAgICAvLyBmb3IgYSBwZW5kaW5nIFJlY29pbCBkZXBlbmRlbmN5IGZyb20gYGdldFJlY29pbFZhbHVlKClgIGFuZCB0aHJld1xuICAgICAgLy8gdGhlaXIgb3duIHByb21pc2UgaW5zdGVhZC5cblxuXG4gICAgICBpZiAobG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5ICE9IG51bGwgJiYgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwUHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZSBmb3IgYXN5bmMgYXRvbXMsIHRoaXMgbWVhbnMgd2UgYXJlIGNoYW5naW5nIHRoZSBhdG9tJ3MgdmFsdWVcbiAgICAgICAgICogaW4gdGhlIHN0b3JlIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi4gVGhpcyBzaG91bGQgYmUgYWxyaWdodCBiZWNhdXNlXG4gICAgICAgICAqIHRoZSB2ZXJzaW9uIG9mIHN0YXRlIGlzIG5vdyBzdGFsZSBhbmQgYSBuZXcgdmVyc2lvbiB3aWxsIGhhdmVcbiAgICAgICAgICogYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCBieSB0aGUgYXRvbSBiZWluZyByZXNvbHZlZCAoc2VlIHRoaXMgbG9naWNcbiAgICAgICAgICogaW4gUmVjb2lsX2F0b20uanMpXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXksIGxvYWRhYmxlV2l0aFZhbHVlJDIocmVzb2x2ZWREZXApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiByZXNvbHZlZERlcEtleSBpcyBub3QgZGVmaW5lZCwgdGhlIHByb21pc2Ugd2FzIGEgdXNlci10aHJvd25cbiAgICAgICAgICogcHJvbWlzZS4gVXNlci10aHJvd24gcHJvbWlzZXMgYXJlIGFuIGFkdmFuY2VkIGZlYXR1cmUgYW5kIHRoZXlcbiAgICAgICAgICogc2hvdWxkIGJlIGF2b2lkZWQgaW4gYWxtb3N0IGFsbCBjYXNlcy4gVXNpbmcgYGxvYWRhYmxlLm1hcCgpYCBpbnNpZGVcbiAgICAgICAgICogb2Ygc2VsZWN0b3JzIGZvciBsb2FkaW5nIGxvYWRhYmxlcyBhbmQgdGhlbiB0aHJvd2luZyB0aGF0IG1hcHBlZFxuICAgICAgICAgKiBsb2FkYWJsZSdzIHByb21pc2UgaXMgYW4gZXhhbXBsZSBvZiBhIHVzZXItdGhyb3duIHByb21pc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gd2UgaGl0IGEgdXNlci10aHJvd24gcHJvbWlzZSwgd2UgaGF2ZSB0byBiYWlsIG91dCBvZiBhbiBvcHRpbWl6YXRpb25cbiAgICAgICAgICogd2hlcmUgd2UgYnlwYXNzIGNhbGN1bGF0aW5nIHNlbGVjdG9yIGNhY2hlIGtleXMgZm9yIHNlbGVjdG9ycyB0aGF0XG4gICAgICAgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNlZW4gZm9yIGEgZ2l2ZW4gc3RhdGUgKHRoZXNlIHNlbGVjdG9ycyBhcmUgc2F2ZWQgaW5cbiAgICAgICAgICogc3RhdGUuYXRvbVZhbHVlcykgdG8gYXZvaWQgc3RhbGUgc3RhdGUgYXMgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZ1xuICAgICAgICAgKiB3aGF0IHN0YXRlIGNoYW5nZXMgaGFwcGVuZWQgKGlmIGFueSkgaW4gcmVzdWx0IHRvIHRoZSBwcm9taXNlIHJlc29sdmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWRlYWxseSB3ZSB3b3VsZCBvbmx5IGJhaWwgb3V0IHNlbGVjdG9ycyB0aGF0IGFyZSBpbiB0aGUgY2hhaW4gb2ZcbiAgICAgICAgICogZGVwZW5kZW5jaWVzIGZvciB0aGlzIHNlbGVjdG9yLCBidXQgdGhlcmUncyBjdXJyZW50bHkgbm8gd2F5IHRvIGdldFxuICAgICAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhIHNlbGVjdG9yJ3MgZG93bnN0cmVhbSBub2RlcyBiZWNhdXNlIHRoZSBzdGF0ZSB0aGF0XG4gICAgICAgICAqIGlzIGV4ZWN1dGluZyBtYXkgYmUgYSBkaXNjYXJkZWQgdHJlZSAoc28gc3RvcmUuZ2V0R3JhcGgoc3RhdGUudmVyc2lvbilcbiAgICAgICAgICogd2lsbCBiZSBlbXB0eSksIGFuZCB0aGUgZnVsbCBkZXAgdHJlZSBtYXkgbm90IGJlIGluIHRoZSBzZWxlY3RvclxuICAgICAgICAgKiBjYWNoZXMgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHNlbGVjdG9yJ3MgY2FjaGUgd2FzIGNsZWFyZWQuIFRvIHNvbHZlXG4gICAgICAgICAqIGZvciB0aGlzIHdlIHdvdWxkIGhhdmUgdG8ga2VlcCB0cmFjayBvZiBhbGwgcnVubmluZyBzZWxlY3RvclxuICAgICAgICAgKiBleGVjdXRpb25zIGFuZCB0aGVpciBkb3duc3RyZWFtIGRlcHMuIEJlY2F1c2UgdGhpcyBvbmx5IGNvdmVycyBlZGdlXG4gICAgICAgICAqIGNhc2VzLCB0aGF0IGNvbXBsZXhpdHkgbWlnaHQgbm90IGJlIGp1c3RpZnlhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycy5mb3JFYWNoKG5vZGVLZXkgPT4ge1xuICAgICAgICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogT3B0aW1pemF0aW9uOiBOb3cgdGhhdCB0aGUgZGVwZW5kZW5jeSBoYXMgcmVzb2x2ZWQsIGxldCdzIHRyeSBoaXR0aW5nXG4gICAgICAgKiB0aGUgY2FjaGUgaW4gY2FzZSB0aGUgZGVwIHJlc29sdmVkIHRvIGEgdmFsdWUgd2UgaGF2ZSBwcmV2aW91c2x5IHNlZW4uXG4gICAgICAgKlxuICAgICAgICogVE9ETzpcbiAgICAgICAqIE5vdGUgdGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IHBlcmZlY3QgYmVjYXVzZSBpdCBvbmx5IHByZXZlbnRzIHJlLWV4ZWN1dGlvbnNcbiAgICAgICAqIF9hZnRlcl8gdGhlIHBvaW50IHdoZXJlIGFuIGFzeW5jIGRlcGVuZGVuY3kgaXMgZm91bmQuIEFueSBjb2RlIGxlYWRpbmdcbiAgICAgICAqIHVwIHRvIHRoZSBhc3luYyBkZXBlbmRlbmN5IG1heSBoYXZlIHJ1biB1bm5lY2Vzc2FyaWx5LiBUaGUgaWRlYWwgY2FzZVxuICAgICAgICogd291bGQgYmUgdG8gd2FpdCBmb3IgdGhlIGFzeW5jIGRlcGVuZGVuY3kgdG8gcmVzb2x2ZSBmaXJzdCwgY2hlY2sgdGhlXG4gICAgICAgKiBjYWNoZSwgYW5kIHByZXZlbnQgX2FueV8gZXhlY3V0aW9uIG9mIHRoZSBzZWxlY3RvciBpZiB0aGUgcmVzdWx0aW5nXG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgZGVwZW5kZW5jeSBsZWFkcyB0byBhIHBhdGggdGhhdCBpcyBmb3VuZCBpbiB0aGUgY2FjaGUuXG4gICAgICAgKiBUaGUgaWRlYWwgY2FzZSBpcyBtb3JlIGRpZmZpY3VsdCB0byBpbXBsZW1lbnQgYXMgaXQgd291bGQgcmVxdWlyZSB0aGF0XG4gICAgICAgKiB3ZSBjYXB0dXJlIGFuZCB3YWl0IGZvciB0aGUgdGhlIGFzeW5jIGRlcGVuZGVuY3kgcmlnaHQgYWZ0ZXIgY2hlY2tpbmdcbiAgICAgICAqIHRoZSBjYWNoZS4gVGhlIGN1cnJlbnQgYXBwcm9hY2ggdGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgcnVubmluZ1xuICAgICAgICogdGhlIHNlbGVjdG9yIGFscmVhZHkgaGFzIGEgY29kZSBwYXRoIHRoYXQgbGV0cyB1cyBleGl0IGVhcmx5IHdoZW5cbiAgICAgICAqIGFuIGFzeW5jIGRlcCByZXNvbHZlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IGNhY2hlZExvYWRhYmxlID0gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChjYWNoZWRMb2FkYWJsZSAmJiBjYWNoZWRMb2FkYWJsZS5zdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGhhcyB0byBub3RpZnkgc3RvcmVzIG9mIGEgcmVzb2x2ZWQgYXN5bmMsIGV2ZW4gaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgICogY3VycmVudCBwZW5kaW5nIGV4ZWN1dGlvbiBmb3IgdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgICAgICAgKiAxKSBBIGNvbXBvbmVudCByZW5kZXJzIHdpdGggdGhpcyBwZW5kaW5nIGxvYWRhYmxlLlxuICAgICAgICAgKiAyKSBUaGUgdXBzdHJlYW0gZGVwZW5kZW5jeSByZXNvbHZlcy5cbiAgICAgICAgICogMykgV2hpbGUgcHJvY2Vzc2luZyBzb21lIG90aGVyIHNlbGVjdG9yIGl0IHJlYWRzIHRoaXMgb25lLCBzdWNoIGFzXG4gICAgICAgICAqICAgIHdoaWxlIHRyYXZlcnNpbmcgaXRzIGRlcGVuZGVuY2llcy4gIEF0IHRoaXMgcG9pbnQgaXQgZ2V0cyB0aGVcbiAgICAgICAgICogICAgbmV3IHJlc29sdmVkIHZhbHVlIHN5bmNocm9ub3VzbHkgYW5kIGNsZWFycyB0aGUgY3VycmVudFxuICAgICAgICAgKiAgICBleGVjdXRpb24gSUQuICBUaGUgY29tcG9uZW50IHdhc24ndCBnZXR0aW5nIHRoZSB2YWx1ZSBpdHNlbGYsXG4gICAgICAgICAqICAgIHRob3VnaCwgc28gaXQgc3RpbGwgaGFzIHRoZSBwZW5kaW5nIGxvYWRhYmxlLlxuICAgICAgICAgKiA0KSBXaGVuIHRoaXMgY29kZSBleGVjdXRlcyB0aGUgY3VycmVudCBleGVjdXRpb24gaWQgd2FzIGNsZWFyZWRcbiAgICAgICAgICogICAgYW5kIGl0IHdvdWxkbid0IG5vdGlmeSB0aGUgY29tcG9uZW50IG9mIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEkgdGhpbmsgdGhpcyBpcyBvbmx5IGFuIGlzc3VlIHdpdGggXCJlYXJseVwiIHJlbmRlcmluZyBzaW5jZSB0aGVcbiAgICAgICAgICogY29tcG9uZW50cyBnb3QgdGhlaXIgdmFsdWUgdXNpbmcgdGhlIGluLXByb2dyZXNzIGV4ZWN1dGlvbi5cbiAgICAgICAgICogV2UgZG9uJ3QgaGF2ZSBhIHVuaXQgdGVzdCBmb3IgdGhpcyBjYXNlIHlldC4gIEknbSBub3Qgc3VyZSBpdCBpc1xuICAgICAgICAgKiBuZWNlc3Nhcnkgd2l0aCByZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB8fCBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSA9PSBudWxsKSB7XG4gICAgICAgICAgbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVkTG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgY2FjaGVkTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhpcyBleGVjdXRpb24gaXMgc3RhbGUsIGxldCdzIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBzb21lIGluXG4gICAgICAgKiBwcm9ncmVzcyBleGVjdXRpb24gd2l0aCBhIG1hdGNoaW5nIHN0YXRlLiBJZiB3ZSBmaW5kIGEgbWF0Y2gsIHRoZW5cbiAgICAgICAqIHdlIGNhbiB0YWtlIHRoZSB2YWx1ZSBmcm9tIHRoYXQgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uLiBOb3RlIHRoaXMgbWF5XG4gICAgICAgKiBzb3VuZCBsaWtlIGFuIGVkZ2UgY2FzZSwgYnV0IG1heSBiZSB2ZXJ5IGNvbW1vbiBpbiBjYXNlcyB3aGVyZSBhXG4gICAgICAgKiBsb2FkaW5nIGRlcGVuZGVuY3kgcmVzb2x2ZXMgZnJvbSBsb2FkaW5nIHRvIGhhdmluZyBhIHZhbHVlICh0aHVzXG4gICAgICAgKiBwb3NzaWJseSB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyKSwgYW5kIFJlYWN0IHJlLXJlbmRlcnMgYmVmb3JlIHRoZVxuICAgICAgICogY2hhaW5lZCAudGhlbigpIGZ1bmN0aW9ucyBydW4sIHRodXMgc3RhcnRpbmcgYSBuZXcgZXhlY3V0aW9uIGFzIHRoZVxuICAgICAgICogZGVwIGhhcyBjaGFuZ2VkIHZhbHVlLiBXaXRob3V0IHRoaXMgY2hlY2sgd2Ugd2lsbCBydW4gdGhlIHNlbGVjdG9yXG4gICAgICAgKiB0d2ljZSAob25jZSBpbiB0aGUgbmV3IGV4ZWN1dGlvbiBhbmQgb25jZSBhZ2FpbiBpbiB0aGlzIC50aGVuKCksIHNvXG4gICAgICAgKiB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBrZWVwIHVubmVjZXNzYXJ5IHJlLWV4ZWN1dGlvbnMgdG8gYVxuICAgICAgICogbWluaW11bSkuXG4gICAgICAgKlxuICAgICAgICogQWxzbyBub3RlIHRoaXMgY29kZSBkb2VzIG5vdCBjaGVjayBhY3Jvc3MgYWxsIGV4ZWN1dGlvbnMgdGhhdCBtYXkgYmVcbiAgICAgICAqIHJ1bm5pbmcuIEl0IG9ubHkgb3B0aW1pemVzIGZvciB0aGUgX2xhdGVzdF8gZXhlY3V0aW9uIHBlciBzdG9yZSBhc1xuICAgICAgICogd2UgY3VycmVudGx5IGRvIG5vdCBtYWludGFpbiBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBydW5uaW5nIGV4ZWN1dGlvbnMuXG4gICAgICAgKiBUaGlzIG1lYW5zIGluIHNvbWUgY2FzZXMgd2UgbWF5IHJ1biBzZWxlY3RvcnMgbW9yZSB0aGFuIHN0cmljdGx5XG4gICAgICAgKiBuZWNlc3Nhcnkgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZXhlY3V0aW9ucyBydW5uaW5nIGZvciB0aGUgc2FtZVxuICAgICAgICogc2VsZWN0b3IuIFRoaXMgbWF5IGJlIGEgdmFsaWQgdHJhZGVvZmYgYXMgY2hlY2tpbmcgZm9yIGRlcCBjaGFuZ2VzXG4gICAgICAgKiBhY3Jvc3MgYWxsIGluLXByb2dyZXNzIGV4ZWN1dGlvbnMgbWF5IHRha2UgbG9uZ2VyIHRoYW4ganVzdFxuICAgICAgICogcmUtcnVubmluZyB0aGUgc2VsZWN0b3IuIFRoaXMgd2lsbCBiZSBhcHAtZGVwZW5kZW50LCBhbmQgbWF5YmUgaW4gdGhlXG4gICAgICAgKiBmdXR1cmUgd2UgY2FuIG1ha2UgdGhlIGJlaGF2aW9yIGNvbmZpZ3VyYWJsZS4gQW4gaWRlYWwgZml4IG1heSBiZVxuICAgICAgICogdG8gZXh0ZW5kIHRoZSB0cmVlIGNhY2hlIHRvIHN1cHBvcnQgY2FjaGluZyBsb2FkaW5nIHN0YXRlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIGlmICghaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oc3RvcmUsIHN0YXRlKTtcblxuICAgICAgICBpZiAoZXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmV0dXJuaW5nIHByb21pc2UgaGVyZSB3aXRob3V0IHdyYXBwaW5nIGFzIHRoZSB3cmFwcGVyIGxvZ2ljIHdhc1xuICAgICAgICAgICAqIGFscmVhZHkgZG9uZSB1cHN0cmVhbSB3aGVuIHRoaXMgcHJvbWlzZSB3YXMgZ2VuZXJhdGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybiBleGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXRyeSB0aGUgc2VsZWN0b3IgZXZhbHVhdGlvbiBub3cgdGhhdCB0aGUgZGVwZW5kZW5jeSBoYXMgcmVzb2x2ZWRcblxuXG4gICAgICBjb25zdCBbbG9hZGFibGUsIGRlcFZhbHVlc10gPSBldmFsdWF0ZVNlbGVjdG9yR2V0dGVyKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQpO1xuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxlZCkge1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDEoZXJyb3IpO1xuICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBleGlzdGluZ0RlcHMpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwcywgZXhlY3V0aW9uSUQpIHtcbiAgICB2YXIgX3N0b3JlJGdldFN0YXRlLCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUsIF9zdG9yZSRnZXRTdGF0ZTIsIF9zdG9yZSRnZXRTdGF0ZTIkbmV4dDtcblxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpIHx8IHN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlJGN1cnJlID0gX3N0b3JlJGdldFN0YXRlLmN1cnJlbnRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkY3VycmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRjdXJyZS52ZXJzaW9uKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZTIgPSBzdG9yZS5nZXRTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3N0b3JlJGdldFN0YXRlMiRuZXh0ID0gX3N0b3JlJGdldFN0YXRlMi5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiRuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUyJG5leHQudmVyc2lvbikpIHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdG9yZSRnZXRTdGF0ZTMsIF9zdG9yZSRnZXRTdGF0ZTMkbmV4dDtcblxuICAgICAgc2F2ZURlcHNUb1N0b3JlJDEoa2V5LCBkZXBzLCBzdG9yZSwgKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IChfc3RvcmUkZ2V0U3RhdGUzID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTMubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMyRuZXh0LnZlcnNpb24pICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGVwcykge1xuICAgICAgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cy5hZGQobm9kZUtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKSB7XG4gICAgY29uc3QgZW5kUGVyZkJsb2NrID0gc3RhcnRQZXJmQmxvY2skMShrZXkpOyAvLyBUT0RPIFQ2Mzk2NTg2NjogdXNlIGV4ZWN1dGlvbiBJRCBoZXJlXG5cbiAgICBsZXQgZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xuICAgIGxldCBkdXJpbmdBc3luY2hyb25vdXNFeGVjdXRpb24gPSB0cnVlO1xuXG4gICAgY29uc3QgZmluaXNoRXZhbHVhdGlvbiA9ICgpID0+IHtcbiAgICAgIGVuZFBlcmZCbG9jaygpO1xuICAgICAgZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHJlc3VsdElzRXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgbG9hZGFibGU7XG4gICAgY29uc3QgbG9hZGluZ0RlcHNTdGF0ZSA9IHtcbiAgICAgIGxvYWRpbmdEZXBLZXk6IG51bGwsXG4gICAgICBsb2FkaW5nRGVwUHJvbWlzZTogbnVsbFxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgYSBmcmVzaCBzZXQgb2YgZGVwcyB0aGF0IHdlJ2xsIGJlIHVzaW5nIHRvIHVwZGF0ZSBzdGF0ZS4gV2UncmVcbiAgICAgKiBzdGFydGluZyBhIG5ldyBzZXQgdmVyc3VzIGFkZGluZyBpdCBpbiBleGlzdGluZyBzdGF0ZSBkZXBzIGJlY2F1c2VcbiAgICAgKiB0aGUgdmVyc2lvbiBvZiBzdGF0ZSB0aGF0IHdlIHVwZGF0ZSBkZXBzIGZvciBtYXkgYmUgYSBtb3JlIHJlY2VudCB2ZXJzaW9uXG4gICAgICogdGhhbiB0aGUgdmVyc2lvbiB0aGUgc2VsZWN0b3Igd2FzIGNhbGxlZCB3aXRoLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxhdGVzdFxuICAgICAqIGV4ZWN1dGlvbiB3aWxsIHVwZGF0ZSB0aGUgZGVwcyBvZiB0aGUgY3VycmVudC9sYXRlc3QgdmVyc2lvbiBvZiBzdGF0ZVxuICAgICAqIChUaGlzIGlzIHNhZmUgdG8gZG8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IHRoZSBzZWxlY3RvciBpcyB0aGUgbGF0ZXN0XG4gICAgICogZXhlY3V0aW9uIG1lYW5zIHRoZSBkZXBzIHdlIGRpc2NvdmVyIGJlbG93IGFyZSBvdXIgYmVzdCBndWVzcyBhdCB0aGVcbiAgICAgKiBkZXBzIGZvciB0aGUgY3VycmVudC9sYXRlc3Qgc3RhdGUgaW4gdGhlIHN0b3JlKVxuICAgICAqL1xuXG4gICAgY29uc3QgZGVwVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWUoe1xuICAgICAga2V5OiBkZXBLZXlcbiAgICB9KSB7XG4gICAgICBjb25zdCBkZXBMb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcbiAgICAgIGRlcFZhbHVlcy5zZXQoZGVwS2V5LCBkZXBMb2FkYWJsZSk7IC8vIFdlIG5lZWQgdG8gdXBkYXRlIGFzeW5jaHJvbm91cyBkZXBlbmRlbmNpZXMgYXMgd2UgZ28gc28gdGhlIHNlbGVjdG9yXG4gICAgICAvLyBrbm93cyBpZiBpdCBoYXMgdG8gcmVzdGFydCBldmFsdWF0aW9uIGlmIG9uZSBvZiB0aGVtIGlzIHVwZGF0ZWQgYmVmb3JlXG4gICAgICAvLyB0aGUgYXN5bmNocm9ub3VzIHNlbGVjdG9yIGNvbXBsZXRlbHkgcmVzb2x2ZXMuXG5cbiAgICAgIGlmICghZHVyaW5nU3luY2hyb25vdXNFeGVjdXRpb24pIHtcbiAgICAgICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcbiAgICAgICAgbm90aWZ5U3RvcmVzT2ZOZXdBc3luY0RlcChzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGRlcExvYWRhYmxlLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ2hhc1ZhbHVlJzpcbiAgICAgICAgICByZXR1cm4gZGVwTG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgY2FzZSAnaGFzRXJyb3InOlxuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSA9IGRlcEtleTtcbiAgICAgICAgICBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBQcm9taXNlID0gZGVwTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgICAgdGhyb3cgZGVwTG9hZGFibGUuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0ludmFsaWQgTG9hZGFibGUgc3RhdGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRDYWxsYmFjayA9IGZuID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQ2FsbGJhY2tzIGZyb20gZ2V0Q2FsbGJhY2soKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHNlbGVjdG9yIGlzIGV2YWx1dGF0ZWQuICBJdCBjYW4gYmUgdXNlZCBmb3Igc2VsZWN0b3JzIHRvIHJldHVybiBvYmplY3RzIHdpdGggY2FsbGJhY2tzIHRoYXQgY2FuIHdvcmsgd2l0aCBSZWNvaWwgc3RhdGUgd2l0aG91dCBhIHN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgICEocmVjb2lsVmFsdWUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnUmVjb2lsIFZhbHVlIGNhbiBuZXZlciBiZSBudWxsJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHJlY29pbENhbGxiYWNrJDEoc3RvcmUsIGZuLCBhcmdzLCB7XG4gICAgICAgICAgbm9kZTogcmVjb2lsVmFsdWVcbiAgICAgICAgfSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBnZXQoe1xuICAgICAgICBnZXQ6IGdldFJlY29pbFZhbHVlLFxuICAgICAgICBnZXRDYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXN1bHQgPSBpc1JlY29pbFZhbHVlJDMocmVzdWx0KSA/IGdldFJlY29pbFZhbHVlKHJlc3VsdCkgOiByZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xvYWRhYmxlJDEocmVzdWx0KSkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICAgICAgcmVzdWx0SXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gd3JhcFJlc3VsdFByb21pc2Uoc3RvcmUsIHJlc3VsdCwgc3RhdGUsIGRlcFZhbHVlcywgZXhlY3V0aW9uSUQsIGxvYWRpbmdEZXBzU3RhdGUpLmZpbmFsbHkoZmluaXNoRXZhbHVhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2hFdmFsdWF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSQxID8gcmVzdWx0LnZhbHVlIDogcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yT3JEZXBQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBlcnJvck9yRGVwUHJvbWlzZTtcblxuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0SXNFcnJvciA9IHRydWU7XG4gICAgICAgIGZpbmlzaEV2YWx1YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0SXNFcnJvcikge1xuICAgICAgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoUHJvbWlzZSQxKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMihyZXN1bHQpO1xuICAgIH1cblxuICAgIGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgdXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyhzdG9yZSwgZXhlY3V0aW9uSUQsIGRlcFZhbHVlcyk7XG4gICAgdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIG5ldyBTZXQoZGVwVmFsdWVzLmtleXMoKSksIGV4ZWN1dGlvbklEKTtcbiAgICByZXR1cm4gW2xvYWRhYmxlLCBkZXBWYWx1ZXNdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TG9hZGFibGVGcm9tQ2FjaGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIEZpcnN0LCBsb29rIHVwIGluIHRoZSBzdGF0ZSBjYWNoZVxuICAgIC8vIElmIGl0J3MgaGVyZSwgdGhlbiB0aGUgZGVwcyBpbiB0aGUgc3RvcmUgc2hvdWxkIGFscmVhZHkgYmUgdmFsaWQuXG4gICAgbGV0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gICAgfSAvLyBTZWNvbmQsIGxvb2sgdXAgaW4gdGhlIHNlbGVjdG9yIGNhY2hlIGFuZCB1cGRhdGUgdGhlIGRlcHMgaW4gdGhlIHN0b3JlXG5cblxuICAgIGNvbnN0IGRlcHNBZnRlckNhY2hlTG9va3VwID0gbmV3IFNldCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlZExvYWRhYmxlID0gY2FjaGUuZ2V0KG5vZGVLZXkgPT4ge1xuICAgICAgICAhKHR5cGVvZiBub2RlS2V5ID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSZWNvaWxfaW52YXJpYW50KGZhbHNlLCAnQ2FjaGUgbm9kZUtleSBpcyB0eXBlIHN0cmluZycpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIG5vZGVLZXkpLmNvbnRlbnRzO1xuICAgICAgfSwge1xuICAgICAgICBvbk5vZGVWaXNpdDogbm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2JyYW5jaCcgJiYgbm9kZS5ub2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIGRlcHNBZnRlckNhY2hlTG9va3VwLmFkZChub2RlLm5vZGVLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBjYWNoZSBsb29rdXAgZm9yIHNlbGVjdG9yIFwiJHtrZXl9XCI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUpIHtcbiAgICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbztcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHMgaW4gdGhlIHN0YXRlIHRvIGFsbG93IGZvciBjaGVhcGVyIGxvb2t1cCB0aGFuXG4gICAgICAvLyBpdGVyYXRpbmcgdGhlIHRyZWUgY2FjaGUgb2YgZGVwZW5kZW5jaWVzLlxuICAgICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBjYWNoZWRMb2FkYWJsZSk7XG4gICAgICAvKipcbiAgICAgICAqIEVuc3VyZSBzdG9yZSBjb250YWlucyBjb3JyZWN0IGRlcGVuZGVuY2llcyBpZiB3ZSBoaXQgdGhlIGNhY2hlIHNvIHRoYXRcbiAgICAgICAqIHRoZSBzdG9yZSBkZXBzIGFuZCBjYWNoZSBhcmUgaW4gc3luYyBmb3IgYSBnaXZlbiBzdGF0ZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgICAgICAqIGJlY2F1c2Ugc3RvcmUgZGVwcyBhcmUgbm9ybWFsbHkgdXBkYXRlZCB3aGVuIG5ldyBleGVjdXRpb25zIGFyZSBjcmVhdGVkLFxuICAgICAgICogYnV0IGNhY2hlIGhpdHMgZG9uJ3QgdHJpZ2dlciBuZXcgZXhlY3V0aW9ucyBidXQgdGhleSBzdGlsbCBfbWF5XyBzaWduaWZ5XG4gICAgICAgKiBhIGNoYW5nZSBpbiBkZXBzIGluIHRoZSBzdG9yZSBpZiB0aGUgc3RvcmUgZGVwcyBmb3IgdGhpcyBzdGF0ZSBhcmUgZW1wdHlcbiAgICAgICAqIG9yIHN0YWxlLlxuICAgICAgICovXG5cbiAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCwgKF9nZXRFeGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mby5leGVjdXRpb25JRCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiBhIHRyZWUgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIExvYWRhYmxlIG9mIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBUaGUgc2VsZWN0b3IncyBnZXQoKSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgcmUtZXZhbHVhdGVkIGlmIF9ib3RoXyBvZiB0aGVcbiAgICogZm9sbG93aW5nIHN0YXRlbWVudHMgYXJlIHRydWU6XG4gICAqXG4gICAqIDEuIFRoZSBjdXJyZW50IGRlcCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgcHJvZHVjZWQgYSBjYWNoZSBrZXkgdGhhdFxuICAgKiAgICB3YXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZS5cbiAgICogMi4gVGhlcmUgaXMgbm8gY3VycmVudGx5IHJ1bm5pbmcgYXN5bmMgZXhlY3V0aW9uIE9SIHRoZXJlIGlzIGFuXG4gICAqICAgIGFzeW5jIGV4ZWN1dGlvbiB0aGF0IGlzIHJ1bm5pbmcsIGJ1dCBhZnRlciBjb21wYXJpbmcgdGhlIGRlcCB2YWx1ZXMgaW5cbiAgICogICAgdGhlIGdpdmVuIHN0YXRlIHdpdGggdGhlIGRlcCB2YWx1ZXMgdGhhdCB0aGUgZXhlY3V0aW9uIGhhcyBkaXNjb3ZlcmVkIHNvXG4gICAqICAgIGZhciB3ZSBmaW5kIHRoYXQgYXQgbGVhc3Qgb25lIGRlcCB2YWx1ZSBoYXMgY2hhbmdlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgKiAgICBzdGFydCBhIG5ldyBleGVjdXRpb24gKHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgZXhlY3V0aW9uIHdpbGwgY29udGludWUgdG9cbiAgICogICAgcnVuIHRvIGNvbXBsZXRpb24sIGJ1dCBvbmx5IHRoZSBuZXcgZXhlY3V0aW9uIHdpbGwgYmUgZGVlbWVkIHRoZVxuICAgKiAgICAnbGF0ZXN0JyBleGVjdXRpb24sIG1lYW5pbmcgaXQgd2lsbCBiZSB0aGUgb25seSBleGVjdXRpb24gdGhhdCB3aWxsXG4gICAqICAgIHVwZGF0ZSBnbG9iYWwgc3RhdGUgd2hlbiBpdCBpcyBmaW5pc2hlZC4gQW55IG5vbi1sYXRlc3QgZXhlY3V0aW9ucyB3aWxsXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uIGFuZCB1cGRhdGUgdGhlIHNlbGVjdG9yIGNhY2hlIGJ1dCBub3QgZ2xvYmFsIHN0YXRlKS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTZWxlY3RvckxvYWRhYmxlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBGaXJzdCwgc2VlIGlmIG91ciBjdXJyZW50IHN0YXRlIGlzIGNhY2hlZFxuICAgIGNvbnN0IGNhY2hlZFZhbCA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgaWYgKGNhY2hlZFZhbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9IC8vIFNlY29uZCwgY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvbmdvaW5nIGV4ZWN1dGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZVxuXG5cbiAgICBjb25zdCBpblByb2dyZXNzRXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICBpZiAoaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgdmFyIF9pblByb2dyZXNzRXhlY3V0aW9uSTtcblxuICAgICAgaWYgKCgoX2luUHJvZ3Jlc3NFeGVjdXRpb25JID0gaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8ubG9hZGluZ0xvYWRhYmxlKSA9PT0gbnVsbCB8fCBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pblByb2dyZXNzRXhlY3V0aW9uSS5zdGF0ZSkgPT09ICdsb2FkaW5nJykge1xuICAgICAgICBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8uZXhlY3V0aW9uSUQpO1xuICAgICAgfSAvLyBGSVhNRTogY2hlY2sgYWZ0ZXIgdGhlIGZhY3QgdG8gc2VlIGlmIHdlIG1hZGUgdGhlIHJpZ2h0IGNob2ljZSBieSB3YWl0aW5nXG5cblxuICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZTtcbiAgICB9IC8vIFRoaXJkLCBzdGFydCBhIG5ldyBldmFsdWF0aW9uIG9mIHRoZSBzZWxlY3RvclxuXG5cbiAgICBjb25zdCBuZXdFeGVjdXRpb25JRCA9IGdldE5ld0V4ZWN1dGlvbklEKCk7XG4gICAgY29uc3QgW2xvYWRhYmxlLCBuZXdEZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIG5ld0V4ZWN1dGlvbklEKTtcbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IHVwZGF0ZXMgdGhlIGNhY2hlIHdpdGggYSBnaXZlbiBsb2FkYWJsZS5cbiAgICAgKlxuICAgICAqIFdlIG9ubHkgY2FjaGUgbG9hZGFibGVzIHRoYXQgYXJlIG5vdCBsb2FkaW5nIGJlY2F1c2Ugb3VyIGNhY2hlIGtleXMgYXJlXG4gICAgICogYmFzZWQgb24gZGVwIHZhbHVlcywgd2hpY2ggYXJlIGluIGFuIHVuZmluaXNoZWQgc3RhdGUgZm9yIGxvYWRhYmxlcyB0aGF0XG4gICAgICogaGF2ZSBhICdsb2FkaW5nJyBzdGF0ZSAobmV3IGRlcHMgbWF5IGJlIGRpc2NvdmVyZWQgd2hpbGUgdGhlIHNlbGVjdG9yXG4gICAgICogcnVucyBpdHMgYXN5bmMgY29kZSkuIFdlIG5ldmVyIHdhbnQgdG8gY2FjaGUgcGFydGlhbCBkZXBlbmRlbmNpZXMgYi9jIGl0XG4gICAgICogY291bGQgbGVhZCB0byBlcnJvcnMsIHN1Y2ggYXMgcHJlbWF0dXJlbHkgcmV0dXJuaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gYVxuICAgICAqIHBhcnRpYWwgbGlzdCBvZiBkZXBzLS0gd2UgbmVlZCB0aGUgZnVsbCBsaXN0IG9mIGRlcHMgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgKiBhcmUgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHJlc3VsdCBmcm9tIGNhY2hlLlxuICAgICAqL1xuXG4gICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIHNldEV4ZWN1dGlvbkluZm8oc3RvcmUsIG5ld0V4ZWN1dGlvbklELCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzLCBzdGF0ZSk7XG4gICAgICBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBuZXdEZXBWYWx1ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2FkYWJsZTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoZXMgZXhlY3V0aW9uIGluZm8gYWNyb3NzIGFsbCBzdG9yZXMgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGluLXByb2dyZXNzXG4gICAqIGV4ZWN1dGlvbiB3aG9zZSBkZXBlbmRlbmN5IHZhbHVlcyBtYXRjaCB0aGUgdmFsdWVzIG9mIHRoZSByZXF1ZXN0aW5nIHN0b3JlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSkge1xuICAgIC8vIFNvcnQgdGhlIHBlbmRpbmcgZXhlY3V0aW9ucyBzbyB0aGF0IG91ciBjdXJyZW50IHN0b3JlIGlzIGNoZWNrZWQgZmlyc3QuXG4gICAgY29uc3QgcGVuZGluZ0V4ZWN1dGlvbnMgPSBSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtleGVjdXRpb25JbmZvTWFwLmhhcyhzdG9yZSkgPyBbUmVjb2lsX251bGx0aHJvd3MoZXhlY3V0aW9uSW5mb01hcC5nZXQoc3RvcmUpKV0gOiBbXSwgUmVjb2lsX21hcEl0ZXJhYmxlKFJlY29pbF9maWx0ZXJJdGVyYWJsZShleGVjdXRpb25JbmZvTWFwLCAoW3NdKSA9PiBzICE9PSBzdG9yZSksIChbLCBleGVjSW5mb10pID0+IGV4ZWNJbmZvKV0pO1xuXG4gICAgZnVuY3Rpb24gYW55RGVwQ2hhbmdlZChleGVjRGVwVmFsdWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtkZXBLZXksIGV4ZWNMb2FkYWJsZV0gb2YgZXhlY0RlcFZhbHVlcykge1xuICAgICAgICBpZiAoIWdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KS5pcyhleGVjTG9hZGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZXhlY0luZm8gb2YgcGVuZGluZ0V4ZWN1dGlvbnMpIHtcbiAgICAgIGlmICggLy8gSWYgdGhpcyBleGVjdXRpb24gd2FzIGFscmVhZHkgY2hlY2tlZCB0byBiZSB2YWxpZCB3aXRoIHRoaXMgdmVyc2lvblxuICAgICAgLy8gb2Ygc3RhdGUsIHRoZW4gbGV0J3MgdXNlIGl0IVxuICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5nZXQoc3RhdGUudmVyc2lvbikgfHwgLy8gSWYgdGhlIGRlcHMgZm9yIHRoZSBleGVjdXRpb24gbWF0Y2ggb3VyIGN1cnJlbnQgc3RhdGUsIHRoZW4gaXQncyB2YWxpZFxuICAgICAgIWFueURlcENoYW5nZWQoZXhlY0luZm8uZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrKSkge1xuICAgICAgICBleGVjSW5mby5zdGF0ZVZlcnNpb25zLnNldChzdGF0ZS52ZXJzaW9uLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGV4ZWNJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGlvbkluZm9NYXAuZ2V0KHN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSB0aGUgc2VsZWN0b3IncyBleGVjdXRpb24gaW5mbyB3aGVuIHRoZSBzZWxlY3RvclxuICAgKiBoYXMgZWl0aGVyIGZpbmlzaGVkIHJ1bm5pbmcgYW4gZXhlY3V0aW9uIG9yIGhhcyBzdGFydGVkIGEgbmV3IGV4ZWN1dGlvbi4gSWZcbiAgICogdGhlIGdpdmVuIGxvYWRhYmxlIGlzIGluIGEgJ2xvYWRpbmcnIHN0YXRlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYSBuZXdcbiAgICogZXhlY3V0aW9uIGhhcyBzdGFydGVkLiBPdGhlcndpc2UsIHRoZSBpbnRlbnRpb24gaXMgdGhhdCBhbiBleGVjdXRpb24gaGFzXG4gICAqIGp1c3QgZmluaXNoZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2V0RXhlY3V0aW9uSW5mbyhzdG9yZSwgbmV3RXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMsIHN0YXRlKSB7XG4gICAgZXhlY3V0aW9uSW5mb01hcC5zZXQoc3RvcmUsIHtcbiAgICAgIGRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yazogZGVwVmFsdWVzLFxuICAgICAgZXhlY3V0aW9uSUQ6IG5ld0V4ZWN1dGlvbklELFxuICAgICAgbG9hZGluZ0xvYWRhYmxlOiBsb2FkYWJsZSxcbiAgICAgIHN0YXRlVmVyc2lvbnM6IG5ldyBNYXAoW1tzdGF0ZS52ZXJzaW9uLCB0cnVlXV0pXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzKHN0b3JlLCBleGVjdXRpb25JRCwgZGVwVmFsdWVzKSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGJvdGhlciB1cGRhdGluZyB0aGUgZGVwcyBmb3IgdGhlIGxhdGVzdCBleGVjdXRpb24gYmVjYXVzZVxuICAgIC8vIHRoYXQncyBhbGwgZ2V0SW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8oKSB3aWxsIGJlIGxvb2tpbmcgZm9yLlxuICAgIGlmIChpc0xhdGVzdEV4ZWN1dGlvbihzdG9yZSwgZXhlY3V0aW9uSUQpKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25JbmZvID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSk7XG5cbiAgICAgIGlmIChleGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgICAgZXhlY3V0aW9uSW5mby5kZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmsgPSBkZXBWYWx1ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKSB7XG4gICAgZXhlY3V0aW9uSW5mb01hcC5kZWxldGUoc3RvcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgdmFyIF9nZXRFeGVjdXRpb25JbmZvMjtcblxuICAgIHJldHVybiBleGVjdXRpb25JRCA9PT0gKChfZ2V0RXhlY3V0aW9uSW5mbzIgPSBnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSkgPT09IG51bGwgfHwgX2dldEV4ZWN1dGlvbkluZm8yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0RXhlY3V0aW9uSW5mbzIuZXhlY3V0aW9uSUQpO1xuICB9XG4gIC8qKlxuICAgKiBGSVhNRTogZGVwIGtleXMgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IHRoZSBzdGF0ZSBvZiB0aGUgbG9hZGFibGUgdG9cbiAgICogcHJldmVudCB0aGUgZWRnZSBjYXNlIHdoZXJlIGEgbG9hZGFibGUgd2l0aCBhbiBlcnJvciBhbmQgYSBsb2FkYWJsZSB3aXRoXG4gICAqIGFuIGVycm9yIGFzIGEgdmFsdWUgYXJlIHRyZWF0ZWQgYXMgdGhlIHNhbWUgdGhpbmcgaW5jb3JyZWN0bHkuIEZvciBleGFtcGxlXG4gICAqIHRoZXNlIHR3byBzaG91bGQgYmUgdHJlYXRlZCBkaWZmZXJlbnRseTpcbiAgICpcbiAgICogc2VsZWN0b3Ioe2tleTogJycsIGdldDogKCkgPT4gbmV3IEVycm9yKCdoaScpfSk7XG4gICAqIHNlbGVjdG9yKHtrZXk6ICcnLCBnZXQgKCkgPT4ge3Rocm93IG5ldyBFcnJvcignaGknKX19KTtcbiAgICpcbiAgICogV2l0aCBjdXJyZW50IGltcGxlbWVudGF0aW9uIHRoZXkgYXJlIHRyZWF0ZWQgdGhlIHNhbWVcbiAgICovXG5cblxuICBmdW5jdGlvbiBkZXBWYWx1ZXNUb0RlcFJvdXRlKGRlcFZhbHVlcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRlcFZhbHVlcy5lbnRyaWVzKCkpLm1hcCgoW2RlcEtleSwgdmFsTG9hZGFibGVdKSA9PiBbZGVwS2V5LCB2YWxMb2FkYWJsZS5jb250ZW50c10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FjaGUoc3RhdGUsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJyAmJiBCb29sZWFuKG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkpID09PSBmYWxzZSkge1xuICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKGxvYWRhYmxlLmNvbnRlbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGxvYWRhYmxlKTtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZS5zZXQoZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpLCBsb2FkYWJsZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBzZXR0aW5nIGNhY2hlIGZvciBzZWxlY3RvciBcIiR7a2V5fVwiOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoZm4pIHtcbiAgICBpZiAoZGVwZW5kZW5jeVN0YWNrLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgUmVjb2lsIHNlbGVjdG9yIGhhcyBjaXJjdWxhciBkZXBlbmRlbmNpZXM6ICR7ZGVwZW5kZW5jeVN0YWNrLnNsaWNlKGRlcGVuZGVuY3lTdGFjay5pbmRleE9mKGtleSkpLmpvaW4oJyBcXHUyMTkyICcpfWA7XG4gICAgICByZXR1cm4gbG9hZGFibGVXaXRoRXJyb3IkMShSZWNvaWxfZXJyKG1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBkZXBlbmRlbmN5U3RhY2sucHVzaChrZXkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZXBlbmRlbmN5U3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JQZWVrKHN0b3JlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGNhY2hlZExvYWRhYmxlID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KTtcblxuICAgIGlmIChjYWNoZWRMb2FkYWJsZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTG9hZGFibGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmdldChub2RlS2V5ID0+IHtcbiAgICAgIHZhciBfcGVla05vZGVMb2FkYWJsZTtcblxuICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIChfcGVla05vZGVMb2FkYWJsZSA9IHBlZWtOb2RlTG9hZGFibGUkMShzdG9yZSwgc3RhdGUsIG5vZGVLZXkpKSA9PT0gbnVsbCB8fCBfcGVla05vZGVMb2FkYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlZWtOb2RlTG9hZGFibGUuY29udGVudHM7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvckdldChzdG9yZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gZGV0ZWN0Q2lyY3VsYXJEZXBlbmRlbmNpZXMoKCkgPT4gZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlU2VsZWN0b3Ioc3RhdGUpIHtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3RvckNhY2hlKHN0b3JlLCB0cmVlU3RhdGUpIHtcbiAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cykge1xuICAgICAgdmFyIF9ub2RlJGNsZWFyQ2FjaGU7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDYobm9kZUtleSk7XG4gICAgICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCB0cmVlU3RhdGUpO1xuICAgIH1cblxuICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuY2xlYXIoKTtcbiAgICBpbnZhbGlkYXRlU2VsZWN0b3IodHJlZVN0YXRlKTtcbiAgICBjYWNoZS5jbGVhcigpO1xuICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDEoc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgfVxuXG4gIGlmIChzZXQgIT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIEVTNSBzdHJpY3QgbW9kZSBwcm9oaWJpdHMgZGVmaW5pbmcgbm9uLXRvcC1sZXZlbCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMsXG4gICAgICogc28gZG9uJ3QgdXNlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIHN5bnRheCBoZXJlXG4gICAgICovXG4gICAgY29uc3Qgc2VsZWN0b3JTZXQgPSAoc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgbGV0IHN5bmNTZWxlY3RvclNldEZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB3cml0ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcbiAgICAgICAga2V5OiBkZXBLZXlcbiAgICAgIH0pIHtcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignUmVjb2lsOiBBc3luYyBzZWxlY3RvciBzZXRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBkZXBLZXkpO1xuXG4gICAgICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYEdldHRpbmcgdmFsdWUgb2YgYXN5bmNocm9ub3VzIGF0b20gb3Igc2VsZWN0b3IgXCIke2RlcEtleX1cIiBpbiBhIHBlbmRpbmcgc3RhdGUgd2hpbGUgc2V0dGluZyBzZWxlY3RvciBcIiR7a2V5fVwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmA7XG4gICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGxvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlLCB2YWx1ZU9yVXBkYXRlcikge1xuICAgICAgICBpZiAoc3luY1NlbGVjdG9yU2V0RmluaXNoZWQpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSAnUmVjb2lsOiBBc3luYyBzZWxlY3RvciBzZXRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nO1xuICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihtc2cpO1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCB0eXBlIFMgZnJvbSBiZWluZyBhIGZ1bmN0aW9uIGl0c2VsZiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcbiAgICAgICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgdmFsdWVPclVwZGF0ZXIoZ2V0UmVjb2lsVmFsdWUocmVjb2lsU3RhdGUpKSA6IHZhbHVlT3JVcGRhdGVyO1xuICAgICAgICBjb25zdCB1cHN0cmVhbVdyaXRlcyA9IHNldE5vZGVWYWx1ZSQzKHN0b3JlLCBzdGF0ZSwgcmVjb2lsU3RhdGUua2V5LCBzZXRWYWx1ZSk7XG4gICAgICAgIHVwc3RyZWFtV3JpdGVzLmZvckVhY2goKHYsIGspID0+IHdyaXRlcy5zZXQoaywgdikpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICAgIHNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDYpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXQgPSBzZXQoe1xuICAgICAgICBzZXQ6IHNldFJlY29pbFN0YXRlLFxuICAgICAgICBnZXQ6IGdldFJlY29pbFZhbHVlLFxuICAgICAgICByZXNldDogcmVzZXRSZWNvaWxTdGF0ZVxuICAgICAgfSwgbmV3VmFsdWUpOyAvLyBzZXQgc2hvdWxkIGJlIGEgdm9pZCBtZXRob2QsIGJ1dCBpZiB0aGUgdXNlciBtYWtlcyBpdCBgYXN5bmNgLCB0aGVuIGl0XG4gICAgICAvLyB3aWxsIHJldHVybiBhIFByb21pc2UsIHdoaWNoIHdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0LlxuXG4gICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2lzUHJvbWlzZShyZXQpID8gUmVjb2lsX2VycignUmVjb2lsOiBBc3luYyBzZWxlY3RvciBzZXRzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nKSA6IFJlY29pbF9lcnIoJ1JlY29pbDogc2VsZWN0b3Igc2V0IHNob3VsZCBiZSBhIHZvaWQgZnVuY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNTZWxlY3RvclNldEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB3cml0ZXM7XG4gICAgfTtcblxuICAgIHJldHVybiByZWNvaWxWYWx1ZSA9IHJlZ2lzdGVyTm9kZSQxKHtcbiAgICAgIGtleSxcbiAgICAgIG5vZGVUeXBlOiAnc2VsZWN0b3InLFxuICAgICAgcGVlazogc2VsZWN0b3JQZWVrLFxuICAgICAgZ2V0OiBzZWxlY3RvckdldCxcbiAgICAgIHNldDogc2VsZWN0b3JTZXQsXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXG4gICAgICBjbGVhckNhY2hlOiBjbGVhclNlbGVjdG9yQ2FjaGUsXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogZmFsc2UsXG4gICAgICByZXRhaW5lZEJ5XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlY29pbFZhbHVlID0gcmVnaXN0ZXJOb2RlJDEoe1xuICAgICAga2V5LFxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXG4gICAgICBwZWVrOiBzZWxlY3RvclBlZWssXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxuICAgICAgaW5pdDogc2VsZWN0b3JJbml0LFxuICAgICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZVNlbGVjdG9yLFxuICAgICAgY2xlYXJDYWNoZTogY2xlYXJTZWxlY3RvckNhY2hlLFxuICAgICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSxcbiAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IGZhbHNlLFxuICAgICAgcmV0YWluZWRCeVxuICAgIH0pO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xuLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdXNlXVxuLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG5cbnNlbGVjdG9yLnZhbHVlID0gdmFsdWUgPT4gbmV3IFdyYXBwZWRWYWx1ZSQxKHZhbHVlKTtcblxudmFyIFJlY29pbF9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4vLyBAZmItb25seTogaW1wb3J0IHR5cGUge1Njb3BlUnVsZXN9IGZyb20gJ1JlY29pbF9TY29wZWRBdG9tJztcbi8vIEBmYi1vbmx5OiBjb25zdCB7c2NvcGVkQXRvbX0gPSByZXF1aXJlKCdSZWNvaWxfU2NvcGVkQXRvbScpO1xuY29uc3Qge1xuICBpc0xvYWRhYmxlOiBpc0xvYWRhYmxlJDIsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBsb2FkYWJsZVdpdGhFcnJvciQyLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDIsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQzXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgV3JhcHBlZFZhbHVlOiBXcmFwcGVkVmFsdWUkMlxufSA9IFJlY29pbF9XcmFwcGVyJDE7XG5cbmNvbnN0IHtcbiAgcGVla05vZGVJbmZvOiBwZWVrTm9kZUluZm8kM1xufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDcsXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDIsXG4gIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIsXG4gIHJlZ2lzdGVyTm9kZTogcmVnaXN0ZXJOb2RlJDIsXG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDRcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWUkMTtcblxuY29uc3Qge1xuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0LFxuICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZDogbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMixcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDQsXG4gIHNldFJlY29pbFZhbHVlTG9hZGFibGU6IHNldFJlY29pbFZhbHVlTG9hZGFibGUkMlxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQ6IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHVud3JhcCA9IHggPT4geCBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSQyID8geC52YWx1ZSA6IHg7XG5cbmZ1bmN0aW9uIGJhc2VBdG9tKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogcGVyc2lzdGVuY2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMihvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUpO1xuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcblxuICBmdW5jdGlvbiB1bndyYXBQcm9taXNlKHByb21pc2UpIHtcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSQyKHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICBkZWZhdWx0TG9hZGFibGUgPSBsb2FkYWJsZVdpdGhWYWx1ZSQzKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBkZWZhdWx0TG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQyKGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pKTtcbiAgfVxuXG4gIGxldCBkZWZhdWx0TG9hZGFibGUgPSBSZWNvaWxfaXNQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdCkgOiBpc0xvYWRhYmxlJDIob3B0aW9ucy5kZWZhdWx0KSA/IG9wdGlvbnMuZGVmYXVsdC5zdGF0ZSA9PT0gJ2xvYWRpbmcnID8gdW53cmFwUHJvbWlzZShvcHRpb25zLmRlZmF1bHQuY29udGVudHMpIDogb3B0aW9ucy5kZWZhdWx0IDogbG9hZGFibGVXaXRoVmFsdWUkMyh1bndyYXAob3B0aW9ucy5kZWZhdWx0KSk7XG4gIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UoZGVmYXVsdExvYWRhYmxlLmNvbnRlbnRzKTtcbiAgbGV0IGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB1bmRlZmluZWQ7IC8vIENsZWFudXAgaGFuZGxlcnMgZm9yIHRoaXMgYXRvbVxuICAvLyBSZWx5IG9uIHN0YWJsZSByZWZlcmVuY2UgZXF1YWxpdHkgb2YgdGhlIHN0b3JlIHRvIHVzZSBpdCBhcyBhIGtleSBwZXIgPFJlY29pbFJvb3Q+XG5cbiAgY29uc3QgY2xlYW51cEVmZmVjdHNCeVN0b3JlID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UodmFsdWVPclByb21pc2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVPclByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWNvaWxfZGVlcEZyZWV6ZVZhbHVlKHZhbHVlT3JQcm9taXNlKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWVPclByb21pc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVPclByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwUGVuZGluZ1Byb21pc2Uoc3RvcmUsIHByb21pc2UpIHtcbiAgICBjb25zdCB3cmFwcGVkUHJvbWlzZSA9IHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQ7XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgaWYgKCgoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0ID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpID09PSB3cmFwcGVkUHJvbWlzZSkge1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQ0KHN0b3JlLCBub2RlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMiwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MjtcblxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMiA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQyID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJGF0b21WYWx1ZXMkZ2V0Mi5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlTG9hZGFibGUkMihzdG9yZSwgbm9kZSwgbG9hZGFibGVXaXRoRXJyb3IkMihlcnJvcikpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICByZXR1cm4gd3JhcHBlZFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0QXRvbShzdG9yZSwgaW5pdFN0YXRlLCB0cmlnZ2VyKSB7XG4gICAgdmFyIF9vcHRpb25zJGVmZmVjdHM7XG5cbiAgICBsaXZlU3RvcmVzQ291bnQrKztcblxuICAgIGNvbnN0IGNsZWFudXBBdG9tID0gKCkgPT4ge1xuICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjtcblxuICAgICAgbGl2ZVN0b3Jlc0NvdW50LS07XG4gICAgICAoX2NsZWFudXBFZmZlY3RzQnlTdG9yID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpID09PSBudWxsIHx8IF9jbGVhbnVwRWZmZWN0c0J5U3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NsZWFudXBFZmZlY3RzQnlTdG9yLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLmRlbGV0ZShzdG9yZSk7XG4gICAgfTtcblxuICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcy5hZGQoa2V5KTsgLy8gU2V0dXAgYXN5bmMgZGVmYXVsdHMgdG8gbm90aWZ5IHN1YnNjcmliZXJzIHdoZW4gdGhleSByZXNvbHZlXG5cbiAgICBpZiAoZGVmYXVsdExvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIGNvbnN0IG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDM7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUMyA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICAgIGlmICghc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIoc3RvcmUsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBkZWZhdWx0TG9hZGFibGUuY29udGVudHMuZmluYWxseShub3RpZnlEZWZhdWx0U3Vic2NyaWJlcnMpO1xuICAgIH0gLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFJ1biBBdG9tIEVmZmVjdHNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICAgIGNvbnN0IGVmZmVjdHMgPSAoX29wdGlvbnMkZWZmZWN0cyA9IG9wdGlvbnMuZWZmZWN0cykgIT09IG51bGwgJiYgX29wdGlvbnMkZWZmZWN0cyAhPT0gdm9pZCAwID8gX29wdGlvbnMkZWZmZWN0cyA6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRTtcblxuICAgIGlmIChlZmZlY3RzICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgc3RhdGUgaXMgc2NvcGVkIGJ5IFN0b3JlLCBzaW5jZSB0aGlzIGlzIGluIHRoZSBpbml0QXRvbSgpIGNsb3N1cmVcbiAgICAgIGxldCBpbml0VmFsdWUgPSBERUZBVUxUX1ZBTFVFJDc7XG4gICAgICBsZXQgaXNEdXJpbmdJbml0ID0gdHJ1ZTtcbiAgICAgIGxldCBpc0luaXRFcnJvciA9IGZhbHNlO1xuICAgICAgbGV0IHBlbmRpbmdTZXRTZWxmID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGp1c3QgZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGFub3RoZXIgYXRvbS5cbiAgICAgICAgLy8gQnV0IGZvciBvdXIgb3duIHZhbHVlIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nXG4gICAgICAgIC8vIGluaXRpYWxpemVkIHZhbHVlIG9yIGdldCB0aGUgZmFsbGJhY2sgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgaWYgKGlzRHVyaW5nSW5pdCAmJiByZWNvaWxWYWx1ZS5rZXkgPT09IGtleSkge1xuICAgICAgICAgIC8vIENhc3QgVCB0byBTXG4gICAgICAgICAgY29uc3QgcmV0VmFsdWUgPSBpbml0VmFsdWU7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4gICAgICAgICAgcmV0dXJuIHJldFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBwZWVrQXRvbShzdG9yZSwgaW5pdFN0YXRlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICA6IFJlY29pbF9pc1Byb21pc2UocmV0VmFsdWUpID8gbG9hZGFibGVXaXRoUHJvbWlzZSQyKHJldFZhbHVlLnRoZW4odiA9PiB2IGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyAvLyBDYXN0IFQgdG8gU1xuICAgICAgICAgIGRlZmF1bHRMb2FkYWJsZS50b1Byb21pc2UoKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICA6IHYpKSA6IGxvYWRhYmxlV2l0aFZhbHVlJDMocmV0VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQ0KHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFByb21pc2UocmVjb2lsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldExvYWRhYmxlKHJlY29pbFZhbHVlKS50b1Byb21pc2UoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0SW5mb19VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUNDtcblxuICAgICAgICBjb25zdCBpbmZvID0gcGVla05vZGVJbmZvJDMoc3RvcmUsIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ0ID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUNCAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUNCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIHJlY29pbFZhbHVlLmtleSk7XG4gICAgICAgIHJldHVybiBpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkgJiYgIShpbml0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikgPyB7IC4uLmluZm8sXG4gICAgICAgICAgaXNTZXQ6IHRydWUsXG4gICAgICAgICAgbG9hZGFibGU6IGdldExvYWRhYmxlKHJlY29pbFZhbHVlKVxuICAgICAgICB9IDogaW5mbztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2V0U2VsZiA9IGVmZmVjdCA9PiB2YWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50TG9hZGFibGUgPSBnZXRMb2FkYWJsZShub2RlKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50TG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgPyBjdXJyZW50TG9hZGFibGUuY29udGVudHMgOiBERUZBVUxUX1ZBTFVFJDc7XG4gICAgICAgICAgaW5pdFZhbHVlID0gdHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nID8gLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcbiAgICAgICAgICB2YWx1ZU9yVXBkYXRlcihjdXJyZW50VmFsdWUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogdmFsdWVPclVwZGF0ZXI7XG5cbiAgICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShpbml0VmFsdWUpKSB7XG4gICAgICAgICAgICBpbml0VmFsdWUgPSBpbml0VmFsdWUudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhbGxpbmcgb25TZXQoKSB3aGVuIHNldFNlbGYoKSBpbml0aWFsaXplcyB3aXRoIGEgUHJvbWlzZVxuICAgICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JVcGRhdGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgUmVjb2lsX2VycignU2V0dGluZyBhdG9tcyB0byBhc3luYyB2YWx1ZXMgaXMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xuICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bndyYXAodmFsdWVPclVwZGF0ZXIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFJlY29pbFZhbHVlJDQoc3RvcmUsIG5vZGUsIHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnRWYWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHVud3JhcCggLy8gY2FzdCB0byBhbnkgYmVjYXVzZSB3ZSBjYW4ndCByZXN0cmljdCBUIGZyb20gYmVpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGxvc2luZyBzdXBwb3J0IGZvciBvcGFxdWUgdHlwZXNcbiAgICAgICAgICAgIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnRWYWx1ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICAgIH0gOiB1bndyYXAodmFsdWVPclVwZGF0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzZXRTZWxmID0gZWZmZWN0ID0+ICgpID0+IHNldFNlbGYoZWZmZWN0KShERUZBVUxUX1ZBTFVFJDcpO1xuXG4gICAgICBjb25zdCBvblNldCA9IGVmZmVjdCA9PiBoYW5kbGVyID0+IHtcbiAgICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjI7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlbGVhc2VcbiAgICAgICAgfSA9IHN0b3JlLnN1YnNjcmliZVRvVHJhbnNhY3Rpb25zKGN1cnJlbnRTdG9yZSA9PiB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50VHJlZSRhdG9tVmFsdTtcblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWVcbiAgICAgICAgICB9ID0gY3VycmVudFN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoIXByZXZpb3VzVHJlZSkge1xuICAgICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmFuc2FjdGlvbiBzdWJzY3JpYmVycyBub3RpZmllZCB3aXRob3V0IGEgbmV4dCB0cmVlIGJlaW5nIHByZXNlbnQgLS0gdGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwnKTtcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSA9IGN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IChfY3VycmVudFRyZWUkYXRvbVZhbHUgPSBjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfY3VycmVudFRyZWUkYXRvbVZhbHUgIT09IHZvaWQgMCA/IF9jdXJyZW50VHJlZSRhdG9tVmFsdSA6IGRlZmF1bHRMb2FkYWJsZTtcblxuICAgICAgICAgIGlmIChuZXdMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgICAgdmFyIF9wcmV2aW91c1RyZWUkYXRvbVZhbCwgX3BlbmRpbmdTZXRTZWxmLCBfcGVuZGluZ1NldFNlbGYyLCBfcGVuZGluZ1NldFNlbGYzO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ld0xvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICAgICAgY29uc3Qgb2xkTG9hZGFibGUgPSAoX3ByZXZpb3VzVHJlZSRhdG9tVmFsID0gcHJldmlvdXNUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9wcmV2aW91c1RyZWUkYXRvbVZhbCAhPT0gdm9pZCAwID8gX3ByZXZpb3VzVHJlZSRhdG9tVmFsIDogZGVmYXVsdExvYWRhYmxlO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvbGRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyA/IG9sZExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3OyAvLyBUT0RPIFRoaXMgaXNuJ3QgYWN0dWFsbHkgdmFsaWQsIHVzZSBhcyBhIHBsYWNlaG9sZGVyIGZvciBub3cuXG4gICAgICAgICAgICAvLyBJZ25vcmUgYXRvbSB2YWx1ZSBjaGFuZ2VzIHRoYXQgd2VyZSBzZXQgdmlhIHNldFNlbGYoKSBpbiB0aGUgc2FtZSBlZmZlY3QuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb3Blcmx5IGNhbGwgdGhlIGhhbmRsZXIgaWYgdGhlcmUgd2FzIGEgc3Vic2VxdWVudFxuICAgICAgICAgICAgLy8gc2V0IGZyb20gc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gYXRvbSBlZmZlY3Qgd2hpY2ggd2FzIGJhdGNoZWRcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIGBzZXRTZWxmKClgIGNhbGwuICBIb3dldmVyLCB3ZSBtYXkgaW5jb3JyZWN0bHkgaWdub3JlXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlciBpZiB0aGUgc3Vic2VxdWVudCBiYXRjaGVkIGNhbGwgaGFwcGVucyB0byBzZXQgdGhlXG4gICAgICAgICAgICAvLyBhdG9tIHRvIHRoZSBleGFjdCBzYW1lIHZhbHVlIGFzIHRoZSBgc2V0U2VsZigpYC4gICBCdXQsIGluIHRoYXRcbiAgICAgICAgICAgIC8vIGNhc2UsIGl0IHdhcyBraW5kIG9mIGEgbm9vcCwgc28gdGhlIHNlbWFudGljcyBhcmUgZGViYXRhYmxlLi5cblxuICAgICAgICAgICAgaWYgKCgoX3BlbmRpbmdTZXRTZWxmID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdTZXRTZWxmLmVmZmVjdCkgIT09IGVmZmVjdCB8fCAoKF9wZW5kaW5nU2V0U2VsZjIgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdTZXRTZWxmMi52YWx1ZSkgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIobmV3VmFsdWUsIG9sZFZhbHVlLCAhY3VycmVudFRyZWUuYXRvbVZhbHVlcy5oYXMoa2V5KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3BlbmRpbmdTZXRTZWxmMyA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYzLmVmZmVjdCkgPT09IGVmZmVjdCkge1xuICAgICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBrZXkpO1xuICAgICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuc2V0KHN0b3JlLCBbLi4uKChfY2xlYW51cEVmZmVjdHNCeVN0b3IyID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpICE9PSBudWxsICYmIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgIT09IHZvaWQgMCA/IF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgOiBbXSksIHJlbGVhc2VdKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwID0gZWZmZWN0KHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzdG9yZUlEOiBzdG9yZS5zdG9yZUlELFxuICAgICAgICAgICAgcGFyZW50U3RvcmVJRF9VTlNUQUJMRTogc3RvcmUucGFyZW50U3RvcmVJRCxcbiAgICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgICBzZXRTZWxmOiBzZXRTZWxmKGVmZmVjdCksXG4gICAgICAgICAgICByZXNldFNlbGY6IHJlc2V0U2VsZihlZmZlY3QpLFxuICAgICAgICAgICAgb25TZXQ6IG9uU2V0KGVmZmVjdCksXG4gICAgICAgICAgICBnZXRQcm9taXNlLFxuICAgICAgICAgICAgZ2V0TG9hZGFibGUsXG4gICAgICAgICAgICBnZXRJbmZvX1VOU1RBQkxFXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMztcblxuICAgICAgICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLnNldChzdG9yZSwgWy4uLigoX2NsZWFudXBFZmZlY3RzQnlTdG9yMyA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSAhPT0gbnVsbCAmJiBfY2xlYW51cEVmZmVjdHNCeVN0b3IzICE9PSB2b2lkIDAgPyBfY2xlYW51cEVmZmVjdHNCeVN0b3IzIDogW10pLCBjbGVhbnVwXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGluaXRWYWx1ZSA9IGVycm9yO1xuICAgICAgICAgIGlzSW5pdEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0R1cmluZ0luaXQgPSBmYWxzZTsgLy8gTXV0YXRlIGluaXRpYWwgc3RhdGUgaW4gcGxhY2Ugc2luY2Ugd2Uga25vdyB0aGVyZSBhcmUgbm8gb3RoZXIgc3Vic2NyaWJlcnNcbiAgICAgIC8vIHNpbmNlIHdlIGFyZSB0aGUgb25lcyBpbml0aWFsaXppbmcgb24gZmlyc3QgdXNlLlxuXG4gICAgICBpZiAoIShpbml0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikpIHtcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDU7XG5cbiAgICAgICAgY29uc3QgaW5pdExvYWRhYmxlID0gaXNJbml0RXJyb3IgPyBsb2FkYWJsZVdpdGhFcnJvciQyKGluaXRWYWx1ZSkgOiBSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIod3JhcFBlbmRpbmdQcm9taXNlKHN0b3JlLCBpbml0VmFsdWUpKSA6IGxvYWRhYmxlV2l0aFZhbHVlJDModW53cmFwKGluaXRWYWx1ZSkpO1xuICAgICAgICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKGluaXRMb2FkYWJsZS5jb250ZW50cyk7XG4gICAgICAgIGluaXRTdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7IC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyB0cmFuc2FjdGlvbiwgdGhlbiBhbHNvIG11dGF0ZSB0aGUgbmV4dCBzdGF0ZSB0cmVlLlxuICAgICAgICAvLyBUaGlzIGNvdWxkIGhhcHBlbiBpZiB0aGUgYXRvbSB3YXMgZmlyc3QgaW5pdGlhbGl6ZWQgaW4gYW4gYWN0aW9uIHRoYXRcbiAgICAgICAgLy8gYWxzbyB1cGRhdGVkIHNvbWUgb3RoZXIgYXRvbSdzIHN0YXRlLlxuXG4gICAgICAgIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJG5leHRUNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJG5leHRUNS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsZWFudXBBdG9tO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVla0F0b20oX3N0b3JlLCBzdGF0ZSkge1xuICAgIHZhciBfcmVmLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzO1xuXG4gICAgcmV0dXJuIChfcmVmID0gKF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzICE9PSB2b2lkIDAgPyBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzIDogY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGRlZmF1bHRMb2FkYWJsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0b20oX3N0b3JlLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBBdG9tIHZhbHVlIGlzIHN0b3JlZCBpbiBzdGF0ZTpcbiAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpKSB7XG4gICAgICAvLyBBdG9tIHZhbHVlIGlzIHN0b3JlZCBidXQgbmVlZHMgdmFsaWRhdGlvbiBiZWZvcmUgdXNlLlxuICAgICAgLy8gV2UgbWlnaHQgaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBpdCBhbmQgaGF2ZSBhIGNhY2hlZCB2YWxpZGF0ZWQgdmFsdWU6XG4gICAgICBpZiAoY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVyc2lzdGVuY2UgPT0gbnVsbCkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oYFRyaWVkIHRvIHJlc3RvcmUgYSBwZXJzaXN0ZWQgdmFsdWUgZm9yIGF0b20gJHtrZXl9IGJ1dCBpdCBoYXMgbm8gcGVyc2lzdGVuY2Ugc2V0dGluZ3MuYCk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZFZhbHVlID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZ2V0KGtleSk7XG4gICAgICBjb25zdCB2YWxpZGF0b3JSZXN1bHQgPSBwZXJzaXN0ZW5jZS52YWxpZGF0b3Iobm9udmFsaWRhdGVkVmFsdWUsIERFRkFVTFRfVkFMVUUkNyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlID0gdmFsaWRhdG9yUmVzdWx0IGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBkZWZhdWx0TG9hZGFibGUgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHZhbGlkYXRvclJlc3VsdCk7XG4gICAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVkVmFsdWVMb2FkYWJsZTtcbiAgICAgIHJldHVybiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmYXVsdExvYWRhYmxlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVBdG9tKCkge1xuICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdG9tKF9zdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKSB7XG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYmVpbmcgc2V0IHRvIHRoZSBleGlzdGluZyB2YWx1ZSwgb3IgaWYgd2UncmUgYmVpbmdcbiAgICAvLyByZXNldCBidXQgaGF2ZSBubyBzdG9yZWQgdmFsdWUgKHZhbGlkYXRlZCBvciB1bnZhbGlkYXRlZCkgdG8gcmVzZXQgZnJvbTpcbiAgICBpZiAoc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnN0YXRlID09PSAnaGFzVmFsdWUnICYmIG5ld1ZhbHVlID09PSBleGlzdGluZy5jb250ZW50cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShuZXdWYWx1ZSk7XG4gICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gY2FuIGJlIHJlbGVhc2VkIG5vdyBpZiBpdCB3YXMgcHJldmlvdXNseSBpbiB1c2VcblxuICAgIHJldHVybiBuZXcgTWFwKCkuc2V0KGtleSwgbG9hZGFibGVXaXRoVmFsdWUkMyhuZXdWYWx1ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSgpIHtcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIoa2V5KSAhPT0gdW5kZWZpbmVkICYmIGxpdmVTdG9yZXNDb3VudCA8PSAwO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IHJlZ2lzdGVyTm9kZSQyKHtcbiAgICBrZXksXG4gICAgbm9kZVR5cGU6ICdhdG9tJyxcbiAgICBwZWVrOiBwZWVrQXRvbSxcbiAgICBnZXQ6IGdldEF0b20sXG4gICAgc2V0OiBzZXRBdG9tLFxuICAgIGluaXQ6IGluaXRBdG9tLFxuICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVBdG9tLFxuICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSxcbiAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSA/IHtcbiAgICAgIHR5cGU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUudHlwZSxcbiAgICAgIGJhY2tCdXR0b246IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUuYmFja0J1dHRvblxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IHRydWUsXG4gICAgcmV0YWluZWRCeVxuICB9KTtcbiAgcmV0dXJuIG5vZGU7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbmZ1bmN0aW9uIGF0b20ob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0Ega2V5IG9wdGlvbiB3aXRoIGEgdW5pcXVlIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYW4gYXRvbS4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG4gICAgLi4ucmVzdE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnNEZWZhdWx0ID0gJ2RlZmF1bHQnIGluIG9wdGlvbnMgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbiAgaWYgKGlzUmVjb2lsVmFsdWUkNChvcHRpb25zRGVmYXVsdCkgLy8gQ29udGludWUgdG8gdXNlIGF0b21XaXRoRmFsbGJhY2sgZm9yIHByb21pc2UgZGVmYXVsdHMgZm9yIHNjb3BlZCBhdG9tc1xuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xuICAvLyBAZmItb25seTogfHwgKGlzUHJvbWlzZShvcHRpb25zRGVmYXVsdCkgJiYgc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTKVxuICAvLyBAZmItb25seTogfHwgKGlzTG9hZGFibGUob3B0aW9uc0RlZmF1bHQpICYmIHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUylcbiAgKSB7XG4gICAgcmV0dXJuIGF0b21XaXRoRmFsbGJhY2soeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG5cbiAgICB9KTsgLy8gQGZiLW9ubHk6IH0gZWxzZSBpZiAoc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc1Byb21pc2Uob3B0aW9uc0RlZmF1bHQpXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxuICAgIC8vIEBmYi1vbmx5OiApIHtcbiAgICAvLyBAZmItb25seTogcmV0dXJuIHNjb3BlZEF0b208VD4oe1xuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcbiAgICAvLyBAZmItb25seTogZGVmYXVsdDogdW53cmFwPFQ+KG9wdGlvbnNEZWZhdWx0KSxcbiAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgIC8vIEBmYi1vbmx5OiB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZUF0b20oeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhGYWxsYmFjayhvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcbiAgICBkZWZhdWx0OiBERUZBVUxUX1ZBTFVFJDcsXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHsgLi4ub3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSxcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXG4gICAgfSxcbiAgICAvLyBUT0RPIEhhY2sgZm9yIG5vdy5cbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXG4gICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIGVmZmVjdHNfVU5TVEFCTEU6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG5cbiAgfSk7XG4gIGNvbnN0IHNlbCA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAga2V5OiBgJHtvcHRpb25zLmtleX1fX3dpdGhGYWxsYmFja2AsXG4gICAgZ2V0OiAoe1xuICAgICAgZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYmFzZVZhbHVlID0gZ2V0KGJhc2UpO1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gb3B0aW9ucy5kZWZhdWx0IDogYmFzZVZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiAoe1xuICAgICAgc2V0XG4gICAgfSwgbmV3VmFsdWUpID0+IHNldChiYXNlLCBuZXdWYWx1ZSksXG4gICAgLy8gVGhpcyBzZWxlY3RvciBkb2VzIG5vdCBuZWVkIHRvIGNhY2hlIGFzIGl0IGlzIGEgd3JhcHBlciBzZWxlY3RvclxuICAgIC8vIGFuZCB0aGUgc2VsZWN0b3Igd2l0aGluIHRoZSB3cmFwcGVyIHNlbGVjdG9yIHdpbGwgaGF2ZSBhIGNhY2hlXG4gICAgLy8gb3B0aW9uIGJ5IGRlZmF1bHRcbiAgICBjYWNoZVBvbGljeV9VTlNUQUJMRToge1xuICAgICAgZXZpY3Rpb246ICdtb3N0LXJlY2VudCdcbiAgICB9LFxuICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5XG4gIH0pO1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMShzZWwua2V5LCBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihvcHRpb25zLmtleSkpO1xuICByZXR1cm4gc2VsO1xufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuYXRvbS52YWx1ZSA9IHZhbHVlID0+IG5ldyBXcmFwcGVkVmFsdWUkMih2YWx1ZSk7XG5cbnZhciBSZWNvaWxfYXRvbSA9IGF0b207XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIE1hcENhY2hlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRtYXBLZXk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fa2V5TWFwcGVyID0gKF9vcHRpb25zJG1hcEtleSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBLZXkpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcEtleSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwS2V5IDogdiA9PiB2O1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIHNldChrZXksIHZhbCkge1xuICAgIHRoaXMuX21hcC5zZXQodGhpcy5fa2V5TWFwcGVyKGtleSksIHZhbCk7XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZSh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGUgPSB7XG4gIE1hcENhY2hlXG59O1xuXG52YXIgUmVjb2lsX01hcENhY2hlXzEgPSBSZWNvaWxfTWFwQ2FjaGUuTWFwQ2FjaGU7XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBNYXBDYWNoZTogUmVjb2lsX01hcENhY2hlXzFcbn0pO1xuXG5jb25zdCB7XG4gIExSVUNhY2hlOiBMUlVDYWNoZSQyXG59ID0gUmVjb2lsX0xSVUNhY2hlJDE7XG5cbmNvbnN0IHtcbiAgTWFwQ2FjaGU6IE1hcENhY2hlJDFcbn0gPSBSZWNvaWxfTWFwQ2FjaGUkMTtcblxuXG5cblxuXG5cblxuY29uc3QgZGVmYXVsdFBvbGljeSQxID0ge1xuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gIGV2aWN0aW9uOiAnbm9uZScsXG4gIG1heFNpemU6IEluZmluaXR5XG59O1xuXG5mdW5jdGlvbiBjYWNoZUZyb21Qb2xpY3koe1xuICBlcXVhbGl0eSA9IGRlZmF1bHRQb2xpY3kkMS5lcXVhbGl0eSxcbiAgZXZpY3Rpb24gPSBkZWZhdWx0UG9saWN5JDEuZXZpY3Rpb24sXG4gIG1heFNpemUgPSBkZWZhdWx0UG9saWN5JDEubWF4U2l6ZVxufSA9IGRlZmF1bHRQb2xpY3kkMSkge1xuICBjb25zdCB2YWx1ZU1hcHBlciA9IGdldFZhbHVlTWFwcGVyJDEoZXF1YWxpdHkpO1xuICBjb25zdCBjYWNoZSA9IGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCB2YWx1ZU1hcHBlcik7XG4gIHJldHVybiBjYWNoZTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSkge1xuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XG4gICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xuXG4gICAgY2FzZSAndmFsdWUnOlxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBLZXkpIHtcbiAgc3dpdGNoIChldmljdGlvbikge1xuICAgIGNhc2UgJ2tlZXAtYWxsJzpcbiAgICAgIHJldHVybiBuZXcgTWFwQ2FjaGUkMSh7XG4gICAgICAgIG1hcEtleVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdscnUnOlxuICAgICAgcmV0dXJuIG5ldyBMUlVDYWNoZSQyKHtcbiAgICAgICAgbWFwS2V5LFxuICAgICAgICBtYXhTaXplOiBSZWNvaWxfbnVsbHRocm93cyhtYXhTaXplKVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gbmV3IExSVUNhY2hlJDIoe1xuICAgICAgICBtYXBLZXksXG4gICAgICAgIG1heFNpemU6IDFcbiAgICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGV2aWN0aW9uIHBvbGljeSAke2V2aWN0aW9ufWApO1xufVxuXG52YXIgUmVjb2lsX2NhY2hlRnJvbVBvbGljeSA9IGNhY2hlRnJvbVBvbGljeTtcblxuLy8gQGZiLW9ubHk6IGltcG9ydCB0eXBlIHtTY29wZVJ1bGVzfSBmcm9tICdSZWNvaWxfU2NvcGVkQXRvbSc7XG5cblxuY29uc3Qge1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyXG59ID0gUmVjb2lsX05vZGU7XG5cblxuXG5cblxuLy8gUHJvY2VzcyBzY29wZVJ1bGVzIHRvIGhhbmRsZSBhbnkgZW50cmllcyB3aGljaCBhcmUgZnVuY3Rpb25zIHRha2luZyBwYXJhbWV0ZXJzXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vIEBmYi1vbmx5OiBmdW5jdGlvbiBtYXBTY29wZVJ1bGVzPFA+KFxuLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXM/OiBQYXJhbWV0ZXJpemVkU2NvcGVSdWxlczxQPixcbi8vIEBmYi1vbmx5OiBwYXJhbTogUCxcbi8vIEBmYi1vbmx5OiApOiBTY29wZVJ1bGVzIHwgdm9pZCB7XG4vLyBAZmItb25seTogcmV0dXJuIHNjb3BlUnVsZXM/Lm1hcChydWxlID0+XG4vLyBAZmItb25seTogQXJyYXkuaXNBcnJheShydWxlKVxuLy8gQGZiLW9ubHk6ID8gcnVsZS5tYXAoZW50cnkgPT4gKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJyA/IGVudHJ5KHBhcmFtKSA6IGVudHJ5KSlcbi8vIEBmYi1vbmx5OiA6IHJ1bGUsXG4vLyBAZmItb25seTogKTtcbi8vIEBmYi1vbmx5OiB9XG5cbi8qXG5BIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gYXRvbSBiYXNlZCBvbiB0aGUgaW5wdXQgcGFyYW1ldGVyLlxuXG5FYWNoIHVuaXF1ZSBwYXJhbWV0ZXIgcmV0dXJucyBhIHVuaXF1ZSBhdG9tLiBFLmcuLFxuXG4gIGNvbnN0IGYgPSBhdG9tRmFtaWx5KC4uLik7XG4gIGYoe2E6IDF9KSA9PiBhbiBhdG9tXG4gIGYoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBhdG9tXG5cblRoaXMgYWxsb3dzIGNvbXBvbmVudHMgdG8gcGVyc2lzdCBsb2NhbCwgcHJpdmF0ZSBzdGF0ZSB1c2luZyBhdG9tcy4gIEVhY2hcbmluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgbWF5IGhhdmUgYSBkaWZmZXJlbnQga2V5LCB3aGljaCBpdCB1c2VzIGFzIHRoZVxucGFyYW1ldGVyIGZvciBhIGZhbWlseSBvZiBhdG9tczsgaW4gdGhpcyB3YXksIGVhY2ggY29tcG9uZW50IHdpbGwgaGF2ZVxuaXRzIG93biBhdG9tIG5vdCBzaGFyZWQgYnkgb3RoZXIgaW5zdGFuY2VzLiAgVGhlc2Ugc3RhdGUga2V5cyBtYXkgYmUgY29tcG9zZWRcbmludG8gY2hpbGRyZW4ncyBzdGF0ZSBrZXlzIGFzIHdlbGwuXG4qL1xuZnVuY3Rpb24gYXRvbUZhbWlseShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRjYWNoZVBvbGljeUYsIF9vcHRpb25zJGNhY2hlUG9saWN5RjI7XG5cbiAgY29uc3QgYXRvbUNhY2hlID0gUmVjb2lsX2NhY2hlRnJvbVBvbGljeSh7XG4gICAgZXF1YWxpdHk6IChfb3B0aW9ucyRjYWNoZVBvbGljeUYgPSAoX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9IG9wdGlvbnMuY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUpID09PSBudWxsIHx8IF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGNhY2hlUG9saWN5RjIuZXF1YWxpdHkpICE9PSBudWxsICYmIF9vcHRpb25zJGNhY2hlUG9saWN5RiAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FjaGVQb2xpY3lGIDogJ3ZhbHVlJyxcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xuICB9KTsgLy8gU2ltcGxlIGF0b21GYW1pbHkgaW1wbGVtZW50YXRpb24gdG8gY2FjaGUgaW5kaXZpZHVhbCBhdG9tcyBiYXNlZFxuICAvLyBvbiB0aGUgcGFyYW1ldGVyIHZhbHVlIGVxdWFsaXR5LlxuXG4gIHJldHVybiBwYXJhbXMgPT4ge1xuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5LCBfb3B0aW9ucyRlZmZlY3RzO1xuXG4gICAgY29uc3QgY2FjaGVkQXRvbSA9IGF0b21DYWNoZS5nZXQocGFyYW1zKTtcblxuICAgIGlmIChjYWNoZWRBdG9tICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRBdG9tO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFLFxuICAgICAgLi4uYXRvbU9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zRGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBvcHRpb25zID8gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcbiAgICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG4gICAgY29uc3QgbmV3QXRvbSA9IFJlY29pbF9hdG9tKHsgLi4uYXRvbU9wdGlvbnMsXG4gICAgICBrZXk6IGAke29wdGlvbnMua2V5fV9fJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zKSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ31gLFxuICAgICAgZGVmYXVsdDogdHlwZW9mIG9wdGlvbnNEZWZhdWx0ID09PSAnZnVuY3Rpb24nID8gLy8gVGhlIGRlZmF1bHQgd2FzIHBhcmFtZXRlcml6ZWRcbiAgICAgIC8vIEZsb3cgZG9lc24ndCBrbm93IHRoYXQgVCBpc24ndCBhIGZ1bmN0aW9uLCBzbyB3ZSBuZWVkIHRvIGNhc2UgdG8gYW55XG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXG4gICAgICBvcHRpb25zRGVmYXVsdChwYXJhbXMpIDogLy8gRGVmYXVsdCBtYXkgYmUgYSBzdGF0aWMgdmFsdWUsIHByb21pc2UsIG9yIFJlY29pbFZhbHVlXG4gICAgICBvcHRpb25zRGVmYXVsdCxcbiAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSxcbiAgICAgIGVmZmVjdHM6IHR5cGVvZiBvcHRpb25zLmVmZmVjdHMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVmZmVjdHMocGFyYW1zKSA6IHR5cGVvZiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUocGFyYW1zKSA6IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUzogbWFwU2NvcGVSdWxlcyhcbiAgICAgIC8vIEBmYi1vbmx5OiBvcHRpb25zLnNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAgIC8vIEBmYi1vbmx5OiBwYXJhbXMsXG4gICAgICAvLyBAZmItb25seTogKSxcblxuICAgIH0pO1xuICAgIGF0b21DYWNoZS5zZXQocGFyYW1zLCBuZXdBdG9tKTtcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihuZXdBdG9tLmtleSwgKCkgPT4ge1xuICAgICAgYXRvbUNhY2hlLmRlbGV0ZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdBdG9tO1xuICB9O1xufVxuXG52YXIgUmVjb2lsX2F0b21GYW1pbHkgPSBhdG9tRmFtaWx5O1xuXG5jb25zdCB7XG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuXG5cblxuXG4gLy8gS2VlcCBpbiBtaW5kIHRoZSBwYXJhbWV0ZXIgbmVlZHMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGEgY2FoY2hlIGtleVxuLy8gdXNpbmcgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeVxuXG5cbi8vIEFkZCBhIHVuaXF1ZSBpbmRleCB0byBlYWNoIHNlbGVjdG9yIGluIGNhc2UgdGhlIGNhY2hlIGltcGxlbWVudGF0aW9uIGFsbG93c1xuLy8gZHVwbGljYXRlIGtleXMgYmFzZWQgb24gZXF1aXZhbGVudCBzdHJpbmdpZmllZCBwYXJhbWV0ZXJzXG5sZXQgbmV4dEluZGV4ID0gMDtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG4vLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWVtYmVycyBvZiBhIGZhbWlseSBvZiBzZWxlY3RvcnMgb2YgdGhlIHNhbWUgdHlwZVxuLy8gRS5nLixcbi8vXG4vLyBjb25zdCBzID0gc2VsZWN0b3JGYW1pbHkoLi4uKTtcbi8vIHMoe2E6IDF9KSA9PiBhIHNlbGVjdG9yXG4vLyBzKHthOiAyfSkgPT4gYSBkaWZmZXJlbnQgc2VsZWN0b3Jcbi8vXG4vLyBCeSBkZWZhdWx0LCB0aGUgc2VsZWN0b3JzIGFyZSBkaXN0aW5ndWlzaGVkIGJ5IGRpc3RpbmN0IHZhbHVlcyBvZiB0aGVcbi8vIHBhcmFtZXRlciBiYXNlZCBvbiB2YWx1ZSBlcXVhbGl0eSwgbm90IHJlZmVyZW5jZSBlcXVhbGl0eS4gIFRoaXMgYWxsb3dzIHVzaW5nXG4vLyBvYmplY3QgbGl0ZXJhbHMgb3Igb3RoZXIgZXF1aXZhbGVudCBvYmplY3RzIGF0IGNhbGxzaXRlcyB0byBub3QgY3JlYXRlXG4vLyBkdXBsaWNhdGUgY2FjaGUgZW50cmllcy4gIFRoaXMgYmVoYXZpb3IgbWF5IGJlIG92ZXJyaWRkZW4gd2l0aCB0aGVcbi8vIGNhY2hlSW1wbGVtZW50YXRpb25Gb3JQYXJhbXMgb3B0aW9uLlxuZnVuY3Rpb24gc2VsZWN0b3JGYW1pbHkob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xuXG4gIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0pO1xuICByZXR1cm4gcGFyYW1zID0+IHtcbiAgICB2YXIgX3N0YWJsZVN0cmluZ2lmeTtcblxuICAgIC8vIFRocm93IGFuIGVycm9yIHdpdGggc2VsZWN0b3Iga2V5IHNvIHRoYXQgaXQgaXMgY2xlYXIgd2hpY2hcbiAgICAvLyBzZWxlY3RvciBpcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgbGV0IGNhY2hlZFNlbGVjdG9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlZFNlbGVjdG9yID0gc2VsZWN0b3JDYWNoZS5nZXQocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIGNhY2hlIGxvb2t1cCBmb3Igc2VsZWN0b3IgJHtvcHRpb25zLmtleX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGVkU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFNlbGVjdG9yO1xuICAgIH1cblxuICAgIGNvbnN0IG15S2V5ID0gYCR7b3B0aW9ucy5rZXl9X19zZWxlY3RvckZhbWlseS8keyhfc3RhYmxlU3RyaW5naWZ5ID0gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeShwYXJhbXMsIHtcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBmdW5jdGlvbnMgaW4gcGFyYW1ldGVycyBpZiB0aGUgdXNlciB1c2VzXG4gICAgICAvLyBhIGNhY2hlIHdpdGggcmVmZXJlbmNlIGVxdWFsaXR5IHRoYW5rcyB0byB0aGUgaW5jcmVtZW50aW5nIGluZGV4LlxuICAgICAgYWxsb3dGdW5jdGlvbnM6IHRydWVcbiAgICB9KSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ30vJHtuZXh0SW5kZXgrK31gOyAvLyBBcHBlbmQgaW5kZXggaW4gY2FzZSB2YWx1ZXMgc2VyaWFsaXplIHRvIHRoZSBzYW1lIGtleSBzdHJpbmdcblxuICAgIGNvbnN0IG15R2V0ID0gY2FsbGJhY2tzID0+IG9wdGlvbnMuZ2V0KHBhcmFtcykoY2FsbGJhY2tzKTtcblxuICAgIGNvbnN0IG15Q2FjaGVQb2xpY3kgPSBvcHRpb25zLmNhY2hlUG9saWN5X1VOU1RBQkxFO1xuICAgIGNvbnN0IHJldGFpbmVkQnkgPSB0eXBlb2Ygb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKHBhcmFtcykgOiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEU7XG4gICAgbGV0IG5ld1NlbGVjdG9yO1xuXG4gICAgaWYgKG9wdGlvbnMuc2V0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0O1xuXG4gICAgICBjb25zdCBteVNldCA9IChjYWxsYmFja3MsIG5ld1ZhbHVlKSA9PiBzZXQocGFyYW1zKShjYWxsYmFja3MsIG5ld1ZhbHVlKTtcblxuICAgICAgbmV3U2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3Ioe1xuICAgICAgICBrZXk6IG15S2V5LFxuICAgICAgICBnZXQ6IG15R2V0LFxuICAgICAgICBzZXQ6IG15U2V0LFxuICAgICAgICBjYWNoZVBvbGljeV9VTlNUQUJMRTogbXlDYWNoZVBvbGljeSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHJldGFpbmVkQnlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAgICAgIGtleTogbXlLZXksXG4gICAgICAgIGdldDogbXlHZXQsXG4gICAgICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBteUNhY2hlUG9saWN5LFxuICAgICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0b3JDYWNoZS5zZXQocGFyYW1zLCBuZXdTZWxlY3Rvcik7XG4gICAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDMobmV3U2VsZWN0b3Iua2V5LCAoKSA9PiB7XG4gICAgICBzZWxlY3RvckNhY2hlLmRlbGV0ZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdTZWxlY3RvcjtcbiAgfTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxudmFyIFJlY29pbF9zZWxlY3RvckZhbWlseSA9IHNlbGVjdG9yRmFtaWx5O1xuXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGNvbnN0YW50U2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX2NvbnN0YW50JyxcbiAgZ2V0OiBjb25zdGFudCA9PiAoKSA9PiBjb25zdGFudCxcbiAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEU6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcbiAgfVxufSk7IC8vIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNlbGVjdG9yIHdoaWNoIGFsd2F5cyBwcm9kdWNlcyB0aGVcbi8vIHNhbWUgY29uc3RhbnQgdmFsdWUuICBJdCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlXG4vLyBzYW1lIHZhbHVlLCBiYXNlZCBvbiByZWZlcmVuY2UgZXF1YWxpdHksIGFuZCB3aWxsIHByb3ZpZGUgdGhlXG4vLyBzYW1lIHNlbGVjdG9yLlxuXG5mdW5jdGlvbiBjb25zdFNlbGVjdG9yKGNvbnN0YW50KSB7XG4gIHJldHVybiBjb25zdGFudFNlbGVjdG9yKGNvbnN0YW50KTtcbn1cblxudmFyIFJlY29pbF9jb25zdFNlbGVjdG9yID0gY29uc3RTZWxlY3RvcjtcblxuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5jb25zdCB0aHJvd2luZ1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX19lcnJvcicsXG4gIGdldDogbWVzc2FnZSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlKTtcbiAgfSxcbiAgLy8gVE9ETyBXaHk/XG4gIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFOiB7XG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnXG4gIH1cbn0pOyAvLyBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZWxlY3RvciB3aGljaCBhbHdheXMgdGhyb3dzIGFuIGVycm9yXG4vLyB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuXG5mdW5jdGlvbiBlcnJvclNlbGVjdG9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRocm93aW5nU2VsZWN0b3IobWVzc2FnZSk7XG59XG5cbnZhciBSZWNvaWxfZXJyb3JTZWxlY3RvciA9IGVycm9yU2VsZWN0b3I7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogV3JhcHMgYW5vdGhlciByZWNvaWwgdmFsdWUgYW5kIHByZXZlbnRzIHdyaXRpbmcgdG8gaXQuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHJlYWRPbmx5U2VsZWN0b3IoYXRvbSkge1xuICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgcmV0dXJuIGF0b207XG59XG5cbnZhciBSZWNvaWxfcmVhZE9ubHlTZWxlY3RvciA9IHJlYWRPbmx5U2VsZWN0b3I7XG5cbmNvbnN0IHtcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDMsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMyxcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDRcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuXG5cblxuXG4gLy8vLy8vLy8vLy8vLy8vLy9cbi8vICBUUlVUSCBUQUJMRVxuLy8vLy8vLy8vLy8vLy8vLy9cbi8vIERlcGVuZGVuY2llcyAgICAgICAgd2FpdEZvck5vbmUgICAgICAgICB3YWl0Rm9yQW55ICAgICAgICB3YWl0Rm9yQWxsICAgICAgIHdhaXRGb3JBbGxTZXR0bGVkXG4vLyAgW2xvYWRpbmcsIGxvYWRpbmddICBbUHJvbWlzZSwgUHJvbWlzZV0gIFByb21pc2UgICAgICAgICAgIFByb21pc2UgICAgICAgICBQcm9taXNlXG4vLyAgW3ZhbHVlLCBsb2FkaW5nXSAgICBbdmFsdWUsIFByb21pc2VdICAgIFt2YWx1ZSwgUHJvbWlzZV0gIFByb21pc2UgICAgICAgICBQcm9taXNlXG4vLyAgW3ZhbHVlLCB2YWx1ZV0gICAgICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgIFt2YWx1ZSwgdmFsdWVdICBbdmFsdWUsIHZhbHVlXVxuLy9cbi8vICBbZXJyb3IsIGxvYWRpbmddICAgIFtFcnJvciwgUHJvbWlzZV0gICAgW0Vycm9yLCBQcm9taXNlXSAgRXJyb3IgICAgICAgICAgIFByb21pc2Vcbi8vICBbZXJyb3IsIGVycm9yXSAgICAgIFtFcnJvciwgRXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFtlcnJvciwgZXJyb3JdXG4vLyAgW3ZhbHVlLCBlcnJvcl0gICAgICBbdmFsdWUsIEVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgIEVycm9yICAgICAgICAgICBbdmFsdWUsIGVycm9yXVxuLy8gSXNzdWUgcGFyYWxsZWwgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgYW5kIHJldHVybiB0aGUgY3VycmVudFxuLy8gc3RhdHVzIGlmIHRoZXkgaGF2ZSByZXN1bHRzLCBoYXZlIHNvbWUgZXJyb3IsIG9yIGFyZSBzdGlsbCBwZW5kaW5nLlxuXG5cbmZ1bmN0aW9uIGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXRSZWNvaWxWYWx1ZSwgZGVwcykge1xuICBjb25zdCByZXN1bHRzID0gQXJyYXkoZGVwcy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcbiAgY29uc3QgZXhjZXB0aW9ucyA9IEFycmF5KGRlcHMubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG5cbiAgZm9yIChjb25zdCBbaSwgZGVwXSBvZiBkZXBzLmVudHJpZXMoKSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRzW2ldID0gZ2V0UmVjb2lsVmFsdWUoZGVwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBleGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgICBleGNlcHRpb25zW2ldID0gZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGV4cCkge1xuICByZXR1cm4gZXhwICE9IG51bGwgJiYgIVJlY29pbF9pc1Byb21pc2UoZXhwKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5tYXAoa2V5ID0+IGRlcGVuZGVuY2llc1trZXldKTtcbn1cblxuZnVuY3Rpb24gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLFxuLyogJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XSBUaGUgdHlwZSBhbm5vdGF0aW9uKHMpIHJlcXVpcmVkIGJ5IEZsb3cnc1xuICogTFRJIHVwZGF0ZSBjb3VsZCBub3QgYmUgYWRkZWQgdmlhIGNvZGVtb2QgKi9cbnJlc3VsdHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IHJlc3VsdHMgOiAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpIGhhcyBjb25zaXN0ZW50IGtleSBvcmRlcmluZyB3aXRoIEVTNlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXBlbmRlbmNpZXMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxuICAgIFtrZXldOiByZXN1bHRzW2lkeF1cbiAgfSksIHt9KTtcbn1cblxuZnVuY3Rpb24gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gZXhjZXB0aW9ucy5tYXAoKGV4Y2VwdGlvbiwgaWR4KSA9PiBleGNlcHRpb24gPT0gbnVsbCA/IGxvYWRhYmxlV2l0aFZhbHVlJDQocmVzdWx0c1tpZHhdKSA6IFJlY29pbF9pc1Byb21pc2UoZXhjZXB0aW9uKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMyhleGNlcHRpb24pIDogbG9hZGFibGVXaXRoRXJyb3IkMyhleGNlcHRpb24pKTtcbiAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgb3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyhzeW5jUmVzdWx0cywgYXN5bmNSZXN1bHRzKSB7XG4gIHJldHVybiBhc3luY1Jlc3VsdHMubWFwKChyZXN1bHQsIGlkeCkgPT5cbiAgLyoqXG4gICAqIGl0J3MgaW1wb3J0YW50IHdlIHVzZSA9PT0gdW5kZWZpbmVkIGFzIG9wcG9zZWQgdG8gPT0gbnVsbCwgYmVjYXVzZSB0aGVcbiAgICogcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIGFzeW5jIHByb21pc2UgY291bGQgYmUgYG51bGxgLCBpbiB3aGljaCBjYXNlIHdlXG4gICAqIGRvbid0IHdhbnQgdG8gdXNlIHN5bmNSZXN1bHRzW2lkeF0sIHdoaWNoIHdvdWxkIGJlIHVuZGVmaW5lZC4gSWYgYXN5bmNcbiAgICogcHJvbWlzZSByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCwgdGhhdCdzIG9rIGJlY2F1c2UgYHN5bmNSZXN1bHRzW2lkeF1gXG4gICAqIHdpbGwgYWxzbyBiZSBgdW5kZWZpbmVkYC4gVGhhdCdzIGEgbGl0dGxlIGhhY2t5LCBidXQgaXQgd29ya3MuXG4gICAqL1xuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHN5bmNSZXN1bHRzW2lkeF0gOiByZXN1bHQpO1xufSAvLyBTZWxlY3RvciB0aGF0IHJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwgYW5kIGltbWVkaWF0ZWx5IHJldHVybnNcbi8vIGN1cnJlbnQgcmVzdWx0cyB3aXRob3V0IHdhaXRpbmcuXG5cblxuY29uc3Qgd2FpdEZvck5vbmUgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JOb25lJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gQWx3YXlzIHJldHVybiB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHJlc3VsdHM7IG5ldmVyIGJsb2NrLlxuXG4gICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pOyAvLyBTZWxlY3RvciB0aGF0IHJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwgYW5kIHdhaXRzIGZvciBhdCBsZWFzdFxuLy8gb25lIHRvIGJlIGF2YWlsYWJsZSBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuICBJdCB3aWxsIG9ubHkgZXJyb3IgaWYgYWxsXG4vLyBkZXBlbmRlbmNpZXMgaGF2ZSBlcnJvcnMuXG5cbmNvbnN0IHdhaXRGb3JBbnkgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbnknLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYW55IHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgdmFsdWUgb3IgZXJyb3IsIHJldHVybiB0aGUgY3VycmVudCBzdGF0dXNcblxuICAgIGlmIChleGNlcHRpb25zLnNvbWUoZXhwID0+ICFSZWNvaWxfaXNQcm9taXNlKGV4cCkpKSB7XG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIG5leHQgcmVzdWx0IGlzXG4gICAgLy8gYXZhaWxhYmxlLCB3aGljaGV2ZXIgb25lIGhhcHBlbnMgdG8gYmUgbmV4dC4gIEJ1dCwgaWYgYWxsIHBlbmRpbmdcbiAgICAvLyBkZXBlbmRlbmNpZXMgZW5kIHVwIHdpdGggZXJyb3JzLCB0aGVuIHJlamVjdCB0aGUgcHJvbWlzZS5cblxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgZm9yIChjb25zdCBbaSwgZXhwXSBvZiBleGNlcHRpb25zLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShleHApKSB7XG4gICAgICAgICAgZXhwLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICBleGNlcHRpb25zW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGFsbCB0byBiZVxuLy8gYXZhaWxhYmxlIGJlZm9yZSByZXR1cm5pbmcgYSB2YWx1ZS4gIEl0IHdpbGwgZXJyb3IgaWYgYW55IGRlcGVuZGVuY2llcyBlcnJvci5cblxuY29uc3Qgd2FpdEZvckFsbCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFsbCcsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBJZiBhbGwgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCByZXR1cm4gdGhlIHJlc3VsdHNcblxuICAgIGlmIChleGNlcHRpb25zLmV2ZXJ5KGV4cCA9PiBleHAgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMpO1xuICAgIH0gLy8gSWYgd2UgaGF2ZSBhbnkgZXJyb3JzLCB0aHJvdyB0aGUgZmlyc3QgZXJyb3JcblxuXG4gICAgY29uc3QgZXJyb3IgPSBleGNlcHRpb25zLmZpbmQoaXNFcnJvcik7XG5cbiAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBhbGwgcmVzdWx0cyBhcmUgYXZhaWxhYmxlXG5cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChleGNlcHRpb25zKS50aGVuKGV4Y2VwdGlvblJlc3VsdHMgPT4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCBjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzKHJlc3VsdHMsIGV4Y2VwdGlvblJlc3VsdHMpKSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTtcbmNvbnN0IHdhaXRGb3JBbGxTZXR0bGVkID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQWxsU2V0dGxlZCcsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBJZiBhbGwgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCByZXR1cm4gdGhlIHJlc3VsdHNcblxuICAgIGlmIChleGNlcHRpb25zLmV2ZXJ5KGV4cCA9PiAhUmVjb2lsX2lzUHJvbWlzZShleHApKSkge1xuICAgICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcbiAgICB9IC8vIFdhaXQgZm9yIGFsbCByZXN1bHRzIHRvIHNldHRsZVxuXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZXhjZXB0aW9ucy5tYXAoKGV4cCwgaSkgPT4gUmVjb2lsX2lzUHJvbWlzZShleHApID8gZXhwLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICBleGNlcHRpb25zW2ldID0gdW5kZWZpbmVkO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHJlc3VsdHNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICBleGNlcHRpb25zW2ldID0gZXJyb3I7XG4gICAgfSkgOiBudWxsKSkgLy8gVGhlbiB3cmFwIHRoZW0gYXMgbG9hZGFibGVzXG4gICAgLnRoZW4oKCkgPT4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xuY29uc3Qgbm9XYWl0ID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX19ub1dhaXQnLFxuICBnZXQ6IGRlcGVuZGVuY3kgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUmVjb2lsX3NlbGVjdG9yLnZhbHVlKGxvYWRhYmxlV2l0aFZhbHVlJDQoZ2V0KGRlcGVuZGVuY3kpKSk7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gUmVjb2lsX3NlbGVjdG9yLnZhbHVlKFJlY29pbF9pc1Byb21pc2UoZXhjZXB0aW9uKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMyhleGNlcHRpb24pIDogbG9hZGFibGVXaXRoRXJyb3IkMyhleGNlcHRpb24pKTtcbiAgICB9XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTtcbnZhciBSZWNvaWxfV2FpdEZvciA9IHtcbiAgd2FpdEZvck5vbmUsXG4gIHdhaXRGb3JBbnksXG4gIHdhaXRGb3JBbGwsXG4gIHdhaXRGb3JBbGxTZXR0bGVkLFxuICBub1dhaXRcbn07XG5cbmNvbnN0IHtcbiAgUmVjb2lsTG9hZGFibGVcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQzXG59ID0gUmVjb2lsX05vZGU7XG5cblxuXG5jb25zdCB7XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMixcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ1XG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgcmV0ZW50aW9uWm9uZTogcmV0ZW50aW9uWm9uZSQxXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XG5cbmNvbnN0IHtcbiAgZnJlc2hTbmFwc2hvdDogZnJlc2hTbmFwc2hvdCQyXG59ID0gUmVjb2lsX1NuYXBzaG90JDE7XG5cbmNvbnN0IHtcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsVmFsdWU6IHVzZVJlY29pbFZhbHVlJDEsXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDFcbn0gPSBSZWNvaWxfSG9va3M7XG5cbmNvbnN0IHtcbiAgdXNlR290b1JlY29pbFNuYXBzaG90OiB1c2VHb3RvUmVjb2lsU25hcHNob3QkMSxcbiAgdXNlUmVjb2lsU25hcHNob3Q6IHVzZVJlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXI6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMVxufSA9IFJlY29pbF9TbmFwc2hvdEhvb2tzO1xuXG5cblxuXG5cbmNvbnN0IHtcbiAgdXNlUmVjb2lsQ2FsbGJhY2s6IHVzZVJlY29pbENhbGxiYWNrJDFcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIG5vV2FpdDogbm9XYWl0JDEsXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcbiAgd2FpdEZvckFsbFNldHRsZWQ6IHdhaXRGb3JBbGxTZXR0bGVkJDEsXG4gIHdhaXRGb3JBbnk6IHdhaXRGb3JBbnkkMSxcbiAgd2FpdEZvck5vbmU6IHdhaXRGb3JOb25lJDFcbn0gPSBSZWNvaWxfV2FpdEZvcjtcblxudmFyIFJlY29pbF9pbmRleCA9IHtcbiAgLy8gVHlwZXNcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMyxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ1LFxuICBSZWNvaWxMb2FkYWJsZSxcbiAgLy8gR2xvYmFsIFJlY29pbCBlbnZpcm9ubWVudCBzZXR0aW9uZ3NcbiAgUmVjb2lsRW52OiBSZWNvaWxfUmVjb2lsRW52LFxuICAvLyBSZWNvaWwgUm9vdFxuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMSxcbiAgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRTogUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMsXG4gIC8vIEF0b21zL1NlbGVjdG9yc1xuICBhdG9tOiBSZWNvaWxfYXRvbSxcbiAgc2VsZWN0b3I6IFJlY29pbF9zZWxlY3RvcixcbiAgLy8gQ29udmVuaWVuY2UgQXRvbXMvU2VsZWN0b3JzXG4gIGF0b21GYW1pbHk6IFJlY29pbF9hdG9tRmFtaWx5LFxuICBzZWxlY3RvckZhbWlseTogUmVjb2lsX3NlbGVjdG9yRmFtaWx5LFxuICBjb25zdFNlbGVjdG9yOiBSZWNvaWxfY29uc3RTZWxlY3RvcixcbiAgZXJyb3JTZWxlY3RvcjogUmVjb2lsX2Vycm9yU2VsZWN0b3IsXG4gIHJlYWRPbmx5U2VsZWN0b3I6IFJlY29pbF9yZWFkT25seVNlbGVjdG9yLFxuICAvLyBDb25jdXJyZW5jeSBIZWxwZXJzIGZvciBBdG9tcy9TZWxlY3RvcnNcbiAgbm9XYWl0OiBub1dhaXQkMSxcbiAgd2FpdEZvck5vbmU6IHdhaXRGb3JOb25lJDEsXG4gIHdhaXRGb3JBbnk6IHdhaXRGb3JBbnkkMSxcbiAgd2FpdEZvckFsbDogd2FpdEZvckFsbCQxLFxuICB3YWl0Rm9yQWxsU2V0dGxlZDogd2FpdEZvckFsbFNldHRsZWQkMSxcbiAgLy8gSG9va3MgZm9yIEF0b21zL1NlbGVjdG9yc1xuICB1c2VSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUkMSxcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSQxLFxuICB1c2VSZWNvaWxTdGF0ZTogdXNlUmVjb2lsU3RhdGUkMSxcbiAgdXNlUmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSQxLFxuICB1c2VTZXRSZWNvaWxTdGF0ZTogdXNlU2V0UmVjb2lsU3RhdGUkMSxcbiAgdXNlUmVzZXRSZWNvaWxTdGF0ZTogdXNlUmVzZXRSZWNvaWxTdGF0ZSQxLFxuICB1c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU6IFJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8sXG4gIHVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRTogUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlcixcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEsXG4gIC8vIEhvb2tzIGZvciBjb21wbGV4IG9wZXJhdGlvbnNcbiAgdXNlUmVjb2lsQ2FsbGJhY2s6IHVzZVJlY29pbENhbGxiYWNrJDEsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsVHJhbnNhY3Rpb24sXG4gIC8vIFNuYXBzaG90c1xuICB1c2VHb3RvUmVjb2lsU25hcHNob3Q6IHVzZUdvdG9SZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxTbmFwc2hvdDogdXNlUmVjb2lsU25hcHNob3QkMSxcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRTogdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciQxLFxuICBzbmFwc2hvdF9VTlNUQUJMRTogZnJlc2hTbmFwc2hvdCQyLFxuICAvLyBNZW1vcnkgTWFuYWdlbWVudFxuICB1c2VSZXRhaW46IFJlY29pbF91c2VSZXRhaW4sXG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxufTtcbnZhciBSZWNvaWxfaW5kZXhfMSA9IFJlY29pbF9pbmRleC5EZWZhdWx0VmFsdWU7XG52YXIgUmVjb2lsX2luZGV4XzIgPSBSZWNvaWxfaW5kZXguaXNSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMyA9IFJlY29pbF9pbmRleC5SZWNvaWxMb2FkYWJsZTtcbnZhciBSZWNvaWxfaW5kZXhfNCA9IFJlY29pbF9pbmRleC5SZWNvaWxFbnY7XG52YXIgUmVjb2lsX2luZGV4XzUgPSBSZWNvaWxfaW5kZXguUmVjb2lsUm9vdDtcbnZhciBSZWNvaWxfaW5kZXhfNiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTdG9yZUlEO1xudmFyIFJlY29pbF9pbmRleF83ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzggPSBSZWNvaWxfaW5kZXguYXRvbTtcbnZhciBSZWNvaWxfaW5kZXhfOSA9IFJlY29pbF9pbmRleC5zZWxlY3RvcjtcbnZhciBSZWNvaWxfaW5kZXhfMTAgPSBSZWNvaWxfaW5kZXguYXRvbUZhbWlseTtcbnZhciBSZWNvaWxfaW5kZXhfMTEgPSBSZWNvaWxfaW5kZXguc2VsZWN0b3JGYW1pbHk7XG52YXIgUmVjb2lsX2luZGV4XzEyID0gUmVjb2lsX2luZGV4LmNvbnN0U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEzID0gUmVjb2lsX2luZGV4LmVycm9yU2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzE0ID0gUmVjb2lsX2luZGV4LnJlYWRPbmx5U2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzE1ID0gUmVjb2lsX2luZGV4Lm5vV2FpdDtcbnZhciBSZWNvaWxfaW5kZXhfMTYgPSBSZWNvaWxfaW5kZXgud2FpdEZvck5vbmU7XG52YXIgUmVjb2lsX2luZGV4XzE3ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbnk7XG52YXIgUmVjb2lsX2luZGV4XzE4ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGw7XG52YXIgUmVjb2lsX2luZGV4XzE5ID0gUmVjb2lsX2luZGV4LndhaXRGb3JBbGxTZXR0bGVkO1xudmFyIFJlY29pbF9pbmRleF8yMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZTtcbnZhciBSZWNvaWxfaW5kZXhfMjIgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGU7XG52YXIgUmVjb2lsX2luZGV4XzIzID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzI0ID0gUmVjb2lsX2luZGV4LnVzZVNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNSA9IFJlY29pbF9pbmRleC51c2VSZXNldFJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yNiA9IFJlY29pbF9pbmRleC51c2VHZXRSZWNvaWxWYWx1ZUluZm9fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI3ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjggPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI5ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzAgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxDYWxsYmFjaztcbnZhciBSZWNvaWxfaW5kZXhfMzIgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMzID0gUmVjb2lsX2luZGV4LnVzZUdvdG9SZWNvaWxTbmFwc2hvdDtcbnZhciBSZWNvaWxfaW5kZXhfMzQgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU25hcHNob3Q7XG52YXIgUmVjb2lsX2luZGV4XzM1ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzM2ID0gUmVjb2lsX2luZGV4LnNuYXBzaG90X1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zNyA9IFJlY29pbF9pbmRleC51c2VSZXRhaW47XG52YXIgUmVjb2lsX2luZGV4XzM4ID0gUmVjb2lsX2luZGV4LnJldGVudGlvblpvbmU7XG5cbmV4cG9ydHMuRGVmYXVsdFZhbHVlID0gUmVjb2lsX2luZGV4XzE7XG5leHBvcnRzLlJlY29pbEVudiA9IFJlY29pbF9pbmRleF80O1xuZXhwb3J0cy5SZWNvaWxMb2FkYWJsZSA9IFJlY29pbF9pbmRleF8zO1xuZXhwb3J0cy5SZWNvaWxSb290ID0gUmVjb2lsX2luZGV4XzU7XG5leHBvcnRzLmF0b20gPSBSZWNvaWxfaW5kZXhfODtcbmV4cG9ydHMuYXRvbUZhbWlseSA9IFJlY29pbF9pbmRleF8xMDtcbmV4cG9ydHMuY29uc3RTZWxlY3RvciA9IFJlY29pbF9pbmRleF8xMjtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlY29pbF9pbmRleDtcbmV4cG9ydHMuZXJyb3JTZWxlY3RvciA9IFJlY29pbF9pbmRleF8xMztcbmV4cG9ydHMuaXNSZWNvaWxWYWx1ZSA9IFJlY29pbF9pbmRleF8yO1xuZXhwb3J0cy5ub1dhaXQgPSBSZWNvaWxfaW5kZXhfMTU7XG5leHBvcnRzLnJlYWRPbmx5U2VsZWN0b3IgPSBSZWNvaWxfaW5kZXhfMTQ7XG5leHBvcnRzLnJldGVudGlvblpvbmUgPSBSZWNvaWxfaW5kZXhfMzg7XG5leHBvcnRzLnNlbGVjdG9yID0gUmVjb2lsX2luZGV4Xzk7XG5leHBvcnRzLnNlbGVjdG9yRmFtaWx5ID0gUmVjb2lsX2luZGV4XzExO1xuZXhwb3J0cy5zbmFwc2hvdF9VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8zNjtcbmV4cG9ydHMudXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFID0gUmVjb2lsX2luZGV4XzI2O1xuZXhwb3J0cy51c2VHb3RvUmVjb2lsU25hcHNob3QgPSBSZWNvaWxfaW5kZXhfMzM7XG5leHBvcnRzLnVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfNztcbmV4cG9ydHMudXNlUmVjb2lsQ2FsbGJhY2sgPSBSZWNvaWxfaW5kZXhfMzE7XG5leHBvcnRzLnVzZVJlY29pbFJlZnJlc2hlcl9VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8yNztcbmV4cG9ydHMudXNlUmVjb2lsU25hcHNob3QgPSBSZWNvaWxfaW5kZXhfMzQ7XG5leHBvcnRzLnVzZVJlY29pbFN0YXRlID0gUmVjb2lsX2luZGV4XzIyO1xuZXhwb3J0cy51c2VSZWNvaWxTdGF0ZUxvYWRhYmxlID0gUmVjb2lsX2luZGV4XzIzO1xuZXhwb3J0cy51c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMzA7XG5leHBvcnRzLnVzZVJlY29pbFN0b3JlSUQgPSBSZWNvaWxfaW5kZXhfNjtcbmV4cG9ydHMudXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8zNTtcbmV4cG9ydHMudXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMzI7XG5leHBvcnRzLnVzZVJlY29pbFZhbHVlID0gUmVjb2lsX2luZGV4XzIwO1xuZXhwb3J0cy51c2VSZWNvaWxWYWx1ZUxvYWRhYmxlID0gUmVjb2lsX2luZGV4XzIxO1xuZXhwb3J0cy51c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8yODtcbmV4cG9ydHMudXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFID0gUmVjb2lsX2luZGV4XzI5O1xuZXhwb3J0cy51c2VSZXNldFJlY29pbFN0YXRlID0gUmVjb2lsX2luZGV4XzI1O1xuZXhwb3J0cy51c2VSZXRhaW4gPSBSZWNvaWxfaW5kZXhfMzc7XG5leHBvcnRzLnVzZVNldFJlY29pbFN0YXRlID0gUmVjb2lsX2luZGV4XzI0O1xuZXhwb3J0cy53YWl0Rm9yQWxsID0gUmVjb2lsX2luZGV4XzE4O1xuZXhwb3J0cy53YWl0Rm9yQWxsU2V0dGxlZCA9IFJlY29pbF9pbmRleF8xOTtcbmV4cG9ydHMud2FpdEZvckFueSA9IFJlY29pbF9pbmRleF8xNztcbmV4cG9ydHMud2FpdEZvck5vbmUgPSBSZWNvaWxfaW5kZXhfMTY7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfaW50ZXJvcERlZmF1bHQiLCJleCIsInJlYWN0IiwicmVxdWlyZSIsInJlYWN0RG9tIiwiZXJyIiwibWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsInVuZGVmaW5lZCIsIl8iLCJlcnJfMSIsIlJlY29pbF9lcnIiLCJpc1Byb21pc2UiLCJwIiwidGhlbiIsIlJlY29pbF9pc1Byb21pc2UiLCJudWxsdGhyb3dzIiwieCIsIlJlY29pbF9udWxsdGhyb3dzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiQmFzZUxvYWRhYmxlIiwiZ2V0VmFsdWUiLCJ0b1Byb21pc2UiLCJ2YWx1ZU1heWJlIiwidmFsdWVPclRocm93Iiwic3RhdGUiLCJwcm9taXNlTWF5YmUiLCJwcm9taXNlT3JUaHJvdyIsImVycm9yTWF5YmUiLCJlcnJvck9yVGhyb3ciLCJpcyIsIm90aGVyIiwiY29udGVudHMiLCJtYXAiLCJfbWFwIiwiVmFsdWVMb2FkYWJsZSIsImNvbnN0cnVjdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJuZXh0IiwibG9hZGFibGVXaXRoUHJvbWlzZSIsImlzTG9hZGFibGUiLCJsb2FkYWJsZVdpdGhWYWx1ZSIsImUiLCJsb2FkYWJsZVdpdGhFcnJvciIsIkVycm9yTG9hZGFibGUiLCJyZWplY3QiLCJMb2FkaW5nTG9hZGFibGUiLCJwcm9taXNlIiwibmV4dExvYWRhYmxlIiwiY2F0Y2giLCJmcmVlemUiLCJsb2FkYWJsZUxvYWRpbmciLCJsb2FkYWJsZUFsbEFycmF5IiwiaW5wdXRzIiwiZXZlcnkiLCJpIiwic29tZSIsImZpbmQiLCJhbGwiLCJsb2FkYWJsZUFsbCIsInVud3JhcGVkSW5wdXRzIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm5vcm1hbGl6ZWRJbnB1dHMiLCJvdXRwdXQiLCJvdXRwdXRzIiwicmVkdWNlIiwib3V0IiwiaWR4IiwiTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UiLCJvZiIsImxvYWRpbmciLCJSZWNvaWxfTG9hZGFibGUiLCJSZWNvaWxMb2FkYWJsZSIsIlJlY29pbF9Mb2FkYWJsZV8xIiwiUmVjb2lsX0xvYWRhYmxlXzIiLCJSZWNvaWxfTG9hZGFibGVfMyIsIlJlY29pbF9Mb2FkYWJsZV80IiwiUmVjb2lsX0xvYWRhYmxlXzUiLCJSZWNvaWxfTG9hZGFibGVfNiIsIlJlY29pbF9Mb2FkYWJsZV83IiwiUmVjb2lsX0xvYWRhYmxlJDEiLCJfX3Byb3RvX18iLCJna3MiLCJNYXAiLCJzZXQiLCJSZWNvaWxfZ2t4X09TUyIsImdrIiwiX2drcyRnZXQiLCJnZXQiLCJzZXRQYXNzIiwic2V0RmFpbCIsImNsZWFyIiwiUmVjb2lsX2dreCIsInJlY292ZXJhYmxlVmlvbGF0aW9uIiwiX3Byb2plY3ROYW1lIiwicHJvY2VzcyIsImNvbnNvbGUiLCJyZWNvdmVyYWJsZVZpb2xhdGlvbl8xIiwiUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uIiwiX2NyZWF0ZU11dGFibGVTb3VyY2UiLCJfdXNlTXV0YWJsZVNvdXJjZSIsIl91c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImNyZWF0ZU11dGFibGVTb3VyY2UiLCJ1bnN0YWJsZV9jcmVhdGVNdXRhYmxlU291cmNlIiwidXNlTXV0YWJsZVNvdXJjZSIsInVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVuc3RhYmxlX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwiUmVhY3RSZW5kZXJlclZlcnNpb25NaXNtYXRjaFdhcm5PbmNlIiwiY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSIsIl9SZWFjdEN1cnJlbnREaXNwYXRjaCIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnRPd25lciIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZGlzcGF0Y2hlciIsImN1cnJlbnQiLCJjdXJyZW50RGlzcGF0Y2hlciIsImlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQiLCJyZWFjdE1vZGUiLCJtb2RlIiwiZWFybHkiLCJjb25jdXJyZW50Iiwid2luZG93IiwiJGRpc2FibGVSZWNvaWxWYWx1ZU11dGFibGVTb3VyY2VfVEVNUF9IQUNLX0RPX05PVF9VU0UiLCJpc0Zhc3RSZWZyZXNoRW5hYmxlZCIsIlJlY29pbF9SZWFjdE1vZGUiLCJlbnYiLCJSRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQiLCJhcHBseVByb2Nlc3NFbnZGbGFnT3ZlcnJpZGVzIiwiX3Byb2Nlc3MiLCJfcHJvY2VzcyRlbnYkUkVDT0lMX0QiLCJfcHJvY2VzcyRlbnYkUkVDT0lMX0QyIiwic2FuaXRpemVkVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJhbGxvd2VkVmFsdWVzIiwiaW5jbHVkZXMiLCJSZWNvaWxfUmVjb2lsRW52IiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSIsIm5ld0tleSIsInRvSlNPTiIsIlJlY29pbFN0YXRlIiwiUmVjb2lsVmFsdWVSZWFkT25seSIsImlzUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWUiLCJSZWNvaWxfUmVjb2lsVmFsdWVfMSIsIlJlY29pbF9SZWNvaWxWYWx1ZV8yIiwiUmVjb2lsX1JlY29pbFZhbHVlXzMiLCJSZWNvaWxfUmVjb2lsVmFsdWVfNCIsIlJlY29pbF9SZWNvaWxWYWx1ZSQxIiwic3ByaW50ZiIsImZvcm1hdCIsImFyZ3MiLCJpbmRleCIsInJlcGxhY2UiLCJTdHJpbmciLCJzcHJpbnRmXzEiLCJleHBlY3RhdGlvblZpb2xhdGlvbiIsImNhbGwiLCJuYW1lIiwiZXhwZWN0YXRpb25WaW9sYXRpb25fMSIsIlJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbiIsIm1hcEl0ZXJhYmxlIiwiaXRlcmFibGUiLCJjYWxsYmFjayIsIlJlY29pbF9tYXBJdGVyYWJsZSIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDEiLCJEZWZhdWx0VmFsdWUiLCJERUZBVUxUX1ZBTFVFIiwibm9kZXMiLCJyZWNvaWxWYWx1ZXMiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzIiwia2V5cyIsImNoZWNrRm9yRHVwbGljYXRlQXRvbUtleSIsImhhcyIsIndhcm4iLCJyZWdpc3Rlck5vZGUiLCJub2RlIiwicmVjb2lsVmFsdWUiLCJOb2RlTWlzc2luZ0Vycm9yIiwiZ2V0Tm9kZSIsImdldE5vZGVNYXliZSIsImNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMiLCJkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSIsIl9ub2RlJHNob3VsZERlbGV0ZUNvbiIsInNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSIsIl9nZXRDb25maWdEZWxldGlvbkhhbiIsImRlbGV0ZSIsImdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciIsImZuIiwiUmVjb2lsX05vZGUiLCJlbnF1ZXVlRXhlY3V0aW9uIiwicyIsImYiLCJSZWNvaWxfUXVldWUiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsIm1vZHVsZSIsImhhbXRfMSIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsInByb3RvdHlwZSIsImhhbXQiLCJTSVpFIiwiQlVDS0VUX1NJWkUiLCJNYXRoIiwicG93IiwiTUFTSyIsIk1BWF9JTkRFWF9OT0RFIiwiTUlOX0FSUkFZX05PREUiLCJub3RoaW5nIiwiY29uc3RhbnQiLCJoYXNoIiwic3RyIiwidHlwZSIsImxlbiIsImxlbmd0aCIsImMiLCJjaGFyQ29kZUF0IiwicG9wY291bnQiLCJoYXNoRnJhZ21lbnQiLCJzaGlmdCIsImgiLCJ0b0JpdG1hcCIsImZyb21CaXRtYXAiLCJiaXRtYXAiLCJiaXQiLCJhcnJheVVwZGF0ZSIsIm11dGF0ZSIsImF0IiwidiIsImFyciIsImFycmF5U3BsaWNlT3V0IiwibmV3TGVuIiwiZyIsImFycmF5U3BsaWNlSW4iLCJfaSIsIkxFQUYiLCJDT0xMSVNJT04iLCJJTkRFWCIsIkFSUkFZIiwiZW1wdHkiLCJfX2hhbXRfaXNFbXB0eSIsImlzRW1wdHlOb2RlIiwiTGVhZiIsImVkaXQiLCJfbW9kaWZ5IiwiTGVhZl9fbW9kaWZ5IiwiQ29sbGlzaW9uIiwiY2hpbGRyZW4iLCJDb2xsaXNpb25fX21vZGlmeSIsIkluZGV4ZWROb2RlIiwibWFzayIsIkluZGV4ZWROb2RlX19tb2RpZnkiLCJBcnJheU5vZGUiLCJzaXplIiwiQXJyYXlOb2RlX19tb2RpZnkiLCJpc0xlYWYiLCJleHBhbmQiLCJmcmFnIiwiY2hpbGQiLCJzdWJOb2RlcyIsImNvdW50IiwicGFjayIsInJlbW92ZWQiLCJlbGVtZW50cyIsImVsZW0iLCJtZXJnZUxlYXZlcyIsImgxIiwibjEiLCJoMiIsIm4yIiwic3ViSDEiLCJzdWJIMiIsInVwZGF0ZUNvbGxpc2lvbkxpc3QiLCJrZXlFcSIsImxpc3QiLCJrIiwiX25ld1ZhbHVlIiwibmV3VmFsdWUiLCJjYW5FZGl0Tm9kZSIsIl92IiwiY2FuRWRpdCIsImluZHgiLCJleGlzdHMiLCJuZXdDaGlsZHJlbiIsIm5ld0NoaWxkIiwiZWRpdGFibGUiLCJjb25maWciLCJyb290IiwiX2VkaXRhYmxlIiwiX2VkaXQiLCJfY29uZmlnIiwiX3Jvb3QiLCJfc2l6ZSIsInNldFRyZWUiLCJuZXdSb290IiwibmV3U2l6ZSIsInRyeUdldEhhc2giLCJhbHQiLCJ0cnlHZXQiLCJnZXRIYXNoIiwiaGFzSGFzaCIsImRlZktleUNvbXBhcmUiLCJ5IiwibWFrZSIsImlzRW1wdHkiLCJtb2RpZnlIYXNoIiwiTmFOIiwibW9kaWZ5Iiwic2V0SGFzaCIsImRlbCIsInJlbW92ZUhhc2giLCJkZWxldGVIYXNoIiwicmVtb3ZlIiwiYmVnaW5NdXRhdGlvbiIsImVuZE11dGF0aW9uIiwidHJhbnNpZW50IiwiYXBwayIsImxhenlWaXNpdENoaWxkcmVuIiwibGF6eVZpc2l0IiwicmVzdCIsIkRPTkUiLCJkb25lIiwiTWFwSXRlcmF0b3IiLCJ2MCIsInZpc2l0IiwiYnVpbGRQYWlycyIsImVudHJpZXMiLCJidWlsZEtleXMiLCJidWlsZFZhbHVlcyIsInZhbHVlcyIsImZvbGQiLCJ6IiwibSIsInRvVmlzaXQiLCJwb3AiLCJwdXNoIiwiZm9yRWFjaCIsIkJ1aWx0SW5NYXAiLCJleGlzdGluZyIsImNsb25lIiwicGVyc2lzdGVudE1hcCIsInRvTWFwIiwiSGFzaEFycmF5TWFwcGVkVHJpZU1hcCIsIl9oYW10IiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAiLCJSZWNvaWxfUGVyc2lzdGVudE1hcF8xIiwiUmVjb2lsX1BlcnNpc3RlbnRNYXAkMSIsImRpZmZlcmVuY2VTZXRzIiwic2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSIsInJldCIsIlNldCIsIkZJUlNUIiwib3RoZXJTZXQiLCJhZGQiLCJSZWNvaWxfZGlmZmVyZW5jZVNldHMiLCJtYXBNYXAiLCJyZXN1bHQiLCJSZWNvaWxfbWFwTWFwIiwibWFrZUdyYXBoIiwibm9kZURlcHMiLCJub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucyIsImNsb25lR3JhcGgiLCJncmFwaCIsIm1lcmdlRGVwc0ludG9HcmFwaCIsIm5ld0RlcHMiLCJvbGRlckdyYXBoIiwib2xkRGVwcyIsImFkZGVkRGVwcyIsImRlcCIsInJlbW92ZWREZXBzIiwic2F2ZURlcHNUb1N0b3JlIiwiZGVwcyIsInN0b3JlIiwidmVyc2lvbiIsIl9zdG9yZVN0YXRlJG5leHRUcmVlIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUIiwiX3N0b3JlU3RhdGUkcHJldmlvdXNUMiIsIl9zdG9yZVN0YXRlJHByZXZpb3VzVDMiLCJzdG9yZVN0YXRlIiwiZ2V0U3RhdGUiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwicHJldmlvdXNUcmVlIiwiZ2V0R3JhcGgiLCJjdXJyZW50R3JhcGgiLCJfc3RvcmVTdGF0ZSRuZXh0VHJlZTIiLCJuZXh0VmVyc2lvbiIsIm5leHRHcmFwaCIsIlJlY29pbF9HcmFwaCIsIm5leHRUcmVlU3RhdGVWZXJzaW9uIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24iLCJuZXh0U3RvcmVJRCIsImdldE5leHRTdG9yZUlEIiwibmV4dENvbXBvbmVudElEIiwiZ2V0TmV4dENvbXBvbmVudElEIiwiUmVjb2lsX0tleXMiLCJwZXJzaXN0ZW50TWFwJDEiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxIiwibWFrZUVtcHR5VHJlZVN0YXRlIiwic3RhdGVJRCIsInRyYW5zYWN0aW9uTWV0YWRhdGEiLCJkaXJ0eUF0b21zIiwiYXRvbVZhbHVlcyIsIm5vbnZhbGlkYXRlZEF0b21zIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSIsImNvbW1pdERlcHRoIiwia25vd25BdG9tcyIsImtub3duU2VsZWN0b3JzIiwidHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zIiwibm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucyIsIm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMiLCJxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCIsInN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycyIsImdyYXBoc0J5VmVyc2lvbiIsInJldGVudGlvbiIsInJlZmVyZW5jZUNvdW50cyIsIm5vZGVzUmV0YWluZWRCeVpvbmUiLCJyZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlIiwibm9kZUNsZWFudXBGdW5jdGlvbnMiLCJSZWNvaWxfU3RhdGUiLCJSZXRlbnRpb25ab25lIiwicmV0ZW50aW9uWm9uZSIsIlJlY29pbF9SZXRlbnRpb25ab25lIiwic2V0QnlBZGRpbmdUb1NldCIsInNldEJ5RGVsZXRpbmdGcm9tU2V0IiwibWFwQnlTZXR0aW5nSW5NYXAiLCJtYXBCeVVwZGF0aW5nSW5NYXAiLCJ1cGRhdGVyIiwibWFwQnlEZWxldGluZ0Zyb21NYXAiLCJtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwIiwia3MiLCJSZWNvaWxfQ29weU9uV3JpdGUiLCJmaWx0ZXJJdGVyYWJsZSIsInByZWRpY2F0ZSIsIlJlY29pbF9maWx0ZXJJdGVyYWJsZSIsImxhenlQcm94eSIsImJhc2UiLCJmYWN0b3JpZXMiLCJwcm94eSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsIm93bktleXMiLCJSZWNvaWxfbGF6eVByb3h5IiwiZ2V0Tm9kZSQxIiwiZ2V0Tm9kZU1heWJlJDEiLCJyZWNvaWxWYWx1ZXNGb3JLZXlzJDEiLCJSZXRlbnRpb25ab25lJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDEiLCJlbXB0eVNldCIsIlJlYWRPbmx5UmVjb2lsVmFsdWVFcnJvciIsImluaXRpYWxpemVSZXRlbnRpb25Gb3JOb2RlIiwibm9kZUtleSIsInJldGFpbmVkQnkiLCJhZGRUb1pvbmUiLCJ6b25lIiwiZGVsZXRlRnJvbVpvbmUiLCJpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZSIsInRyZWVTdGF0ZSIsInRyaWdnZXIiLCJyZXRlbnRpb25DbGVhbnVwIiwibm9kZUNsZWFudXAiLCJpbml0IiwiaW5pdGlhbGl6ZU5vZGUiLCJjbGVhblVwTm9kZSIsIl9zdGF0ZSRub2RlQ2xlYW51cEZ1biIsImdldE5vZGVMb2FkYWJsZSIsInBlZWtOb2RlTG9hZGFibGUiLCJwZWVrIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCIsIl9ub2RlJGludmFsaWRhdGUiLCJpbnZhbGlkYXRlIiwic2V0Tm9kZVZhbHVlIiwicGVla05vZGVJbmZvIiwibm9kZVR5cGUiLCJsb2FkYWJsZSIsImlzQWN0aXZlIiwiaXNTZXQiLCJpc01vZGlmaWVkIiwiX2dyYXBoJG5vZGVEZXBzJGdldCIsInN1YnNjcmliZXJzIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tIiwiX3N0b3JlU3RhdGUkbm9kZVRvQ29tMiIsImdldERvd25zdHJlYW1Ob2RlcyIsImNvbXBvbmVudHMiLCJ2aXNpdGVkTm9kZXMiLCJ2aXNpdGluZ05vZGVzIiwiZnJvbSIsIl9ncmFwaCRub2RlVG9Ob2RlU3VicyIsInN1YnNjcmliZWROb2RlcyIsImRvd25zdHJlYW1Ob2RlIiwiUmVjb2lsX0Z1bmN0aW9uYWxDb3JlIiwiX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90Iiwic2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QiLCJpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCIsIl9pbnZhbGlkYXRlTWVtb2l6ZWRTbiIsIlJlY29pbF9TbmFwc2hvdENhY2hlIiwiZ2V0RG93bnN0cmVhbU5vZGVzJDEiLCJnZXROb2RlTG9hZGFibGUkMSIsInNldE5vZGVWYWx1ZSQxIiwiZ2V0TmV4dENvbXBvbmVudElEJDEiLCJnZXROb2RlJDIiLCJnZXROb2RlTWF5YmUkMiIsIkRlZmF1bHRWYWx1ZSQxIiwicmVhY3RNb2RlJDEiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDEiLCJSZWNvaWxTdGF0ZSQxIiwiUmVjb2lsVmFsdWVSZWFkT25seSQxIiwiaXNSZWNvaWxWYWx1ZSQxIiwiaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSIsImFwcGx5QXRvbVZhbHVlV3JpdGVzIiwid3JpdGVzIiwidmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIiLCJ2YWx1ZU9yVXBkYXRlciIsIm1zZyIsImFwcGx5QWN0aW9uIiwiYWN0aW9uIiwid3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlIiwidW52YWxpZGF0ZWRWYWx1ZSIsImFwcGx5QWN0aW9uc1RvU3RvcmUiLCJhY3Rpb25zIiwicmVwbGFjZVN0YXRlIiwibmV3U3RhdGUiLCJjb3B5VHJlZVN0YXRlIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zIiwicXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZSIsImJhdGNoU3RhY2siLCJhY3Rpb25zQnlTdG9yZSIsImJhdGNoU3RhcnQiLCJwb3BwZWQiLCJkb3duc3RyZWFtcyIsIl9nZXROb2RlTWF5YmUiLCJfZ2V0Tm9kZU1heWJlJGludmFsaWQiLCJzZXRSZWNvaWxWYWx1ZSIsInNldFJlY29pbFZhbHVlTG9hZGFibGUiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlIiwiY29tcG9uZW50RGVidWdOYW1lIiwic3ViSUQiLCJyZWxlYXNlIiwicmVsZWFzZVN0b3JlU3RhdGUiLCJzdWJzIiwicmVmcmVzaFJlY29pbFZhbHVlIiwiX25vZGUkY2xlYXJDYWNoZSIsImNsZWFyQ2FjaGUiLCJSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UiLCJzb21lU2V0IiwiY29udGV4dCIsImVudHJ5IiwiUmVjb2lsX3NvbWVTZXQiLCJjbGVhblVwTm9kZSQxIiwiZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUkMSIsImdldE5vZGUkMyIsIlJldGVudGlvblpvbmUkMiIsIlNVU1BFTlNFX1RJTUVPVVRfTVMiLCJlbXB0eVNldCQxIiwicmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZSIsInJldGFpbmFibGVzIiwiciIsIm4iLCJyZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzIiwicmVsZWFzZU5vZGUiLCJzZWFyY2hGcm9tTm9kZXMiLCJub25SZWxlYXNhYmxlTm9kZXMiLCJmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIiLCJyZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24iLCJnZXREb3duc3RyZWFtTm9kZXNJblRvcG9sb2dpY2FsT3JkZXIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24iLCJ6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUiLCJub2RlQ2hpbGRyZW4iLCJwYXJlbnRzIiwicGFyZW50IiwiZG9Ob3REZXNjZW5kSW50bzEiLCJkb05vdERlc2NlbmRJbnRvMiIsImFuc3dlciIsInZpc2l0ZWQiLCJ6b25lcyIsIl9zdG9yZVN0YXRlJHJldGVudGlvbjIiLCJfc3RvcmVTdGF0ZSRyZXRlbnRpb24zIiwic2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUiLCJyZXRhaW5hYmxlIiwidXBkYXRlUmV0YWluQ291bnQiLCJkZWx0YSIsIl9tYXAkZ2V0IiwibmV3Q291bnQiLCJ1cGRhdGVSZXRhaW5Db3VudFRvWmVybyIsInJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCIsIlJlY29pbF9SZXRlbnRpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsIlJlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxIiwiUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaFN0YXJ0JDEiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyIiwiYmF0Y2hlciIsInNldEJhdGNoZXIiLCJuZXdCYXRjaGVyIiwiZ2V0QmF0Y2hlciIsImJhdGNoVXBkYXRlcyIsImJhdGNoRW5kIiwiUmVjb2lsX0JhdGNoaW5nIiwiY29uY2F0SXRlcmFibGVzIiwiaXRlcnMiLCJpdGVyIiwidmFsIiwiUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyIsImlzU1NSIiwiV2luZG93IiwiaXNXaW5kb3ciLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIlJlY29pbF9FbnZpcm9ubWVudCIsIm1lbW9pemVXaXRoQXJnc0hhc2giLCJoYXNoRnVuY3Rpb24iLCJjYWNoZSIsIm1lbW9pemVkRm4iLCJoYXNPd25Qcm9wZXJ0eSIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2giLCJsYXN0S2V5IiwibGFzdFJlc3VsdCIsIm1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24iLCJSZWNvaWxfTWVtb2l6ZSIsImJhdGNoVXBkYXRlcyQxIiwiaW5pdGlhbGl6ZU5vZGUkMSIsInBlZWtOb2RlSW5mbyQxIiwiZ3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDEiLCJERUZBVUxUX1ZBTFVFJDEiLCJyZWNvaWxWYWx1ZXMkMSIsInJlY29pbFZhbHVlc0ZvcktleXMkMiIsIkFic3RyYWN0UmVjb2lsVmFsdWUkMiIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxIiwic2V0UmVjb2lsVmFsdWUkMSIsInNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMSIsInVwZGF0ZVJldGFpbkNvdW50JDEiLCJzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxIiwiZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMiIsIm1ha2VFbXB0eVN0b3JlU3RhdGUkMSIsImlzU1NSJDEiLCJtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEiLCJyZXRhaW5XYXJuaW5nIiwiU25hcHNob3QiLCJwYXJlbnRTdG9yZUlEIiwiY2hlY2tSZWZDb3VudF9JTlRFUk5BTCIsIl9zdG9yZSIsImdldExvYWRhYmxlIiwib3B0IiwiaXNJbml0aWFsaXplZCIsIm1hcHBlciIsIm11dGFibGVTbmFwc2hvdCIsIk11dGFibGVTbmFwc2hvdCIsInJldGFpbiIsImF1dG9SZWxlYXNlX0lOVEVSTkFMIiwic3RvcmVJRCIsInJlcGxhY2VyIiwiZ3JhcGhzIiwibmV3R3JhcGgiLCJzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyIsImFkZFRyYW5zYWN0aW9uTWV0YWRhdGEiLCJfcmVmQ291bnQiLCJyZWxlYXNlZCIsIl9yZWxlYXNlIiwic2V0VGltZW91dCIsImNsZWFudXAiLCJpc1JldGFpbmVkIiwiZ2V0U3RvcmVfSU5URVJOQUwiLCJnZXRJRCIsImdldFN0b3JlSUQiLCJjbG9uZVN0b3JlU3RhdGUiLCJidW1wVmVyc2lvbiIsImZyZXNoU25hcHNob3QiLCJpbml0aWFsaXplU3RhdGUiLCJzbmFwc2hvdCIsIm1lbW9pemVkQ2xvbmVTbmFwc2hvdCIsImludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQiLCJfc3RvcmUkZ2V0U3RhdGUkcHJldmkiLCJjbG9uZVNuYXBzaG90IiwiYmF0Y2giLCJyZWNvaWxTdGF0ZSIsIm5ld1ZhbHVlT3JVcGRhdGVyIiwiX2JhdGNoIiwiUmVjb2lsX1NuYXBzaG90IiwiUmVjb2lsX1NuYXBzaG90XzEiLCJSZWNvaWxfU25hcHNob3RfMiIsIlJlY29pbF9TbmFwc2hvdF8zIiwiUmVjb2lsX1NuYXBzaG90XzQiLCJSZWNvaWxfU25hcHNob3QkMSIsInVuaW9uU2V0cyIsInNldHMiLCJSZWNvaWxfdW5pb25TZXRzIiwidXNlUmVmIiwidXNlUmVmSW5pdE9uY2UiLCJpbml0aWFsVmFsdWUiLCJyZWYiLCJSZWNvaWxfdXNlUmVmSW5pdE9uY2UiLCJnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQzIiwibWFrZUVtcHR5U3RvcmVTdGF0ZSQyIiwiY2xlYW5VcE5vZGUkMiIsImdldERvd25zdHJlYW1Ob2RlcyQyIiwiaW5pdGlhbGl6ZU5vZGUkMiIsInNldE5vZGVWYWx1ZSQyIiwic2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxIiwiZ3JhcGgkMiIsImNsb25lR3JhcGgkMSIsImdldE5leHRTdG9yZUlEJDIiLCJjcmVhdGVNdXRhYmxlU291cmNlJDEiLCJyZWFjdE1vZGUkMiIsImFwcGx5QXRvbVZhbHVlV3JpdGVzJDEiLCJyZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMSIsImZyZXNoU25hcHNob3QkMSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYkMSIsInVzZVN0YXRlIiwibm90SW5BQ29udGV4dCIsImRlZmF1bHRTdG9yZSIsInN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQiLCJzdGFydE5leHRUcmVlSWZOZWVkZWQiLCJBcHBDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0b3JlUmVmIiwiTXV0YWJsZVNvdXJjZUNvbnRleHQiLCJ1c2VSZWNvaWxNdXRhYmxlU291cmNlIiwibXV0YWJsZVNvdXJjZSIsIm5vdGlmeUNvbXBvbmVudHMiLCJkZXBlbmRlbnROb2RlcyIsImNvbXBzIiwiX3N1YklEIiwiX2RlYnVnTmFtZSIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9ucyIsInN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpcHRpb24iLCJjYiIsInNwbGljZSIsImVuZEJhdGNoIiwiQmF0Y2hlciIsInNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsInN0b3JlUmVmIiwic2V0U3RhdGUiLCIkcmVjb2lsRGVidWdTdGF0ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEIiwiaW5pdGlhbCIsImF0b20iLCJ3cml0dGVuTm9kZXMiLCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMiLCJpbml0aWFsU3RvcmVTdGF0ZSIsIm5leHRJRCIsIlJlY29pbFJvb3RfSU5URVJOQUwiLCJpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCIsInN0b3JlX0lOVEVSTkFMIiwic3RvcmVQcm9wIiwic3RvcmVTdGF0ZVJlZiIsImlkIiwibWV0YWRhdGEiLCJyZXBsYWNlZCIsIm5vdGlmeUJhdGNoZXJPZkNoYW5nZSIsImF0b21LZXkiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJSZWNvaWxSb290IiwicHJvcHMiLCJvdmVycmlkZSIsInByb3BzRXhjZXB0T3ZlcnJpZGUiLCJhbmNlc3RvclN0b3JlUmVmIiwidXNlUmVjb2lsU3RvcmVJRCIsIlJlY29pbF9SZWNvaWxSb290Iiwibm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORyIsInNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORyIsInNoYWxsb3dBcnJheUVxdWFsIiwiYSIsImIiLCJsIiwiUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsIiwidXNlRWZmZWN0JDEiLCJ1c2VSZWYkMiIsInVzZVByZXZpb3VzIiwiUmVjb2lsX3VzZVByZXZpb3VzIiwidXNlU3RvcmVSZWYkMSIsIlNVU1BFTlNFX1RJTUVPVVRfTVMkMSIsInVwZGF0ZVJldGFpbkNvdW50JDIiLCJSZXRlbnRpb25ab25lJDMiLCJ1c2VFZmZlY3QkMiIsInVzZVJlZiQzIiwiaXNTU1IkMiIsInVzZVJldGFpbiIsInRvUmV0YWluIiwidXNlUmV0YWluX0FDVFVBTCIsImFycmF5IiwidGltZW91dElEIiwiY2xlYXJUaW1lb3V0IiwicHJldmlvdXNSZXRhaW5hYmxlcyIsIlJlY29pbF91c2VSZXRhaW4iLCJ1c2VDb21wb25lbnROYW1lIiwiUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUiLCJiYXRjaFVwZGF0ZXMkMiIsIkRFRkFVTFRfVkFMVUUkMiIsImN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUkMSIsInJlYWN0TW9kZSQzIiwidXNlTXV0YWJsZVNvdXJjZSQxIiwidXNlU3luY0V4dGVybmFsU3RvcmUkMSIsInVzZVJlY29pbE11dGFibGVTb3VyY2UkMSIsInVzZVN0b3JlUmVmJDIiLCJpc1JlY29pbFZhbHVlJDIiLCJBYnN0cmFjdFJlY29pbFZhbHVlJDMiLCJnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMiIsInNldFJlY29pbFZhbHVlJDIiLCJzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIiLCJzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEiLCJ1c2VDYWxsYmFjayQxIiwidXNlRWZmZWN0JDMiLCJ1c2VNZW1vJDEiLCJ1c2VSZWYkNCIsInVzZVN0YXRlJDEiLCJzZXRCeUFkZGluZ1RvU2V0JDIiLCJoYW5kbGVMb2FkYWJsZSIsInZhbGlkYXRlUmVjb2lsVmFsdWUiLCJob29rTmFtZSIsInVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEIiwiY29tcG9uZW50TmFtZSIsImZvcmNlVXBkYXRlIiwicmVjb2lsVmFsdWVzVXNlZCIsInByZXZpb3VzU3Vic2NyaXB0aW9ucyIsInVuc3Vic2NyaWJlRnJvbSIsInN1YiIsInVwZGF0ZVN0YXRlIiwiX3N0YXRlIiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJ1c2VTZXRSZWNvaWxTdGF0ZSIsInVzZVJlc2V0UmVjb2lsU3RhdGUiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlIiwidXNlUmVjb2lsVmFsdWUiLCJ1c2VSZWNvaWxTdGF0ZSIsInVzZVJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRSZWNvaWxWYWx1ZSIsImdldFJlY29pbFZhbHVlTG9hZGFibGUiLCJnZXRSZWNvaWxTdGF0ZSIsImdldFJlY29pbFN0YXRlTG9hZGFibGUiLCJnZXRTZXRSZWNvaWxTdGF0ZSIsImdldFJlc2V0UmVjb2lsU3RhdGUiLCJyZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HIiwidXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFIiwiZ2V0U25hcHNob3QiLCJtZW1vaXplUHJldmlvdXNTbmFwc2hvdCIsInByZXZTdGF0ZSIsIl9wcmV2U3RhdGUiLCJfcHJldlN0YXRlMiIsIm5leHRTdGF0ZSIsImdldE1lbW9pemVkU25hcHNob3QiLCJzdWJzY3JpYmUiLCJub3RpZnkiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWUzIiwiZ2V0TG9hZGFibGVXaXRoVGVzdGluZyIsIl9zdG9yZVN0YXRlIiwibmV3TG9hZGFibGUiLCJwcmV2TG9hZGFibGVSZWYiLCJzb3VyY2UiLCJ1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCIsIl9zdG9yZVN0YXRlJG5leHRUcmVlNCIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZIiwiX3N0b3JlU3RhdGUkbmV4dFRyZWU1IiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyIiwiX3ByZXZMb2FkYWJsZVJlZiRjdXJyMiIsIlRSQU5TSVRJT05fU1VQUE9SVCIsIlNZTkNfRVhURVJOQUxfU1RPUkUiLCJNVVRBQkxFX1NPVVJDRSIsIkxFR0FDWSIsInVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwidXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFIiwiUmVjb2lsX0hvb2tzIiwidXNlUmVjb2lsSW50ZXJmYWNlIiwiZmlsdGVyTWFwIiwiUmVjb2lsX2ZpbHRlck1hcCIsImZpbHRlclNldCIsIlJlY29pbF9maWx0ZXJTZXQiLCJtZXJnZU1hcHMiLCJtYXBzIiwibmV4dEtleSIsIlJlY29pbF9tZXJnZU1hcHMiLCJiYXRjaFVwZGF0ZXMkMyIsIkRFRkFVTFRfVkFMVUUkMyIsImdldE5vZGUkNCIsIm5vZGVzJDEiLCJ1c2VTdG9yZVJlZiQzIiwiQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0Iiwic2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQxIiwiU1VTUEVOU0VfVElNRU9VVF9NUyQyIiwiY2xvbmVTbmFwc2hvdCQxIiwidXNlQ2FsbGJhY2skMiIsInVzZUVmZmVjdCQ0IiwidXNlUmVmJDUiLCJ1c2VTdGF0ZSQyIiwiaXNTU1IkMyIsInVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uIiwiZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZSIsInBlcnNpc3RlZEF0b21Db250ZW50c1ZhbHVlcyIsInBlcnNpc3RlbmNlIiwicGVyc2lzdGVuY2VfVU5TVEFCTEUiLCJ1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQiLCJwcmV2aW91c0F0b21WYWx1ZXMiLCJhdG9tSW5mbyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUyIsIl9ub2RlJHBlcnNpc3RlbmNlX1VOUzIiLCJfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzIiwiX25vZGUkcGVyc2lzdGVuY2VfVU5TNCIsImJhY2tCdXR0b24iLCJtb2RpZmllZEF0b21zIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciIsInByZXZpb3VzU25hcHNob3QiLCJ1c2VSZWNvaWxTbmFwc2hvdCIsInNldFNuYXBzaG90IiwicmVsZWFzZVJlZiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQiLCJfcmVsZWFzZVJlZiRjdXJyZW50MiIsIl9yZWxlYXNlUmVmJGN1cnJlbnQzIiwiZ290b1NuYXBzaG90IiwicHJldiIsImtleXNUb1VwZGF0ZSIsIl9wcmV2JGF0b21WYWx1ZXMkZ2V0IiwiX25leHQkYXRvbVZhbHVlcyRnZXQiLCJzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90cyIsInVzZUdvdG9SZWNvaWxTbmFwc2hvdCIsIlJlY29pbF9TbmFwc2hvdEhvb2tzIiwidXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25fREVQUkVDQVRFRCIsInBlZWtOb2RlSW5mbyQyIiwidXNlU3RvcmVSZWYkNCIsInVzZUdldFJlY29pbFZhbHVlSW5mbyIsIlJlY29pbF91c2VHZXRSZWNvaWxWYWx1ZUluZm8iLCJyZWFjdE1vZGUkNCIsIlJlY29pbFJvb3QkMSIsInVzZVN0b3JlUmVmJDUiLCJ1c2VNZW1vJDIiLCJ1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzIiwiUmVjb2lsQnJpZGdlIiwiUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMiLCJsb2FkYWJsZVdpdGhWYWx1ZSQxIiwiaW5pdGlhbGl6ZU5vZGUkMyIsIkRFRkFVTFRfVkFMVUUkNCIsImdldE5vZGUkNSIsImNvcHlUcmVlU3RhdGUkMSIsImdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzIiwiaW52YWxpZGF0ZURvd25zdHJlYW1zJDEiLCJ3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMSIsImlzQXRvbSIsIlRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbCIsIl9jaGFuZ2VzIiwiX3RyZWVTdGF0ZSIsIm5ld1RyZWVTdGF0ZV9JTlRFUk5BTCIsImF0b21pY1VwZGF0ZXIiLCJjaGFuZ2VzZXQiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyIsIlJlY29pbF9BdG9taWNVcGRhdGVzXzEiLCJSZWNvaWxfQXRvbWljVXBkYXRlcyQxIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiaW52YXJpYW50XzEiLCJSZWNvaWxfaW52YXJpYW50IiwiYXRvbWljVXBkYXRlciQxIiwiYmF0Y2hVcGRhdGVzJDQiLCJERUZBVUxUX1ZBTFVFJDUiLCJ1c2VTdG9yZVJlZiQ2IiwicmVmcmVzaFJlY29pbFZhbHVlJDEiLCJzZXRSZWNvaWxWYWx1ZSQzIiwiY2xvbmVTbmFwc2hvdCQyIiwiZ290b1NuYXBzaG90JDEiLCJ1c2VDYWxsYmFjayQzIiwiU2VudGluZWwiLCJTRU5USU5FTCIsInJlY29pbENhbGxiYWNrIiwiZXh0cmFJbnRlcmZhY2UiLCJyZWxlYXNlU25hcHNob3QiLCJlcnJNc2ciLCJjYWxsYmFja0ludGVyZmFjZSIsInJlc2V0IiwicmVmcmVzaCIsInRyYW5zYWN0X1VOU1RBQkxFIiwidHJhbnNhY3Rpb24iLCJmaW5hbGx5IiwiX3JlbGVhc2VTbmFwc2hvdCIsIl9yZWxlYXNlU25hcHNob3QyIiwidXNlUmVjb2lsQ2FsbGJhY2siLCJSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2siLCJ1c2VTdG9yZVJlZiQ3IiwicmVmcmVzaFJlY29pbFZhbHVlJDIiLCJ1c2VDYWxsYmFjayQ0IiwidXNlUmVjb2lsUmVmcmVzaGVyIiwiUmVjb2lsX3VzZVJlY29pbFJlZnJlc2hlciIsImF0b21pY1VwZGF0ZXIkMiIsInVzZVN0b3JlUmVmJDgiLCJ1c2VNZW1vJDMiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbiIsImF0b21pY1VwZGF0ZSIsInRyYW5zYWN0aW9uSW50ZXJmYWNlIiwiUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uIiwiV3JhcHBlZFZhbHVlIiwiUmVjb2lsX1dyYXBwZXIiLCJSZWNvaWxfV3JhcHBlcl8xIiwiUmVjb2lsX1dyYXBwZXIkMSIsImlzRmFzdFJlZnJlc2hFbmFibGVkJDIiLCJDaGFuZ2VkUGF0aEVycm9yIiwiVHJlZUNhY2hlIiwib3B0aW9ucyIsIl9vcHRpb25zJG9uSGl0IiwiX29wdGlvbnMkb25TZXQiLCJfb3B0aW9ucyRtYXBOb2RlVmFsdWUiLCJfbmFtZSIsIl9udW1MZWFmcyIsIl9vbkhpdCIsIm9uSGl0IiwiX29uU2V0Iiwib25TZXQiLCJfbWFwTm9kZVZhbHVlIiwibWFwTm9kZVZhbHVlIiwiZ2V0Tm9kZVZhbHVlIiwiaGFuZGxlcnMiLCJfdGhpcyRnZXRMZWFmTm9kZSIsImdldExlYWZOb2RlIiwib25Ob2RlVmlzaXQiLCJub2RlVmFsdWUiLCJicmFuY2hlcyIsInJvdXRlIiwiYWRkTGVhZiIsIl9ub2RlMiIsIl9ub2RlMyIsIl90aGlzJF9yb290MiIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdDIiLCJicmFuY2hLZXkiLCJfbm9kZSIsIl9oYW5kbGVycyRvbk5vZGVWaXNpdCIsIl90aGlzJF9yb290IiwiaW52YWxpZENhY2hlRXJyb3IiLCJvbGRMZWFmIiwibGVhZk5vZGUiLCJsZWFmIiwiX25vZGU0IiwiQ0hBTkdFRF9QQVRIX0VSUk9SX01FU1NBR0UiLCJSZWNvaWxfVHJlZUNhY2hlIiwiUmVjb2lsX1RyZWVDYWNoZV8xIiwiUmVjb2lsX1RyZWVDYWNoZSQxIiwiTFJVQ2FjaGUiLCJfb3B0aW9ucyRtYXBLZXkiLCJfbWF4U2l6ZSIsIm1heFNpemUiLCJfaGVhZCIsIl90YWlsIiwiX2tleU1hcHBlciIsIm1hcEtleSIsImhlYWQiLCJ0YWlsIiwibWFwcGVkS2V5IiwiZXhpc3RpbmdOb2RlIiwicmlnaHQiLCJsZWZ0IiwiX21heWJlRGVsZXRlTFJVIiwiZGVsZXRlTHJ1IiwiUmVjb2lsX0xSVUNhY2hlIiwiUmVjb2lsX0xSVUNhY2hlXzEiLCJSZWNvaWxfTFJVQ2FjaGUkMSIsIkxSVUNhY2hlJDEiLCJUcmVlQ2FjaGUkMSIsInRyZWVDYWNoZUxSVSIsImxydUNhY2hlIiwibHJ1Tm9kZSIsIlJlY29pbF90cmVlQ2FjaGVMUlUiLCJUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TIiwic3RyaW5naWZ5IiwiSlNPTiIsImFsbG93RnVuY3Rpb25zIiwiX0pTT04kc3RyaW5naWZ5IiwidG9TdHJpbmciLCJzb3J0IiwibG9jYWxlQ29tcGFyZSIsImZpbHRlciIsImpvaW4iLCJzdGFibGVTdHJpbmdpZnkiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSIsIlRyZWVDYWNoZSQyIiwiZGVmYXVsdFBvbGljeSIsImVxdWFsaXR5IiwiZXZpY3Rpb24iLCJJbmZpbml0eSIsInRyZWVDYWNoZUZyb21Qb2xpY3kiLCJ2YWx1ZU1hcHBlciIsImdldFZhbHVlTWFwcGVyIiwiZ2V0VHJlZUNhY2hlIiwiUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3kiLCJpc05vZGUiLCJvYmplY3QiLCJfb3duZXJEb2N1bWVudCIsIl9kb2MkZGVmYXVsdFZpZXciLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIk5vZGUiLCJub2RlTmFtZSIsIlJlY29pbF9pc05vZGUiLCJpc1JlYWN0TmF0aXZlJDEiLCJpc1dpbmRvdyQxIiwic2hvdWxkTm90QmVGcm96ZW4iLCIkJHR5cGVvZiIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZGVlcEZyZWV6ZVZhbHVlIiwiaXNGcm96ZW4iLCJzZWFsIiwiUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSIsInN0YXJ0UGVyZkJsb2NrIiwiX2lkIiwiUmVjb2lsX1BlcmZvcm1hbmNlVGltaW5ncyIsImlzTG9hZGFibGUkMSIsImxvYWRhYmxlV2l0aEVycm9yJDEiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDEiLCJsb2FkYWJsZVdpdGhWYWx1ZSQyIiwiV3JhcHBlZFZhbHVlJDEiLCJnZXROb2RlTG9hZGFibGUkMiIsInBlZWtOb2RlTG9hZGFibGUkMSIsInNldE5vZGVWYWx1ZSQzIiwic2F2ZURlcHNUb1N0b3JlJDEiLCJERUZBVUxUX1ZBTFVFJDYiLCJnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSIsImdldE5vZGUkNiIsInJlZ2lzdGVyTm9kZSQxIiwiaXNSZWNvaWxWYWx1ZSQzIiwibWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMSIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQxIiwicmVjb2lsQ2FsbGJhY2skMSIsInN0YXJ0UGVyZkJsb2NrJDEiLCJDYW5jZWxlZCIsIkNBTkNFTEVEIiwiZGVwZW5kZW5jeVN0YWNrIiwid2FpdGluZ1N0b3JlcyIsImdldE5ld0V4ZWN1dGlvbklEIiwiZXhlY3V0aW9uSUQiLCJzZWxlY3RvciIsImNhY2hlUG9saWN5X1VOU1RBQkxFIiwiY2FjaGVQb2xpY3kiLCJkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzIiwicmV0YWluZWRCeV9VTlNUQUJMRSIsImV4ZWN1dGlvbkluZm9NYXAiLCJsaXZlU3RvcmVzQ291bnQiLCJzZWxlY3RvcklzTGl2ZSIsInNlbGVjdG9ySW5pdCIsInNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlIiwicmVzb2x2ZUFzeW5jIiwiZGVwVmFsdWVzIiwic2V0Q2FjaGUiLCJub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMiLCJpc0xhdGVzdEV4ZWN1dGlvbiIsImNsZWFyRXhlY3V0aW9uSW5mbyIsIm5vdGlmeVdhaXRpbmdTdG9yZXMiLCJub3RpZnlTdG9yZXNPZk5ld0FzeW5jRGVwIiwiZXhlY3V0aW9uSW5mbyIsImdldEV4ZWN1dGlvbkluZm8iLCJzdGF0ZVZlcnNpb25zIiwiY2xlYXJXYWl0bGlzdCIsInN0b3JlcyIsIndhaXRpbmdTdG9yZSIsIm1hcmtTdG9yZVdhaXRpbmdGb3JSZXNvbHZlZEFzeW5jIiwid3JhcFJlc3VsdFByb21pc2UiLCJsb2FkaW5nRGVwc1N0YXRlIiwiZXJyb3JPclByb21pc2UiLCJ3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlIiwiZXhpc3RpbmdEZXBzIiwicmVzb2x2ZWREZXAiLCJsb2FkaW5nRGVwS2V5IiwibG9hZGluZ0RlcFByb21pc2UiLCJjYWNoZWRMb2FkYWJsZSIsImdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyIsImdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvIiwibG9hZGluZ0xvYWRhYmxlIiwiZXZhbHVhdGVTZWxlY3RvckdldHRlciIsInVwZGF0ZURlcHMiLCJfc3RvcmUkZ2V0U3RhdGUiLCJfc3RvcmUkZ2V0U3RhdGUkY3VycmUiLCJfc3RvcmUkZ2V0U3RhdGUyIiwiX3N0b3JlJGdldFN0YXRlMiRuZXh0IiwiX3N0b3JlJGdldFN0YXRlMyIsIl9zdG9yZSRnZXRTdGF0ZTMkbmV4dCIsImVuZFBlcmZCbG9jayIsImR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uIiwiZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uIiwiZmluaXNoRXZhbHVhdGlvbiIsInJlc3VsdElzRXJyb3IiLCJkZXBLZXkiLCJkZXBMb2FkYWJsZSIsImdldENhbGxiYWNrIiwiZXJyb3JPckRlcFByb21pc2UiLCJ1cGRhdGVFeGVjdXRpb25JbmZvRGVwVmFsdWVzIiwiZGVwc0FmdGVyQ2FjaGVMb29rdXAiLCJfZ2V0RXhlY3V0aW9uSW5mbyIsImdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzIiwiY2FjaGVkVmFsIiwiaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8iLCJfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkiLCJuZXdFeGVjdXRpb25JRCIsIm5ld0RlcFZhbHVlcyIsInNldEV4ZWN1dGlvbkluZm8iLCJwZW5kaW5nRXhlY3V0aW9ucyIsImV4ZWNJbmZvIiwiYW55RGVwQ2hhbmdlZCIsImV4ZWNEZXBWYWx1ZXMiLCJleGVjTG9hZGFibGUiLCJkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcmsiLCJfZ2V0RXhlY3V0aW9uSW5mbzIiLCJkZXBWYWx1ZXNUb0RlcFJvdXRlIiwidmFsTG9hZGFibGUiLCJCb29sZWFuIiwiZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkiLCJkZXRlY3RDaXJjdWxhckRlcGVuZGVuY2llcyIsInNsaWNlIiwiaW5kZXhPZiIsInNlbGVjdG9yUGVlayIsIl9wZWVrTm9kZUxvYWRhYmxlIiwic2VsZWN0b3JHZXQiLCJpbnZhbGlkYXRlU2VsZWN0b3IiLCJjbGVhclNlbGVjdG9yQ2FjaGUiLCJzZWxlY3RvclNldCIsInN5bmNTZWxlY3RvclNldEZpbmlzaGVkIiwic2V0UmVjb2lsU3RhdGUiLCJzZXRWYWx1ZSIsInVwc3RyZWFtV3JpdGVzIiwicmVzZXRSZWNvaWxTdGF0ZSIsIlJlY29pbF9zZWxlY3RvciIsImlzTG9hZGFibGUkMiIsImxvYWRhYmxlV2l0aEVycm9yJDIiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDIiLCJsb2FkYWJsZVdpdGhWYWx1ZSQzIiwiV3JhcHBlZFZhbHVlJDIiLCJwZWVrTm9kZUluZm8kMyIsIkRFRkFVTFRfVkFMVUUkNyIsIkRlZmF1bHRWYWx1ZSQyIiwiZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIiLCJyZWdpc3Rlck5vZGUkMiIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxIiwiaXNSZWNvaWxWYWx1ZSQ0IiwiZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQiLCJtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyIiwic2V0UmVjb2lsVmFsdWUkNCIsInNldFJlY29pbFZhbHVlTG9hZGFibGUkMiIsInJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyIiwidW53cmFwIiwiYmFzZUF0b20iLCJ1bndyYXBQcm9taXNlIiwiZGVmYXVsdExvYWRhYmxlIiwiZGVmYXVsdCIsIm1heWJlRnJlZXplVmFsdWVPclByb21pc2UiLCJjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlIiwiY2xlYW51cEVmZmVjdHNCeVN0b3JlIiwidmFsdWVPclByb21pc2UiLCJ3cmFwUGVuZGluZ1Byb21pc2UiLCJ3cmFwcGVkUHJvbWlzZSIsIl9zdGF0ZSRhdG9tVmFsdWVzJGdldCIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIiLCJfc3RhdGUkYXRvbVZhbHVlcyRnZXQyIiwiaW5pdEF0b20iLCJpbml0U3RhdGUiLCJfb3B0aW9ucyRlZmZlY3RzIiwiY2xlYW51cEF0b20iLCJfY2xlYW51cEVmZmVjdHNCeVN0b3IiLCJub3RpZnlEZWZhdWx0U3Vic2NyaWJlcnMiLCJfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzIiwiZWZmZWN0cyIsImVmZmVjdHNfVU5TVEFCTEUiLCJpbml0VmFsdWUiLCJpc0R1cmluZ0luaXQiLCJpc0luaXRFcnJvciIsInBlbmRpbmdTZXRTZWxmIiwicmV0VmFsdWUiLCJwZWVrQXRvbSIsImdldFByb21pc2UiLCJnZXRJbmZvX1VOU1RBQkxFIiwiX3N0b3JlJGdldFN0YXRlJG5leHRUNCIsImluZm8iLCJzZXRTZWxmIiwiZWZmZWN0IiwiY3VycmVudExvYWRhYmxlIiwiY3VycmVudFZhbHVlIiwicmVzZXRTZWxmIiwiaGFuZGxlciIsIl9jbGVhbnVwRWZmZWN0c0J5U3RvcjIiLCJjdXJyZW50U3RvcmUiLCJfY3VycmVudFRyZWUkYXRvbVZhbHUiLCJfcHJldmlvdXNUcmVlJGF0b21WYWwiLCJfcGVuZGluZ1NldFNlbGYiLCJfcGVuZGluZ1NldFNlbGYyIiwiX3BlbmRpbmdTZXRTZWxmMyIsIm9sZExvYWRhYmxlIiwib2xkVmFsdWUiLCJwYXJlbnRTdG9yZUlEX1VOU1RBQkxFIiwiX2NsZWFudXBFZmZlY3RzQnlTdG9yMyIsIl9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUiLCJpbml0TG9hZGFibGUiLCJfcmVmIiwiX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyIsImdldEF0b20iLCJub252YWxpZGF0ZWRWYWx1ZSIsInZhbGlkYXRvclJlc3VsdCIsInZhbGlkYXRvciIsInZhbGlkYXRlZFZhbHVlTG9hZGFibGUiLCJpbnZhbGlkYXRlQXRvbSIsInNldEF0b20iLCJzaG91bGREZWxldGVDb25maWdPblJlbGVhc2VBdG9tIiwicmVzdE9wdGlvbnMiLCJvcHRpb25zRGVmYXVsdCIsImF0b21XaXRoRmFsbGJhY2siLCJzdG9yZWRWYWx1ZSIsInNlbCIsImJhc2VWYWx1ZSIsIlJlY29pbF9hdG9tIiwiTWFwQ2FjaGUiLCJSZWNvaWxfTWFwQ2FjaGUiLCJSZWNvaWxfTWFwQ2FjaGVfMSIsIlJlY29pbF9NYXBDYWNoZSQxIiwiTFJVQ2FjaGUkMiIsIk1hcENhY2hlJDEiLCJkZWZhdWx0UG9saWN5JDEiLCJjYWNoZUZyb21Qb2xpY3kiLCJnZXRWYWx1ZU1hcHBlciQxIiwiZ2V0Q2FjaGUiLCJSZWNvaWxfY2FjaGVGcm9tUG9saWN5Iiwic2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIiLCJhdG9tRmFtaWx5IiwiX29wdGlvbnMkY2FjaGVQb2xpY3lGIiwiX29wdGlvbnMkY2FjaGVQb2xpY3lGMiIsImF0b21DYWNoZSIsImNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFIiwicGFyYW1zIiwiX3N0YWJsZVN0cmluZ2lmeSIsImNhY2hlZEF0b20iLCJhdG9tT3B0aW9ucyIsIm5ld0F0b20iLCJSZWNvaWxfYXRvbUZhbWlseSIsInNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzIiwibmV4dEluZGV4Iiwic2VsZWN0b3JGYW1pbHkiLCJzZWxlY3RvckNhY2hlIiwiY2FjaGVkU2VsZWN0b3IiLCJteUtleSIsIm15R2V0IiwiY2FsbGJhY2tzIiwibXlDYWNoZVBvbGljeSIsIm5ld1NlbGVjdG9yIiwibXlTZXQiLCJSZWNvaWxfc2VsZWN0b3JGYW1pbHkiLCJjb25zdGFudFNlbGVjdG9yIiwiY29uc3RTZWxlY3RvciIsIlJlY29pbF9jb25zdFNlbGVjdG9yIiwidGhyb3dpbmdTZWxlY3RvciIsImVycm9yU2VsZWN0b3IiLCJSZWNvaWxfZXJyb3JTZWxlY3RvciIsInJlYWRPbmx5U2VsZWN0b3IiLCJSZWNvaWxfcmVhZE9ubHlTZWxlY3RvciIsImxvYWRhYmxlV2l0aEVycm9yJDMiLCJsb2FkYWJsZVdpdGhQcm9taXNlJDMiLCJsb2FkYWJsZVdpdGhWYWx1ZSQ0IiwiY29uY3VycmVudFJlcXVlc3RzIiwicmVzdWx0cyIsImZpbGwiLCJleGNlcHRpb25zIiwiaXNFcnJvciIsImV4cCIsInVud3JhcERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsIndyYXBSZXN1bHRzIiwid3JhcExvYWRhYmxlcyIsImV4Y2VwdGlvbiIsImNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMiLCJzeW5jUmVzdWx0cyIsImFzeW5jUmVzdWx0cyIsIndhaXRGb3JOb25lIiwid2FpdEZvckFueSIsIndhaXRGb3JBbGwiLCJleGNlcHRpb25SZXN1bHRzIiwid2FpdEZvckFsbFNldHRsZWQiLCJub1dhaXQiLCJkZXBlbmRlbmN5IiwiUmVjb2lsX1dhaXRGb3IiLCJEZWZhdWx0VmFsdWUkMyIsIlJlY29pbFJvb3QkMiIsInVzZVJlY29pbFN0b3JlSUQkMSIsImlzUmVjb2lsVmFsdWUkNSIsInJldGVudGlvblpvbmUkMSIsImZyZXNoU25hcHNob3QkMiIsInVzZVJlY29pbFN0YXRlJDEiLCJ1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSIsInVzZVJlY29pbFZhbHVlJDEiLCJ1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSIsInVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJDEiLCJ1c2VSZXNldFJlY29pbFN0YXRlJDEiLCJ1c2VTZXRSZWNvaWxTdGF0ZSQxIiwidXNlR290b1JlY29pbFNuYXBzaG90JDEiLCJ1c2VSZWNvaWxTbmFwc2hvdCQxIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlciQxIiwidXNlUmVjb2lsQ2FsbGJhY2skMSIsIm5vV2FpdCQxIiwid2FpdEZvckFsbCQxIiwid2FpdEZvckFsbFNldHRsZWQkMSIsIndhaXRGb3JBbnkkMSIsIndhaXRGb3JOb25lJDEiLCJSZWNvaWxfaW5kZXgiLCJSZWNvaWxFbnYiLCJ1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFIiwidXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFIiwidXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFIiwidXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUiLCJ1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFIiwic25hcHNob3RfVU5TVEFCTEUiLCJSZWNvaWxfaW5kZXhfMSIsIlJlY29pbF9pbmRleF8yIiwiUmVjb2lsX2luZGV4XzMiLCJSZWNvaWxfaW5kZXhfNCIsIlJlY29pbF9pbmRleF81IiwiUmVjb2lsX2luZGV4XzYiLCJSZWNvaWxfaW5kZXhfNyIsIlJlY29pbF9pbmRleF84IiwiUmVjb2lsX2luZGV4XzkiLCJSZWNvaWxfaW5kZXhfMTAiLCJSZWNvaWxfaW5kZXhfMTEiLCJSZWNvaWxfaW5kZXhfMTIiLCJSZWNvaWxfaW5kZXhfMTMiLCJSZWNvaWxfaW5kZXhfMTQiLCJSZWNvaWxfaW5kZXhfMTUiLCJSZWNvaWxfaW5kZXhfMTYiLCJSZWNvaWxfaW5kZXhfMTciLCJSZWNvaWxfaW5kZXhfMTgiLCJSZWNvaWxfaW5kZXhfMTkiLCJSZWNvaWxfaW5kZXhfMjAiLCJSZWNvaWxfaW5kZXhfMjEiLCJSZWNvaWxfaW5kZXhfMjIiLCJSZWNvaWxfaW5kZXhfMjMiLCJSZWNvaWxfaW5kZXhfMjQiLCJSZWNvaWxfaW5kZXhfMjUiLCJSZWNvaWxfaW5kZXhfMjYiLCJSZWNvaWxfaW5kZXhfMjciLCJSZWNvaWxfaW5kZXhfMjgiLCJSZWNvaWxfaW5kZXhfMjkiLCJSZWNvaWxfaW5kZXhfMzAiLCJSZWNvaWxfaW5kZXhfMzEiLCJSZWNvaWxfaW5kZXhfMzIiLCJSZWNvaWxfaW5kZXhfMzMiLCJSZWNvaWxfaW5kZXhfMzQiLCJSZWNvaWxfaW5kZXhfMzUiLCJSZWNvaWxfaW5kZXhfMzYiLCJSZWNvaWxfaW5kZXhfMzciLCJSZWNvaWxfaW5kZXhfMzgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/recoil/cjs/index.js\n");

/***/ }),

/***/ "(sc_client)/./app/components/Card.jsx":
/*!*********************************!*\
  !*** ./app/components/Card.jsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Card)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useIntersectionObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/useIntersectionObserver */ \"(sc_client)/./app/hooks/useIntersectionObserver.jsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction Card(props) {\n    const { image  } = props;\n    const cardRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const isIntersecting = (0,_hooks_useIntersectionObserver__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cardRef);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-32 h-32 lg:w-96 lg:h-96\",\n        ref: cardRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                className: \" w-full h-full object-cover\",\n                src: image,\n                alt: \"cat-image\"\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Card.jsx\",\n                lineNumber: 13,\n                columnNumber: 3\n            }, this),\n            isIntersecting ? \"Itersecting\" : \"Not intersecting\"\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Card.jsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9hcHAvY29tcG9uZW50cy9DYXJkLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXNFO0FBRXZDO0FBRWhCLFNBQVNFLEtBQUtDLEtBQUssRUFBRTtJQUNuQyxNQUFNLEVBQUVDLE1BQUssRUFBRSxHQUFHRDtJQUNsQixNQUFNRSxVQUFVSiw2Q0FBTUEsQ0FBQyxJQUFJO0lBQzNCLE1BQU1LLGlCQUFpQk4sMEVBQXVCQSxDQUFDSztJQUM5QyxxQkFDQSw4REFBQ0U7UUFBSUMsV0FBVTtRQUE0QkMsS0FBS0o7OzBCQUNoRCw4REFBQ0s7Z0JBQUlGLFdBQVU7Z0JBQThCRyxLQUFLUDtnQkFBT1EsS0FBSTs7Ozs7O1lBQzVETixpQkFBaUIsZ0JBQWdCLGtCQUFrQjs7Ozs7OztBQUd0RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL2FwcC9jb21wb25lbnRzL0NhcmQuanN4Pzk0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlciBmcm9tIFwiLi4vaG9va3MvdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIlxuXG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FyZChwcm9wcykge1xuXHRjb25zdCB7IGltYWdlIH0gPSBwcm9wc1xuXHRjb25zdCBjYXJkUmVmID0gdXNlUmVmKG51bGwpXG5cdGNvbnN0IGlzSW50ZXJzZWN0aW5nID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FyZFJlZilcbiAgcmV0dXJuIChcblx0IDxkaXYgY2xhc3NOYW1lPSd3LTMyIGgtMzIgbGc6dy05NiBsZzpoLTk2JyByZWY9e2NhcmRSZWZ9PlxuXHRcdDxpbWcgY2xhc3NOYW1lPVwiIHctZnVsbCBoLWZ1bGwgb2JqZWN0LWNvdmVyXCIgc3JjPXtpbWFnZX0gYWx0PSdjYXQtaW1hZ2UnLz5cblx0XHR7aXNJbnRlcnNlY3RpbmcgPyBcIkl0ZXJzZWN0aW5nXCIgOiBcIk5vdCBpbnRlcnNlY3RpbmdcIn1cblx0IDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsidXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJ1c2VSZWYiLCJDYXJkIiwicHJvcHMiLCJpbWFnZSIsImNhcmRSZWYiLCJpc0ludGVyc2VjdGluZyIsImRpdiIsImNsYXNzTmFtZSIsInJlZiIsImltZyIsInNyYyIsImFsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./app/components/Card.jsx\n");

/***/ }),

/***/ "(sc_client)/./app/components/Dropdown.jsx":
/*!*************************************!*\
  !*** ./app/components/Dropdown.jsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dropdown)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recoil */ \"(sc_client)/./node_modules/recoil/cjs/index.js\");\n\n\nfunction Dropdown(props) {\n    const [selectedBreed, setSelectedBreed] = (0,recoil__WEBPACK_IMPORTED_MODULE_1__.useRecoilState)(breedState);\n    const { breeds  } = props;\n    const handleChange = (e)=>{\n        setSelectedBreed(e.target.value);\n    };\n    console.log(selectedBreed);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                className: \"\",\n                defaultValue: selectedBreed,\n                onChange: (e)=>handleChange(e),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                        children: \"Select breed\"\n                    }, void 0, false, {\n                        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx\",\n                        lineNumber: 19,\n                        columnNumber: 5\n                    }, this),\n                    breeds.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                            className: \"text-lg\",\n                            value: item,\n                            children: item\n                        }, item, false, {\n                            fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx\",\n                            lineNumber: 21,\n                            columnNumber: 6\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx\",\n                lineNumber: 18,\n                columnNumber: 4\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx\",\n            lineNumber: 17,\n            columnNumber: 3\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Dropdown.jsx\",\n        lineNumber: 16,\n        columnNumber: 2\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9hcHAvY29tcG9uZW50cy9Ecm9wZG93bi5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFdUM7QUFFeEIsU0FBU0MsU0FBU0MsS0FBSyxFQUFFO0lBRXZDLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdKLHNEQUFjQSxDQUFDSztJQUN6RCxNQUFNLEVBQUVDLE9BQU0sRUFBRSxHQUFHSjtJQUVuQixNQUFNSyxlQUFlLENBQUNDLElBQU07UUFDM0JKLGlCQUFpQkksRUFBRUMsTUFBTSxDQUFDQyxLQUFLO0lBQ2hDO0lBRUFDLFFBQVFDLEdBQUcsQ0FBQ1Q7SUFDWCxxQkFDRCw4REFBQ1U7UUFBSUMsV0FBVTtrQkFDZCw0RUFBQ0M7c0JBQ0EsNEVBQUNDO2dCQUFPRixXQUFVO2dCQUFHRyxjQUFjZDtnQkFBZWUsVUFBV1YsQ0FBQUEsSUFBS0QsYUFBYUM7O2tDQUM5RSw4REFBQ1c7a0NBQU87Ozs7OztvQkFDUGIsT0FBT2MsR0FBRyxDQUFDQyxDQUFBQSxxQkFDWCw4REFBQ0Y7NEJBQU9MLFdBQVU7NEJBQXFCSixPQUFPVztzQ0FBT0E7MkJBQXBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT3RDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vYXBwL2NvbXBvbmVudHMvRHJvcGRvd24uanN4Pzg1MTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVJlY29pbFN0YXRlIH0gZnJvbSAncmVjb2lsJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcm9wZG93bihwcm9wcykge1xuXHRcblx0Y29uc3QgW3NlbGVjdGVkQnJlZWQsIHNldFNlbGVjdGVkQnJlZWRdID0gdXNlUmVjb2lsU3RhdGUoYnJlZWRTdGF0ZSlcblx0Y29uc3QgeyBicmVlZHMgfSA9IHByb3BzXG5cblx0Y29uc3QgaGFuZGxlQ2hhbmdlID0gKGUpID0+IHtcblx0XHRzZXRTZWxlY3RlZEJyZWVkKGUudGFyZ2V0LnZhbHVlKVxuXHR9XG5cblx0Y29uc29sZS5sb2coc2VsZWN0ZWRCcmVlZClcbiAgcmV0dXJuIChcblx0PGRpdiBjbGFzc05hbWU9Jyc+XG5cdFx0PGZvcm0+XG5cdFx0XHQ8c2VsZWN0IGNsYXNzTmFtZT0nJyBkZWZhdWx0VmFsdWU9e3NlbGVjdGVkQnJlZWR9IG9uQ2hhbmdlPXsgZSA9PiBoYW5kbGVDaGFuZ2UoZSl9PlxuXHRcdFx0XHQ8b3B0aW9uPlNlbGVjdCBicmVlZDwvb3B0aW9uPlxuXHRcdFx0XHR7YnJlZWRzLm1hcChpdGVtID0+IChcblx0XHRcdFx0XHQ8b3B0aW9uIGNsYXNzTmFtZT0ndGV4dC1sZycga2V5PXtpdGVtfSB2YWx1ZT17aXRlbX0+e2l0ZW19PC9vcHRpb24+XG5cdFx0XHRcdCkpfVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0PC9mb3JtPlxuXHQ8L2Rpdj5cblxuICApXG59XG5cblxuIl0sIm5hbWVzIjpbInVzZVJlY29pbFN0YXRlIiwiRHJvcGRvd24iLCJwcm9wcyIsInNlbGVjdGVkQnJlZWQiLCJzZXRTZWxlY3RlZEJyZWVkIiwiYnJlZWRTdGF0ZSIsImJyZWVkcyIsImhhbmRsZUNoYW5nZSIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsImNvbnNvbGUiLCJsb2ciLCJkaXYiLCJjbGFzc05hbWUiLCJmb3JtIiwic2VsZWN0IiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJvcHRpb24iLCJtYXAiLCJpdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./app/components/Dropdown.jsx\n");

/***/ }),

/***/ "(sc_client)/./app/components/Highlights.jsx":
/*!***************************************!*\
  !*** ./app/components/Highlights.jsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Highlights)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(sc_client)/./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Highlights(props) {\n    const { image , name  } = props;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-12 h-12\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                className: \"rounded-full w-full h-full\",\n                src: image,\n                alt: \"cat-image\"\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Highlights.jsx\",\n                lineNumber: 9,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-xs text-center font-semibold\",\n                children: name\n            }, void 0, false, {\n                fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Highlights.jsx\",\n                lineNumber: 10,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/anamdiazs/Documents/GitHub/catstagram/app/components/Highlights.jsx\",\n        lineNumber: 8,\n        columnNumber: 3\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9hcHAvY29tcG9uZW50cy9IaWdobGlnaHRzLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFK0I7QUFFaEIsU0FBU0MsV0FBV0MsS0FBSyxFQUFFO0lBQ3pDLE1BQU0sRUFBRUMsTUFBSyxFQUFHQyxLQUFJLEVBQUUsR0FBR0Y7SUFDekIscUJBQ0MsOERBQUNHO1FBQUlDLFdBQVU7OzBCQUNkLDhEQUFDQztnQkFBSUQsV0FBVTtnQkFBNkJFLEtBQUtMO2dCQUFPTSxLQUFJOzs7Ozs7MEJBQzVELDhEQUFDQztnQkFBRUosV0FBVTswQkFBcUNGOzs7Ozs7Ozs7Ozs7QUFHckQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9hcHAvY29tcG9uZW50cy9IaWdobGlnaHRzLmpzeD8xMzkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XHRcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGlnaGxpZ2h0cyhwcm9wcykge1xuXHRjb25zdCB7IGltYWdlICwgbmFtZSB9ID0gcHJvcHNcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cInctMTIgaC0xMlwiPlxuXHRcdFx0PGltZyBjbGFzc05hbWU9XCJyb3VuZGVkLWZ1bGwgdy1mdWxsIGgtZnVsbFwiIHNyYz17aW1hZ2V9IGFsdD1cImNhdC1pbWFnZVwiIC8+XG5cdFx0XHQ8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtY2VudGVyIGZvbnQtc2VtaWJvbGRcIj57bmFtZX08L3A+XG5cdFx0PC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJJbWFnZSIsIkhpZ2hsaWdodHMiLCJwcm9wcyIsImltYWdlIiwibmFtZSIsImRpdiIsImNsYXNzTmFtZSIsImltZyIsInNyYyIsImFsdCIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./app/components/Highlights.jsx\n");

/***/ }),

/***/ "(sc_client)/./app/hooks/useIntersectionObserver.jsx":
/*!***********************************************!*\
  !*** ./app/hooks/useIntersectionObserver.jsx ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useIntersectionObserver = (ref, options = {})=>{\n    const [isIntersecting, setIsIntersecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const observerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!ref.current) return;\n        const handleIntersect = (entries)=>{\n            setIsIntersecting(entries[0].isIntersecting);\n        };\n        observerRef.current = new IntersectionObserver(handleIntersect, options);\n        observerRef.current.observe(ref.current);\n        return ()=>{\n            observerRef.current.disconnect();\n        };\n    }, [\n        ref,\n        options\n    ]);\n    return isIntersecting;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useIntersectionObserver);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9hcHAvaG9va3MvdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuanN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVvRDtBQUVwRCxNQUFNRywwQkFBMEIsQ0FBQ0MsS0FBS0MsVUFBVSxDQUFDLENBQUMsR0FBTTtJQUV2RCxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdQLCtDQUFRQSxDQUFDLEtBQUs7SUFDMUQsTUFBTVEsY0FBY04sNkNBQU1BLENBQUMsSUFBSTtJQUMvQkQsZ0RBQVNBLENBQUMsSUFBTTtRQUNmLElBQUksQ0FBQ0csSUFBSUssT0FBTyxFQUFFO1FBRWxCLE1BQU1DLGtCQUFrQixDQUFDQyxVQUFZO1lBQ3BDSixrQkFBa0JJLE9BQU8sQ0FBQyxFQUFFLENBQUNMLGNBQWM7UUFDNUM7UUFFQUUsWUFBWUMsT0FBTyxHQUFHLElBQUlHLHFCQUFxQkYsaUJBQWlCTDtRQUNoRUcsWUFBWUMsT0FBTyxDQUFDSSxPQUFPLENBQUNULElBQUlLLE9BQU87UUFFdkMsT0FBTyxJQUFNO1lBQ1pELFlBQVlDLE9BQU8sQ0FBQ0ssVUFBVTtRQUMvQjtJQUNELEdBQUc7UUFBQ1Y7UUFBS0M7S0FBUTtJQUVqQixPQUFPQztBQUNSO0FBQ0EsaUVBQWVILHVCQUF1QkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9hcHAvaG9va3MvdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuanN4PzkwZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG5jb25zdCB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlciA9IChyZWYsIG9wdGlvbnMgPSB7fSApID0+IHtcblxuXHRjb25zdCBbaXNJbnRlcnNlY3RpbmcsIHNldElzSW50ZXJzZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0Y29uc3Qgb2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7XG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFyZWYuY3VycmVudCkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgaGFuZGxlSW50ZXJzZWN0ID0gKGVudHJpZXMpID0+IHtcblx0XHRcdHNldElzSW50ZXJzZWN0aW5nKGVudHJpZXNbMF0uaXNJbnRlcnNlY3RpbmcpO1xuXHRcdH07XG5cblx0XHRvYnNlcnZlclJlZi5jdXJyZW50ID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwgb3B0aW9ucyk7XG5cdFx0b2JzZXJ2ZXJSZWYuY3VycmVudC5vYnNlcnZlKHJlZi5jdXJyZW50KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRvYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcblx0XHR9O1xuXHR9LCBbcmVmLCBvcHRpb25zXSk7XG5cblx0cmV0dXJuIGlzSW50ZXJzZWN0aW5nO1xufVxuZXhwb3J0IGRlZmF1bHQgdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJlZiIsIm9wdGlvbnMiLCJpc0ludGVyc2VjdGluZyIsInNldElzSW50ZXJzZWN0aW5nIiwib2JzZXJ2ZXJSZWYiLCJjdXJyZW50IiwiaGFuZGxlSW50ZXJzZWN0IiwiZW50cmllcyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./app/hooks/useIntersectionObserver.jsx\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/add-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/add-base-path.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ \"../shared/lib/router/utils/add-path-prefix\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(sc_client)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction addBasePath(path, required) {\n    if (false) {}\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLDhGQUE0QztBQUN6RSxJQUFJQywwQkFBMEJELG1CQUFPQSxDQUFDLDJHQUE0QjtBQUNsRSxNQUFNRSxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNMLFlBQVlRLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQ2pDLElBQUlKLEtBQTBDLEVBQUUsRUFJL0M7SUFDRCxPQUFPLENBQUMsR0FBR0YsdUJBQXVCLEVBQUVRLDBCQUEwQixDQUFDLENBQUMsR0FBR1YsY0FBYyxFQUFFVyxhQUFhLENBQUNKLE1BQU1KO0FBQzNHO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQmtCLE9BQU9sQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzPzYxMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG52YXIgX2FkZFBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4XCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aCwgcmVxdWlyZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIKSB7XG4gICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfYWRkUGF0aFByZWZpeCkuYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtYmFzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZEJhc2VQYXRoIiwiX2FkZFBhdGhQcmVmaXgiLCJyZXF1aXJlIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInJlcXVpcmVkIiwiX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJhZGRQYXRoUHJlZml4IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/add-base-path.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/app-router-headers.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-headers.js ***!
  \************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FLIGHT_PARAMETERS = exports.RSC_VARY_HEADER = exports.RSC_CONTENT_TYPE_HEADER = exports.FETCH_CACHE_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.ACTION = exports.RSC = void 0;\nconst RSC = \"RSC\";\nexports.RSC = RSC;\nconst ACTION = \"Action\";\nexports.ACTION = ACTION;\nconst NEXT_ROUTER_STATE_TREE = \"Next-Router-State-Tree\";\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nconst NEXT_ROUTER_PREFETCH = \"Next-Router-Prefetch\";\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nconst FETCH_CACHE_HEADER = \"x-vercel-sc-headers\";\nexports.FETCH_CACHE_HEADER = FETCH_CACHE_HEADER;\nconst RSC_CONTENT_TYPE_HEADER = \"text/x-component\";\nexports.RSC_CONTENT_TYPE_HEADER = RSC_CONTENT_TYPE_HEADER;\nconst RSC_VARY_HEADER = `${RSC}, ${NEXT_ROUTER_STATE_TREE}, ${NEXT_ROUTER_PREFETCH}`;\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nconst FLIGHT_PARAMETERS = [\n    [\n        RSC\n    ],\n    [\n        NEXT_ROUTER_STATE_TREE\n    ],\n    [\n        NEXT_ROUTER_PREFETCH\n    ]\n];\nexports.FLIGHT_PARAMETERS = FLIGHT_PARAMETERS;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-headers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0EsdUJBQXVCLEdBQUdBLCtCQUErQixHQUFHQSwwQkFBMEIsR0FBR0EsNEJBQTRCLEdBQUdBLDhCQUE4QixHQUFHQSxjQUFjLEdBQUdBLFdBQVcsR0FBRyxLQUFLO0FBQ3pOLE1BQU1TLE1BQU07QUFDWlQsV0FBVyxHQUFHUztBQUNkLE1BQU1ELFNBQVM7QUFDZlIsY0FBYyxHQUFHUTtBQUNqQixNQUFNRCx5QkFBeUI7QUFDL0JQLDhCQUE4QixHQUFHTztBQUNqQyxNQUFNRCx1QkFBdUI7QUFDN0JOLDRCQUE0QixHQUFHTTtBQUMvQixNQUFNRCxxQkFBcUI7QUFDM0JMLDBCQUEwQixHQUFHSztBQUM3QixNQUFNRCwwQkFBMEI7QUFDaENKLCtCQUErQixHQUFHSTtBQUNsQyxNQUFNRCxrQkFBa0IsQ0FBQyxFQUFFTSxJQUFJLEVBQUUsRUFBRUYsdUJBQXVCLEVBQUUsRUFBRUQscUJBQXFCLENBQUM7QUFDcEZOLHVCQUF1QixHQUFHRztBQUMxQixNQUFNRCxvQkFBb0I7SUFDdEI7UUFDSU87S0FDSDtJQUNEO1FBQ0lGO0tBQ0g7SUFDRDtRQUNJRDtLQUNIO0NBQ0o7QUFDRE4seUJBQXlCLEdBQUdFO0FBRTVCLElBQUksQ0FBQyxPQUFPRixRQUFRVSxPQUFPLEtBQUssY0FBZSxPQUFPVixRQUFRVSxPQUFPLEtBQUssWUFBWVYsUUFBUVUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPVixRQUFRVSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLYixPQUFPQyxjQUFjLENBQUNDLFFBQVFVLE9BQU8sRUFBRSxjQUFjO1FBQUVULE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYyxNQUFNLENBQUNaLFFBQVFVLE9BQU8sRUFBRVY7SUFDL0JhLE9BQU9iLE9BQU8sR0FBR0EsUUFBUVUsT0FBTztBQUNsQyxDQUFDLENBRUQsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLmpzPzM1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZMSUdIVF9QQVJBTUVURVJTID0gZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBleHBvcnRzLlJTQ19DT05URU5UX1RZUEVfSEVBREVSID0gZXhwb3J0cy5GRVRDSF9DQUNIRV9IRUFERVIgPSBleHBvcnRzLk5FWFRfUk9VVEVSX1BSRUZFVENIID0gZXhwb3J0cy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFID0gZXhwb3J0cy5BQ1RJT04gPSBleHBvcnRzLlJTQyA9IHZvaWQgMDtcbmNvbnN0IFJTQyA9ICdSU0MnO1xuZXhwb3J0cy5SU0MgPSBSU0M7XG5jb25zdCBBQ1RJT04gPSAnQWN0aW9uJztcbmV4cG9ydHMuQUNUSU9OID0gQUNUSU9OO1xuY29uc3QgTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9ICdOZXh0LVJvdXRlci1TdGF0ZS1UcmVlJztcbmV4cG9ydHMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUU7XG5jb25zdCBORVhUX1JPVVRFUl9QUkVGRVRDSCA9ICdOZXh0LVJvdXRlci1QcmVmZXRjaCc7XG5leHBvcnRzLk5FWFRfUk9VVEVSX1BSRUZFVENIID0gTkVYVF9ST1VURVJfUFJFRkVUQ0g7XG5jb25zdCBGRVRDSF9DQUNIRV9IRUFERVIgPSAneC12ZXJjZWwtc2MtaGVhZGVycyc7XG5leHBvcnRzLkZFVENIX0NBQ0hFX0hFQURFUiA9IEZFVENIX0NBQ0hFX0hFQURFUjtcbmNvbnN0IFJTQ19DT05URU5UX1RZUEVfSEVBREVSID0gJ3RleHQveC1jb21wb25lbnQnO1xuZXhwb3J0cy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9IFJTQ19DT05URU5UX1RZUEVfSEVBREVSO1xuY29uc3QgUlNDX1ZBUllfSEVBREVSID0gYCR7UlNDfSwgJHtORVhUX1JPVVRFUl9TVEFURV9UUkVFfSwgJHtORVhUX1JPVVRFUl9QUkVGRVRDSH1gO1xuZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBSU0NfVkFSWV9IRUFERVI7XG5jb25zdCBGTElHSFRfUEFSQU1FVEVSUyA9IFtcbiAgICBbXG4gICAgICAgIFJTQ1xuICAgIF0sXG4gICAgW1xuICAgICAgICBORVhUX1JPVVRFUl9TVEFURV9UUkVFXG4gICAgXSxcbiAgICBbXG4gICAgICAgIE5FWFRfUk9VVEVSX1BSRUZFVENIXG4gICAgXSwgXG5dO1xuZXhwb3J0cy5GTElHSFRfUEFSQU1FVEVSUyA9IEZMSUdIVF9QQVJBTUVURVJTO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWhlYWRlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRkxJR0hUX1BBUkFNRVRFUlMiLCJSU0NfVkFSWV9IRUFERVIiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkZFVENIX0NBQ0hFX0hFQURFUiIsIk5FWFRfUk9VVEVSX1BSRUZFVENIIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIkFDVElPTiIsIlJTQyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/app-router-headers.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.urlToUrlWithoutFlightMarker = urlToUrlWithoutFlightMarker;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _routerReducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nvar _routerReducerTypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"../../shared/lib/hooks-client-context\");\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"(sc_client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(sc_client)/./node_modules/next/dist/client/components/error-boundary.js\");\nvar _createInitialRouterState = __webpack_require__(/*! ./router-reducer/create-initial-router-state */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nvar _fetchServerResponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _isBot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"../../shared/lib/router/utils/is-bot\");\nvar _addBasePath = __webpack_require__(/*! ../add-base-path */ \"(sc_client)/./node_modules/next/dist/client/add-base-path.js\");\nfunction AppRouter(props) {\n    const { globalErrorComponent  } = props, rest = _object_without_properties_loose(props, [\n        \"globalErrorComponent\"\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n        errorComponent: globalErrorComponent\n    }, /*#__PURE__*/ _react.default.createElement(Router, Object.assign({}, rest)));\n}\nconst isServer = \"undefined\" === \"undefined\";\n// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\nlet initialParallelRoutes = isServer ? null : new Map();\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    // TODO-APP: handle .rsc for static export case\n    return urlWithoutFlightParameters;\n}\nconst HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\nconst prefetched = new Set();\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\n/**\n * The global router that wraps the application components.\n */ function Router({ initialHead , initialTree , initialCanonicalUrl , children , assetPrefix  }) {\n    const initialState = (0, _react).useMemo(()=>(0, _createInitialRouterState).createInitialRouterState({\n            children,\n            initialCanonicalUrl,\n            initialTree,\n            initialParallelRoutes,\n            isServer,\n            location: !isServer ? window.location : null,\n            initialHead\n        }), [\n        children,\n        initialCanonicalUrl,\n        initialTree,\n        initialHead\n    ]);\n    const [{ tree , cache , prefetchCache , pushRef , focusAndScrollRef , canonicalUrl  }, dispatch, sync] = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_routerReducer.reducer, initialState);\n    (0, _react).useEffect(()=>{\n        // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n        initialParallelRoutes = null;\n    }, []);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams , pathname  } = (0, _react).useMemo(()=>{\n        const url = new URL(canonicalUrl,  true ? \"http://n\" : 0);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    /**\n   * Server response that only patches the cache and tree.\n   */ const changeByServerResponse = (0, _react).useCallback((previousTree, flightData, overrideCanonicalUrl)=>{\n        dispatch({\n            type: _routerReducerTypes.ACTION_SERVER_PATCH,\n            flightData,\n            previousTree,\n            overrideCanonicalUrl,\n            cache: {\n                status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                data: null,\n                subTreeData: null,\n                parallelRoutes: new Map()\n            },\n            mutable: {}\n        });\n    }, [\n        dispatch\n    ]);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react).useMemo(()=>{\n        const navigate = (href, navigateType, forceOptimisticNavigation)=>{\n            const url = new URL((0, _addBasePath).addBasePath(href), location.origin);\n            return dispatch({\n                type: _routerReducerTypes.ACTION_NAVIGATE,\n                url,\n                isExternalUrl: isExternalURL(url),\n                locationSearch: location.search,\n                forceOptimisticNavigation,\n                navigateType,\n                cache: {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                },\n                mutable: {}\n            });\n        };\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch: _async_to_generator(function*(href) {\n                const hrefWithBasePath = (0, _addBasePath).addBasePath(href);\n                // If prefetch has already been triggered, don't trigger it again.\n                if (prefetched.has(hrefWithBasePath) ||  false && 0) {\n                    return;\n                }\n                prefetched.add(hrefWithBasePath);\n                const url = new URL(hrefWithBasePath, location.origin);\n                // External urls can't be prefetched in the same way.\n                if (isExternalURL(url)) {\n                    return;\n                }\n                try {\n                    var ref;\n                    const routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                    const serverResponse = yield (0, _fetchServerResponse).fetchServerResponse(url, routerTree, true);\n                    // @ts-ignore startTransition exists\n                    _react.default.startTransition(()=>{\n                        dispatch({\n                            type: _routerReducerTypes.ACTION_PREFETCH,\n                            url,\n                            tree: routerTree,\n                            serverResponse\n                        });\n                    });\n                } catch (err) {\n                    console.error(\"PREFETCH ERROR\", err);\n                }\n            }),\n            replace: (href, options = {})=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"replace\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            push: (href, options = {})=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"push\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            refresh: ()=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    dispatch({\n                        type: _routerReducerTypes.ACTION_REFRESH,\n                        cache: {\n                            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                            data: null,\n                            subTreeData: null,\n                            parallelRoutes: new Map()\n                        },\n                        mutable: {},\n                        origin: window.location.origin\n                    });\n                });\n            }\n        };\n        return routerInstance;\n    }, [\n        dispatch,\n        initialTree\n    ]);\n    (0, _react).useEffect(()=>{\n        // When mpaNavigation flag is set do a hard navigation to the new url.\n        if (pushRef.mpaNavigation) {\n            const location1 = window.location;\n            if (pushRef.pendingPush) {\n                location1.assign(canonicalUrl);\n            } else {\n                location1.replace(canonicalUrl);\n            }\n            return;\n        }\n        // Identifier is shortened intentionally.\n        // __NA is used to identify if the history entry can be handled by the app-router.\n        // __N is used to identify if the history entry can be handled by the old router.\n        const historyState = {\n            __NA: true,\n            tree\n        };\n        if (pushRef.pendingPush && (0, _createHrefFromUrl).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, \"\", canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, \"\", canonicalUrl);\n        }\n        sync();\n    }, [\n        tree,\n        pushRef,\n        canonicalUrl,\n        sync\n    ]);\n    // Add `window.nd` for debugging purposes.\n    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n    if (false) {}\n    /**\n   * Handle popstate event, this is used to handle back/forward in the browser.\n   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n   * That case can happen when the old router injected the history entry.\n   */ const onPopState = (0, _react).useCallback(({ state  })=>{\n        if (!state) {\n            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n            return;\n        }\n        // This case happens when the history entry was pushed by the `pages` router.\n        if (!state.__NA) {\n            window.location.reload();\n            return;\n        }\n        // @ts-ignore useTransition exists\n        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n        // Without startTransition works if the cache is there for this path\n        _react.default.startTransition(()=>{\n            dispatch({\n                type: _routerReducerTypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: state.tree\n            });\n        });\n    }, [\n        dispatch\n    ]);\n    // Register popstate event to call onPopstate.\n    (0, _react).useEffect(()=>{\n        window.addEventListener(\"popstate\", onPopState);\n        return ()=>{\n            window.removeEventListener(\"popstate\", onPopState);\n        };\n    }, [\n        onPopState\n    ]);\n    const content = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, cache.subTreeData);\n    return /*#__PURE__*/ _react.default.createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: pathname\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: searchParams\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n        value: {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: appRouter\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            childNodes: cache.parallelRoutes,\n            tree: tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            headRenderedAboveThisLevel: false\n        }\n    }, HotReloader ? /*#__PURE__*/ _react.default.createElement(HotReloader, {\n        assetPrefix: assetPrefix\n    }, content) : content)))));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILG1DQUFtQyxHQUFHSTtBQUN0QyxJQUFJQyxzQkFBc0JDLHFKQUEwRDtBQUNwRixJQUFJQyw0QkFBNEJELGlLQUFnRTtBQUNoRyxJQUFJRSxtQ0FBbUNGLCtLQUF1RTtBQUM5RyxJQUFJRyxTQUFTRiwwQkFBMEJELG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3RELElBQUlJLG9CQUFvQkosbUJBQU9BLENBQUMsZ0ZBQXFDO0FBQ3JFLElBQUlLLGlCQUFpQkwsbUJBQU9BLENBQUMsZ0lBQWlDO0FBQzlELElBQUlNLHNCQUFzQk4sbUJBQU9BLENBQUMsNElBQXVDO0FBQ3pFLElBQUlPLHFCQUFxQlAsbUJBQU9BLENBQUMsNElBQXVDO0FBQ3hFLElBQUlRLHNCQUFzQlIsbUJBQU9BLENBQUMsb0ZBQXVDO0FBQ3pFLElBQUlTLDBCQUEwQlQsbUJBQU9BLENBQUMsd0hBQTZCO0FBQ25FLElBQUlVLGlCQUFpQlYsbUJBQU9BLENBQUMsa0dBQWtCO0FBQy9DLElBQUlXLDRCQUE0QlgsbUJBQU9BLENBQUMsMEpBQThDO0FBQ3RGLElBQUlZLHVCQUF1QlosbUJBQU9BLENBQUMsOElBQXdDO0FBQzNFLElBQUlhLFNBQVNiLG1CQUFPQSxDQUFDLGtGQUFzQztBQUMzRCxJQUFJYyxlQUFlZCxtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDN0MsU0FBU0gsVUFBVWtCLEtBQUssRUFBRTtJQUN0QixNQUFNLEVBQUVDLHFCQUFvQixFQUFHLEdBQUdELE9BQU9FLE9BQU9mLGlDQUFpQ2EsT0FBTztRQUNwRjtLQUNIO0lBQ0QsT0FBTyxXQUFXLEdBQUdaLE9BQU9QLE9BQU8sQ0FBQ3NCLGFBQWEsQ0FBQ1IsZUFBZVMs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QUFPOEU7SUFDWCxHQUFHLFdBQVcsR0FBR3RFLE9BQU9QLE9BQU8sQ0FBQ3NCLGFBQWEsQ0FBQ2Qsa0JBQWtCOEgsbUJBQW1CLENBQUNKLFFBQVEsRUFBRTtRQUMxRm5JLE9BQU87WUFDSHdJLFlBQVlyRixNQUFNeUIsY0FBYztZQUNoQzFCLE1BQU1BO1lBQ04sNkJBQTZCO1lBQzdCLDhFQUE4RTtZQUM5RW5CLEtBQUt3QjtZQUNMa0YsNEJBQTRCLEtBQUs7UUFDckM7SUFDSixHQUFHckcsY0FBYyxXQUFXLEdBQUc1QixPQUFPUCxPQUFPLENBQUNzQixhQUFhLENBQUNhLGFBQWE7UUFDckVVLGFBQWFBO0lBQ2pCLEdBQUdrRixXQUFXQSxPQUFPO0FBQ3pCO0FBRUEsSUFBSSxDQUFDLE9BQU9qSSxRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUN5SSxVQUFVLEtBQUssYUFBYTtJQUNySzdJLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU84QixNQUFNLENBQUM1QixRQUFRRSxPQUFPLEVBQUVGO0lBQy9CNEksT0FBTzVJLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcz80MTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHBSb3V0ZXI7XG5leHBvcnRzLnVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciA9IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcjtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfcm91dGVyUmVkdWNlciA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyXCIpO1xudmFyIF9yb3V0ZXJSZWR1Y2VyVHlwZXMgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbnZhciBfY3JlYXRlSHJlZkZyb21VcmwgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHRcIik7XG52YXIgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMgPSByZXF1aXJlKFwiLi91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX2NyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZVwiKTtcbnZhciBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbnZhciBfaXNCb3QgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90XCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi9hZGQtYmFzZS1wYXRoXCIpO1xuZnVuY3Rpb24gQXBwUm91dGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBnbG9iYWxFcnJvckNvbXBvbmVudCAgfSA9IHByb3BzLCByZXN0ID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UocHJvcHMsIFtcbiAgICAgICAgXCJnbG9iYWxFcnJvckNvbXBvbmVudFwiXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIGVycm9yQ29tcG9uZW50OiBnbG9iYWxFcnJvckNvbXBvbmVudFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb3V0ZXIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QpKSk7XG59XG5cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4vLyBFbnN1cmUgdGhlIGluaXRpYWxQYXJhbGxlbFJvdXRlcyBhcmUgbm90IGNvbWJpbmVkIGJlY2F1c2Ugb2YgZG91YmxlLXJlbmRlcmluZyBpbiB0aGUgYnJvd3NlciB3aXRoIFN0cmljdCBNb2RlLlxubGV0IGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IGlzU2VydmVyID8gbnVsbCA6IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmwpIHtcbiAgICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgLnJzYyBmb3Igc3RhdGljIGV4cG9ydCBjYXNlXG4gICAgcmV0dXJuIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzO1xufVxuY29uc3QgSG90UmVsb2FkZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gbnVsbCA6IHJlcXVpcmUoJy4vcmVhY3QtZGV2LW92ZXJsYXkvaG90LXJlbG9hZGVyLWNsaWVudCcpLmRlZmF1bHQ7XG5jb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbn1cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBSb3V0ZXIoeyBpbml0aWFsSGVhZCAsIGluaXRpYWxUcmVlICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGNoaWxkcmVuICwgYXNzZXRQcmVmaXggIH0pIHtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT4oMCwgX2NyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSkuY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHtcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGluaXRpYWxUcmVlLFxuICAgICAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgaXNTZXJ2ZXIsXG4gICAgICAgICAgICBsb2NhdGlvbjogIWlzU2VydmVyID8gd2luZG93LmxvY2F0aW9uIDogbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxIZWFkXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpbml0aWFsQ2Fub25pY2FsVXJsLFxuICAgICAgICBpbml0aWFsVHJlZSxcbiAgICAgICAgaW5pdGlhbEhlYWRcbiAgICBdKTtcbiAgICBjb25zdCBbeyB0cmVlICwgY2FjaGUgLCBwcmVmZXRjaENhY2hlICwgcHVzaFJlZiAsIGZvY3VzQW5kU2Nyb2xsUmVmICwgY2Fub25pY2FsVXJsICB9LCBkaXNwYXRjaCwgc3luYywgXSA9ICgwLCBfdXNlUmVkdWNlcldpdGhEZXZ0b29scykudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzKF9yb3V0ZXJSZWR1Y2VyLnJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIEVuc3VyZSBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgaXMgY2xlYW5lZCB1cCBmcm9tIG1lbW9yeSBvbmNlIGl0J3MgdXNlZC5cbiAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gbnVsbDtcbiAgICB9LCBbXSk7XG4gICAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zICwgcGF0aG5hbWUgIH0gPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY2Fub25pY2FsVXJsLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNhbm9uaWNhbFVybFxuICAgIF0pO1xuICAgIC8qKlxuICAgKiBTZXJ2ZXIgcmVzcG9uc2UgdGhhdCBvbmx5IHBhdGNoZXMgdGhlIGNhY2hlIGFuZCB0cmVlLlxuICAgKi8gY29uc3QgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChwcmV2aW91c1RyZWUsIGZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsKT0+e1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgcHJldmlvdXNUcmVlLFxuICAgICAgICAgICAgb3ZlcnJpZGVDYW5vbmljYWxVcmwsXG4gICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoXG4gICAgXSk7XG4gICAgLyoqXG4gICAqIFRoZSBhcHAgcm91dGVyIHRoYXQgaXMgZXhwb3NlZCB0aHJvdWdoIGB1c2VSb3V0ZXJgLiBJdCdzIG9ubHkgY29uY2VybmVkIHdpdGggZGlzcGF0Y2hpbmcgYWN0aW9ucyB0byB0aGUgcmVkdWNlciwgZG9lcyBub3QgaG9sZCBzdGF0ZS5cbiAgICovIGNvbnN0IGFwcFJvdXRlciA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgbmF2aWdhdGUgPSAoaHJlZiwgbmF2aWdhdGVUeXBlLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKT0+e1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCgoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChocmVmKSwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fTkFWSUdBVEUsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGlzRXh0ZXJuYWxVcmw6IGlzRXh0ZXJuYWxVUkwodXJsKSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvblNlYXJjaDogbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUeXBlLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm91dGVySW5zdGFuY2UgPSB7XG4gICAgICAgICAgICBiYWNrOiAoKT0+d2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICAgICAgICAgICAgZm9yd2FyZDogKCk9PndpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSxcbiAgICAgICAgICAgIHByZWZldGNoOiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihocmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZldpdGhCYXNlUGF0aCA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKGhyZWYpO1xuICAgICAgICAgICAgICAgIC8vIElmIHByZWZldGNoIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLCBkb24ndCB0cmlnZ2VyIGl0IGFnYWluLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhocmVmV2l0aEJhc2VQYXRoKSB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoMCwgX2lzQm90KS5pc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmVmZXRjaGVkLmFkZChocmVmV2l0aEJhc2VQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWZXaXRoQmFzZVBhdGgsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZXJuYWwgdXJscyBjYW4ndCBiZSBwcmVmZXRjaGVkIGluIHRoZSBzYW1lIHdheS5cbiAgICAgICAgICAgICAgICBpZiAoaXNFeHRlcm5hbFVSTCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVyVHJlZSA9ICgocmVmID0gd2luZG93Lmhpc3Rvcnkuc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYudHJlZSkgfHwgaW5pdGlhbFRyZWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0geWllbGQgKDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgLy8gaW5pdGlhbFRyZWUgaXMgdXNlZCB3aGVuIGhpc3Rvcnkuc3RhdGUudHJlZSBpcyBtaXNzaW5nIGJlY2F1c2UgdGhlIGhpc3Rvcnkgc3RhdGUgaXMgc2V0IGluIGB1c2VFZmZlY3RgIGJlbG93LCBpdCBiZWluZyBtaXNzaW5nIG1lYW5zIHRoaXMgaXMgdGhlIGh5ZHJhdGlvbiBjYXNlLlxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJUcmVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiByb3V0ZXJUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BSRUZFVENIIEVSUk9SJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlcGxhY2U6IChocmVmLCBvcHRpb25zID0ge30pPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdyZXBsYWNlJywgQm9vbGVhbihvcHRpb25zLmZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncHVzaCcsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmcmVzaDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fUkVGUkVTSCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGU6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm91dGVySW5zdGFuY2U7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gV2hlbiBtcGFOYXZpZ2F0aW9uIGZsYWcgaXMgc2V0IGRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBuZXcgdXJsLlxuICAgICAgICBpZiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uYXNzaWduKGNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoY2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZGVudGlmaWVyIGlzIHNob3J0ZW5lZCBpbnRlbnRpb25hbGx5LlxuICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgIC8vIF9fTiBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgICBjb25zdCBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICAgICAgICBfX05BOiB0cnVlLFxuICAgICAgICAgICAgdHJlZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCAmJiAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkgIT09IGNhbm9uaWNhbFVybCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpbnRlbnRpb25hbGx5IG11dGF0ZXMgUmVhY3Qgc3RhdGUsIHB1c2hSZWYgaXMgb3ZlcndyaXR0ZW4gdG8gZW5zdXJlIGFkZGl0aW9uYWwgcHVzaC9yZXBsYWNlIGNhbGxzIGRvIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgaGlzdG9yeSBlbnRyeS5cbiAgICAgICAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIGNhbm9uaWNhbFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgc3luYygpO1xuICAgIH0sIFtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgcHVzaFJlZixcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICBzeW5jXG4gICAgXSk7XG4gICAgLy8gQWRkIGB3aW5kb3cubmRgIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICB3aW5kb3cubmQgPSB7XG4gICAgICAgICAgICByb3V0ZXI6IGFwcFJvdXRlcixcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIHRyZWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEhhbmRsZSBwb3BzdGF0ZSBldmVudCwgdGhpcyBpcyB1c2VkIHRvIGhhbmRsZSBiYWNrL2ZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgKiBUaGF0IGNhc2UgY2FuIGhhcHBlbiB3aGVuIHRoZSBvbGQgcm91dGVyIGluamVjdGVkIHRoZSBoaXN0b3J5IGVudHJ5LlxuICAgKi8gY29uc3Qgb25Qb3BTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCh7IHN0YXRlICB9KT0+e1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGhpc3RvcnkgZW50cnkgd2FzIHB1c2hlZCBieSB0aGUgYHBhZ2VzYCByb3V0ZXIuXG4gICAgICAgIGlmICghc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdXNlVHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBXaXRob3V0IHN0YXJ0VHJhbnNpdGlvbiB3b3JrcyBpZiB0aGUgY2FjaGUgaXMgdGhlcmUgZm9yIHRoaXMgcGF0aFxuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgICAgICAgIHVybDogbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksXG4gICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgb25Qb3BTdGF0ZVxuICAgIF0pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNhY2hlLnN1YlRyZWVEYXRhKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuUGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwYXRobmFtZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHNlYXJjaFBhcmFtc1xuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogYXBwUm91dGVyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNhY2hlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgIC8vIFJvb3Qgbm9kZSBhbHdheXMgaGFzIGB1cmxgXG4gICAgICAgICAgICAvLyBQcm92aWRlZCBpbiBBcHBUcmVlQ29udGV4dCB0byBlbnN1cmUgaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGluIGxheW91dC1yb3V0ZXJcbiAgICAgICAgICAgIHVybDogY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LCBIb3RSZWxvYWRlciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIb3RSZWxvYWRlciwge1xuICAgICAgICBhc3NldFByZWZpeDogYXNzZXRQcmVmaXhcbiAgICB9LCBjb250ZW50KSA6IGNvbnRlbnQpKSkpKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiQXBwUm91dGVyIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3QiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9yb3V0ZXJSZWR1Y2VyIiwiX3JvdXRlclJlZHVjZXJUeXBlcyIsIl9jcmVhdGVIcmVmRnJvbVVybCIsIl9ob29rc0NsaWVudENvbnRleHQiLCJfdXNlUmVkdWNlcldpdGhEZXZ0b29scyIsIl9lcnJvckJvdW5kYXJ5IiwiX2NyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsIl9mZXRjaFNlcnZlclJlc3BvbnNlIiwiX2lzQm90IiwiX2FkZEJhc2VQYXRoIiwicHJvcHMiLCJnbG9iYWxFcnJvckNvbXBvbmVudCIsInJlc3QiLCJjcmVhdGVFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiUm91dGVyIiwiYXNzaWduIiwiaXNTZXJ2ZXIiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJ1cmwiLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiSG90UmVsb2FkZXIiLCJwcm9jZXNzIiwicHJlZmV0Y2hlZCIsIlNldCIsImlzRXh0ZXJuYWxVUkwiLCJ3aW5kb3ciLCJpbml0aWFsSGVhZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImNoaWxkcmVuIiwiYXNzZXRQcmVmaXgiLCJpbml0aWFsU3RhdGUiLCJ1c2VNZW1vIiwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwidHJlZSIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImNhbm9uaWNhbFVybCIsImRpc3BhdGNoIiwic3luYyIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsInJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsImhyZWYiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwidXNlQ2FsbGJhY2siLCJwcmV2aW91c1RyZWUiLCJmbGlnaHREYXRhIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInBhcmFsbGVsUm91dGVzIiwibXV0YWJsZSIsImFwcFJvdXRlciIsIm5hdmlnYXRlIiwibmF2aWdhdGVUeXBlIiwiZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiIsImFkZEJhc2VQYXRoIiwiQUNUSU9OX05BVklHQVRFIiwiaXNFeHRlcm5hbFVybCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsImhyZWZXaXRoQmFzZVBhdGgiLCJoYXMiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImFkZCIsInJlZiIsInJvdXRlclRyZWUiLCJzdGF0ZSIsInNlcnZlclJlc3BvbnNlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsIkFDVElPTl9QUkVGRVRDSCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInJlcGxhY2UiLCJvcHRpb25zIiwiQm9vbGVhbiIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJtcGFOYXZpZ2F0aW9uIiwicGVuZGluZ1B1c2giLCJoaXN0b3J5U3RhdGUiLCJfX05BIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJuZCIsInJvdXRlciIsIm9uUG9wU3RhdGUiLCJyZWxvYWQiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29udGVudCIsIkZyYWdtZW50IiwiUGF0aG5hbWVDb250ZXh0IiwiUHJvdmlkZXIiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiY2hpbGROb2RlcyIsImhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsIiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/app-router.js\n");

/***/ }),

/***/ "(sc_shared)/./node_modules/next/dist/client/components/async-local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/async-local-storage.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createAsyncLocalStorage = createAsyncLocalStorage;\nclass FakeAsyncLocalStorage {\n    disable() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    getStore() {\n        // This fake implementation of AsyncLocalStorage always returns `undefined`.\n        return undefined;\n    }\n    run() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    exit() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n    enterWith() {\n        throw new Error(\"Invariant: AsyncLocalStorage accessed in runtime where it is not available\");\n    }\n}\nfunction createAsyncLocalStorage() {\n    if (globalThis.AsyncLocalStorage) {\n        return new globalThis.AsyncLocalStorage();\n    }\n    return new FakeAsyncLocalStorage();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=async-local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NoYXJlZCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FzeW5jLWxvY2FsLXN0b3JhZ2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsK0JBQStCLEdBQUdFO0FBQ2xDLE1BQU1DO0lBQ0ZDLFVBQVU7UUFDTixNQUFNLElBQUlDLE1BQU0sOEVBQThFO0lBQ2xHO0lBQ0FDLFdBQVc7UUFDUCw0RUFBNEU7UUFDNUUsT0FBT0M7SUFDWDtJQUNBQyxNQUFNO1FBQ0YsTUFBTSxJQUFJSCxNQUFNLDhFQUE4RTtJQUNsRztJQUNBSSxPQUFPO1FBQ0gsTUFBTSxJQUFJSixNQUFNLDhFQUE4RTtJQUNsRztJQUNBSyxZQUFZO1FBQ1IsTUFBTSxJQUFJTCxNQUFNLDhFQUE4RTtJQUNsRztBQUNKO0FBQ0EsU0FBU0gsMEJBQTBCO0lBQy9CLElBQUlTLFdBQVdDLGlCQUFpQixFQUFFO1FBQzlCLE9BQU8sSUFBSUQsV0FBV0MsaUJBQWlCO0lBQzNDLENBQUM7SUFDRCxPQUFPLElBQUlUO0FBQ2Y7QUFFQSxJQUFJLENBQUMsT0FBT0gsUUFBUWEsT0FBTyxLQUFLLGNBQWUsT0FBT2IsUUFBUWEsT0FBTyxLQUFLLFlBQVliLFFBQVFhLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2IsUUFBUWEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWEsT0FBTyxFQUFFLGNBQWM7UUFBRVosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9pQixNQUFNLENBQUNmLFFBQVFhLE9BQU8sRUFBRWI7SUFDL0JnQixPQUFPaEIsT0FBTyxHQUFHQSxRQUFRYSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hc3luYy1sb2NhbC1zdG9yYWdlLmpzP2FmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlID0gY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2U7XG5jbGFzcyBGYWtlQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIC8vIFRoaXMgZmFrZSBpbXBsZW1lbnRhdGlvbiBvZiBBc3luY0xvY2FsU3RvcmFnZSBhbHdheXMgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogQXN5bmNMb2NhbFN0b3JhZ2UgYWNjZXNzZWQgaW4gcnVudGltZSB3aGVyZSBpdCBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIGV4aXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgZW50ZXJXaXRoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFyaWFudDogQXN5bmNMb2NhbFN0b3JhZ2UgYWNjZXNzZWQgaW4gcnVudGltZSB3aGVyZSBpdCBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLkFzeW5jTG9jYWxTdG9yYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmFrZUFzeW5jTG9jYWxTdG9yYWdlKCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWxvY2FsLXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiLCJGYWtlQXN5bmNMb2NhbFN0b3JhZ2UiLCJkaXNhYmxlIiwiRXJyb3IiLCJnZXRTdG9yZSIsInVuZGVmaW5lZCIsInJ1biIsImV4aXQiLCJlbnRlcldpdGgiLCJnbG9iYWxUaGlzIiwiQXN5bmNMb2NhbFN0b3JhZ2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_shared)/./node_modules/next/dist/client/components/async-local-storage.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/bailout-to-client-rendering.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/bailout-to-client-rendering.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bailoutToClientRendering = bailoutToClientRendering;\nvar _dynamicNoSsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/dynamic-no-ssr */ \"(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js\");\nvar _staticGenerationAsyncStorage = __webpack_require__(/*! ./static-generation-async-storage */ \"(sc_shared)/./node_modules/next/dist/client/components/static-generation-async-storage.js\");\nfunction bailoutToClientRendering() {\n    const staticGenerationStore = _staticGenerationAsyncStorage.staticGenerationAsyncStorage.getStore();\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {\n        return true;\n    }\n    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {\n        (0, _dynamicNoSsr).suspense();\n    }\n    return false;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=bailout-to-client-rendering.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2JhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBR0U7QUFDbkMsSUFBSUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvSUFBOEM7QUFDMUUsSUFBSUMsZ0NBQWdDRCxtQkFBT0EsQ0FBQyxvSUFBbUM7QUFDL0UsU0FBU0YsMkJBQTJCO0lBQ2hDLE1BQU1JLHdCQUF3QkQsOEJBQThCRSw0QkFBNEIsQ0FBQ0MsUUFBUTtJQUNqRyxJQUFJRix5QkFBeUIsSUFBSSxHQUFHLEtBQUssSUFBSUEsc0JBQXNCRyxXQUFXLEVBQUU7UUFDNUUsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELElBQUlILHlCQUF5QixJQUFJLEdBQUcsS0FBSyxJQUFJQSxzQkFBc0JJLGtCQUFrQixFQUFFO1FBQ2xGLElBQUdQLGFBQWEsRUFBRVEsUUFBUTtJQUMvQixDQUFDO0lBQ0QsT0FBTyxLQUFLO0FBQ2hCO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFZLE9BQU8sS0FBSyxjQUFlLE9BQU9aLFFBQVFZLE9BQU8sS0FBSyxZQUFZWixRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9aLFFBQVFZLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVksT0FBTyxFQUFFLGNBQWM7UUFBRVgsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLFFBQVFZLE9BQU8sRUFBRVo7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsUUFBUVksT0FBTztBQUNsQyxDQUFDLENBRUQsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYmFpbG91dC10by1jbGllbnQtcmVuZGVyaW5nLmpzP2IxNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyA9IGJhaWxvdXRUb0NsaWVudFJlbmRlcmluZztcbnZhciBfZHluYW1pY05vU3NyID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2R5bmFtaWMtbm8tc3NyXCIpO1xudmFyIF9zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlID0gcmVxdWlyZShcIi4vc3RhdGljLWdlbmVyYXRpb24tYXN5bmMtc3RvcmFnZVwiKTtcbmZ1bmN0aW9uIGJhaWxvdXRUb0NsaWVudFJlbmRlcmluZygpIHtcbiAgICBjb25zdCBzdGF0aWNHZW5lcmF0aW9uU3RvcmUgPSBfc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZS5zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHN0YXRpY0dlbmVyYXRpb25TdG9yZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljR2VuZXJhdGlvblN0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGljR2VuZXJhdGlvblN0b3JlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNHZW5lcmF0aW9uU3RvcmUuaXNTdGF0aWNHZW5lcmF0aW9uKSB7XG4gICAgICAgICgwLCBfZHluYW1pY05vU3NyKS5zdXNwZW5zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmciLCJfZHluYW1pY05vU3NyIiwicmVxdWlyZSIsIl9zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIiwic3RhdGljR2VuZXJhdGlvblN0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJpc1N0YXRpY0dlbmVyYXRpb24iLCJzdXNwZW5zZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/bailout-to-client-rendering.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/client-hook-in-server-component-error.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-hook-in-server-component-error.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.clientHookInServerComponentError = clientHookInServerComponentError;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nfunction clientHookInServerComponentError(hookName) {\n    if (true) {\n        // If useState is undefined we're in a server component\n        if (!_react.default.useState) {\n            throw new Error(`${hookName} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);\n        }\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client-hook-in-server-component-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1ob29rLWluLXNlcnZlci1jb21wb25lbnQtZXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsd0NBQXdDLEdBQUdFO0FBQzNDLElBQUlDLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlFLFNBQVNILHlCQUF5QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsU0FBU0YsaUNBQWlDSyxRQUFRLEVBQUU7SUFDaEQsSUFBSUMsSUFBeUIsRUFBYztRQUN2Qyx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDRixPQUFPRCxPQUFPLENBQUNJLFFBQVEsRUFBRTtZQUMxQixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFSCxTQUFTLG9MQUFvTCxDQUFDLEVBQUU7UUFDdk4sQ0FBQztJQUNMLENBQUM7QUFDTDtBQUVBLElBQUksQ0FBQyxPQUFPUCxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNNLFVBQVUsS0FBSyxhQUFhO0lBQ3JLYixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYyxNQUFNLENBQUNaLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JhLE9BQU9iLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsaUVBQWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LWhvb2staW4tc2VydmVyLWNvbXBvbmVudC1lcnJvci5qcz8zZGFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvciA9IGNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IoaG9va05hbWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBJZiB1c2VTdGF0ZSBpcyB1bmRlZmluZWQgd2UncmUgaW4gYSBzZXJ2ZXIgY29tcG9uZW50XG4gICAgICAgIGlmICghX3JlYWN0LmRlZmF1bHQudXNlU3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtob29rTmFtZX0gb25seSB3b3JrcyBpbiBDbGllbnQgQ29tcG9uZW50cy4gQWRkIHRoZSBcInVzZSBjbGllbnRcIiBkaXJlY3RpdmUgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZSB0byB1c2UgaXQuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcmVhY3QtY2xpZW50LWhvb2staW4tc2VydmVyLWNvbXBvbmVudGApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtaG9vay1pbi1zZXJ2ZXItY29tcG9uZW50LWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJob29rTmFtZSIsInByb2Nlc3MiLCJ1c2VTdGF0ZSIsIkVycm9yIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/client-hook-in-server-component-error.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/error-boundary.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/error-boundary.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = GlobalError;\nexports.ErrorBoundary = ErrorBoundary;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nfunction GlobalError({ error  }) {\n    return /*#__PURE__*/ _react.default.createElement(\"html\", null, /*#__PURE__*/ _react.default.createElement(\"head\", null), /*#__PURE__*/ _react.default.createElement(\"body\", null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.error\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.desc\n    }, /*#__PURE__*/ _react.default.createElement(\"h2\", {\n        style: styles.text\n    }, \"Application error: a client-side exception has occurred (see the browser console for more information).\"), (error == null ? void 0 : error.digest) && /*#__PURE__*/ _react.default.createElement(\"p\", {\n        style: styles.text\n    }, `Digest: ${error.digest}`)))));\n}\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        textAlign: \"left\"\n    },\n    text: {\n        fontSize: \"14px\",\n        fontWeight: 400,\n        lineHeight: \"3em\",\n        margin: 0\n    }\n};\nclass ErrorBoundaryHandler extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, this.props.errorStyles, /*#__PURE__*/ _react.default.createElement(this.props.errorComponent, {\n                error: this.state.error,\n                reset: this.reset\n            }));\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null\n        };\n    }\n}\nexports.ErrorBoundaryHandler = ErrorBoundaryHandler;\nfunction ErrorBoundary({ errorComponent , errorStyles , children  }) {\n    if (errorComponent) {\n        return /*#__PURE__*/ _react.default.createElement(ErrorBoundaryHandler, {\n            errorComponent: errorComponent,\n            errorStyles: errorStyles\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCSCxxQkFBcUIsR0FBR0k7QUFDeEIsSUFBSUMsMkJBQTJCQywrSkFBK0Q7QUFDOUYsSUFBSUMsU0FBU0YseUJBQXlCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxTQUFTSCxZQUFZLEVBQUVLLE1BQUssRUFBRyxFQUFFO0lBQzdCLE9BQU8sV0FBVyxHQUFHRCxPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRSxXQUFXLEdBQUdGLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLFFBQVEsSUFBSSxHQUFHLFdBQVcsR0FBR0YsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsUUFBUSxJQUFJLEVBQUUsV0FBVyxHQUFHRixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxPQUFPO1FBQ2pPQyxPQUFPQyxPQUFPSCxLQUFLO0lBQ3ZCLEdBQUcsV0FBVyxHQUFHRCxPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxPQUFPO1FBQ2pEQyxPQUFPQyxPQUFPQyxJQUFJO0lBQ3RCLEdBQUcsV0FBVyxHQUFHTCxPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxNQUFNO1FBQ2hEQyxPQUFPQyxPQUFPRSxJQUFJO0lBQ3RCLEdBQUcsNEdBQTRHLENBQUNMLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSUEsTUFBTU0sTUFBTSxLQUFLLFdBQVcsR0FBR1AsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsS0FBSztRQUN0TUMsT0FBT0MsT0FBT0UsSUFBSTtJQUN0QixHQUFHLENBQUMsUUFBUSxFQUFFTCxNQUFNTSxNQUFNLENBQUMsQ0FBQztBQUNoQztBQUVBLE1BQU1ILFNBQVM7SUFDWEgsT0FBTztRQUNILDBGQUEwRjtRQUMxRk8sWUFBWTtRQUNaQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsZ0JBQWdCO0lBQ3BCO0lBQ0FULE1BQU07UUFDRkssV0FBVztJQUNmO0lBQ0FKLE1BQU07UUFDRlMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsUUFBUTtJQUNaO0FBQ0o7QUFDQSxNQUFNQyw2QkFBNkJuQixPQUFPTCxPQUFPLENBQUN5QixTQUFTO0lBQ3ZELE9BQU9DLHlCQUF5QnBCLEtBQUssRUFBRTtRQUNuQyxPQUFPO1lBQ0hBO1FBQ0o7SUFDSjtJQUNBcUIsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDQyxLQUFLLENBQUN0QixLQUFLLEVBQUU7WUFDbEIsT0FBTyxXQUFXLEdBQUdELE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDRixPQUFPTCxPQUFPLENBQUM2QixRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxXQUFXLEVBQUUsV0FBVyxHQUFHMUIsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsSUFBSSxDQUFDdUIsS0FBSyxDQUFDRSxjQUFjLEVBQUU7Z0JBQzNLMUIsT0FBTyxJQUFJLENBQUNzQixLQUFLLENBQUN0QixLQUFLO2dCQUN2QjJCLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ3JCO1FBQ0osQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNJLFFBQVE7SUFDOUI7SUFDQUMsWUFBWUwsS0FBSyxDQUFDO1FBQ2QsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0csS0FBSyxHQUFHLElBQUk7WUFDYixJQUFJLENBQUNHLFFBQVEsQ0FBQztnQkFDVjlCLE9BQU8sSUFBSTtZQUNmO1FBQ0o7UUFDQSxJQUFJLENBQUNzQixLQUFLLEdBQUc7WUFDVHRCLE9BQU8sSUFBSTtRQUNmO0lBQ0o7QUFDSjtBQUNBUiw0QkFBNEIsR0FBRzBCO0FBQy9CLFNBQVN0QixjQUFjLEVBQUU4QixlQUFjLEVBQUdELFlBQVcsRUFBR0csU0FBUSxFQUFHLEVBQUU7SUFDakUsSUFBSUYsZ0JBQWdCO1FBQ2hCLE9BQU8sV0FBVyxHQUFHM0IsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUNpQixzQkFBc0I7WUFDcEVRLGdCQUFnQkE7WUFDaEJELGFBQWFBO1FBQ2pCLEdBQUdHO0lBQ1AsQ0FBQztJQUNELE9BQU8sV0FBVyxHQUFHN0IsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUNGLE9BQU9MLE9BQU8sQ0FBQzZCLFFBQVEsRUFBRSxJQUFJLEVBQUVLO0FBQ3JGO0FBRUEsSUFBSSxDQUFDLE9BQU9wQyxRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUNxQyxVQUFVLEtBQUssYUFBYTtJQUNyS3pDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8wQyxNQUFNLENBQUN4QyxRQUFRRSxPQUFPLEVBQUVGO0lBQy9CeUMsT0FBT3pDLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanM/NzY5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gR2xvYmFsRXJyb3I7XG5leHBvcnRzLkVycm9yQm91bmRhcnkgPSBFcnJvckJvdW5kYXJ5O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gR2xvYmFsRXJyb3IoeyBlcnJvciAgfSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5lcnJvclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuZGVzY1xuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImgyXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy50ZXh0XG4gICAgfSwgXCJBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkIChzZWUgdGhlIGJyb3dzZXIgY29uc29sZSBmb3IgbW9yZSBpbmZvcm1hdGlvbikuXCIpLCAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgJiYgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMudGV4dFxuICAgIH0sIGBEaWdlc3Q6ICR7ZXJyb3IuZGlnZXN0fWApKSkpKTtcbn1cblxuY29uc3Qgc3R5bGVzID0ge1xuICAgIGVycm9yOiB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbW9kZXJuLW5vcm1hbGl6ZS9ibG9iL21haW4vbW9kZXJuLW5vcm1hbGl6ZS5jc3MjTDM4LUw1MlxuICAgICAgICBmb250RmFtaWx5OiAnc3lzdGVtLXVpLFwiU2Vnb2UgVUlcIixSb2JvdG8sSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWYsXCJBcHBsZSBDb2xvciBFbW9qaVwiLFwiU2Vnb2UgVUkgRW1vamlcIicsXG4gICAgICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgIH0sXG4gICAgZGVzYzoge1xuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0J1xuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICczZW0nLFxuICAgICAgICBtYXJnaW46IDBcbiAgICB9XG59O1xuY2xhc3MgRXJyb3JCb3VuZGFyeUhhbmRsZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHRoaXMucHJvcHMuZXJyb3JTdHlsZXMsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHRoaXMucmVzZXRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkVycm9yQm91bmRhcnlIYW5kbGVyID0gRXJyb3JCb3VuZGFyeUhhbmRsZXI7XG5mdW5jdGlvbiBFcnJvckJvdW5kYXJ5KHsgZXJyb3JDb21wb25lbnQgLCBlcnJvclN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgaWYgKGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeUhhbmRsZXIsIHtcbiAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlc1xuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3ItYm91bmRhcnkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkdsb2JhbEVycm9yIiwiRXJyb3JCb3VuZGFyeSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJlcnJvciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInN0eWxlcyIsImRlc2MiLCJ0ZXh0IiwiZGlnZXN0IiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsIm1hcmdpbiIsIkVycm9yQm91bmRhcnlIYW5kbGVyIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwicmVuZGVyIiwic3RhdGUiLCJGcmFnbWVudCIsInByb3BzIiwiZXJyb3JTdHlsZXMiLCJlcnJvckNvbXBvbmVudCIsInJlc2V0IiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsInNldFN0YXRlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/error-boundary.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/infinite-promise.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/infinite-promise.js ***!
  \**********************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */ let infinitePromise;\nfunction createInfinitePromise() {\n    if (!infinitePromise) {\n        // Only create the Promise once\n        infinitePromise = new Promise(()=>{\n        // This is used to debug when the rendering is never updated.\n        // setTimeout(() => {\n        //   infinitePromise = new Error('Infinite promise')\n        //   resolve()\n        // }, 5000)\n        });\n    }\n    return infinitePromise;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=infinite-promise.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2luZmluaXRlLXByb21pc2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsNkJBQTZCLEdBQUdFO0FBQ2hDOztDQUVDLEdBQUcsSUFBSUM7QUFDUixTQUFTRCx3QkFBd0I7SUFDN0IsSUFBSSxDQUFDQyxpQkFBaUI7UUFDbEIsK0JBQStCO1FBQy9CQSxrQkFBa0IsSUFBSUMsUUFBUSxJQUFJO1FBQ2xDLDZEQUE2RDtRQUM3RCxxQkFBcUI7UUFDckIsb0RBQW9EO1FBQ3BELGNBQWM7UUFDZCxXQUFXO1FBQ1g7SUFDSixDQUFDO0lBQ0QsT0FBT0Q7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPSCxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLUixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPUyxNQUFNLENBQUNQLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JRLE9BQU9SLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcz83MmZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVJbmZpbml0ZVByb21pc2UgPSBjcmVhdGVJbmZpbml0ZVByb21pc2U7XG4vKipcbiAqIFVzZWQgdG8gY2FjaGUgaW4gY3JlYXRlSW5maW5pdGVQcm9taXNlXG4gKi8gbGV0IGluZmluaXRlUHJvbWlzZTtcbmZ1bmN0aW9uIGNyZWF0ZUluZmluaXRlUHJvbWlzZSgpIHtcbiAgICBpZiAoIWluZmluaXRlUHJvbWlzZSkge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgUHJvbWlzZSBvbmNlXG4gICAgICAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBkZWJ1ZyB3aGVuIHRoZSByZW5kZXJpbmcgaXMgbmV2ZXIgdXBkYXRlZC5cbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vICAgaW5maW5pdGVQcm9taXNlID0gbmV3IEVycm9yKCdJbmZpbml0ZSBwcm9taXNlJylcbiAgICAgICAgLy8gICByZXNvbHZlKClcbiAgICAgICAgLy8gfSwgNTAwMClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZpbml0ZVByb21pc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmluaXRlLXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwiaW5maW5pdGVQcm9taXNlIiwiUHJvbWlzZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/infinite-promise.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"react-dom\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _fetchServerResponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"(sc_client)/./node_modules/next/dist/client/components/infinite-promise.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(sc_client)/./node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(sc_client)/./node_modules/next/dist/client/components/match-segments.js\");\nvar _navigation = __webpack_require__(/*! ./navigation */ \"(sc_client)/./node_modules/next/dist/client/components/navigation.js\");\nvar _handleSmoothScroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"../../shared/lib/router/utils/handle-smooth-scroll\");\nvar _redirect = __webpack_require__(/*! ./redirect */ \"(sc_client)/./node_modules/next/dist/client/components/redirect.js\");\nvar _findHeadInCache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nfunction OuterLayoutRouter({ parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles  }) {\n    const context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes , tree , url , headRenderedAboveThisLevel  } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        currentChildSegment\n    ];\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, preservedSegments.map((preservedSegment)=>{\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react.default.createElement(_appRouterContext.TemplateContext.Provider, {\n            key: preservedSegment,\n            value: /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles\n            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles\n            }, /*#__PURE__*/ _react.default.createElement(NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles\n            }, /*#__PURE__*/ _react.default.createElement(RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: childPropSegment === preservedSegment ? childProp : null,\n                segmentPath: segmentPath,\n                path: preservedSegment,\n                isActive: currentChildSegment === preservedSegment,\n                headRenderedAboveThisLevel: headRenderedAboveThisLevel\n            })))))\n        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));\n    }));\n}\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _extends({}, treeToRecreate[1], {\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        })\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _extends({}, treeToRecreate[1], {\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    })\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = (...messages)=>{\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactDom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactDom.default.findDOMNode(instance);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\nclass ScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n        const { focusAndScrollRef  } = this.props;\n        // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n        // This already caused a bug where the first child was a <link/> in head.\n        const domNode = findDOMNode(this);\n        if (focusAndScrollRef.apply && domNode instanceof HTMLElement) {\n            // State is mutated to ensure that the focus and scroll is applied only once.\n            focusAndScrollRef.apply = false;\n            (0, _handleSmoothScroll).handleSmoothScroll(()=>{\n                // Store the current viewport height because reading `clientHeight` causes a reflow,\n                // and it won't change during this function.\n                const htmlElement = document.documentElement;\n                const viewportHeight = htmlElement.clientHeight;\n                // If the element's top edge is already in the viewport, exit early.\n                if (topOfElementInViewport(domNode, viewportHeight)) {\n                    return;\n                }\n                // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                htmlElement.scrollTop = 0;\n                // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                if (!topOfElementInViewport(domNode, viewportHeight)) {\n                    // Scroll into view doesn't scroll horizontally by default when not needed\n                    domNode.scrollIntoView();\n                }\n            }, {\n                // We will force layout by querying domNode position\n                dontForceLayout: true\n            });\n            // Set focus on the element\n            domNode.focus();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n}\nfunction InnerLayoutRouter({ parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,\npath , headRenderedAboveThisLevel  }) {\n    const context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { changeByServerResponse , tree: fullTree , focusAndScrollRef  } = context;\n    const head = (0, _react).useMemo(()=>{\n        if (headRenderedAboveThisLevel) {\n            return null;\n        }\n        return (0, _findHeadInCache).findHeadInCache(childNodes, tree[1]);\n    }, [\n        childNodes,\n        tree,\n        headRenderedAboveThisLevel\n    ]);\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(path);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.status = _appRouterContext.CacheStates.READY;\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.subTreeData = childProp.current;\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n        } else {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNodes.set(path, {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            });\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n            childNode = childNodes.get(path);\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode || childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(path, {\n            status: _appRouterContext.CacheStates.DATA_FETCH,\n            data: (0, _fetchServerResponse).fetchServerResponse(new URL(url, location.origin), refetchTree),\n            subTreeData: null,\n            head: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n            parallelRoutes: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react).use(childNode.data);\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            // @ts-ignore startTransition exists\n            _react.default.startTransition(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    const subtree = /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            headRenderedAboveThisLevel: true\n        }\n    }, head, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return /*#__PURE__*/ _react.default.createElement(ScrollAndFocusHandler, {\n        focusAndScrollRef: focusAndScrollRef\n    }, subtree);\n}\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary({ children , loading , loadingStyles , hasLoading  }) {\n    if (hasLoading) {\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\nfunction HandleRedirect({ redirect  }) {\n    const router = (0, _navigation).useRouter();\n    (0, _react).useEffect(()=>{\n        router.replace(redirect, {});\n    }, [\n        redirect,\n        router\n    ]);\n    return null;\n}\nclass RedirectErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((0, _redirect).isRedirectError(error)) {\n            const url = (0, _redirect).getURLFromRedirectError(error);\n            return {\n                redirect: url\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    render() {\n        const redirect = this.state.redirect;\n        if (redirect !== null) {\n            return /*#__PURE__*/ _react.default.createElement(HandleRedirect, {\n                redirect: redirect\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null\n        };\n    }\n}\nfunction RedirectBoundary({ children  }) {\n    const router = (0, _navigation).useRouter();\n    return /*#__PURE__*/ _react.default.createElement(RedirectErrorBoundary, {\n        router: router\n    }, children);\n}\nclass NotFoundErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((error == null ? void 0 : error.digest) === \"NEXT_NOT_FOUND\") {\n            return {\n                notFoundTriggered: true\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    render() {\n        if (this.state.notFoundTriggered) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"meta\", {\n                name: \"robots\",\n                content: \"noindex\"\n            }), this.props.notFoundStyles, this.props.notFound);\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            notFoundTriggered: false\n        };\n    }\n}\nfunction NotFoundBoundary({ notFound , notFoundStyles , children  }) {\n    return notFound ? /*#__PURE__*/ _react.default.createElement(NotFoundErrorBoundary, {\n        notFound: notFound,\n        notFoundStyles: notFoundStyles\n    }, children) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILHlCQUF5QixHQUFHSTtBQUM1QixJQUFJQyxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCwrSkFBK0Q7QUFDOUYsSUFBSUUsNEJBQTRCRixpS0FBZ0U7QUFDaEcsSUFBSUcsU0FBU0QsMEJBQTBCRixtQkFBT0EsQ0FBQyxvQkFBTztBQUN0RCxJQUFJSSxZQUFZSCx5QkFBeUJELG1CQUFPQSxDQUFDLDRCQUFXO0FBQzVELElBQUlLLG9CQUFvQkwsbUJBQU9BLENBQUMsZ0ZBQXFDO0FBQ3JFLElBQUlNLHVCQUF1Qk4sbUJBQU9BLENBQUMsOElBQXdDO0FBQzNFLElBQUlPLG1CQUFtQlAsbUJBQU9BLENBQUMsc0dBQW9CO0FBQ25ELElBQUlRLGlCQUFpQlIsbUJBQU9BLENBQUMsa0dBQWtCO0FBQy9DLElBQUlTLGlCQUFpQlQsbUJBQU9BLENBQUMsa0dBQWtCO0FBQy9DLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLDBGQUFjO0FBQ3hDLElBQUlXLHNCQUFzQlgsbUJBQU9BLENBQUMsOEdBQW9EO0FBQ3RGLElBQUlZLFlBQVlaLG1CQUFPQSxDQUFDLHNGQUFZO0FBQ3BDLElBQUlhLG1CQUFtQmIsbUJBQU9BLENBQUMsMEpBQThDO0FBQzdFLFNBQVNILGtCQUFrQixFQUFFaUIsa0JBQWlCLEVBQUdDLFlBQVcsRUFBR0MsVUFBUyxFQUFHQyxNQUFLLEVBQUdDLFlBQVcsRUFBR0MsZUFBYyxFQUFHQyxRQUFPLEVBQUdDLGNBQWEsRUFBR0MsV0FBVSxFQUFHQyxTQUFRLEVBQUdDLFNBQVEsRUFBR0MsZUFBYyxFQUFHLEVBQUU7SUFDOUwsTUFBTUMsVUFBVSxDQUFDLEdBQUd2QixNQUFNLEVBQUV3QixVQUFVLENBQUN0QixrQkFBa0J1QixtQkFBbUI7SUFDNUUsSUFBSSxDQUFDRixTQUFTO1FBQ1YsTUFBTSxJQUFJRyxNQUFNLGtEQUFrRDtJQUN0RSxDQUFDO0lBQ0QsTUFBTSxFQUFFQyxXQUFVLEVBQUdDLEtBQUksRUFBR0MsSUFBRyxFQUFHQywyQkFBMEIsRUFBRyxHQUFHUDtJQUNsRSw0Q0FBNEM7SUFDNUMsSUFBSVEsOEJBQThCSixXQUFXSyxHQUFHLENBQUNyQjtJQUNqRCxtRUFBbUU7SUFDbkUseUpBQXlKO0lBQ3pKLElBQUksQ0FBQ29CLDZCQUE2QjtRQUM5QkosV0FBV00sR0FBRyxDQUFDdEIsbUJBQW1CLElBQUl1QjtRQUN0Q0gsOEJBQThCSixXQUFXSyxHQUFHLENBQUNyQjtJQUNqRCxDQUFDO0lBQ0QscUNBQXFDO0lBQ3JDLDhJQUE4STtJQUM5SSxNQUFNd0IsY0FBY1AsSUFBSSxDQUFDLEVBQUUsQ0FBQ2pCLGtCQUFrQixDQUFDLEVBQUU7SUFDakQsTUFBTXlCLG1CQUFtQkMsTUFBTUMsT0FBTyxDQUFDekIsVUFBVTBCLE9BQU8sSUFBSTFCLFVBQVUwQixPQUFPLENBQUMsRUFBRSxHQUFHMUIsVUFBVTBCLE9BQU87SUFDcEcsZ0lBQWdJO0lBQ2hJLE1BQU1DLHNCQUFzQkgsTUFBTUMsT0FBTyxDQUFDSCxlQUFlQSxXQUFXLENBQUMsRUFBRSxHQUFHQSxXQUFXO0lBQ3JGOztHQUVELEdBQUcsK0RBQStEO0lBQ2pFLE1BQU1NLG9CQUFvQjtRQUN0QkQ7S0FDSDtJQUNELE9BQU8sV0FBVyxHQUFHeEMsT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDMUMsT0FBT1AsT0FBTyxDQUFDa0QsUUFBUSxFQUFFLElBQUksRUFBRUYsa0JBQWtCRyxHQUFHLENBQUMsQ0FBQ0MsbUJBQW1CO1FBQ3ZILE9BQU87Ozs7Ozs7O1VBUUwsR0FBRyxXQUFXLEdBQUc3QyxPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUN4QyxrQkFBa0I0QyxlQUFlLENBQUNDLFFBQVEsRUFBRTtZQUN4RkMsS0FBS0g7WUFDTHJELE9BQU8sV0FBVyxHQUFHUSxPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUNyQyxlQUFlNEMsYUFBYSxFQUFFO2dCQUM1RUMsZ0JBQWdCcEM7Z0JBQ2hCQyxhQUFhQTtZQUNqQixHQUFHLFdBQVcsR0FBR2YsT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDUyxpQkFBaUI7Z0JBQzNEaEMsWUFBWUE7Z0JBQ1pGLFNBQVNBO2dCQUNUQyxlQUFlQTtZQUNuQixHQUFHLFdBQVcsR0FBR2xCLE9BQU9QLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQ1Usa0JBQWtCO2dCQUM1RC9CLFVBQVVBO2dCQUNWQyxnQkFBZ0JBO1lBQ3BCLEdBQUcsV0FBVyxHQUFHdEIsT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDVyxrQkFBa0IsSUFBSSxFQUFFLFdBQVcsR0FBR3JELE9BQU9QLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQy9DLG1CQUFtQjtnQkFDaElnQixtQkFBbUJBO2dCQUNuQmtCLEtBQUtBO2dCQUNMRCxNQUFNQTtnQkFDTkQsWUFBWUk7Z0JBQ1psQixXQUFXdUIscUJBQXFCUyxtQkFBbUJoQyxZQUFZLElBQUk7Z0JBQ25FRCxhQUFhQTtnQkFDYjBDLE1BQU1UO2dCQUNOVSxVQUFVZix3QkFBd0JLO2dCQUNsQ2YsNEJBQTRCQTtZQUNoQztRQUNKLEdBQUcsV0FBVyxHQUFHOUIsT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDMUMsT0FBT1AsT0FBTyxDQUFDa0QsUUFBUSxFQUFFLElBQUksRUFBRTNCLGdCQUFnQkk7SUFDakc7QUFDSjtBQUVBOzs7Q0FHQyxHQUFHLFNBQVNvQyxlQUFlQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO0lBQzNELElBQUlELG1CQUFtQjtRQUNuQixNQUFNLENBQUNsQixTQUFTb0IsaUJBQWlCLEdBQUdGO1FBQ3BDLE1BQU1HLFNBQVNILGtCQUFrQkksTUFBTSxLQUFLO1FBQzVDLElBQUksQ0FBQyxHQUFHdkQsY0FBYyxFQUFFd0QsWUFBWSxDQUFDSixjQUFjLENBQUMsRUFBRSxFQUFFbkIsVUFBVTtZQUM5RCxJQUFJbUIsY0FBYyxDQUFDLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDSixtQkFBbUI7Z0JBQ3BELElBQUlDLFFBQVE7b0JBQ1IsTUFBTUksVUFBVVIsZUFBZVMsV0FBV1AsY0FBYyxDQUFDLEVBQUUsQ0FBQ0MsaUJBQWlCO29CQUM3RSxPQUFPO3dCQUNIRCxjQUFjLENBQUMsRUFBRTt3QkFDakI5RCxTQUFTLENBQUMsR0FBRzhELGNBQWMsQ0FBQyxFQUFFLEVBQUU7NEJBQzVCLENBQUNDLGlCQUFpQixFQUFFO2dDQUNoQkssT0FBTyxDQUFDLEVBQUU7Z0NBQ1ZBLE9BQU8sQ0FBQyxFQUFFO2dDQUNWQSxPQUFPLENBQUMsRUFBRTtnQ0FDVjs2QkFDSDt3QkFDTDtxQkFDSDtnQkFDTCxDQUFDO2dCQUNELE9BQU87b0JBQ0hOLGNBQWMsQ0FBQyxFQUFFO29CQUNqQjlELFNBQVMsQ0FBQyxHQUFHOEQsY0FBYyxDQUFDLEVBQUUsRUFBRTt3QkFDNUIsQ0FBQ0MsaUJBQWlCLEVBQUVILGVBQWVDLGtCQUFrQlMsS0FBSyxDQUFDLElBQUlSLGNBQWMsQ0FBQyxFQUFFLENBQUNDLGlCQUFpQjtvQkFDdEc7aUJBQ0g7WUFDTCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBQ0EsNEZBQTRGO0FBQzVGOztDQUVDLEdBQUcsU0FBU1MsWUFBWUMsUUFBUSxFQUFFO0lBQy9CLCtCQUErQjtJQUMvQixJQUFJLEtBQTJCSCxFQUFFLEVBQVk7SUFDN0Msd0RBQXdEO0lBQ3hELElBQUlJLElBQXlCLEVBQWM7UUFDdkMsTUFBTUMsdUJBQXVCQyxRQUFRekQsS0FBSztRQUMxQyxJQUFJO1lBQ0F5RCxRQUFRekQsS0FBSyxHQUFHLENBQUMsR0FBRzBELFdBQVc7Z0JBQzNCLDREQUE0RDtnQkFDNUQsSUFBSSxDQUFDQSxRQUFRLENBQUMsRUFBRSxDQUFDQyxRQUFRLENBQUMsNkNBQTZDO29CQUNuRUgsd0JBQXdCRTtnQkFDNUIsQ0FBQztZQUNMO1lBQ0EsT0FBT3ZFLFVBQVVSLE9BQU8sQ0FBQzBFLFdBQVcsQ0FBQ0M7UUFDekMsU0FBUztZQUNMRyxRQUFRekQsS0FBSyxHQUFHd0Q7UUFDcEI7SUFDSixDQUFDO0lBQ0QsT0FBT3JFLFVBQVVSLE9BQU8sQ0FBQzBFLFdBQVcsQ0FBQ0M7QUFDekM7QUFDQTs7Q0FFQyxHQUFHLFNBQVNNLHVCQUF1QkMsT0FBTyxFQUFFQyxjQUFjLEVBQUU7SUFDekQsTUFBTUMsT0FBT0YsUUFBUUcscUJBQXFCO0lBQzFDLE9BQU9ELEtBQUtFLEdBQUcsSUFBSSxLQUFLRixLQUFLRSxHQUFHLElBQUlIO0FBQ3hDO0FBQ0EsTUFBTUksOEJBQThCaEYsT0FBT1AsT0FBTyxDQUFDd0YsU0FBUztJQUN4REMsb0JBQW9CO1FBQ2hCLHFHQUFxRztRQUNyRyxNQUFNLEVBQUVDLGtCQUFpQixFQUFHLEdBQUcsSUFBSSxDQUFDQyxLQUFLO1FBQ3pDLGtHQUFrRztRQUNsRyx5RUFBeUU7UUFDekUsTUFBTUMsVUFBVWxCLFlBQVksSUFBSTtRQUNoQyxJQUFJZ0Isa0JBQWtCRyxLQUFLLElBQUlELG1CQUFtQkUsYUFBYTtZQUMzRCw2RUFBNkU7WUFDN0VKLGtCQUFrQkcsS0FBSyxHQUFHLEtBQUs7WUFDOUIsSUFBRzlFLG1CQUFtQixFQUFFZ0Ysa0JBQWtCLENBQUMsSUFBSTtnQkFDNUMsb0ZBQW9GO2dCQUNwRiw0Q0FBNEM7Z0JBQzVDLE1BQU1DLGNBQWNDLFNBQVNDLGVBQWU7Z0JBQzVDLE1BQU1mLGlCQUFpQmEsWUFBWUcsWUFBWTtnQkFDL0Msb0VBQW9FO2dCQUNwRSxJQUFJbEIsdUJBQXVCVyxTQUFTVCxpQkFBaUI7b0JBQ2pEO2dCQUNKLENBQUM7Z0JBQ0QsMkZBQTJGO2dCQUMzRixrSEFBa0g7Z0JBQ2xILHFIQUFxSDtnQkFDckgsNkhBQTZIO2dCQUM3SGEsWUFBWUksU0FBUyxHQUFHO2dCQUN4QixtRkFBbUY7Z0JBQ25GLElBQUksQ0FBQ25CLHVCQUF1QlcsU0FBU1QsaUJBQWlCO29CQUNsRCwwRUFBMEU7b0JBQzFFUyxRQUFRUyxjQUFjO2dCQUMxQixDQUFDO1lBQ0wsR0FBRztnQkFDQyxvREFBb0Q7Z0JBQ3BEQyxpQkFBaUIsSUFBSTtZQUN6QjtZQUNBLDJCQUEyQjtZQUMzQlYsUUFBUVcsS0FBSztRQUNqQixDQUFDO0lBQ0w7SUFDQUMsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDYixLQUFLLENBQUNjLFFBQVE7SUFDOUI7QUFDSjtBQUNBLFNBQVN2RyxrQkFBa0IsRUFBRWdCLGtCQUFpQixFQUFHa0IsSUFBRyxFQUFHRixXQUFVLEVBQUdkLFVBQVMsRUFBR0QsWUFBVyxFQUFHZ0IsS0FBSSxFQUNsRyxZQUFZO0FBQ1owQixLQUFJLEVBQUd4QiwyQkFBMEIsRUFBRyxFQUFFO0lBQ2xDLE1BQU1QLFVBQVUsQ0FBQyxHQUFHdkIsTUFBTSxFQUFFd0IsVUFBVSxDQUFDdEIsa0JBQWtCaUcseUJBQXlCO0lBQ2xGLElBQUksQ0FBQzVFLFNBQVM7UUFDVixNQUFNLElBQUlHLE1BQU0sOENBQThDO0lBQ2xFLENBQUM7SUFDRCxNQUFNLEVBQUUwRSx1QkFBc0IsRUFBR3hFLE1BQU15RSxTQUFRLEVBQUdsQixrQkFBaUIsRUFBRyxHQUFHNUQ7SUFDekUsTUFBTStFLE9BQU8sQ0FBQyxHQUFHdEcsTUFBTSxFQUFFdUcsT0FBTyxDQUFDLElBQUk7UUFDakMsSUFBSXpFLDRCQUE0QjtZQUM1QixPQUFPLElBQUk7UUFDZixDQUFDO1FBQ0QsT0FBTyxDQUFDLEdBQUdwQixnQkFBZ0IsRUFBRThGLGVBQWUsQ0FBQzdFLFlBQVlDLElBQUksQ0FBQyxFQUFFO0lBQ3BFLEdBQUc7UUFDQ0Q7UUFDQUM7UUFDQUU7S0FDSDtJQUNELHlEQUF5RDtJQUN6RCxJQUFJMkUsWUFBWTlFLFdBQVdLLEdBQUcsQ0FBQ3NCO0lBQy9CLG1FQUFtRTtJQUNuRSxJQUFJekMsYUFBYSwwREFBMEQ7SUFDM0VBLFVBQVU2RixPQUFPLEtBQUssSUFBSSxFQUFFO1FBQ3hCLElBQUlELGFBQWFBLFVBQVVFLE1BQU0sS0FBS3pHLGtCQUFrQjBHLFdBQVcsQ0FBQ0MsZ0JBQWdCLEVBQUU7WUFDbEYseURBQXlEO1lBQ3pESixVQUFVRSxNQUFNLEdBQUd6RyxrQkFBa0IwRyxXQUFXLENBQUNFLEtBQUs7WUFDdEQseURBQXlEO1lBQ3pETCxVQUFVTSxXQUFXLEdBQUdsRyxVQUFVNkYsT0FBTztZQUN6QyxtSEFBbUg7WUFDbkg3RixVQUFVNkYsT0FBTyxHQUFHLElBQUk7UUFDNUIsT0FBTztZQUNILDhDQUE4QztZQUM5Qyx5SkFBeUo7WUFDekovRSxXQUFXTSxHQUFHLENBQUNxQixNQUFNO2dCQUNqQnFELFFBQVF6RyxrQkFBa0IwRyxXQUFXLENBQUNFLEtBQUs7Z0JBQzNDRSxNQUFNLElBQUk7Z0JBQ1ZELGFBQWFsRyxVQUFVNkYsT0FBTztnQkFDOUJPLGdCQUFnQixJQUFJL0U7WUFDeEI7WUFDQSxtSEFBbUg7WUFDbkhyQixVQUFVNkYsT0FBTyxHQUFHLElBQUk7WUFDeEIscUdBQXFHO1lBQ3JHRCxZQUFZOUUsV0FBV0ssR0FBRyxDQUFDc0I7UUFDL0IsQ0FBQztJQUNMLENBQUM7SUFDRCxvR0FBb0c7SUFDcEcsSUFBSSxDQUFDbUQsYUFBYUEsVUFBVUUsTUFBTSxLQUFLekcsa0JBQWtCMEcsV0FBVyxDQUFDQyxnQkFBZ0IsRUFBRTtRQUNuRjs7S0FFSCxHQUFHLHNCQUFzQjtRQUN0QixNQUFNSyxjQUFjMUQsZUFBZTtZQUMvQjtlQUNHNUM7U0FDTixFQUFFeUY7UUFDSDs7S0FFSCxHQUFHMUUsV0FBV00sR0FBRyxDQUFDcUIsTUFBTTtZQUNqQnFELFFBQVF6RyxrQkFBa0IwRyxXQUFXLENBQUNPLFVBQVU7WUFDaERILE1BQU0sQ0FBQyxHQUFHN0csb0JBQW9CLEVBQUVpSCxtQkFBbUIsQ0FBQyxJQUFJQyxJQUFJeEYsS0FBS3lGLFNBQVNDLE1BQU0sR0FBR0w7WUFDbkZILGFBQWEsSUFBSTtZQUNqQlQsTUFBTUcsYUFBYUEsVUFBVUUsTUFBTSxLQUFLekcsa0JBQWtCMEcsV0FBVyxDQUFDQyxnQkFBZ0IsR0FBR0osVUFBVUgsSUFBSSxHQUFHckMsU0FBUztZQUNuSGdELGdCQUFnQlIsYUFBYUEsVUFBVUUsTUFBTSxLQUFLekcsa0JBQWtCMEcsV0FBVyxDQUFDQyxnQkFBZ0IsR0FBR0osVUFBVVEsY0FBYyxHQUFHLElBQUkvRSxLQUFLO1FBQzNJO1FBQ0EscUdBQXFHO1FBQ3JHdUUsWUFBWTlFLFdBQVdLLEdBQUcsQ0FBQ3NCO0lBQy9CLENBQUM7SUFDRCxrR0FBa0c7SUFDbEcsSUFBSSxDQUFDbUQsV0FBVztRQUNaLE1BQU0sSUFBSS9FLE1BQU0sa0NBQWtDO0lBQ3RELENBQUM7SUFDRCxrR0FBa0c7SUFDbEcsSUFBSStFLFVBQVVNLFdBQVcsSUFBSU4sVUFBVU8sSUFBSSxFQUFFO1FBQ3pDLE1BQU0sSUFBSXRGLE1BQU0sd0RBQXdEO0lBQzVFLENBQUM7SUFDRCw2RkFBNkY7SUFDN0YsSUFBSStFLFVBQVVPLElBQUksRUFBRTtRQUNoQjs7S0FFSCxHQUFHLDhEQUE4RDtRQUM5RCxNQUFNLENBQUNRLFlBQVlDLHFCQUFxQixHQUFHLENBQUMsR0FBR3pILE1BQU0sRUFBRTBILEdBQUcsQ0FBQ2pCLFVBQVVPLElBQUk7UUFDekUsNERBQTREO1FBQzVELElBQUksT0FBT1EsZUFBZSxVQUFVO1lBQ2hDRyxPQUFPTCxRQUFRLENBQUNNLElBQUksR0FBRy9GO1lBQ3ZCLE9BQU8sSUFBSTtRQUNmLENBQUM7UUFDRCxzRUFBc0U7UUFDdEU0RSxVQUFVTyxJQUFJLEdBQUcsSUFBSTtRQUNyQix3R0FBd0c7UUFDeEdhLFdBQVcsSUFBSTtZQUNYLG9DQUFvQztZQUNwQzdILE9BQU9QLE9BQU8sQ0FBQ3FJLGVBQWUsQ0FBQyxJQUFJO2dCQUMvQjFCLHVCQUF1QkMsVUFBVW1CLFlBQVlDO1lBQ2pEO1FBQ0o7UUFDQSx5R0FBeUc7UUFDeEcsSUFBR3pILE1BQU0sRUFBRTBILEdBQUcsQ0FBQyxDQUFDLEdBQUd0SCxnQkFBZ0IsRUFBRTJILHFCQUFxQjtJQUMvRCxDQUFDO0lBQ0QseUlBQXlJO0lBQ3pJLHdGQUF3RjtJQUN4RixJQUFJLENBQUN0QixVQUFVTSxXQUFXLEVBQUU7UUFDdkIsSUFBRy9HLE1BQU0sRUFBRTBILEdBQUcsQ0FBQyxDQUFDLEdBQUd0SCxnQkFBZ0IsRUFBRTJILHFCQUFxQjtJQUMvRCxDQUFDO0lBQ0QsTUFBTUMsVUFDTixXQUFXLEdBQUdoSSxPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUN4QyxrQkFBa0J1QixtQkFBbUIsQ0FBQ3NCLFFBQVEsRUFBRTtRQUN2RnZELE9BQU87WUFDSG9DLE1BQU1BLElBQUksQ0FBQyxFQUFFLENBQUNqQixrQkFBa0I7WUFDaENnQixZQUFZOEUsVUFBVVEsY0FBYztZQUNwQyxrREFBa0Q7WUFDbERwRixLQUFLQTtZQUNMQyw0QkFBNEIsSUFBSTtRQUNwQztJQUNKLEdBQUd3RSxNQUFNRyxVQUFVTSxXQUFXO0lBQzlCLGlGQUFpRjtJQUNqRixPQUFPLFdBQVcsR0FBRy9HLE9BQU9QLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQ3NDLHVCQUF1QjtRQUNyRUcsbUJBQW1CQTtJQUN2QixHQUFHNkM7QUFDUDtBQUNBOzs7Q0FHQyxHQUFHLFNBQVM3RSxnQkFBZ0IsRUFBRStDLFNBQVEsRUFBR2pGLFFBQU8sRUFBR0MsY0FBYSxFQUFHQyxXQUFVLEVBQUcsRUFBRTtJQUMvRSxJQUFJQSxZQUFZO1FBQ1osT0FBTyxXQUFXLEdBQUduQixPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUMxQyxPQUFPUCxPQUFPLENBQUN3SSxRQUFRLEVBQUU7WUFDdkVDLFVBQVUsV0FBVyxHQUFHbEksT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDMUMsT0FBT1AsT0FBTyxDQUFDa0QsUUFBUSxFQUFFLElBQUksRUFBRXpCLGVBQWVEO1FBQ3ZHLEdBQUdpRjtJQUNQLENBQUM7SUFDRCxPQUFPLFdBQVcsR0FBR2xHLE9BQU9QLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQzFDLE9BQU9QLE9BQU8sQ0FBQ2tELFFBQVEsRUFBRSxJQUFJLEVBQUV1RDtBQUNyRjtBQUNBLFNBQVNpQyxlQUFlLEVBQUVDLFNBQVEsRUFBRyxFQUFFO0lBQ25DLE1BQU1DLFNBQVMsQ0FBQyxHQUFHOUgsV0FBVyxFQUFFK0gsU0FBUztJQUN4QyxJQUFHdEksTUFBTSxFQUFFdUksU0FBUyxDQUFDLElBQUk7UUFDdEJGLE9BQU9HLE9BQU8sQ0FBQ0osVUFBVSxDQUFDO0lBQzlCLEdBQUc7UUFDQ0E7UUFDQUM7S0FDSDtJQUNELE9BQU8sSUFBSTtBQUNmO0FBQ0EsTUFBTUksOEJBQThCekksT0FBT1AsT0FBTyxDQUFDd0YsU0FBUztJQUN4RCxPQUFPeUQseUJBQXlCNUgsS0FBSyxFQUFFO1FBQ25DLElBQUksQ0FBQyxHQUFHTCxTQUFTLEVBQUVrSSxlQUFlLENBQUM3SCxRQUFRO1lBQ3ZDLE1BQU1lLE1BQU0sQ0FBQyxHQUFHcEIsU0FBUyxFQUFFbUksdUJBQXVCLENBQUM5SDtZQUNuRCxPQUFPO2dCQUNIc0gsVUFBVXZHO1lBQ2Q7UUFDSixDQUFDO1FBQ0Qsd0NBQXdDO1FBQ3hDLE1BQU1mLE1BQU07SUFDaEI7SUFDQW1GLFNBQVM7UUFDTCxNQUFNbUMsV0FBVyxJQUFJLENBQUNTLEtBQUssQ0FBQ1QsUUFBUTtRQUNwQyxJQUFJQSxhQUFhLElBQUksRUFBRTtZQUNuQixPQUFPLFdBQVcsR0FBR3BJLE9BQU9QLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQ3lGLGdCQUFnQjtnQkFDOURDLFVBQVVBO1lBQ2Q7UUFDSixDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUNoRCxLQUFLLENBQUNjLFFBQVE7SUFDOUI7SUFDQTRDLFlBQVkxRCxLQUFLLENBQUM7UUFDZCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDeUQsS0FBSyxHQUFHO1lBQ1RULFVBQVUsSUFBSTtRQUNsQjtJQUNKO0FBQ0o7QUFDQSxTQUFTL0UsaUJBQWlCLEVBQUU2QyxTQUFRLEVBQUcsRUFBRTtJQUNyQyxNQUFNbUMsU0FBUyxDQUFDLEdBQUc5SCxXQUFXLEVBQUUrSCxTQUFTO0lBQ3pDLE9BQU8sV0FBVyxHQUFHdEksT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDK0YsdUJBQXVCO1FBQ3JFSixRQUFRQTtJQUNaLEdBQUduQztBQUNQO0FBQ0EsTUFBTTZDLDhCQUE4Qi9JLE9BQU9QLE9BQU8sQ0FBQ3dGLFNBQVM7SUFDeEQsT0FBT3lELHlCQUF5QjVILEtBQUssRUFBRTtRQUNuQyxJQUFJLENBQUNBLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSUEsTUFBTWtJLE1BQU0sTUFBTSxrQkFBa0I7WUFDOUQsT0FBTztnQkFDSEMsbUJBQW1CLElBQUk7WUFDM0I7UUFDSixDQUFDO1FBQ0QsbUNBQW1DO1FBQ25DLE1BQU1uSSxNQUFNO0lBQ2hCO0lBQ0FtRixTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUM0QyxLQUFLLENBQUNJLGlCQUFpQixFQUFFO1lBQzlCLE9BQU8sV0FBVyxHQUFHakosT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDMUMsT0FBT1AsT0FBTyxDQUFDa0QsUUFBUSxFQUFFLElBQUksRUFBRSxXQUFXLEdBQUczQyxPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUMsUUFBUTtnQkFDaEl3RyxNQUFNO2dCQUNOQyxTQUFTO1lBQ2IsSUFBSSxJQUFJLENBQUMvRCxLQUFLLENBQUM5RCxjQUFjLEVBQUUsSUFBSSxDQUFDOEQsS0FBSyxDQUFDL0QsUUFBUTtRQUN0RCxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMrRCxLQUFLLENBQUNjLFFBQVE7SUFDOUI7SUFDQTRDLFlBQVkxRCxLQUFLLENBQUM7UUFDZCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDeUQsS0FBSyxHQUFHO1lBQ1RJLG1CQUFtQixLQUFLO1FBQzVCO0lBQ0o7QUFDSjtBQUNBLFNBQVM3RixpQkFBaUIsRUFBRS9CLFNBQVEsRUFBR0MsZUFBYyxFQUFHNEUsU0FBUSxFQUFHLEVBQUU7SUFDakUsT0FBTzdFLFdBQVcsV0FBVyxHQUFHckIsT0FBT1AsT0FBTyxDQUFDaUQsYUFBYSxDQUFDcUcsdUJBQXVCO1FBQ2hGMUgsVUFBVUE7UUFDVkMsZ0JBQWdCQTtJQUNwQixHQUFHNEUsWUFBWSxXQUFXLEdBQUdsRyxPQUFPUCxPQUFPLENBQUNpRCxhQUFhLENBQUMxQyxPQUFPUCxPQUFPLENBQUNrRCxRQUFRLEVBQUUsSUFBSSxFQUFFdUQsU0FBUztBQUN0RztBQUVBLElBQUksQ0FBQyxPQUFPM0csUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDMkosVUFBVSxLQUFLLGFBQWE7SUFDcksvSixPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPZ0ssTUFBTSxDQUFDOUosUUFBUUUsT0FBTyxFQUFFRjtJQUMvQitKLE9BQU8vSixPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG5leHBvcnRzLklubmVyTGF5b3V0Um91dGVyID0gSW5uZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbnZhciBfaW5maW5pdGVQcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uXCIpO1xudmFyIF9oYW5kbGVTbW9vdGhTY3JvbGwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG52YXIgX3JlZGlyZWN0ID0gcmVxdWlyZShcIi4vcmVkaXJlY3RcIik7XG52YXIgX2ZpbmRIZWFkSW5DYWNoZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZVwiKTtcbmZ1bmN0aW9uIE91dGVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCBzZWdtZW50UGF0aCAsIGNoaWxkUHJvcCAsIGVycm9yICwgZXJyb3JTdHlsZXMgLCB0ZW1wbGF0ZVN0eWxlcyAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAsIHRlbXBsYXRlICwgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBsYXlvdXQgcm91dGVyIHRvIGJlIG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZE5vZGVzICwgdHJlZSAsIHVybCAsIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsICB9ID0gY29udGV4dDtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYWxsZWxSb3V0ZXIgY2FjaGUgbm9kZVxuICAgIGxldCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIGlmICghY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBuZXcgTWFwKCkpO1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYWN0aXZlIHNlZ21lbnQgaW4gdGhlIHRyZWVcbiAgICAvLyBUaGUgcmVhc29uIGFycmF5cyBhcmUgdXNlZCBpbiB0aGUgZGF0YSBmb3JtYXQgaXMgdGhhdCB0aGVzZSBhcmUgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBicm93c2VyIHNvIGl0J3Mgb3B0aW1pemVkIHRvIHNhdmUgYnl0ZXMuXG4gICAgY29uc3QgdHJlZVNlZ21lbnQgPSB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVswXTtcbiAgICBjb25zdCBjaGlsZFByb3BTZWdtZW50ID0gQXJyYXkuaXNBcnJheShjaGlsZFByb3Auc2VnbWVudCkgPyBjaGlsZFByb3Auc2VnbWVudFsxXSA6IGNoaWxkUHJvcC5zZWdtZW50O1xuICAgIC8vIElmIHNlZ21lbnQgaXMgYW4gYXJyYXkgaXQncyBhIGR5bmFtaWMgcm91dGUgYW5kIHdlIHdhbnQgdG8gcmVhZCB0aGUgZHluYW1pYyByb3V0ZSB2YWx1ZSBhcyB0aGUgc2VnbWVudCB0byBnZXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgY29uc3QgY3VycmVudENoaWxkU2VnbWVudCA9IEFycmF5LmlzQXJyYXkodHJlZVNlZ21lbnQpID8gdHJlZVNlZ21lbnRbMV0gOiB0cmVlU2VnbWVudDtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgY3VycmVudENoaWxkU2VnbWVudFxuICAgIF07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICByZXR1cm4oLypcbiAgICAgICAgICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAgICAgICAgICovIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIGtleTogcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2Vycm9yQm91bmRhcnkuRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvcixcbiAgICAgICAgICAgICAgICBlcnJvclN0eWxlczogZXJyb3JTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChMb2FkaW5nQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBoYXNMb2FkaW5nOiBoYXNMb2FkaW5nLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlczogbG9hZGluZ1N0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgICAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RCb3VuZGFyeSwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KElubmVyTGF5b3V0Um91dGVyLCB7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXJLZXk6IHBhcmFsbGVsUm91dGVyS2V5LFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkUHJvcDogY2hpbGRQcm9wU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCA/IGNoaWxkUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIHBhdGg6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGN1cnJlbnRDaGlsZFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgICAgICAgICB9KSkpKSlcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGUpKSk7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgLy8gT25seSBhcHBseSBzdHJpY3QgbW9kZSB3YXJuaW5nIHdoZW4gbm90IGluIHByb2R1Y3Rpb25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gKC4uLm1lc3NhZ2VzKT0+e1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzdHJpY3QgbW9kZSB3YXJuaW5nIGZvciB0aGUgZmluZERvbU5vZGUgY2FsbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZXNbMF0uaW5jbHVkZXMoJ1dhcm5pbmc6ICVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4nKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVFcnJvciguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIGNvcm5lciBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovIGZ1bmN0aW9uIHRvcE9mRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodDtcbn1cbmNsYXNzIFNjcm9sbEFuZEZvY3VzSGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzY3JvbGwgYW5kIGZvY3VzLCBpdCdzIG9ubHkgYXBwbGllZCBvbmNlIGluIHRoZSBmaXJzdCB1c2VFZmZlY3QgdGhhdCB0cmlnZ2VycyB0aGF0IGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAvLyBgZmluZERPTU5vZGVgIGlzIHRyaWNreSBiZWNhdXNlIGl0IHJldHVybnMganVzdCB0aGUgZmlyc3QgY2hpbGQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50LlxuICAgICAgICAvLyBUaGlzIGFscmVhZHkgY2F1c2VkIGEgYnVnIHdoZXJlIHRoZSBmaXJzdCBjaGlsZCB3YXMgYSA8bGluay8+IGluIGhlYWQuXG4gICAgICAgIGNvbnN0IGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ICYmIGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZVNtb290aFNjcm9sbCkuaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT57XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCdzIHRvcCBlZGdlIGlzIGFscmVhZHkgaW4gdGhlIHZpZXdwb3J0LCBleGl0IGVhcmx5LlxuICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxJbnRvVmlldygpIGNhbGxlZCBvbiBgPGh0bWwvPmAgZWxlbWVudCBzY3JvbGxzIGhvcml6b250YWxseSBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggKHRoYXQgc2hvdWxkbid0IGhhcHBlbilcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB1c2UgaXQgdG8gc2Nyb2xsIGhvcml6b250YWxseSBmb2xsb3dpbmcgUlRMIGJ1dCB0aGF0IGFsc28gc2VlbXMgdG8gYmUgYnJva2VuIC0gaXQgd2lsbCBhbHdheXMgc2Nyb2xsIGxlZnRcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIGRvbU5vZGUgaWYgZG9tTm9kZSBpcyBub3QgaW4gdmlld3BvcnQgd2hlbiBzY3JvbGxlZCB0byB0b3Agb2YgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbCBpbnRvIHZpZXcgZG9lc24ndCBzY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQgd2hlbiBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGRvbnRGb3JjZUxheW91dDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCB1cmwgLCBjaGlsZE5vZGVzICwgY2hpbGRQcm9wICwgc2VnbWVudFBhdGggLCB0cmVlICwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuLy8gaXNBY3RpdmUsXG5wYXRoICwgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWwgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlICwgdHJlZTogZnVsbFRyZWUgLCBmb2N1c0FuZFNjcm9sbFJlZiAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9maW5kSGVhZEluQ2FjaGUpLmZpbmRIZWFkSW5DYWNoZShjaGlsZE5vZGVzLCB0cmVlWzFdKTtcbiAgICB9LCBbXG4gICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgXSk7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIC8vIElmIGNoaWxkUHJvcCBpcyBhdmFpbGFibGUgdGhpcyBtZWFucyBpdCdzIHRoZSBGbGlnaHQgLyBTU1IgY2FzZS5cbiAgICBpZiAoY2hpbGRQcm9wICYmIC8vIFRPRE8tQVBQOiB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgbnVsbCBiYXNlZCBvbiB1c2VyIGNvZGVcbiAgICBjaGlsZFByb3AuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3ViVHJlZURhdGEgPSBjaGlsZFByb3AuY3VycmVudDtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCdzIHN1YlRyZWVEYXRhIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiBjaGlsZE5vZGUgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmICghY2hpbGROb2RlIHx8IGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgLyoqXG4gICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgZGF0YTogKDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pLCByZWZldGNoVHJlZSksXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLmhlYWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMgOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiBzbyBpdCB0aHJvd3MgYW4gZXJyb3IuIEl0IGluZGljYXRlcyB0aGVyZSdzIGEgYnVnIGluIHRoZSBOZXh0LmpzLlxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgYWx3YXlzIGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKGNoaWxkTm9kZS5zdWJUcmVlRGF0YSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGJvdGggc3ViVHJlZURhdGEgYW5kIGRhdGEnKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgYSBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byB1bndyYXAgcmVzcG9uc2UgYnkgYHVzZWAgYW5kIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCByZXNwb25zZSBkYXRhXG4gICAgICovIC8vIFdoZW4gdGhlIGRhdGEgaGFzIG5vdCByZXNvbHZlZCB5ZXQgYHVzZWAgd2lsbCBzdXNwZW5kIGhlcmUuXG4gICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSAoMCwgX3JlYWN0KS51c2UoY2hpbGROb2RlLmRhdGEpO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50UGF0aCBmcm9tIHRoZSBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGxheW91dCdzIHNlZ21lbnRQYXRoXG4gICAgICAgIGNoaWxkTm9kZS5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIHRvIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBoYWNrIGFyb3VuZCBSZWFjdC5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0sIGhlYWQsIGNoaWxkTm9kZS5zdWJUcmVlRGF0YSk7XG4gICAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JvbGxBbmRGb2N1c0hhbmRsZXIsIHtcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgfSwgc3VidHJlZSk7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgIH0pIHtcbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsb2FkaW5nU3R5bGVzLCBsb2FkaW5nKVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHsgcmVkaXJlY3QgIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pO1xuICAgIH0sIFtcbiAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgUmVkaXJlY3RFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgX3JlZGlyZWN0KS5pc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgX3JlZGlyZWN0KS5nZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJPdXRlckxheW91dFJvdXRlciIsIklubmVyTGF5b3V0Um91dGVyIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9yZWFjdERvbSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJfaW5maW5pdGVQcm9taXNlIiwiX2Vycm9yQm91bmRhcnkiLCJfbWF0Y2hTZWdtZW50cyIsIl9uYXZpZ2F0aW9uIiwiX2hhbmRsZVNtb290aFNjcm9sbCIsIl9yZWRpcmVjdCIsIl9maW5kSGVhZEluQ2FjaGUiLCJwYXJhbGxlbFJvdXRlcktleSIsInNlZ21lbnRQYXRoIiwiY2hpbGRQcm9wIiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsInRlbXBsYXRlU3R5bGVzIiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJoYXNMb2FkaW5nIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsIm5vdEZvdW5kU3R5bGVzIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJjaGlsZE5vZGVzIiwidHJlZSIsInVybCIsImhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsIiwiY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyIiwiZ2V0Iiwic2V0IiwiTWFwIiwidHJlZVNlZ21lbnQiLCJjaGlsZFByb3BTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJUZW1wbGF0ZUNvbnRleHQiLCJQcm92aWRlciIsImtleSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkxvYWRpbmdCb3VuZGFyeSIsIk5vdEZvdW5kQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwicGF0aCIsImlzQWN0aXZlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsInByb2Nlc3MiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlcyIsImluY2x1ZGVzIiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsImVsZW1lbnQiLCJ2aWV3cG9ydEhlaWdodCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRNb3VudCIsImZvY3VzQW5kU2Nyb2xsUmVmIiwicHJvcHMiLCJkb21Ob2RlIiwiYXBwbHkiLCJIVE1MRWxlbWVudCIsImhhbmRsZVNtb290aFNjcm9sbCIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxUb3AiLCJzY3JvbGxJbnRvVmlldyIsImRvbnRGb3JjZUxheW91dCIsImZvY3VzIiwicmVuZGVyIiwiY2hpbGRyZW4iLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsImZ1bGxUcmVlIiwiaGVhZCIsInVzZU1lbW8iLCJmaW5kSGVhZEluQ2FjaGUiLCJjaGlsZE5vZGUiLCJjdXJyZW50Iiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJMQVpZX0lOSVRJQUxJWkVEIiwiUkVBRFkiLCJzdWJUcmVlRGF0YSIsImRhdGEiLCJwYXJhbGxlbFJvdXRlcyIsInJlZmV0Y2hUcmVlIiwiREFUQV9GRVRDSCIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodERhdGEiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsInVzZSIsIndpbmRvdyIsImhyZWYiLCJzZXRUaW1lb3V0Iiwic3RhcnRUcmFuc2l0aW9uIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwic3VidHJlZSIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJIYW5kbGVSZWRpcmVjdCIsInJlZGlyZWN0Iiwicm91dGVyIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwicmVwbGFjZSIsIlJlZGlyZWN0RXJyb3JCb3VuZGFyeSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImlzUmVkaXJlY3RFcnJvciIsImdldFVSTEZyb21SZWRpcmVjdEVycm9yIiwic3RhdGUiLCJjb25zdHJ1Y3RvciIsIk5vdEZvdW5kRXJyb3JCb3VuZGFyeSIsImRpZ2VzdCIsIm5vdEZvdW5kVHJpZ2dlcmVkIiwibmFtZSIsImNvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/layout-router.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/match-segments.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/match-segments.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchSegment = void 0;\nconst matchSegment = (existingSegment, segment)=>{\n    // Common case: segment is just a string\n    if (typeof existingSegment === \"string\" && typeof segment === \"string\") {\n        return existingSegment === segment;\n    }\n    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n    if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n    }\n    return false;\n};\nexports.matchSegment = matchSegment;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHLEtBQUs7QUFDNUIsTUFBTUUsZUFBZSxDQUFDQyxpQkFBaUJDLFVBQVU7SUFDN0Msd0NBQXdDO0lBQ3hDLElBQUksT0FBT0Qsb0JBQW9CLFlBQVksT0FBT0MsWUFBWSxVQUFVO1FBQ3BFLE9BQU9ELG9CQUFvQkM7SUFDL0IsQ0FBQztJQUNELG1HQUFtRztJQUNuRyxJQUFJQyxNQUFNQyxPQUFPLENBQUNILG9CQUFvQkUsTUFBTUMsT0FBTyxDQUFDRixVQUFVO1FBQzFELE9BQU9ELGVBQWUsQ0FBQyxFQUFFLEtBQUtDLE9BQU8sQ0FBQyxFQUFFLElBQUlELGVBQWUsQ0FBQyxFQUFFLEtBQUtDLE9BQU8sQ0FBQyxFQUFFO0lBQ2pGLENBQUM7SUFDRCxPQUFPLEtBQUs7QUFDaEI7QUFDQUosb0JBQW9CLEdBQUdFO0FBRXZCLElBQUksQ0FBQyxPQUFPRixRQUFRTyxPQUFPLEtBQUssY0FBZSxPQUFPUCxRQUFRTyxPQUFPLEtBQUssWUFBWVAsUUFBUU8sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUCxRQUFRTyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVixPQUFPQyxjQUFjLENBQUNDLFFBQVFPLE9BQU8sRUFBRSxjQUFjO1FBQUVOLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanM/YmNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWF0Y2hTZWdtZW50ID0gdm9pZCAwO1xuY29uc3QgbWF0Y2hTZWdtZW50ID0gKGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk9PntcbiAgICAvLyBDb21tb24gY2FzZTogc2VnbWVudCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZ1NlZ21lbnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50ID09PSBzZWdtZW50O1xuICAgIH1cbiAgICAvLyBEeW5hbWljIHBhcmFtZXRlciBjYXNlOiBzZWdtZW50IGlzIGFuIGFycmF5IHdpdGggcGFyYW0vdmFsdWUuIEJvdGggcGFyYW0gYW5kIHZhbHVlIGFyZSBjb21wYXJlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1NlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudFswXSA9PT0gc2VnbWVudFswXSAmJiBleGlzdGluZ1NlZ21lbnRbMV0gPT09IHNlZ21lbnRbMV07XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IG1hdGNoU2VnbWVudDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtc2VnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWF0Y2hTZWdtZW50IiwiZXhpc3RpbmdTZWdtZW50Iiwic2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/match-segments.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/navigation.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/navigation.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useSearchParams = useSearchParams;\nexports.usePathname = usePathname;\nObject.defineProperty(exports, \"ServerInsertedHTMLContext\", ({\n    enumerable: true,\n    get: function() {\n        return _serverInsertedHtml.ServerInsertedHTMLContext;\n    }\n}));\nObject.defineProperty(exports, \"useServerInsertedHTML\", ({\n    enumerable: true,\n    get: function() {\n        return _serverInsertedHtml.useServerInsertedHTML;\n    }\n}));\nexports.useRouter = useRouter;\nexports.useSelectedLayoutSegments = useSelectedLayoutSegments;\nexports.useSelectedLayoutSegment = useSelectedLayoutSegment;\nObject.defineProperty(exports, \"redirect\", ({\n    enumerable: true,\n    get: function() {\n        return _redirect.redirect;\n    }\n}));\nObject.defineProperty(exports, \"notFound\", ({\n    enumerable: true,\n    get: function() {\n        return _notFound.notFound;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"../../shared/lib/hooks-client-context\");\nvar _clientHookInServerComponentError = __webpack_require__(/*! ./client-hook-in-server-component-error */ \"(sc_client)/./node_modules/next/dist/client/components/client-hook-in-server-component-error.js\");\nvar _serverInsertedHtml = __webpack_require__(/*! ../../shared/lib/server-inserted-html */ \"../../shared/lib/server-inserted-html\");\nvar _redirect = __webpack_require__(/*! ./redirect */ \"(sc_client)/./node_modules/next/dist/client/components/redirect.js\");\nvar _notFound = __webpack_require__(/*! ./not-found */ \"(sc_client)/./node_modules/next/dist/client/components/not-found.js\");\nconst INTERNAL_URLSEARCHPARAMS_INSTANCE = Symbol(\"internal for urlsearchparams readonly\");\nfunction readonlyURLSearchParamsError() {\n    return new Error(\"ReadonlyURLSearchParams cannot be modified\");\n}\nclass ReadonlyURLSearchParams {\n    [Symbol.iterator]() {\n        return this[INTERNAL_URLSEARCHPARAMS_INSTANCE][Symbol.iterator]();\n    }\n    append() {\n        throw readonlyURLSearchParamsError();\n    }\n    delete() {\n        throw readonlyURLSearchParamsError();\n    }\n    set() {\n        throw readonlyURLSearchParamsError();\n    }\n    sort() {\n        throw readonlyURLSearchParamsError();\n    }\n    constructor(urlSearchParams){\n        // Since `new Headers` uses `this.append()` to fill the headers object ReadonlyHeaders can't extend from Headers directly as it would throw.\n        this[INTERNAL_URLSEARCHPARAMS_INSTANCE] = urlSearchParams;\n        this.entries = urlSearchParams.entries.bind(urlSearchParams);\n        this.forEach = urlSearchParams.forEach.bind(urlSearchParams);\n        this.get = urlSearchParams.get.bind(urlSearchParams);\n        this.getAll = urlSearchParams.getAll.bind(urlSearchParams);\n        this.has = urlSearchParams.has.bind(urlSearchParams);\n        this.keys = urlSearchParams.keys.bind(urlSearchParams);\n        this.values = urlSearchParams.values.bind(urlSearchParams);\n        this.toString = urlSearchParams.toString.bind(urlSearchParams);\n    }\n}\nexports.ReadonlyURLSearchParams = ReadonlyURLSearchParams;\nfunction useSearchParams() {\n    (0, _clientHookInServerComponentError).clientHookInServerComponentError(\"useSearchParams\");\n    const searchParams = (0, _react).useContext(_hooksClientContext.SearchParamsContext);\n    const readonlySearchParams = (0, _react).useMemo(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    if (true) {\n        // AsyncLocalStorage should not be included in the client bundle.\n        const { bailoutToClientRendering  } = __webpack_require__(/*! ./bailout-to-client-rendering */ \"(sc_client)/./node_modules/next/dist/client/components/bailout-to-client-rendering.js\");\n        if (bailoutToClientRendering()) {\n            // TODO-APP: handle dynamic = 'force-static' here and on the client\n            return readonlySearchParams;\n        }\n    }\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    (0, _clientHookInServerComponentError).clientHookInServerComponentError(\"usePathname\");\n    return (0, _react).useContext(_hooksClientContext.PathnameContext);\n}\nfunction useRouter() {\n    (0, _clientHookInServerComponentError).clientHookInServerComponentError(\"useRouter\");\n    const router = (0, _react).useContext(_appRouterContext.AppRouterContext);\n    if (router === null) {\n        throw new Error(\"invariant expected app router to be mounted\");\n    }\n    return router;\n}\n// TODO-APP: handle parallel routes\nfunction getSelectedLayoutSegmentPath(tree, parallelRouteKey, first = true, segmentPath = []) {\n    let node;\n    if (first) {\n        // Use the provided parallel route key on the first parallel route\n        node = tree[1][parallelRouteKey];\n    } else {\n        // After first parallel route prefer children, if there's no children pick the first parallel route.\n        const parallelRoutes = tree[1];\n        var _children;\n        node = (_children = parallelRoutes.children) != null ? _children : Object.values(parallelRoutes)[0];\n    }\n    if (!node) return segmentPath;\n    const segment = node[0];\n    const segmentValue = Array.isArray(segment) ? segment[1] : segment;\n    if (!segmentValue) return segmentPath;\n    segmentPath.push(segmentValue);\n    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);\n}\nfunction useSelectedLayoutSegments(parallelRouteKey = \"children\") {\n    (0, _clientHookInServerComponentError).clientHookInServerComponentError(\"useSelectedLayoutSegments\");\n    const { tree  } = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    return getSelectedLayoutSegmentPath(tree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey = \"children\") {\n    (0, _clientHookInServerComponentError).clientHookInServerComponentError(\"useSelectedLayoutSegment\");\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    if (selectedLayoutSegments.length === 0) {\n        return null;\n    }\n    return selectedLayoutSegments[0];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCRixtQkFBbUIsR0FBR0c7QUFDdEJMLDZEQUE0RDtJQUN4RE0sWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxvQkFBb0JDLHlCQUF5QjtJQUN4RDtBQUNKLENBQUMsRUFBQztBQUNGVCx5REFBd0Q7SUFDcERNLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0Msb0JBQW9CRSxxQkFBcUI7SUFDcEQ7QUFDSixDQUFDLEVBQUM7QUFDRlIsaUJBQWlCLEdBQUdTO0FBQ3BCVCxpQ0FBaUMsR0FBR1U7QUFDcENWLGdDQUFnQyxHQUFHVztBQUNuQ2IsNENBQTJDO0lBQ3ZDTSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9PLFVBQVVDLFFBQVE7SUFDN0I7QUFDSixDQUFDLEVBQUM7QUFDRmYsNENBQTJDO0lBQ3ZDTSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9TLFVBQVVDLFFBQVE7SUFDN0I7QUFDSixDQUFDLEVBQUM7QUFDRixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixJQUFJQyxvQkFBb0JELG1CQUFPQSxDQUFDLGdGQUFxQztBQUNyRSxJQUFJRSxzQkFBc0JGLG1CQUFPQSxDQUFDLG9GQUF1QztBQUN6RSxJQUFJRyxvQ0FBb0NILG1CQUFPQSxDQUFDLGdKQUF5QztBQUN6RixJQUFJWCxzQkFBc0JXLG1CQUFPQSxDQUFDLG9GQUF1QztBQUN6RSxJQUFJTCxZQUFZSyxtQkFBT0EsQ0FBQyxzRkFBWTtBQUNwQyxJQUFJSCxZQUFZRyxtQkFBT0EsQ0FBQyx3RkFBYTtBQUNyQyxNQUFNSSxv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cEUsUUFBUW9FLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BFLFFBQVFvRSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0UsT0FBTyxFQUFFLGNBQWM7UUFBRW5FLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPd0UsTUFBTSxDQUFDdEUsUUFBUW9FLE9BQU8sRUFBRXBFO0lBQy9CdUUsT0FBT3ZFLE9BQU8sR0FBR0EsUUFBUW9FLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24uanM/MzQ4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlU2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zO1xuZXhwb3J0cy51c2VQYXRobmFtZSA9IHVzZVBhdGhuYW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVySW5zZXJ0ZWRIVE1MQ29udGV4dFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlcnZlckluc2VydGVkSHRtbC5TZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0O1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlU2VydmVySW5zZXJ0ZWRIVE1MXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VydmVySW5zZXJ0ZWRIdG1sLnVzZVNlcnZlckluc2VydGVkSFRNTDtcbiAgICB9XG59KTtcbmV4cG9ydHMudXNlUm91dGVyID0gdXNlUm91dGVyO1xuZXhwb3J0cy51c2VTZWxlY3RlZExheW91dFNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cztcbmV4cG9ydHMudXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50ID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVkaXJlY3RcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWRpcmVjdC5yZWRpcmVjdDtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vdEZvdW5kXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbm90Rm91bmQubm90Rm91bmQ7XG4gICAgfVxufSk7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9ob29rc0NsaWVudENvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dFwiKTtcbnZhciBfY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IgPSByZXF1aXJlKFwiLi9jbGllbnQtaG9vay1pbi1zZXJ2ZXItY29tcG9uZW50LWVycm9yXCIpO1xudmFyIF9zZXJ2ZXJJbnNlcnRlZEh0bWwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9zZXJ2ZXItaW5zZXJ0ZWQtaHRtbFwiKTtcbnZhciBfcmVkaXJlY3QgPSByZXF1aXJlKFwiLi9yZWRpcmVjdFwiKTtcbnZhciBfbm90Rm91bmQgPSByZXF1aXJlKFwiLi9ub3QtZm91bmRcIik7XG5jb25zdCBJTlRFUk5BTF9VUkxTRUFSQ0hQQVJBTVNfSU5TVEFOQ0UgPSBTeW1ib2woJ2ludGVybmFsIGZvciB1cmxzZWFyY2hwYXJhbXMgcmVhZG9ubHknKTtcbmZ1bmN0aW9uIHJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMgY2Fubm90IGJlIG1vZGlmaWVkJyk7XG59XG5jbGFzcyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMX1VSTFNFQVJDSFBBUkFNU19JTlNUQU5DRV1bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBhcHBlbmQoKSB7XG4gICAgICAgIHRocm93IHJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aHJvdyByZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKCk7XG4gICAgfVxuICAgIHNldCgpIHtcbiAgICAgICAgdGhyb3cgcmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvcigpO1xuICAgIH1cbiAgICBzb3J0KCkge1xuICAgICAgICB0aHJvdyByZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHVybFNlYXJjaFBhcmFtcyl7XG4gICAgICAgIC8vIFNpbmNlIGBuZXcgSGVhZGVyc2AgdXNlcyBgdGhpcy5hcHBlbmQoKWAgdG8gZmlsbCB0aGUgaGVhZGVycyBvYmplY3QgUmVhZG9ubHlIZWFkZXJzIGNhbid0IGV4dGVuZCBmcm9tIEhlYWRlcnMgZGlyZWN0bHkgYXMgaXQgd291bGQgdGhyb3cuXG4gICAgICAgIHRoaXNbSU5URVJOQUxfVVJMU0VBUkNIUEFSQU1TX0lOU1RBTkNFXSA9IHVybFNlYXJjaFBhcmFtcztcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gdXJsU2VhcmNoUGFyYW1zLmVudHJpZXMuYmluZCh1cmxTZWFyY2hQYXJhbXMpO1xuICAgICAgICB0aGlzLmZvckVhY2ggPSB1cmxTZWFyY2hQYXJhbXMuZm9yRWFjaC5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgICAgIHRoaXMuZ2V0ID0gdXJsU2VhcmNoUGFyYW1zLmdldC5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgICAgIHRoaXMuZ2V0QWxsID0gdXJsU2VhcmNoUGFyYW1zLmdldEFsbC5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgICAgIHRoaXMuaGFzID0gdXJsU2VhcmNoUGFyYW1zLmhhcy5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgICAgIHRoaXMua2V5cyA9IHVybFNlYXJjaFBhcmFtcy5rZXlzLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB1cmxTZWFyY2hQYXJhbXMudmFsdWVzLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy50b1N0cmluZyA9IHVybFNlYXJjaFBhcmFtcy50b1N0cmluZy5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkb25seVVSTFNlYXJjaFBhcmFtcyA9IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zO1xuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKCkge1xuICAgICgwLCBfY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKCd1c2VTZWFyY2hQYXJhbXMnKTtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9ob29rc0NsaWVudENvbnRleHQuU2VhcmNoUGFyYW1zQ29udGV4dCk7XG4gICAgY29uc3QgcmVhZG9ubHlTZWFyY2hQYXJhbXMgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSByb3V0ZXIgaXMgbm90IHJlYWR5IGluIHBhZ2VzLCB3ZSB3b24ndCBoYXZlIHRoZSBzZWFyY2ggcGFyYW1zXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcyk7XG4gICAgfSwgW1xuICAgICAgICBzZWFyY2hQYXJhbXNcbiAgICBdKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50IGJ1bmRsZS5cbiAgICAgICAgY29uc3QgeyBiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmcgIH0gPSByZXF1aXJlKCcuL2JhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZycpO1xuICAgICAgICBpZiAoYmFpbG91dFRvQ2xpZW50UmVuZGVyaW5nKCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgZHluYW1pYyA9ICdmb3JjZS1zdGF0aWMnIGhlcmUgYW5kIG9uIHRoZSBjbGllbnRcbiAgICAgICAgICAgIHJldHVybiByZWFkb25seVNlYXJjaFBhcmFtcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVhZG9ubHlTZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiB1c2VQYXRobmFtZSgpIHtcbiAgICAoMCwgX2NsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKS5jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcigndXNlUGF0aG5hbWUnKTtcbiAgICByZXR1cm4gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaG9va3NDbGllbnRDb250ZXh0LlBhdGhuYW1lQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXIoKSB7XG4gICAgKDAsIF9jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcikuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IoJ3VzZVJvdXRlcicpO1xuICAgIGNvbnN0IHJvdXRlciA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuQXBwUm91dGVyQ29udGV4dCk7XG4gICAgaWYgKHJvdXRlciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBhcHAgcm91dGVyIHRvIGJlIG1vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlcjtcbn1cbi8vIFRPRE8tQVBQOiBoYW5kbGUgcGFyYWxsZWwgcm91dGVzXG5mdW5jdGlvbiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKHRyZWUsIHBhcmFsbGVsUm91dGVLZXksIGZpcnN0ID0gdHJ1ZSwgc2VnbWVudFBhdGggPSBbXSkge1xuICAgIGxldCBub2RlO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIHBhcmFsbGVsIHJvdXRlIGtleSBvbiB0aGUgZmlyc3QgcGFyYWxsZWwgcm91dGVcbiAgICAgICAgbm9kZSA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWZ0ZXIgZmlyc3QgcGFyYWxsZWwgcm91dGUgcHJlZmVyIGNoaWxkcmVuLCBpZiB0aGVyZSdzIG5vIGNoaWxkcmVuIHBpY2sgdGhlIGZpcnN0IHBhcmFsbGVsIHJvdXRlLlxuICAgICAgICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IHRyZWVbMV07XG4gICAgICAgIHZhciBfY2hpbGRyZW47XG4gICAgICAgIG5vZGUgPSAoX2NoaWxkcmVuID0gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4pICE9IG51bGwgPyBfY2hpbGRyZW4gOiBPYmplY3QudmFsdWVzKHBhcmFsbGVsUm91dGVzKVswXTtcbiAgICB9XG4gICAgaWYgKCFub2RlKSByZXR1cm4gc2VnbWVudFBhdGg7XG4gICAgY29uc3Qgc2VnbWVudCA9IG5vZGVbMF07XG4gICAgY29uc3Qgc2VnbWVudFZhbHVlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGlmICghc2VnbWVudFZhbHVlKSByZXR1cm4gc2VnbWVudFBhdGg7XG4gICAgc2VnbWVudFBhdGgucHVzaChzZWdtZW50VmFsdWUpO1xuICAgIHJldHVybiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKG5vZGUsIHBhcmFsbGVsUm91dGVLZXksIGZhbHNlLCBzZWdtZW50UGF0aCk7XG59XG5mdW5jdGlvbiB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKHBhcmFsbGVsUm91dGVLZXkgPSAnY2hpbGRyZW4nKSB7XG4gICAgKDAsIF9jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcikuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IoJ3VzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHMnKTtcbiAgICBjb25zdCB7IHRyZWUgIH0gPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQpO1xuICAgIHJldHVybiBnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoKHRyZWUsIHBhcmFsbGVsUm91dGVLZXkpO1xufVxuZnVuY3Rpb24gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50KHBhcmFsbGVsUm91dGVLZXkgPSAnY2hpbGRyZW4nKSB7XG4gICAgKDAsIF9jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcikuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IoJ3VzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCcpO1xuICAgIGNvbnN0IHNlbGVjdGVkTGF5b3V0U2VnbWVudHMgPSB1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzKHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmIChzZWxlY3RlZExheW91dFNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkTGF5b3V0U2VnbWVudHNbMF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlUGF0aG5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3NlcnZlckluc2VydGVkSHRtbCIsIlNlcnZlckluc2VydGVkSFRNTENvbnRleHQiLCJ1c2VTZXJ2ZXJJbnNlcnRlZEhUTUwiLCJ1c2VSb3V0ZXIiLCJ1c2VTZWxlY3RlZExheW91dFNlZ21lbnRzIiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50IiwiX3JlZGlyZWN0IiwicmVkaXJlY3QiLCJfbm90Rm91bmQiLCJub3RGb3VuZCIsIl9yZWFjdCIsInJlcXVpcmUiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9ob29rc0NsaWVudENvbnRleHQiLCJfY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IiLCJJTlRFUk5BTF9VUkxTRUFSQ0hQQVJBTVNfSU5TVEFOQ0UiLCJTeW1ib2wiLCJyZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yIiwiRXJyb3IiLCJSZWFkb25seVVSTFNlYXJjaFBhcmFtcyIsIml0ZXJhdG9yIiwiYXBwZW5kIiwiZGVsZXRlIiwic2V0Iiwic29ydCIsImNvbnN0cnVjdG9yIiwidXJsU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsImJpbmQiLCJmb3JFYWNoIiwiZ2V0QWxsIiwiaGFzIiwia2V5cyIsInZhbHVlcyIsInRvU3RyaW5nIiwiY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IiLCJzZWFyY2hQYXJhbXMiLCJ1c2VDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsInJlYWRvbmx5U2VhcmNoUGFyYW1zIiwidXNlTWVtbyIsImJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyIsIlBhdGhuYW1lQ29udGV4dCIsInJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJnZXRTZWxlY3RlZExheW91dFNlZ21lbnRQYXRoIiwidHJlZSIsInBhcmFsbGVsUm91dGVLZXkiLCJmaXJzdCIsInNlZ21lbnRQYXRoIiwibm9kZSIsInBhcmFsbGVsUm91dGVzIiwiX2NoaWxkcmVuIiwiY2hpbGRyZW4iLCJzZWdtZW50Iiwic2VnbWVudFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJzZWxlY3RlZExheW91dFNlZ21lbnRzIiwibGVuZ3RoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/navigation.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/not-found.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/client/components/not-found.js ***!
  \***************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.notFound = notFound;\nexports.isNotFoundError = isNotFoundError;\nconst NOT_FOUND_ERROR_CODE = \"NEXT_NOT_FOUND\";\nfunction notFound() {\n    // eslint-disable-next-line no-throw-literal\n    const error = new Error(NOT_FOUND_ERROR_CODE);\n    error.digest = NOT_FOUND_ERROR_CODE;\n    throw error;\n}\nfunction isNotFoundError(error) {\n    return (error == null ? void 0 : error.digest) === NOT_FOUND_ERROR_CODE;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=not-found.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25vdC1mb3VuZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0U7QUFDbkJGLHVCQUF1QixHQUFHRztBQUMxQixNQUFNQyx1QkFBdUI7QUFDN0IsU0FBU0YsV0FBVztJQUNoQiw0Q0FBNEM7SUFDNUMsTUFBTUcsUUFBUSxJQUFJQyxNQUFNRjtJQUN4QkMsTUFBTUUsTUFBTSxHQUFHSDtJQUNmLE1BQU1DLE1BQU07QUFDaEI7QUFDQSxTQUFTRixnQkFBZ0JFLEtBQUssRUFBRTtJQUM1QixPQUFPLENBQUNBLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSUEsTUFBTUUsTUFBTSxNQUFNSDtBQUN2RDtBQUVBLElBQUksQ0FBQyxPQUFPSixRQUFRUSxPQUFPLEtBQUssY0FBZSxPQUFPUixRQUFRUSxPQUFPLEtBQUssWUFBWVIsUUFBUVEsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUixRQUFRUSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLWCxPQUFPQyxjQUFjLENBQUNDLFFBQVFRLE9BQU8sRUFBRSxjQUFjO1FBQUVQLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPWSxNQUFNLENBQUNWLFFBQVFRLE9BQU8sRUFBRVI7SUFDL0JXLE9BQU9YLE9BQU8sR0FBR0EsUUFBUVEsT0FBTztBQUNsQyxDQUFDLENBRUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kLmpzPzQyMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vdEZvdW5kID0gbm90Rm91bmQ7XG5leHBvcnRzLmlzTm90Rm91bmRFcnJvciA9IGlzTm90Rm91bmRFcnJvcjtcbmNvbnN0IE5PVF9GT1VORF9FUlJPUl9DT0RFID0gJ05FWFRfTk9UX0ZPVU5EJztcbmZ1bmN0aW9uIG5vdEZvdW5kKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoTk9UX0ZPVU5EX0VSUk9SX0NPREUpO1xuICAgIGVycm9yLmRpZ2VzdCA9IE5PVF9GT1VORF9FUlJPUl9DT0RFO1xuICAgIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gaXNOb3RGb3VuZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZGlnZXN0KSA9PT0gTk9UX0ZPVU5EX0VSUk9SX0NPREU7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC1mb3VuZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3RGb3VuZCIsImlzTm90Rm91bmRFcnJvciIsIk5PVF9GT1VORF9FUlJPUl9DT0RFIiwiZXJyb3IiLCJFcnJvciIsImRpZ2VzdCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/not-found.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = HotReload;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _stripAnsi = _interop_require_default(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"next/dist/compiled/strip-ansi\"));\nvar _formatWebpackMessages = _interop_require_default(__webpack_require__(/*! ../../dev/error-overlay/format-webpack-messages */ \"(sc_client)/./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\"));\nvar _navigation = __webpack_require__(/*! ../navigation */ \"(sc_client)/./node_modules/next/dist/client/components/navigation.js\");\nvar _errorOverlayReducer = __webpack_require__(/*! ./internal/error-overlay-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\");\nvar _parseStack = __webpack_require__(/*! ./internal/helpers/parseStack */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js\");\nvar _reactDevOverlay = _interop_require_default(__webpack_require__(/*! ./internal/ReactDevOverlay */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/ReactDevOverlay.js\"));\nvar _useErrorHandler = __webpack_require__(/*! ./internal/helpers/use-error-handler */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js\");\nvar _useWebsocket = __webpack_require__(/*! ./internal/helpers/use-websocket */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-websocket.js\");\nvar _parseComponentStack = __webpack_require__(/*! ./internal/helpers/parse-component-stack */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js\");\nfunction HotReload({ assetPrefix , children  }) {\n    const [state, dispatch] = (0, _react).useReducer(_errorOverlayReducer.errorOverlayReducer, {\n        nextId: 1,\n        buildError: null,\n        errors: [],\n        refreshState: {\n            type: \"idle\"\n        },\n        versionInfo: {\n            installed: \"0.0.0\",\n            staleness: \"unknown\"\n        }\n    });\n    const dispatcher = (0, _react).useMemo(()=>{\n        return {\n            onBuildOk () {\n                dispatch({\n                    type: _errorOverlayReducer.ACTION_BUILD_OK\n                });\n            },\n            onBuildError (message) {\n                dispatch({\n                    type: _errorOverlayReducer.ACTION_BUILD_ERROR,\n                    message\n                });\n            },\n            onBeforeRefresh () {\n                dispatch({\n                    type: _errorOverlayReducer.ACTION_BEFORE_REFRESH\n                });\n            },\n            onRefresh () {\n                dispatch({\n                    type: _errorOverlayReducer.ACTION_REFRESH\n                });\n            },\n            onVersionInfo (versionInfo) {\n                dispatch({\n                    type: _errorOverlayReducer.ACTION_VERSION_INFO,\n                    versionInfo\n                });\n            }\n        };\n    }, [\n        dispatch\n    ]);\n    const handleOnUnhandledError = (0, _react).useCallback((error)=>{\n        // Component stack is added to the error in use-error-handler\n        const componentStack = error._componentStack;\n        dispatch({\n            type: _errorOverlayReducer.ACTION_UNHANDLED_ERROR,\n            reason: error,\n            frames: (0, _parseStack).parseStack(error.stack),\n            componentStackFrames: componentStack && (0, _parseComponentStack).parseComponentStack(componentStack)\n        });\n    }, []);\n    const handleOnUnhandledRejection = (0, _react).useCallback((reason)=>{\n        dispatch({\n            type: _errorOverlayReducer.ACTION_UNHANDLED_REJECTION,\n            reason: reason,\n            frames: (0, _parseStack).parseStack(reason.stack)\n        });\n    }, []);\n    const handleOnReactError = (0, _react).useCallback(()=>{\n        _useErrorHandler.RuntimeErrorHandler.hadRuntimeError = true;\n    }, []);\n    (0, _useErrorHandler).useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection);\n    const webSocketRef = (0, _useWebsocket).useWebsocket(assetPrefix);\n    (0, _useWebsocket).useWebsocketPing(webSocketRef);\n    const sendMessage = (0, _useWebsocket).useSendMessage(webSocketRef);\n    const router = (0, _navigation).useRouter();\n    (0, _react).useEffect(()=>{\n        const handler = (event)=>{\n            if (event.data.indexOf(\"action\") === -1 && // TODO-APP: clean this up for consistency\n            event.data.indexOf(\"pong\") === -1) {\n                return;\n            }\n            try {\n                processMessage(event, sendMessage, router, dispatcher);\n            } catch (ex) {\n                console.warn(\"Invalid HMR message: \" + event.data + \"\\n\", ex);\n            }\n        };\n        const websocket = webSocketRef.current;\n        if (websocket) {\n            websocket.addEventListener(\"message\", handler);\n        }\n        return ()=>websocket && websocket.removeEventListener(\"message\", handler);\n    }, [\n        sendMessage,\n        router,\n        webSocketRef,\n        dispatcher\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_reactDevOverlay.default, {\n        onReactError: handleOnReactError,\n        state: state\n    }, children);\n}\nlet mostRecentCompilationHash = null;\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now());\n// let startLatency = undefined\nfunction onBeforeFastRefresh(dispatcher, hasUpdates) {\n    if (hasUpdates) {\n        dispatcher.onBeforeRefresh();\n    }\n}\nfunction onFastRefresh(dispatcher, hasUpdates) {\n    dispatcher.onBuildOk();\n    if (hasUpdates) {\n        dispatcher.onRefresh();\n    }\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    // @ts-expect-error module.hot exists\n    return module.hot.status() === \"idle\";\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === \"idle\") {\n                // @ts-expect-error module.hot exists\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        // @ts-expect-error module.hot exists\n        module.hot.addStatusHandler(handler);\n    }\n}\nfunction performFullReload(err, sendMessage) {\n    const stackTrace = err && (err.stack && err.stack.split(\"\\n\").slice(0, 5).join(\"\\n\") || err.message || err + \"\");\n    sendMessage(JSON.stringify({\n        event: \"client-full-reload\",\n        stackTrace,\n        hadRuntimeError: !!_useErrorHandler.RuntimeErrorHandler.hadRuntimeError\n    }));\n    window.location.reload();\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onBeforeUpdate, onHotUpdateSuccess, sendMessage, dispatcher) {\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        dispatcher.onBuildOk();\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || _useErrorHandler.RuntimeErrorHandler.hadRuntimeError || !updatedModules) {\n            if (err) {\n                console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n            } else if (_useErrorHandler.RuntimeErrorHandler.hadRuntimeError) {\n                console.warn(\"[Fast Refresh] performing full reload because your application had an unrecoverable error\");\n            }\n            performFullReload(err, sendMessage);\n            return;\n        }\n        const hasUpdates = Boolean(updatedModules.length);\n        if (typeof onHotUpdateSuccess === \"function\") {\n            // Maybe we want to do something.\n            onHotUpdateSuccess(hasUpdates);\n        }\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdates(hasUpdates ? ()=>{} : onBeforeUpdate, hasUpdates ? ()=>dispatcher.onBuildOk() : onHotUpdateSuccess, sendMessage, dispatcher);\n        } else {\n            dispatcher.onBuildOk();\n            if (false) {}\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    // @ts-expect-error module.hot exists\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (!updatedModules) {\n            return null;\n        }\n        if (typeof onBeforeUpdate === \"function\") {\n            const hasUpdates = Boolean(updatedModules.length);\n            onBeforeUpdate(hasUpdates);\n        }\n        // https://webpack.js.org/api/hot-module-replacement/#apply\n        // @ts-expect-error module.hot exists\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\nfunction processMessage(e, sendMessage, router, dispatcher) {\n    const obj = JSON.parse(e.data);\n    switch(obj.action){\n        case \"building\":\n            {\n                console.log(\"[Fast Refresh] rebuilding\");\n                break;\n            }\n        case \"built\":\n        case \"sync\":\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                const { errors , warnings , versionInfo  } = obj;\n                // Is undefined when it's a 'built' event\n                if (versionInfo) {\n                    dispatcher.onVersionInfo(versionInfo);\n                }\n                const hasErrors = Boolean(errors && errors.length);\n                // Compilation with errors (e.g. syntax error or missing modules).\n                if (hasErrors) {\n                    sendMessage(JSON.stringify({\n                        event: \"client-error\",\n                        errorCount: errors.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // \"Massage\" webpack messages.\n                    let formatted = (0, _formatWebpackMessages).default({\n                        errors: errors,\n                        warnings: []\n                    });\n                    // Only show the first error.\n                    dispatcher.onBuildError(formatted.errors[0]);\n                    // Also log them to the console.\n                    for(let i = 0; i < formatted.errors.length; i++){\n                        console.error((0, _stripAnsi).default(formatted.errors[i]));\n                    }\n                    // Do not attempt to reload now.\n                    // We will reload on next success instead.\n                    if (false) {}\n                    return;\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    sendMessage(JSON.stringify({\n                        event: \"client-warning\",\n                        warningCount: warnings.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // Compilation with warnings (e.g. ESLint).\n                    const isHotUpdate = obj.action !== \"sync\";\n                    // Print warnings to the console.\n                    const formattedMessages = (0, _formatWebpackMessages).default({\n                        warnings: warnings,\n                        errors: []\n                    });\n                    for(let i = 0; i < formattedMessages.warnings.length; i++){\n                        if (i === 5) {\n                            console.warn(\"There were more warnings in other files.\\n\" + \"You can find a complete log in the terminal.\");\n                            break;\n                        }\n                        console.warn((0, _stripAnsi).default(formattedMessages.warnings[i]));\n                    }\n                    // Attempt to apply hot updates or reload.\n                    if (isHotUpdate) {\n                        tryApplyUpdates(function onBeforeHotUpdate(hasUpdates) {\n                            onBeforeFastRefresh(dispatcher, hasUpdates);\n                        }, function onSuccessfulHotUpdate(hasUpdates) {\n                            // Only dismiss it when we're sure it's a hot update.\n                            // Otherwise it would flicker right before the reload.\n                            onFastRefresh(dispatcher, hasUpdates);\n                        }, sendMessage, dispatcher);\n                    }\n                    return;\n                }\n                sendMessage(JSON.stringify({\n                    event: \"client-success\",\n                    clientId: __nextDevClientId\n                }));\n                const isHotUpdate = obj.action !== \"sync\" || (!window.__NEXT_DATA__ || window.__NEXT_DATA__.page !== \"/_error\") && isUpdateAvailable();\n                // Attempt to apply hot updates or reload.\n                if (isHotUpdate) {\n                    tryApplyUpdates(function onBeforeHotUpdate(hasUpdates) {\n                        onBeforeFastRefresh(dispatcher, hasUpdates);\n                    }, function onSuccessfulHotUpdate(hasUpdates) {\n                        // Only dismiss it when we're sure it's a hot update.\n                        // Otherwise it would flicker right before the reload.\n                        onFastRefresh(dispatcher, hasUpdates);\n                    }, sendMessage, dispatcher);\n                }\n                return;\n            }\n        // TODO-APP: make server component change more granular\n        case \"serverComponentChanges\":\n            {\n                sendMessage(JSON.stringify({\n                    event: \"server-component-reload-page\",\n                    clientId: __nextDevClientId\n                }));\n                if (_useErrorHandler.RuntimeErrorHandler.hadRuntimeError) {\n                    return window.location.reload();\n                }\n                (0, _react).startTransition(()=>{\n                    router.refresh();\n                    dispatcher.onRefresh();\n                });\n                if (false) {}\n                return;\n            }\n        case \"reloadPage\":\n            {\n                sendMessage(JSON.stringify({\n                    event: \"client-reload-page\",\n                    clientId: __nextDevClientId\n                }));\n                return window.location.reload();\n            }\n        case \"removedPage\":\n            {\n                // TODO-APP: potentially only refresh if the currently viewed page was removed.\n                router.refresh();\n                return;\n            }\n        case \"addedPage\":\n            {\n                // TODO-APP: potentially only refresh if the currently viewed page was added.\n                router.refresh();\n                return;\n            }\n        case \"pong\":\n            {\n                const { invalid  } = obj;\n                if (invalid) {\n                    // Payload can be invalid even if the page does exist.\n                    // So, we check if it can be created.\n                    router.refresh();\n                }\n                return;\n            }\n        default:\n            {\n                throw new Error(\"Unexpected action \" + obj.action);\n            }\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hot-reloader-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2hvdC1yZWxvYWRlci1jbGllbnQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCLElBQUlDLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlDLDRCQUE0QkQsaUtBQWdFO0FBQ2hHLElBQUlFLFNBQVNELDBCQUEwQkQsbUJBQU9BLENBQUMsb0JBQU87QUFDdEQsSUFBSUcsYUFBYUoseUJBQXlCQyxtQkFBT0EsQ0FBQyxvRUFBK0I7QUFDakYsSUFBSUkseUJBQXlCTCx5QkFBeUJDLG1CQUFPQSxDQUFDLGlKQUFpRDtBQUMvRyxJQUFJSyxjQUFjTCxtQkFBT0EsQ0FBQywyRkFBZTtBQUN6QyxJQUFJTSx1QkFBdUJOLG1CQUFPQSxDQUFDLG9KQUFrQztBQUNyRSxJQUFJTyxjQUFjUCxtQkFBT0EsQ0FBQyw4SUFBK0I7QUFDekQsSUFBSVEsbUJBQW1CVCx5QkFBeUJDLG1CQUFPQSxDQUFDLHdJQUE0QjtBQUNwRixJQUFJUyxtQkFBbUJULG1CQUFPQSxDQUFDLDRKQUFzQztBQUNyRSxJQUFJVSxnQkFBZ0JWLG1CQUFPQSxDQUFDLG9KQUFrQztBQUM5RCxJQUFJVyx1QkFBdUJYLG1CQUFPQSxDQUFDLG9LQUEwQztBQUM3RSxTQUFTRixVQUFVLEVBQUVjLFlBQVcsRUFBR0MsU0FBUSxFQUFHLEVBQUU7SUFDNUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUcsQ0FBQyxHQUFHYixNQUFNLEVBQUVjLFVBQVUsQ0FBQ1YscUJBQXFCVyxtQkFBbUIsRUFBRTtRQUN2RkMsUUFBUTtRQUNSQyxZQUFZLElBQUk7UUFDaEJDLFFBQVEsRUFBRTtRQUNWQyxjQUFjO1lBQ1ZDLE1BQU07UUFDVjtRQUNBQyxhQUFhO1lBQ1RDLFdBQVc7WUFD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SjtRQUNKO1lBQ0k7Z0JBQ0ksTUFBTSxJQUFJRSxNQUFNLHVCQUF1QnJCLElBQUlFLE1BQU0sRUFBRTtZQUN2RDtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT3ZJLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ3lKLFVBQVUsS0FBSyxhQUFhO0lBQ3JLN0osT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzhKLE1BQU0sQ0FBQzVKLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JtRyxPQUFPbkcsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50LmpzPzA2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIb3RSZWxvYWQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3N0cmlwQW5zaSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2lcIikpO1xudmFyIF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Rldi9lcnJvci1vdmVybGF5L2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzXCIpKTtcbnZhciBfbmF2aWdhdGlvbiA9IHJlcXVpcmUoXCIuLi9uYXZpZ2F0aW9uXCIpO1xudmFyIF9lcnJvck92ZXJsYXlSZWR1Y2VyID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvZXJyb3Itb3ZlcmxheS1yZWR1Y2VyXCIpO1xudmFyIF9wYXJzZVN0YWNrID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrXCIpO1xudmFyIF9yZWFjdERldk92ZXJsYXkgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5XCIpKTtcbnZhciBfdXNlRXJyb3JIYW5kbGVyID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy91c2UtZXJyb3ItaGFuZGxlclwiKTtcbnZhciBfdXNlV2Vic29ja2V0ID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy91c2Utd2Vic29ja2V0XCIpO1xudmFyIF9wYXJzZUNvbXBvbmVudFN0YWNrID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZS1jb21wb25lbnQtc3RhY2tcIik7XG5mdW5jdGlvbiBIb3RSZWxvYWQoeyBhc3NldFByZWZpeCAsIGNoaWxkcmVuICB9KSB7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKF9lcnJvck92ZXJsYXlSZWR1Y2VyLmVycm9yT3ZlcmxheVJlZHVjZXIsIHtcbiAgICAgICAgbmV4dElkOiAxLFxuICAgICAgICBidWlsZEVycm9yOiBudWxsLFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICByZWZyZXNoU3RhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdpZGxlJ1xuICAgICAgICB9LFxuICAgICAgICB2ZXJzaW9uSW5mbzoge1xuICAgICAgICAgICAgaW5zdGFsbGVkOiAnMC4wLjAnLFxuICAgICAgICAgICAgc3RhbGVuZXNzOiAndW5rbm93bidcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkJ1aWxkT2sgKCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX2Vycm9yT3ZlcmxheVJlZHVjZXIuQUNUSU9OX0JVSUxEX09LXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25CdWlsZEVycm9yIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfZXJyb3JPdmVybGF5UmVkdWNlci5BQ1RJT05fQlVJTERfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkJlZm9yZVJlZnJlc2ggKCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX2Vycm9yT3ZlcmxheVJlZHVjZXIuQUNUSU9OX0JFRk9SRV9SRUZSRVNIXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWZyZXNoICgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9SRUZSRVNIXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25WZXJzaW9uSW5mbyAodmVyc2lvbkluZm8pIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9WRVJTSU9OX0lORk8sXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25JbmZvXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZU9uVW5oYW5kbGVkRXJyb3IgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoZXJyb3IpPT57XG4gICAgICAgIC8vIENvbXBvbmVudCBzdGFjayBpcyBhZGRlZCB0byB0aGUgZXJyb3IgaW4gdXNlLWVycm9yLWhhbmRsZXJcbiAgICAgICAgY29uc3QgY29tcG9uZW50U3RhY2sgPSBlcnJvci5fY29tcG9uZW50U3RhY2s7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9VTkhBTkRMRURfRVJST1IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLFxuICAgICAgICAgICAgZnJhbWVzOiAoMCwgX3BhcnNlU3RhY2spLnBhcnNlU3RhY2soZXJyb3Iuc3RhY2spLFxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tGcmFtZXM6IGNvbXBvbmVudFN0YWNrICYmICgwLCBfcGFyc2VDb21wb25lbnRTdGFjaykucGFyc2VDb21wb25lbnRTdGFjayhjb21wb25lbnRTdGFjaylcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKHJlYXNvbik9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yT3ZlcmxheVJlZHVjZXIuQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgIGZyYW1lczogKDAsIF9wYXJzZVN0YWNrKS5wYXJzZVN0YWNrKHJlYXNvbi5zdGFjaylcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZU9uUmVhY3RFcnJvciA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIF91c2VFcnJvckhhbmRsZXIuUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IgPSB0cnVlO1xuICAgIH0sIFtdKTtcbiAgICAoMCwgX3VzZUVycm9ySGFuZGxlcikudXNlRXJyb3JIYW5kbGVyKGhhbmRsZU9uVW5oYW5kbGVkRXJyb3IsIGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKTtcbiAgICBjb25zdCB3ZWJTb2NrZXRSZWYgPSAoMCwgX3VzZVdlYnNvY2tldCkudXNlV2Vic29ja2V0KGFzc2V0UHJlZml4KTtcbiAgICAoMCwgX3VzZVdlYnNvY2tldCkudXNlV2Vic29ja2V0UGluZyh3ZWJTb2NrZXRSZWYpO1xuICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKDAsIF91c2VXZWJzb2NrZXQpLnVzZVNlbmRNZXNzYWdlKHdlYlNvY2tldFJlZik7XG4gICAgY29uc3Qgcm91dGVyID0gKDAsIF9uYXZpZ2F0aW9uKS51c2VSb3V0ZXIoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudCk9PntcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ2FjdGlvbicpID09PSAtMSAmJiAvLyBUT0RPLUFQUDogY2xlYW4gdGhpcyB1cCBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZigncG9uZycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2UoZXZlbnQsIHNlbmRNZXNzYWdlLCByb3V0ZXIsIGRpc3BhdGNoZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgSE1SIG1lc3NhZ2U6ICcgKyBldmVudC5kYXRhICsgJ1xcbicsIGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0ID0gd2ViU29ja2V0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh3ZWJzb2NrZXQpIHtcbiAgICAgICAgICAgIHdlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT53ZWJzb2NrZXQgJiYgd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyKTtcbiAgICB9LCBbXG4gICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIHdlYlNvY2tldFJlZixcbiAgICAgICAgZGlzcGF0Y2hlclxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RGV2T3ZlcmxheS5kZWZhdWx0LCB7XG4gICAgICAgIG9uUmVhY3RFcnJvcjogaGFuZGxlT25SZWFjdEVycm9yLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICB9LCBjaGlsZHJlbik7XG59XG5sZXQgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IG51bGw7XG5sZXQgX19uZXh0RGV2Q2xpZW50SWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAgKyBEYXRlLm5vdygpKTtcbi8vIGxldCBzdGFydExhdGVuY3kgPSB1bmRlZmluZWRcbmZ1bmN0aW9uIG9uQmVmb3JlRmFzdFJlZnJlc2goZGlzcGF0Y2hlciwgaGFzVXBkYXRlcykge1xuICAgIGlmIChoYXNVcGRhdGVzKSB7XG4gICAgICAgIGRpc3BhdGNoZXIub25CZWZvcmVSZWZyZXNoKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaChkaXNwYXRjaGVyLCBoYXNVcGRhdGVzKSB7XG4gICAgZGlzcGF0Y2hlci5vbkJ1aWxkT2soKTtcbiAgICBpZiAoaGFzVXBkYXRlcykge1xuICAgICAgICBkaXNwYXRjaGVyLm9uUmVmcmVzaCgpO1xuICAgIH1cbn1cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgICAvLyBVcGRhdGUgbGFzdCBrbm93biBjb21waWxhdGlvbiBoYXNoLlxuICAgIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBoYXNoO1xufVxuLy8gSXMgdGhlcmUgYSBuZXdlciB2ZXJzaW9uIG9mIHRoaXMgY29kZSBhdmFpbGFibGU/XG5mdW5jdGlvbiBpc1VwZGF0ZUF2YWlsYWJsZSgpIHtcbiAgICAvKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi8gLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgICAvLyBJdCdzIGEgZ2xvYmFsIHZhcmlhYmxlIGluamVjdGVkIGJ5IFdlYnBhY2suXG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggIT09IF9fd2VicGFja19oYXNoX187XG59XG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJztcbn1cbmZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgIGZuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdpZGxlJykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbW9kdWxlLmhvdCBleGlzdHNcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtRnVsbFJlbG9hZChlcnIsIHNlbmRNZXNzYWdlKSB7XG4gICAgY29uc3Qgc3RhY2tUcmFjZSA9IGVyciAmJiAoZXJyLnN0YWNrICYmIGVyci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMCwgNSkuam9pbignXFxuJykgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyICsgJycpO1xuICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXZlbnQ6ICdjbGllbnQtZnVsbC1yZWxvYWQnLFxuICAgICAgICBzdGFja1RyYWNlLFxuICAgICAgICBoYWRSdW50aW1lRXJyb3I6ICEhX3VzZUVycm9ySGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvclxuICAgIH0pKTtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG59XG4vLyBBdHRlbXB0IHRvIHVwZGF0ZSBjb2RlIG9uIHRoZSBmbHksIGZhbGwgYmFjayB0byBhIGhhcmQgcmVsb2FkLlxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzKG9uQmVmb3JlVXBkYXRlLCBvbkhvdFVwZGF0ZVN1Y2Nlc3MsIHNlbmRNZXNzYWdlLCBkaXNwYXRjaGVyKSB7XG4gICAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICBkaXNwYXRjaGVyLm9uQnVpbGRPaygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgIGlmIChlcnIgfHwgX3VzZUVycm9ySGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWRcXG5cXG4nICsgXCJGYXN0IFJlZnJlc2ggd2lsbCBwZXJmb3JtIGEgZnVsbCByZWxvYWQgd2hlbiB5b3UgZWRpdCBhIGZpbGUgdGhhdCdzIGltcG9ydGVkIGJ5IG1vZHVsZXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyaW5nIHRyZWUuXFxuXCIgKyAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuJyArICdDb25zaWRlciBtaWdyYXRpbmcgdGhlIG5vbi1SZWFjdCBjb21wb25lbnQgZXhwb3J0IHRvIGEgc2VwYXJhdGUgZmlsZSBhbmQgaW1wb3J0aW5nIGl0IGludG8gYm90aCBmaWxlcy5cXG5cXG4nICsgJ0l0IGlzIGFsc28gcG9zc2libGUgdGhlIHBhcmVudCBjb21wb25lbnQgb2YgdGhlIGNvbXBvbmVudCB5b3UgZWRpdGVkIGlzIGEgY2xhc3MgY29tcG9uZW50LCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJyArICdGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfdXNlRXJyb3JIYW5kbGVyLlJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyZm9ybUZ1bGxSZWxvYWQoZXJyLCBzZW5kTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVXBkYXRlcyA9IEJvb2xlYW4odXBkYXRlZE1vZHVsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkhvdFVwZGF0ZVN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxuICAgICAgICAgICAgb25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VwZGF0ZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbiAgICAgICAgICAgIHRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzID8gKCk9Pnt9IDogb25CZWZvcmVVcGRhdGUsIGhhc1VwZGF0ZXMgPyAoKT0+ZGlzcGF0Y2hlci5vbkJ1aWxkT2soKSA6IG9uSG90VXBkYXRlU3VjY2Vzcywgc2VuZE1lc3NhZ2UsIGRpc3BhdGNoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5vbkJ1aWxkT2soKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJBcHBseVVwZGF0ZXMoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1vZHVsZS5ob3QgZXhpc3RzXG4gICAgbW9kdWxlLmhvdC5jaGVjaygvKiBhdXRvQXBwbHkgKi8gZmFsc2UpLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uQmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNVcGRhdGVzID0gQm9vbGVhbih1cGRhdGVkTW9kdWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgb25CZWZvcmVVcGRhdGUoaGFzVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jYXBwbHlcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtb2R1bGUuaG90IGV4aXN0c1xuICAgICAgICByZXR1cm4gbW9kdWxlLmhvdC5hcHBseSgpO1xuICAgIH0pLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMobnVsbCwgdXBkYXRlZE1vZHVsZXMpO1xuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIG51bGwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UoZSwgc2VuZE1lc3NhZ2UsIHJvdXRlciwgZGlzcGF0Y2hlcikge1xuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBzd2l0Y2gob2JqLmFjdGlvbil7XG4gICAgICAgIGNhc2UgJ2J1aWxkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdidWlsdCc6XG4gICAgICAgIGNhc2UgJ3N5bmMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdmFpbGFibGVIYXNoKG9iai5oYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgLCB3YXJuaW5ncyAsIHZlcnNpb25JbmZvICB9ID0gb2JqO1xuICAgICAgICAgICAgICAgIC8vIElzIHVuZGVmaW5lZCB3aGVuIGl0J3MgYSAnYnVpbHQnIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIub25WZXJzaW9uSW5mbyh2ZXJzaW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb3VudDogZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JtYXR0ZWQgPSAoMCwgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcykuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzaG93IHRoZSBmaXJzdCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28gbG9nIHRoZW0gdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQoZm9ybWF0dGVkLmVycm9yc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmVsb2FkIG9uIG5leHQgc3VjY2VzcyBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzV2FybmluZ3MgPSBCb29sZWFuKHdhcm5pbmdzICYmIHdhcm5pbmdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXdhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ0NvdW50OiB3YXJuaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21waWxhdGlvbiB3aXRoIHdhcm5pbmdzIChlLmcuIEVTTGludCkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSG90VXBkYXRlID0gb2JqLmFjdGlvbiAhPT0gJ3N5bmMnO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZXMgPSAoMCwgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcykuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkTWVzc2FnZXMud2FybmluZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICsgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQoZm9ybWF0dGVkTWVzc2FnZXMud2FybmluZ3NbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25CZWZvcmVIb3RVcGRhdGUoaGFzVXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlRmFzdFJlZnJlc2goZGlzcGF0Y2hlciwgaGFzVXBkYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GYXN0UmVmcmVzaChkaXNwYXRjaGVyLCBoYXNVcGRhdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNlbmRNZXNzYWdlLCBkaXNwYXRjaGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjbGllbnQtc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvdFVwZGF0ZSA9IG9iai5hY3Rpb24gIT09ICdzeW5jJyB8fCAoIXdpbmRvdy5fX05FWFRfREFUQV9fIHx8IHdpbmRvdy5fX05FWFRfREFUQV9fLnBhZ2UgIT09ICcvX2Vycm9yJykgJiYgaXNVcGRhdGVBdmFpbGFibGUoKTtcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgICAgICAgICAgICAgICBpZiAoaXNIb3RVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5QXBwbHlVcGRhdGVzKGZ1bmN0aW9uIG9uQmVmb3JlSG90VXBkYXRlKGhhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlRmFzdFJlZnJlc2goZGlzcGF0Y2hlciwgaGFzVXBkYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZhc3RSZWZyZXNoKGRpc3BhdGNoZXIsIGhhc1VwZGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBzZW5kTWVzc2FnZSwgZGlzcGF0Y2hlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVE9ETy1BUFA6IG1ha2Ugc2VydmVyIGNvbXBvbmVudCBjaGFuZ2UgbW9yZSBncmFudWxhclxuICAgICAgICBjYXNlICdzZXJ2ZXJDb21wb25lbnRDaGFuZ2VzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnc2VydmVyLWNvbXBvbmVudC1yZWxvYWQtcGFnZScsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoX3VzZUVycm9ySGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoMCwgX3JlYWN0KS5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5vblJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWxvYWRQYWdlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiAnY2xpZW50LXJlbG9hZC1wYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IF9fbmV4dERldkNsaWVudElkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbW92ZWRQYWdlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogcG90ZW50aWFsbHkgb25seSByZWZyZXNoIGlmIHRoZSBjdXJyZW50bHkgdmlld2VkIHBhZ2Ugd2FzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgcm91dGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FkZGVkUGFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHBvdGVudGlhbGx5IG9ubHkgcmVmcmVzaCBpZiB0aGUgY3VycmVudGx5IHZpZXdlZCBwYWdlIHdhcyBhZGRlZC5cbiAgICAgICAgICAgICAgICByb3V0ZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnZhbGlkICB9ID0gb2JqO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY2FuIGJlIGludmFsaWQgZXZlbiBpZiB0aGUgcGFnZSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBTbywgd2UgY2hlY2sgaWYgaXQgY2FuIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYWN0aW9uICcgKyBvYmouYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvdC1yZWxvYWRlci1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkhvdFJlbG9hZCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiX3N0cmlwQW5zaSIsIl9mb3JtYXRXZWJwYWNrTWVzc2FnZXMiLCJfbmF2aWdhdGlvbiIsIl9lcnJvck92ZXJsYXlSZWR1Y2VyIiwiX3BhcnNlU3RhY2siLCJfcmVhY3REZXZPdmVybGF5IiwiX3VzZUVycm9ySGFuZGxlciIsIl91c2VXZWJzb2NrZXQiLCJfcGFyc2VDb21wb25lbnRTdGFjayIsImFzc2V0UHJlZml4IiwiY2hpbGRyZW4iLCJzdGF0ZSIsImRpc3BhdGNoIiwidXNlUmVkdWNlciIsImVycm9yT3ZlcmxheVJlZHVjZXIiLCJuZXh0SWQiLCJidWlsZEVycm9yIiwiZXJyb3JzIiwicmVmcmVzaFN0YXRlIiwidHlwZSIsInZlcnNpb25JbmZvIiwiaW5zdGFsbGVkIiwic3RhbGVuZXNzIiwiZGlzcGF0Y2hlciIsInVzZU1lbW8iLCJvbkJ1aWxkT2siLCJBQ1RJT05fQlVJTERfT0siLCJvbkJ1aWxkRXJyb3IiLCJtZXNzYWdlIiwiQUNUSU9OX0JVSUxEX0VSUk9SIiwib25CZWZvcmVSZWZyZXNoIiwiQUNUSU9OX0JFRk9SRV9SRUZSRVNIIiwib25SZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJvblZlcnNpb25JbmZvIiwiQUNUSU9OX1ZFUlNJT05fSU5GTyIsImhhbmRsZU9uVW5oYW5kbGVkRXJyb3IiLCJ1c2VDYWxsYmFjayIsImVycm9yIiwiY29tcG9uZW50U3RhY2siLCJfY29tcG9uZW50U3RhY2siLCJBQ1RJT05fVU5IQU5ETEVEX0VSUk9SIiwicmVhc29uIiwiZnJhbWVzIiwicGFyc2VTdGFjayIsInN0YWNrIiwiY29tcG9uZW50U3RhY2tGcmFtZXMiLCJwYXJzZUNvbXBvbmVudFN0YWNrIiwiaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24iLCJBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTiIsImhhbmRsZU9uUmVhY3RFcnJvciIsIlJ1bnRpbWVFcnJvckhhbmRsZXIiLCJoYWRSdW50aW1lRXJyb3IiLCJ1c2VFcnJvckhhbmRsZXIiLCJ3ZWJTb2NrZXRSZWYiLCJ1c2VXZWJzb2NrZXQiLCJ1c2VXZWJzb2NrZXRQaW5nIiwic2VuZE1lc3NhZ2UiLCJ1c2VTZW5kTWVzc2FnZSIsInJvdXRlciIsInVzZVJvdXRlciIsInVzZUVmZmVjdCIsImhhbmRsZXIiLCJldmVudCIsImRhdGEiLCJpbmRleE9mIiwicHJvY2Vzc01lc3NhZ2UiLCJleCIsImNvbnNvbGUiLCJ3YXJuIiwid2Vic29ja2V0IiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JlYXRlRWxlbWVudCIsIm9uUmVhY3RFcnJvciIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJfX25leHREZXZDbGllbnRJZCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIkRhdGUiLCJub3ciLCJvbkJlZm9yZUZhc3RSZWZyZXNoIiwiaGFzVXBkYXRlcyIsIm9uRmFzdFJlZnJlc2giLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzaCIsImlzVXBkYXRlQXZhaWxhYmxlIiwiX193ZWJwYWNrX2hhc2hfXyIsImNhbkFwcGx5VXBkYXRlcyIsIm1vZHVsZSIsImhvdCIsInN0YXR1cyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiZm4iLCJyZW1vdmVTdGF0dXNIYW5kbGVyIiwiYWRkU3RhdHVzSGFuZGxlciIsInBlcmZvcm1GdWxsUmVsb2FkIiwiZXJyIiwic3RhY2tUcmFjZSIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsIndpbmRvdyIsImxvY2F0aW9uIiwicmVsb2FkIiwidHJ5QXBwbHlVcGRhdGVzIiwib25CZWZvcmVVcGRhdGUiLCJvbkhvdFVwZGF0ZVN1Y2Nlc3MiLCJoYW5kbGVBcHBseVVwZGF0ZXMiLCJ1cGRhdGVkTW9kdWxlcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RFU1RfTU9ERSIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwiY2hlY2siLCJ0aGVuIiwiYXBwbHkiLCJlIiwib2JqIiwicGFyc2UiLCJhY3Rpb24iLCJsb2ciLCJ3YXJuaW5ncyIsImhhc0Vycm9ycyIsImVycm9yQ291bnQiLCJjbGllbnRJZCIsImZvcm1hdHRlZCIsImkiLCJoYXNXYXJuaW5ncyIsIndhcm5pbmdDb3VudCIsImlzSG90VXBkYXRlIiwiZm9ybWF0dGVkTWVzc2FnZXMiLCJvbkJlZm9yZUhvdFVwZGF0ZSIsIm9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZSIsIl9fTkVYVF9EQVRBX18iLCJwYWdlIiwic3RhcnRUcmFuc2l0aW9uIiwicmVmcmVzaCIsImludmFsaWQiLCJFcnJvciIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/ReactDevOverlay.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/ReactDevOverlay.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _errorOverlayReducer = __webpack_require__(/*! ./error-overlay-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\");\nvar _shadowPortal = __webpack_require__(/*! ./components/ShadowPortal */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js\");\nvar _buildError = __webpack_require__(/*! ./container/BuildError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/BuildError.js\");\nvar _errors = __webpack_require__(/*! ./container/Errors */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/Errors.js\");\nvar _rootLayoutError = __webpack_require__(/*! ./container/RootLayoutError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RootLayoutError.js\");\nvar _parseStack = __webpack_require__(/*! ./helpers/parseStack */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js\");\nvar _base = __webpack_require__(/*! ./styles/Base */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/Base.js\");\nvar _componentStyles = __webpack_require__(/*! ./styles/ComponentStyles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/ComponentStyles.js\");\nvar _cssReset = __webpack_require__(/*! ./styles/CssReset */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/CssReset.js\");\nclass ReactDevOverlay extends React.PureComponent {\n    static getDerivedStateFromError(error) {\n        const e = error;\n        const event = {\n            type: _errorOverlayReducer.ACTION_UNHANDLED_ERROR,\n            reason: error,\n            frames: (0, _parseStack).parseStack(e.stack)\n        };\n        const errorEvent = {\n            id: 0,\n            event\n        };\n        return {\n            reactError: errorEvent\n        };\n    }\n    componentDidCatch(componentErr) {\n        this.props.onReactError(componentErr);\n    }\n    render() {\n        const { state , children  } = this.props;\n        const { reactError  } = this.state;\n        const hasBuildError = state.buildError != null;\n        const hasRuntimeErrors = Boolean(state.errors.length);\n        const rootLayoutMissingTagsError = state.rootLayoutMissingTagsError;\n        const isMounted = hasBuildError || hasRuntimeErrors || reactError || rootLayoutMissingTagsError;\n        return /*#__PURE__*/ React.createElement(React.Fragment, null, reactError ? /*#__PURE__*/ React.createElement(\"html\", null, /*#__PURE__*/ React.createElement(\"head\", null), /*#__PURE__*/ React.createElement(\"body\", null)) : children, isMounted ? /*#__PURE__*/ React.createElement(_shadowPortal.ShadowPortal, null, /*#__PURE__*/ React.createElement(_cssReset.CssReset, null), /*#__PURE__*/ React.createElement(_base.Base, null), /*#__PURE__*/ React.createElement(_componentStyles.ComponentStyles, null), rootLayoutMissingTagsError ? /*#__PURE__*/ React.createElement(_rootLayoutError.RootLayoutError, {\n            missingTags: rootLayoutMissingTagsError.missingTags\n        }) : hasBuildError ? /*#__PURE__*/ React.createElement(_buildError.BuildError, {\n            message: state.buildError,\n            versionInfo: state.versionInfo\n        }) : reactError ? /*#__PURE__*/ React.createElement(_errors.Errors, {\n            versionInfo: state.versionInfo,\n            initialDisplayState: \"fullscreen\",\n            errors: [\n                reactError\n            ]\n        }) : hasRuntimeErrors ? /*#__PURE__*/ React.createElement(_errors.Errors, {\n            initialDisplayState: \"minimized\",\n            errors: state.errors,\n            versionInfo: state.versionInfo\n        }) : undefined) : undefined);\n    }\n    constructor(...args){\n        super(...args);\n        this.state = {\n            reactError: null\n        };\n    }\n}\nvar _default = ReactDevOverlay;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ReactDevOverlay.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsNEJBQTRCQyxpS0FBZ0U7QUFDaEcsSUFBSUMsUUFBUUYsMEJBQTBCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDJJQUF5QjtBQUM1RCxJQUFJRyxnQkFBZ0JILG1CQUFPQSxDQUFDLCtJQUEyQjtBQUN2RCxJQUFJSSxjQUFjSixtQkFBT0EsQ0FBQyx5SUFBd0I7QUFDbEQsSUFBSUssVUFBVUwsbUJBQU9BLENBQUMsaUlBQW9CO0FBQzFDLElBQUlNLG1CQUFtQk4sbUJBQU9BLENBQUMsbUpBQTZCO0FBQzVELElBQUlPLGNBQWNQLG1CQUFPQSxDQUFDLHFJQUFzQjtBQUNoRCxJQUFJUSxRQUFRUixtQkFBT0EsQ0FBQyx1SEFBZTtBQUNuQyxJQUFJUyxtQkFBbUJULG1CQUFPQSxDQUFDLDZJQUEwQjtBQUN6RCxJQUFJVSxZQUFZVixtQkFBT0EsQ0FBQywrSEFBbUI7QUFDM0MsTUFBTVcsd0JBQXdCVixNQUFNVyxhQUFhO0lBQzdDLE9BQU9DLHlCQUF5QkMsS0FBSyxFQUFFO1FBQ25DLE1BQU1DLElBQUlEO1FBQ1YsTUFBTUUsUUFBUTtZQUNWQyxNQUFNZixxQkFBcUJnQixzQkFBc0I7WUFDakRDLFFBQVFMO1lBQ1JNLFFBQVEsQ0FBQyxHQUFHYixXQUFXLEVBQUVjLFVBQVUsQ0FBQ04sRUFBRU8sS0FBSztRQUMvQztRQUNBLE1BQU1DLGFBQWE7WUFDZkMsSUFBSTtZQUNKUjtRQUNKO1FBQ0EsT0FBTztZQUNIUyxZQUFZRjtRQUNoQjtJQUNKO0lBQ0FHLGtCQUFrQkMsWUFBWSxFQUFFO1FBQzVCLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxZQUFZLENBQUNGO0lBQzVCO0lBQ0FHLFNBQVM7UUFDTCxNQUFNLEVBQUVDLE1BQUssRUFBR0MsU0FBUSxFQUFHLEdBQUcsSUFBSSxDQUFDSixLQUFLO1FBQ3hDLE1BQU0sRUFBRUgsV0FBVSxFQUFHLEdBQUcsSUFBSSxDQUFDTSxLQUFLO1FBQ2xDLE1BQU1FLGdCQUFnQkYsTUFBTUcsVUFBVSxJQUFJLElBQUk7UUFDOUMsTUFBTUMsbUJBQW1CQyxRQUFRTCxNQUFNTSxNQUFNLENBQUNDLE1BQU07UUFDcEQsTUFBTUMsNkJBQTZCUixNQUFNUSwwQkFBMEI7UUFDbkUsTUFBTUMsWUFBWVAsaUJBQWlCRSxvQkFBb0JWLGNBQWNjO1FBQ3JFLE9BQU8sV0FBVyxHQUFHdEMsTUFBTXdDLGFBQWEsQ0FBQ3hDLE1BQU15QyxRQUFRLEVBQUUsSUFBSSxFQUFFakIsYUFBYSxXQUFXLEdBQUd4QixNQUFNd0MsYUFBYSxDQUFDLFFBQVEsSUFBSSxFQUFFLFdBQVcsR0FBR3hDLE1BQU13QyxhQUFhLENBQUMsUUFBUSxJQUFJLEdBQUcsV0FBVyxHQUFHeEMsTUFBTXdDLGFBQWEsQ0FBQyxRQUFRLElBQUksS0FBS1QsUUFBUSxFQUFFUSxZQUFZLFdBQVcsR0FBR3ZDLE1BQU13QyxhQUFhLENBQUN0QyxjQUFjd0MsWUFBWSxFQUFFLElBQUksRUFBRSxXQUFXLEdBQUcxQyxNQUFNd0MsYUFBYSxDQUFDL0IsVUFBVWtDLFFBQVEsRUFBRSxJQUFJLEdBQUcsV0FBVyxHQUFHM0MsTUFBTXdDLGFBQWEsQ0FBQ2pDLE1BQU1xQyxJQUFJLEVBQUUsSUFBSSxHQUFHLFdBQVcsR0FBRzVDLE1BQU13QyxhQUFhLENBQUNoQyxpQkFBaUJxQyxlQUFlLEVBQUUsSUFBSSxHQUFHUCw2QkFBNkIsV0FBVyxHQUFHdEMsTUFBTXdDLGFBQWEsQ0FBQ25DLGlCQUFpQnlDLGVBQWUsRUFBRTtZQUNwbEJDLGFBQWFULDJCQUEyQlMsV0FBVztRQUN2RCxLQUFLZixnQkFBZ0IsV0FBVyxHQUFHaEMsTUFBTXdDLGFBQWEsQ0FBQ3JDLFlBQVk2QyxVQUFVLEVBQUU7WUFDM0VDLFNBQVNuQixNQUFNRyxVQUFVO1lBQ3pCaUIsYUFBYXBCLE1BQU1vQixXQUFXO1FBQ2xDLEtBQUsxQixhQUFhLFdBQVcsR0FBR3hCLE1BQU13QyxhQUFhLENBQUNwQyxRQUFRK0MsTUFBTSxFQUFFO1lBQ2hFRCxhQUFhcEIsTUFBTW9CLFdBQVc7WUFDOUJFLHFCQUFxQjtZQUNyQmhCLFFBQVE7Z0JBQ0paO2FBQ0g7UUFDTCxLQUFLVSxtQkFBbUIsV0FBVyxHQUFHbEMsTUFBTXdDLGFBQWEsQ0FBQ3BDLFFBQVErQyxNQUFNLEVBQUU7WUFDdEVDLHFCQUFxQjtZQUNyQmhCLFFBQVFOLE1BQU1NLE1BQU07WUFDcEJjLGFBQWFwQixNQUFNb0IsV0FBVztRQUNsQyxLQUFLRyxTQUFTLElBQUlBLFNBQVM7SUFDL0I7SUFDQUMsWUFBWSxHQUFHQyxJQUFJLENBQUM7UUFDaEIsS0FBSyxJQUFJQTtRQUNULElBQUksQ0FBQ3pCLEtBQUssR0FBRztZQUNUTixZQUFZLElBQUk7UUFDcEI7SUFDSjtBQUNKO0FBQ0EsSUFBSWdDLFdBQVc5QztBQUNmZixrQkFBZSxHQUFHNkQ7QUFFbEIsSUFBSSxDQUFDLE9BQU83RCxRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUM0RCxVQUFVLEtBQUssYUFBYTtJQUNyS2hFLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9pRSxNQUFNLENBQUMvRCxRQUFRRSxPQUFPLEVBQUVGO0lBQy9CZ0UsT0FBT2hFLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5LmpzP2QyYzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZXJyb3JPdmVybGF5UmVkdWNlciA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXktcmVkdWNlclwiKTtcbnZhciBfc2hhZG93UG9ydGFsID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG52YXIgX2J1aWxkRXJyb3IgPSByZXF1aXJlKFwiLi9jb250YWluZXIvQnVpbGRFcnJvclwiKTtcbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0Vycm9yc1wiKTtcbnZhciBfcm9vdExheW91dEVycm9yID0gcmVxdWlyZShcIi4vY29udGFpbmVyL1Jvb3RMYXlvdXRFcnJvclwiKTtcbnZhciBfcGFyc2VTdGFjayA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvcGFyc2VTdGFja1wiKTtcbnZhciBfYmFzZSA9IHJlcXVpcmUoXCIuL3N0eWxlcy9CYXNlXCIpO1xudmFyIF9jb21wb25lbnRTdHlsZXMgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xudmFyIF9jc3NSZXNldCA9IHJlcXVpcmUoXCIuL3N0eWxlcy9Dc3NSZXNldFwiKTtcbmNsYXNzIFJlYWN0RGV2T3ZlcmxheSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZSA9IGVycm9yO1xuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9VTkhBTkRMRURfRVJST1IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLFxuICAgICAgICAgICAgZnJhbWVzOiAoMCwgX3BhcnNlU3RhY2spLnBhcnNlU3RhY2soZS5zdGFjaylcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3JFdmVudCA9IHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWN0RXJyb3I6IGVycm9yRXZlbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25SZWFjdEVycm9yKGNvbXBvbmVudEVycik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSAsIGNoaWxkcmVuICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyByZWFjdEVycm9yICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaGFzQnVpbGRFcnJvciA9IHN0YXRlLmJ1aWxkRXJyb3IgIT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzUnVudGltZUVycm9ycyA9IEJvb2xlYW4oc3RhdGUuZXJyb3JzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJvb3RMYXlvdXRNaXNzaW5nVGFnc0Vycm9yID0gc3RhdGUucm9vdExheW91dE1pc3NpbmdUYWdzRXJyb3I7XG4gICAgICAgIGNvbnN0IGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycyB8fCByZWFjdEVycm9yIHx8IHJvb3RMYXlvdXRNaXNzaW5nVGFnc0Vycm9yO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZWFjdEVycm9yID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwpLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwpKSA6IGNoaWxkcmVuLCBpc01vdW50ZWQgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX3NoYWRvd1BvcnRhbC5TaGFkb3dQb3J0YWwsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfY3NzUmVzZXQuQ3NzUmVzZXQsIG51bGwpLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2Jhc2UuQmFzZSwgbnVsbCksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfY29tcG9uZW50U3R5bGVzLkNvbXBvbmVudFN0eWxlcywgbnVsbCksIHJvb3RMYXlvdXRNaXNzaW5nVGFnc0Vycm9yID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9yb290TGF5b3V0RXJyb3IuUm9vdExheW91dEVycm9yLCB7XG4gICAgICAgICAgICBtaXNzaW5nVGFnczogcm9vdExheW91dE1pc3NpbmdUYWdzRXJyb3IubWlzc2luZ1RhZ3NcbiAgICAgICAgfSkgOiBoYXNCdWlsZEVycm9yID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9idWlsZEVycm9yLkJ1aWxkRXJyb3IsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHN0YXRlLmJ1aWxkRXJyb3IsXG4gICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm9cbiAgICAgICAgfSkgOiByZWFjdEVycm9yID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9lcnJvcnMuRXJyb3JzLCB7XG4gICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm8sXG4gICAgICAgICAgICBpbml0aWFsRGlzcGxheVN0YXRlOiBcImZ1bGxzY3JlZW5cIixcbiAgICAgICAgICAgIGVycm9yczogW1xuICAgICAgICAgICAgICAgIHJlYWN0RXJyb3JcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSkgOiBoYXNSdW50aW1lRXJyb3JzID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9lcnJvcnMuRXJyb3JzLCB7XG4gICAgICAgICAgICBpbml0aWFsRGlzcGxheVN0YXRlOiBcIm1pbmltaXplZFwiLFxuICAgICAgICAgICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICB2ZXJzaW9uSW5mbzogc3RhdGUudmVyc2lvbkluZm9cbiAgICAgICAgfSkgOiB1bmRlZmluZWQpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVhY3RFcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbnZhciBfZGVmYXVsdCA9IFJlYWN0RGV2T3ZlcmxheTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFjdERldk92ZXJsYXkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiUmVhY3QiLCJfZXJyb3JPdmVybGF5UmVkdWNlciIsIl9zaGFkb3dQb3J0YWwiLCJfYnVpbGRFcnJvciIsIl9lcnJvcnMiLCJfcm9vdExheW91dEVycm9yIiwiX3BhcnNlU3RhY2siLCJfYmFzZSIsIl9jb21wb25lbnRTdHlsZXMiLCJfY3NzUmVzZXQiLCJSZWFjdERldk92ZXJsYXkiLCJQdXJlQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJlIiwiZXZlbnQiLCJ0eXBlIiwiQUNUSU9OX1VOSEFORExFRF9FUlJPUiIsInJlYXNvbiIsImZyYW1lcyIsInBhcnNlU3RhY2siLCJzdGFjayIsImVycm9yRXZlbnQiLCJpZCIsInJlYWN0RXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsInByb3BzIiwib25SZWFjdEVycm9yIiwicmVuZGVyIiwic3RhdGUiLCJjaGlsZHJlbiIsImhhc0J1aWxkRXJyb3IiLCJidWlsZEVycm9yIiwiaGFzUnVudGltZUVycm9ycyIsIkJvb2xlYW4iLCJlcnJvcnMiLCJsZW5ndGgiLCJyb290TGF5b3V0TWlzc2luZ1RhZ3NFcnJvciIsImlzTW91bnRlZCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIlNoYWRvd1BvcnRhbCIsIkNzc1Jlc2V0IiwiQmFzZSIsIkNvbXBvbmVudFN0eWxlcyIsIlJvb3RMYXlvdXRFcnJvciIsIm1pc3NpbmdUYWdzIiwiQnVpbGRFcnJvciIsIm1lc3NhZ2UiLCJ2ZXJzaW9uSW5mbyIsIkVycm9ycyIsImluaXRpYWxEaXNwbGF5U3RhdGUiLCJ1bmRlZmluZWQiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/ReactDevOverlay.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/CodeFrame.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/CodeFrame.js ***!
  \***************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CodeFrame = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _anser = _interop_require_default(__webpack_require__(/*! next/dist/compiled/anser */ \"next/dist/compiled/anser\"));\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _stripAnsi = _interop_require_default(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"next/dist/compiled/strip-ansi\"));\nvar _stackFrame = __webpack_require__(/*! ../../helpers/stack-frame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js\");\nvar _useOpenInEditor = __webpack_require__(/*! ../../helpers/use-open-in-editor */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\");\nconst CodeFrame = function CodeFrame({ stackFrame , codeFrame  }) {\n    // Strip leading spaces out of the code frame:\n    const formattedFrame = React.useMemo(()=>{\n        const lines = codeFrame.split(/\\r?\\n/g);\n        const prefixLength = lines.map((line)=>/^>? +\\d+ +\\| [ ]+/.exec((0, _stripAnsi).default(line)) === null ? null : /^>? +\\d+ +\\| ( *)/.exec((0, _stripAnsi).default(line))).filter(Boolean).map((v)=>v.pop()).reduce((c, n)=>isNaN(c) ? n.length : Math.min(c, n.length), NaN);\n        if (prefixLength > 1) {\n            const p = \" \".repeat(prefixLength);\n            return lines.map((line, a)=>~(a = line.indexOf(\"|\")) ? line.substring(0, a) + line.substring(a).replace(p, \"\") : line).join(\"\\n\");\n        }\n        return lines.join(\"\\n\");\n    }, [\n        codeFrame\n    ]);\n    const decoded = React.useMemo(()=>{\n        return _anser.default.ansiToJson(formattedFrame, {\n            json: true,\n            use_classes: true,\n            remove_empty: true\n        });\n    }, [\n        formattedFrame\n    ]);\n    const open = (0, _useOpenInEditor).useOpenInEditor({\n        file: stackFrame.file,\n        lineNumber: stackFrame.lineNumber,\n        column: stackFrame.column\n    });\n    // TODO: make the caret absolute\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-codeframe\": true\n    }, /*#__PURE__*/ React.createElement(\"div\", null, /*#__PURE__*/ React.createElement(\"p\", {\n        role: \"link\",\n        onClick: open,\n        tabIndex: 1,\n        title: \"Click to open in your editor\"\n    }, /*#__PURE__*/ React.createElement(\"span\", null, (0, _stackFrame).getFrameSource(stackFrame), \" @ \", stackFrame.methodName), /*#__PURE__*/ React.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }, /*#__PURE__*/ React.createElement(\"path\", {\n        d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"\n    }), /*#__PURE__*/ React.createElement(\"polyline\", {\n        points: \"15 3 21 3 21 9\"\n    }), /*#__PURE__*/ React.createElement(\"line\", {\n        x1: \"10\",\n        y1: \"14\",\n        x2: \"21\",\n        y2: \"3\"\n    })))), /*#__PURE__*/ React.createElement(\"pre\", null, decoded.map((entry, index)=>/*#__PURE__*/ React.createElement(\"span\", {\n            key: `frame-${index}`,\n            style: _extends({\n                color: entry.fg ? `var(--color-${entry.fg})` : undefined\n            }, entry.decoration === \"bold\" ? {\n                fontWeight: 800\n            } : entry.decoration === \"italic\" ? {\n                fontStyle: \"italic\"\n            } : undefined)\n        }, entry.content))));\n};\nexports.CodeFrame = CodeFrame;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=CodeFrame.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL0NvZGVGcmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLFdBQVdDLCtIQUErQztBQUM5RCxJQUFJRSwyQkFBMkJGLCtKQUErRDtBQUM5RixJQUFJRyw0QkFBNEJILGlLQUFnRTtBQUNoRyxJQUFJSSxTQUFTRix5QkFBeUJGLG1CQUFPQSxDQUFDLDBEQUEwQjtBQUN4RSxJQUFJSyxRQUFRRiwwQkFBMEJILG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlNLGFBQWFKLHlCQUF5QkYsbUJBQU9BLENBQUMsb0VBQStCO0FBQ2pGLElBQUlPLGNBQWNQLG1CQUFPQSxDQUFDLDJJQUEyQjtBQUNyRCxJQUFJUSxtQkFBbUJSLG1CQUFPQSxDQUFDLHlKQUFrQztBQUNqRSxNQUFNRixZQUFZLFNBQVNBLFVBQVUsRUFBRVcsV0FBVSxFQUFHQyxVQUFTLEVBQUssRUFBRTtJQUNoRSw4Q0FBOEM7SUFDOUMsTUFBTUMsaUJBQWlCTixNQUFNTyxPQUFPLENBQUMsSUFBSTtRQUNyQyxNQUFNQyxRQUFRSCxVQUFVSSxLQUFLLENBQUM7UUFDOUIsTUFBTUMsZUFBZUYsTUFBTUcsR0FBRyxDQUFDLENBQUNDLE9BQU8sb0JBQW9CQyxJQUFJLENBQUMsQ0FBQyxHQUFHWixVQUFVLEVBQUVMLE9BQU8sQ0FBQ2dCLFdBQVcsSUFBSSxHQUFHLElBQUksR0FBRyxvQkFBb0JDLElBQUksQ0FBQyxDQUFDLEdBQUdaLFVBQVUsRUFBRUwsT0FBTyxDQUFDZ0IsTUFBTSxFQUFFRSxNQUFNLENBQUNDLFNBQVNKLEdBQUcsQ0FBQyxDQUFDSyxJQUFJQSxFQUFFQyxHQUFHLElB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SSxDQUFDLE9BQU9GLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQzhFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3NGLE1BQU0sQ0FBQ3BGLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JxRixPQUFPckYsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9Db2RlRnJhbWUuanM/ZjYyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29kZUZyYW1lID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9hbnNlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Fuc2VyXCIpKTtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfc3RyaXBBbnNpID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKSk7XG52YXIgX3N0YWNrRnJhbWUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9zdGFjay1mcmFtZVwiKTtcbnZhciBfdXNlT3BlbkluRWRpdG9yID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvdXNlLW9wZW4taW4tZWRpdG9yXCIpO1xuY29uc3QgQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKHsgc3RhY2tGcmFtZSAsIGNvZGVGcmFtZSAsICB9KSB7XG4gICAgLy8gU3RyaXAgbGVhZGluZyBzcGFjZXMgb3V0IG9mIHRoZSBjb2RlIGZyYW1lOlxuICAgIGNvbnN0IGZvcm1hdHRlZEZyYW1lID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNvZGVGcmFtZS5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICAgICAgY29uc3QgcHJlZml4TGVuZ3RoID0gbGluZXMubWFwKChsaW5lKT0+L14+PyArXFxkKyArXFx8IFsgXSsvLmV4ZWMoKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQobGluZSkpID09PSBudWxsID8gbnVsbCA6IC9ePj8gK1xcZCsgK1xcfCAoICopLy5leGVjKCgwLCBfc3RyaXBBbnNpKS5kZWZhdWx0KGxpbmUpKSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgodik9PnYucG9wKCkpLnJlZHVjZSgoYywgbik9PmlzTmFOKGMpID8gbi5sZW5ndGggOiBNYXRoLm1pbihjLCBuLmxlbmd0aCksIE5hTik7XG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzLm1hcCgobGluZSwgYSk9Pn4oYSA9IGxpbmUuaW5kZXhPZignfCcpKSA/IGxpbmUuc3Vic3RyaW5nKDAsIGEpICsgbGluZS5zdWJzdHJpbmcoYSkucmVwbGFjZShwLCAnJykgOiBsaW5lKS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfSwgW1xuICAgICAgICBjb2RlRnJhbWVcbiAgICBdKTtcbiAgICBjb25zdCBkZWNvZGVkID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gX2Fuc2VyLmRlZmF1bHQuYW5zaVRvSnNvbihmb3JtYXR0ZWRGcmFtZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZm9ybWF0dGVkRnJhbWVcbiAgICBdKTtcbiAgICBjb25zdCBvcGVuID0gKDAsIF91c2VPcGVuSW5FZGl0b3IpLnVzZU9wZW5JbkVkaXRvcih7XG4gICAgICAgIGZpbGU6IHN0YWNrRnJhbWUuZmlsZSxcbiAgICAgICAgbGluZU51bWJlcjogc3RhY2tGcmFtZS5saW5lTnVtYmVyLFxuICAgICAgICBjb2x1bW46IHN0YWNrRnJhbWUuY29sdW1uXG4gICAgfSk7XG4gICAgLy8gVE9ETzogbWFrZSB0aGUgY2FyZXQgYWJzb2x1dGVcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLW5leHRqcy1jb2RlZnJhbWVcIjogdHJ1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgcm9sZTogXCJsaW5rXCIsXG4gICAgICAgIG9uQ2xpY2s6IG9wZW4sXG4gICAgICAgIHRhYkluZGV4OiAxLFxuICAgICAgICB0aXRsZTogXCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsICgwLCBfc3RhY2tGcmFtZSkuZ2V0RnJhbWVTb3VyY2Uoc3RhY2tGcmFtZSksIFwiIEAgXCIsIHN0YWNrRnJhbWUubWV0aG9kTmFtZSksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIlxuICAgIH0pLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7XG4gICAgICAgIHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgICAgICB4MTogXCIxMFwiLFxuICAgICAgICB5MTogXCIxNFwiLFxuICAgICAgICB4MjogXCIyMVwiLFxuICAgICAgICB5MjogXCIzXCJcbiAgICB9KSkpKSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIG51bGwsIGRlY29kZWQubWFwKChlbnRyeSwgaW5kZXgpPT4vKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGtleTogYGZyYW1lLSR7aW5kZXh9YCxcbiAgICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgY29sb3I6IGVudHJ5LmZnID8gYHZhcigtLWNvbG9yLSR7ZW50cnkuZmd9KWAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sIGVudHJ5LmRlY29yYXRpb24gPT09ICdib2xkJyA/IHtcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA4MDBcbiAgICAgICAgICAgIH0gOiBlbnRyeS5kZWNvcmF0aW9uID09PSAnaXRhbGljJyA/IHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6ICdpdGFsaWMnXG4gICAgICAgICAgICB9IDogdW5kZWZpbmVkKVxuICAgICAgICB9LCBlbnRyeS5jb250ZW50KSkpKTtcbn07XG5leHBvcnRzLkNvZGVGcmFtZSA9IENvZGVGcmFtZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29kZUZyYW1lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNvZGVGcmFtZSIsIl9leHRlbmRzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2Fuc2VyIiwiUmVhY3QiLCJfc3RyaXBBbnNpIiwiX3N0YWNrRnJhbWUiLCJfdXNlT3BlbkluRWRpdG9yIiwic3RhY2tGcmFtZSIsImNvZGVGcmFtZSIsImZvcm1hdHRlZEZyYW1lIiwidXNlTWVtbyIsImxpbmVzIiwic3BsaXQiLCJwcmVmaXhMZW5ndGgiLCJtYXAiLCJsaW5lIiwiZXhlYyIsImZpbHRlciIsIkJvb2xlYW4iLCJ2IiwicG9wIiwicmVkdWNlIiwiYyIsIm4iLCJpc05hTiIsImxlbmd0aCIsIk1hdGgiLCJtaW4iLCJOYU4iLCJwIiwicmVwZWF0IiwiYSIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwiam9pbiIsImRlY29kZWQiLCJhbnNpVG9Kc29uIiwianNvbiIsInVzZV9jbGFzc2VzIiwicmVtb3ZlX2VtcHR5Iiwib3BlbiIsInVzZU9wZW5JbkVkaXRvciIsImZpbGUiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiY3JlYXRlRWxlbWVudCIsInJvbGUiLCJvbkNsaWNrIiwidGFiSW5kZXgiLCJ0aXRsZSIsImdldEZyYW1lU291cmNlIiwibWV0aG9kTmFtZSIsInhtbG5zIiwidmlld0JveCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsImQiLCJwb2ludHMiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImVudHJ5IiwiaW5kZXgiLCJrZXkiLCJzdHlsZSIsImNvbG9yIiwiZmciLCJ1bmRlZmluZWQiLCJkZWNvcmF0aW9uIiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsImNvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/CodeFrame.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/index.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/index.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"CodeFrame\", ({\n    enumerable: true,\n    get: function() {\n        return _codeFrame.CodeFrame;\n    }\n}));\nvar _codeFrame = __webpack_require__(/*! ./CodeFrame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/CodeFrame.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxXQUFXQyxTQUFTO0lBQy9CO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBSUQsYUFBYUUsbUJBQU9BLENBQUMsd0lBQWE7QUFFdEMsSUFBSSxDQUFDLE9BQU9OLFFBQVFPLE9BQU8sS0FBSyxjQUFlLE9BQU9QLFFBQVFPLE9BQU8sS0FBSyxZQUFZUCxRQUFRTyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLFFBQVFPLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU8sT0FBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsUUFBUU8sT0FBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxRQUFRTyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9pbmRleC5qcz83MGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUZyYW1lXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29kZUZyYW1lLkNvZGVGcmFtZTtcbiAgICB9XG59KTtcbnZhciBfY29kZUZyYW1lID0gcmVxdWlyZShcIi4vQ29kZUZyYW1lXCIpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2NvZGVGcmFtZSIsIkNvZGVGcmFtZSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/styles.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/styles.js ***!
  \************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-codeframe] {\n    overflow: auto;\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > div {\n    display: inline-block;\n    width: auto;\n    min-width: 100%;\n    border-bottom: 1px solid var(--color-ansi-bright-black);\n  }\n  [data-nextjs-codeframe] > div > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n    margin: 0;\n  }\n  [data-nextjs-codeframe] > div > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] div > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 8px;\n  }\n  [data-nextjs-codeframe] div > pre {\n    overflow: hidden;\n    display: inline-block;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL3N0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLCtJQUE2QjtBQUN6RCxNQUFNRixTQUFTQyxjQUFjRSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NsQyxDQUFDO0FBQ0RMLGNBQWMsR0FBR0U7QUFFakIsSUFBSSxDQUFDLE9BQU9GLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktULE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9VLE1BQU0sQ0FBQ1IsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQlMsT0FBT1QsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9zdHlsZXMuanM/ZGJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSB7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1iZyk7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdOjpzZWxlY3Rpb24sXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gZGl2IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtYXJnaW46IDA7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwOmhvdmVyIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcCA+IHN2ZyB7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgaGVpZ2h0OiAxZW07XG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgfVxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSBkaXYgPiBwcmUge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB9XG5gO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHlsZXMiLCJfbm9vcFRlbXBsYXRlIiwicmVxdWlyZSIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/Dialog.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/Dialog.js ***!
  \*********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Dialog = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _useOnClickOutside = __webpack_require__(/*! ../../hooks/use-on-click-outside */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/hooks/use-on-click-outside.js\");\nconst Dialog = function Dialog(_param) {\n    var { children , type , onClose  } = _param, props = _object_without_properties_loose(_param, [\n        \"children\",\n        \"type\",\n        \"onClose\"\n    ]);\n    const [dialog, setDialog] = React.useState(null);\n    const onDialog = React.useCallback((node)=>{\n        setDialog(node);\n    }, []);\n    (0, _useOnClickOutside).useOnClickOutside(dialog, onClose);\n    // Make HTMLElements with `role=link` accessible to be triggered by the\n    // keyboard, i.e. [Enter].\n    React.useEffect(()=>{\n        if (dialog == null) {\n            return;\n        }\n        const root = dialog.getRootNode();\n        // Always true, but we do this for TypeScript:\n        if (!(root instanceof ShadowRoot)) {\n            return;\n        }\n        const shadowRoot = root;\n        function handler(e) {\n            const el = shadowRoot.activeElement;\n            if (e.key === \"Enter\" && el instanceof HTMLElement && el.getAttribute(\"role\") === \"link\") {\n                e.preventDefault();\n                e.stopPropagation();\n                el.click();\n            }\n        }\n        shadowRoot.addEventListener(\"keydown\", handler);\n        return ()=>shadowRoot.removeEventListener(\"keydown\", handler);\n    }, [\n        dialog\n    ]);\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        ref: onDialog,\n        \"data-nextjs-dialog\": true,\n        tabIndex: -1,\n        role: \"dialog\",\n        \"aria-labelledby\": props[\"aria-labelledby\"],\n        \"aria-describedby\": props[\"aria-describedby\"],\n        \"aria-modal\": \"true\"\n    }, /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-banner\": true,\n        className: `banner-${type}`\n    }), children);\n};\nexports.Dialog = Dialog;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Dialog.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxtQ0FBbUNGLCtLQUF1RTtBQUM5RyxJQUFJRyxRQUFRSiwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlJLHFCQUFxQkosbUJBQU9BLENBQUMseUpBQWtDO0FBQ25FLE1BQU1GLFNBQVMsU0FBU0EsT0FBT08sTUFBTSxFQUFFO0lBQ25DLElBQUksRUFBRUMsU0FBUSxFQUFHQyxLQUFJLEVBQUdDLFFBQU8sRUFBRyxHQUFHSCxRQUFRSSxRQUFRUCxpQ0FBaUNHLFFBQVE7UUFDMUY7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNLENBQUNLLFFBQVFDLFVBQVUsR0FBR1IsTUFBTVMsUUFBUSxDQUFDLElBQUk7SUFDL0MsTUFBTUMsV0FBV1YsTUFBTVcsV0FBVyxDQUFDLENBQUNDLE9BQU87UUFDdkNKLFVBQVVJO0lBQ2QsR0FBRyxFQUFFO0lBQ0osSUFBR1gsa0JBQWtCLEVBQUVZLGlCQUFpQixDQUFDTixRQUFRRjtJQUNsRCx1RUFBdUU7SUFDdkUsMEJBQTBCO0lBQzFCTCxNQUFNYyxTQUFTLENBQUMsSUFBSTtRQUNoQixJQUFJUCxVQUFVLElBQUksRUFBRTtZQUNoQjtRQUNKLENBQUM7UUFDRCxNQUFNUSxPQUFPUixPQUFPUyxXQUFXO1FBQy9CLDhDQUE4QztRQUM5QyxJQUFJLENBQUVELENBQUFBLGdCQUFnQkUsVUFBUyxHQUFJO1lBQy9CO1FBQ0osQ0FBQztRQUNELE1BQU1DLGFBQWFIO1FBQ25CLFNBQVNJLFFBQVFDLENBQUMsRUFBRTtZQUNoQixNQUFNQyxLQUFLSCxXQUFXSSxhQUFhO1lBQ25DLElBQUlGLEVBQUVHLEdBQUcsS0FBSyxXQUFXRixjQUFjRyxlQUFlSCxHQUFHSSxZQUFZLENBQUMsWUFBWSxRQUFRO2dCQUN0RkwsRUFBRU0sY0FBYztnQkFDaEJOLEVBQUVPLGVBQWU7Z0JBQ2pCTixHQUFHTyxLQUFLO1lBQ1osQ0FBQztRQUNMO1FBQ0FWLFdBQVdXLGdCQUFnQixDQUFDLFdBQVdWO1FBQ3ZDLE9BQU8sSUFBSUQsV0FBV1ksbUJBQW1CLENBQUMsV0FBV1g7SUFDekQsR0FBRztRQUNDWjtLQUNIO0lBQ0QsT0FBTyxXQUFXLEdBQUdQLE1BQU0rQixhQUFhLENBQUMsT0FBTztRQUM1Q0MsS0FBS3RCO1FBQ0wsc0JBQXNCLElBQUk7UUFDMUJ1QixVQUFVLENBQUM7UUFDWEMsTUFBTTtRQUNOLG1CQUFtQjVCLEtBQUssQ0FBQyxrQkFBa0I7UUFDM0Msb0JBQW9CQSxLQUFLLENBQUMsbUJBQW1CO1FBQzdDLGNBQWM7SUFDbEIsR0FBRyxXQUFXLEdBQUdOLE1BQU0rQixhQUFhLENBQUMsT0FBTztRQUN4Qyw2QkFBNkIsSUFBSTtRQUNqQ0ksV0FBVyxDQUFDLE9BQU8sRUFBRS9CLEtBQUssQ0FBQztJQUMvQixJQUFJRDtBQUNSO0FBQ0FWLGNBQWMsR0FBR0U7QUFFakIsSUFBSSxDQUFDLE9BQU9GLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ3NDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLN0MsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzhDLE1BQU0sQ0FBQzVDLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0I2QyxPQUFPN0MsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2cuanM/ZmQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlhbG9nID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF91c2VPbkNsaWNrT3V0c2lkZSA9IHJlcXVpcmUoXCIuLi8uLi9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZVwiKTtcbmNvbnN0IERpYWxvZyA9IGZ1bmN0aW9uIERpYWxvZyhfcGFyYW0pIHtcbiAgICB2YXIgeyBjaGlsZHJlbiAsIHR5cGUgLCBvbkNsb3NlICB9ID0gX3BhcmFtLCBwcm9wcyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9wYXJhbSwgW1xuICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgIFwidHlwZVwiLFxuICAgICAgICBcIm9uQ2xvc2VcIlxuICAgIF0pO1xuICAgIGNvbnN0IFtkaWFsb2csIHNldERpYWxvZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBvbkRpYWxvZyA9IFJlYWN0LnVzZUNhbGxiYWNrKChub2RlKT0+e1xuICAgICAgICBzZXREaWFsb2cobm9kZSk7XG4gICAgfSwgW10pO1xuICAgICgwLCBfdXNlT25DbGlja091dHNpZGUpLnVzZU9uQ2xpY2tPdXRzaWRlKGRpYWxvZywgb25DbG9zZSk7XG4gICAgLy8gTWFrZSBIVE1MRWxlbWVudHMgd2l0aCBgcm9sZT1saW5rYCBhY2Nlc3NpYmxlIHRvIGJlIHRyaWdnZXJlZCBieSB0aGVcbiAgICAvLyBrZXlib2FyZCwgaS5lLiBbRW50ZXJdLlxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoZGlhbG9nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290ID0gZGlhbG9nLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIC8vIEFsd2F5cyB0cnVlLCBidXQgd2UgZG8gdGhpcyBmb3IgVHlwZVNjcmlwdDpcbiAgICAgICAgaWYgKCEocm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IHJvb3Q7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgY29uc3QgZWwgPSBzaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZWwuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGFkb3dSb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpPT5zaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICB9LCBbXG4gICAgICAgIGRpYWxvZ1xuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IG9uRGlhbG9nLFxuICAgICAgICBcImRhdGEtbmV4dGpzLWRpYWxvZ1wiOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgIHJvbGU6IFwiZGlhbG9nXCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzWydhcmlhLWxhYmVsbGVkYnknXSxcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IHByb3BzWydhcmlhLWRlc2NyaWJlZGJ5J10sXG4gICAgICAgIFwiYXJpYS1tb2RhbFwiOiBcInRydWVcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOiB0cnVlLFxuICAgICAgICBjbGFzc05hbWU6IGBiYW5uZXItJHt0eXBlfWBcbiAgICB9KSwgY2hpbGRyZW4pO1xufTtcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaWFsb2cuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRGlhbG9nIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJSZWFjdCIsIl91c2VPbkNsaWNrT3V0c2lkZSIsIl9wYXJhbSIsImNoaWxkcmVuIiwidHlwZSIsIm9uQ2xvc2UiLCJwcm9wcyIsImRpYWxvZyIsInNldERpYWxvZyIsInVzZVN0YXRlIiwib25EaWFsb2ciLCJ1c2VDYWxsYmFjayIsIm5vZGUiLCJ1c2VPbkNsaWNrT3V0c2lkZSIsInVzZUVmZmVjdCIsInJvb3QiLCJnZXRSb290Tm9kZSIsIlNoYWRvd1Jvb3QiLCJzaGFkb3dSb290IiwiaGFuZGxlciIsImUiLCJlbCIsImFjdGl2ZUVsZW1lbnQiLCJrZXkiLCJIVE1MRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2xpY2siLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJ0YWJJbmRleCIsInJvbGUiLCJjbGFzc05hbWUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/Dialog.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogBody.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogBody.js ***!
  \*************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DialogBody = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nconst DialogBody = function DialogBody({ children , className  }) {\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-body\": true,\n        className: className\n    }, children);\n};\nexports.DialogBody = DialogBody;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=DialogBody.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0JvZHkuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixJQUFJRyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELE1BQU1GLGFBQWEsU0FBU0EsV0FBVyxFQUFFSyxTQUFRLEVBQUdDLFVBQVMsRUFBSyxFQUFFO0lBQ2hFLE9BQU8sV0FBVyxHQUFHRixNQUFNRyxhQUFhLENBQUMsT0FBTztRQUM1QywyQkFBMkIsSUFBSTtRQUMvQkQsV0FBV0E7SUFDZixHQUFHRDtBQUNQO0FBQ0FQLGtCQUFrQixHQUFHRTtBQUVyQixJQUFJLENBQUMsT0FBT0YsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDSyxVQUFVLEtBQUssYUFBYTtJQUNyS1osT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2EsTUFBTSxDQUFDWCxRQUFRSyxPQUFPLEVBQUVMO0lBQy9CWSxPQUFPWixPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0JvZHkuanM/YTEwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlhbG9nQm9keSA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgRGlhbG9nQm9keSA9IGZ1bmN0aW9uIERpYWxvZ0JvZHkoeyBjaGlsZHJlbiAsIGNsYXNzTmFtZSAsICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtZGlhbG9nLWJvZHlcIjogdHJ1ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9LCBjaGlsZHJlbik7XG59O1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlhbG9nQm9keS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEaWFsb2dCb2R5IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogBody.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogContent.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogContent.js ***!
  \****************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DialogContent = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nconst DialogContent = function DialogContent({ children , className  }) {\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-content\": true,\n        className: className\n    }, children);\n};\nexports.DialogContent = DialogContent;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=DialogContent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0NvbnRlbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixJQUFJRyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELE1BQU1GLGdCQUFnQixTQUFTQSxjQUFjLEVBQUVLLFNBQVEsRUFBR0MsVUFBUyxFQUFLLEVBQUU7SUFDdEUsT0FBTyxXQUFXLEdBQUdGLE1BQU1HLGFBQWEsQ0FBQyxPQUFPO1FBQzVDLDhCQUE4QixJQUFJO1FBQ2xDRCxXQUFXQTtJQUNmLEdBQUdEO0FBQ1A7QUFDQVAscUJBQXFCLEdBQUdFO0FBRXhCLElBQUksQ0FBQyxPQUFPRixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNLLFVBQVUsS0FBSyxhQUFhO0lBQ3JLWixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYSxNQUFNLENBQUNYLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JZLE9BQU9aLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nQ29udGVudC5qcz85NTM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgUmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBEaWFsb2dDb250ZW50ID0gZnVuY3Rpb24gRGlhbG9nQ29udGVudCh7IGNoaWxkcmVuICwgY2xhc3NOYW1lICwgIH0pIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudFwiOiB0cnVlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0sIGNoaWxkcmVuKTtcbn07XG5leHBvcnRzLkRpYWxvZ0NvbnRlbnQgPSBEaWFsb2dDb250ZW50O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaWFsb2dDb250ZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRpYWxvZ0NvbnRlbnQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsImRlZmF1bHQiLCJSZWFjdCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogContent.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogHeader.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogHeader.js ***!
  \***************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DialogHeader = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nconst DialogHeader = function DialogHeader({ children , className  }) {\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-header\": true,\n        className: className\n    }, children);\n};\nexports.DialogHeader = DialogHeader;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=DialogHeader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0hlYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLElBQUlHLDRCQUE0QkMsaUtBQWdFO0FBQ2hHLElBQUlFLFFBQVFILDBCQUEwQkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsTUFBTUYsZUFBZSxTQUFTQSxhQUFhLEVBQUVLLFNBQVEsRUFBR0MsVUFBUyxFQUFLLEVBQUU7SUFDcEUsT0FBTyxXQUFXLEdBQUdGLE1BQU1HLGFBQWEsQ0FBQyxPQUFPO1FBQzVDLDZCQUE2QixJQUFJO1FBQ2pDRCxXQUFXQTtJQUNmLEdBQUdEO0FBQ1A7QUFDQVAsb0JBQW9CLEdBQUdFO0FBRXZCLElBQUksQ0FBQyxPQUFPRixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNLLFVBQVUsS0FBSyxhQUFhO0lBQ3JLWixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYSxNQUFNLENBQUNYLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JZLE9BQU9aLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nSGVhZGVyLmpzP2ZiZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRpYWxvZ0hlYWRlciA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgRGlhbG9nSGVhZGVyID0gZnVuY3Rpb24gRGlhbG9nSGVhZGVyKHsgY2hpbGRyZW4gLCBjbGFzc05hbWUgLCAgfSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJcIjogdHJ1ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9LCBjaGlsZHJlbik7XG59O1xuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXI7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpYWxvZ0hlYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEaWFsb2dIZWFkZXIiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsImRlZmF1bHQiLCJSZWFjdCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogHeader.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Dialog\", ({\n    enumerable: true,\n    get: function() {\n        return _dialog.Dialog;\n    }\n}));\nObject.defineProperty(exports, \"DialogBody\", ({\n    enumerable: true,\n    get: function() {\n        return _dialogBody.DialogBody;\n    }\n}));\nObject.defineProperty(exports, \"DialogContent\", ({\n    enumerable: true,\n    get: function() {\n        return _dialogContent.DialogContent;\n    }\n}));\nObject.defineProperty(exports, \"DialogHeader\", ({\n    enumerable: true,\n    get: function() {\n        return _dialogHeader.DialogHeader;\n    }\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return _styles.styles;\n    }\n}));\nvar _dialog = __webpack_require__(/*! ./Dialog */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/Dialog.js\");\nvar _dialogBody = __webpack_require__(/*! ./DialogBody */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogBody.js\");\nvar _dialogContent = __webpack_require__(/*! ./DialogContent */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogContent.js\");\nvar _dialogHeader = __webpack_require__(/*! ./DialogHeader */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/DialogHeader.js\");\nvar _styles = __webpack_require__(/*! ./styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/styles.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxRQUFRQyxNQUFNO0lBQ3pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZQLDhDQUE2QztJQUN6Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPRyxZQUFZQyxVQUFVO0lBQ2pDO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZULGlEQUFnRDtJQUM1Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPSyxlQUFlQyxhQUFhO0lBQ3ZDO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZYLGdEQUErQztJQUMzQ0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPTyxjQUFjQyxZQUFZO0lBQ3JDO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZiLDBDQUF5QztJQUNyQ0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPUyxRQUFRQyxNQUFNO0lBQ3pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBSVQsVUFBVVUsbUJBQU9BLENBQUMsK0hBQVU7QUFDaEMsSUFBSVIsY0FBY1EsbUJBQU9BLENBQUMsdUlBQWM7QUFDeEMsSUFBSU4saUJBQWlCTSxtQkFBT0EsQ0FBQyw2SUFBaUI7QUFDOUMsSUFBSUosZ0JBQWdCSSxtQkFBT0EsQ0FBQywySUFBZ0I7QUFDNUMsSUFBSUYsVUFBVUUsbUJBQU9BLENBQUMsK0hBQVU7QUFFaEMsSUFBSSxDQUFDLE9BQU9kLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQmtCLE9BQU9sQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL2luZGV4LmpzPzIzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFsb2dcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kaWFsb2cuRGlhbG9nO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhbG9nQm9keVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RpYWxvZ0JvZHkuRGlhbG9nQm9keTtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpYWxvZ0NvbnRlbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kaWFsb2dDb250ZW50LkRpYWxvZ0NvbnRlbnQ7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFsb2dIZWFkZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kaWFsb2dIZWFkZXIuRGlhbG9nSGVhZGVyO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3R5bGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3R5bGVzLnN0eWxlcztcbiAgICB9XG59KTtcbnZhciBfZGlhbG9nID0gcmVxdWlyZShcIi4vRGlhbG9nXCIpO1xudmFyIF9kaWFsb2dCb2R5ID0gcmVxdWlyZShcIi4vRGlhbG9nQm9keVwiKTtcbnZhciBfZGlhbG9nQ29udGVudCA9IHJlcXVpcmUoXCIuL0RpYWxvZ0NvbnRlbnRcIik7XG52YXIgX2RpYWxvZ0hlYWRlciA9IHJlcXVpcmUoXCIuL0RpYWxvZ0hlYWRlclwiKTtcbnZhciBfc3R5bGVzID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RpYWxvZyIsIkRpYWxvZyIsIl9kaWFsb2dCb2R5IiwiRGlhbG9nQm9keSIsIl9kaWFsb2dDb250ZW50IiwiRGlhbG9nQ29udGVudCIsIl9kaWFsb2dIZWFkZXIiLCJEaWFsb2dIZWFkZXIiLCJfc3R5bGVzIiwic3R5bGVzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/styles.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/styles.js ***!
  \*********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 56px);\n    overflow-y: hidden;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      max-height: calc(100% - 15px);\n    }\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL3N0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLCtJQUE2QjtBQUN6RCxNQUFNRixTQUFTQyxjQUFjRSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0ZsQyxDQUFDO0FBQ0RMLGNBQWMsR0FBR0U7QUFFakIsSUFBSSxDQUFDLE9BQU9GLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktULE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9VLE1BQU0sQ0FBQ1IsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQlMsT0FBT1QsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9zdHlsZXMuanM/NjhiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwKTtcbiAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWRvdWJsZSlcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gNTZweCk7XG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICB9XG5cbiAgQG1lZGlhIChtYXgtaGVpZ2h0OiA4MTJweCkge1xuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xuICAgICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gMTVweCk7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChtaW4td2lkdGg6IDU3NnB4KSB7XG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xuICAgICAgbWF4LXdpZHRoOiA1NDBweDtcbiAgICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXApIHZhcigtLXNpemUtZ2FwLXF1YWQpIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xuICAgICAgbWF4LXdpZHRoOiA3MjBweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XG4gICAgICBtYXgtd2lkdGg6IDk2MHB4O1xuICAgIH1cbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl06OmFmdGVyIHtcbiAgICB6LWluZGV4OiAyO1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLyogYmFubmVyIHdpZHRoOiAqL1xuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XG4gICAgYm9yZGVyLXRvcC1jb2xvcjogaW5oZXJpdDtcbiAgICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0ge1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxuICAgICAgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlcl0ge1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctYm9keV0ge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmbGV4OiAxIDEgYXV0bztcbiAgfVxuYDtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3R5bGVzIiwiX25vb3BUZW1wbGF0ZSIsInJlcXVpcmUiLCJub29wIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LeftRightDialogHeader = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _closeIcon = __webpack_require__(/*! ../../icons/CloseIcon */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/icons/CloseIcon.js\");\nconst LeftRightDialogHeader = function LeftRightDialogHeader({ children , className , previous , next , close  }) {\n    const buttonLeft = React.useRef(null);\n    const buttonRight = React.useRef(null);\n    const buttonClose = React.useRef(null);\n    const [nav, setNav] = React.useState(null);\n    const onNav = React.useCallback((el)=>{\n        setNav(el);\n    }, []);\n    React.useEffect(()=>{\n        if (nav == null) {\n            return;\n        }\n        const root = nav.getRootNode();\n        const d = self.document;\n        function handler(e) {\n            if (e.key === \"ArrowLeft\") {\n                e.stopPropagation();\n                if (buttonLeft.current) {\n                    buttonLeft.current.focus();\n                }\n                previous && previous();\n            } else if (e.key === \"ArrowRight\") {\n                e.stopPropagation();\n                if (buttonRight.current) {\n                    buttonRight.current.focus();\n                }\n                next && next();\n            } else if (e.key === \"Escape\") {\n                e.stopPropagation();\n                if (root instanceof ShadowRoot) {\n                    const a = root.activeElement;\n                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {\n                        a.blur();\n                        return;\n                    }\n                }\n                if (close) {\n                    close();\n                }\n            }\n        }\n        root.addEventListener(\"keydown\", handler);\n        if (root !== d) {\n            d.addEventListener(\"keydown\", handler);\n        }\n        return function() {\n            root.removeEventListener(\"keydown\", handler);\n            if (root !== d) {\n                d.removeEventListener(\"keydown\", handler);\n            }\n        };\n    }, [\n        close,\n        nav,\n        next,\n        previous\n    ]);\n    // Unlock focus for browsers like Firefox, that break all user focus if the\n    // currently focused item becomes disabled.\n    React.useEffect(()=>{\n        if (nav == null) {\n            return;\n        }\n        const root = nav.getRootNode();\n        // Always true, but we do this for TypeScript:\n        if (root instanceof ShadowRoot) {\n            const a = root.activeElement;\n            if (previous == null) {\n                if (buttonLeft.current && a === buttonLeft.current) {\n                    buttonLeft.current.blur();\n                }\n            } else if (next == null) {\n                if (buttonRight.current && a === buttonRight.current) {\n                    buttonRight.current.blur();\n                }\n            }\n        }\n    }, [\n        nav,\n        next,\n        previous\n    ]);\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-left-right\": true,\n        className: className\n    }, /*#__PURE__*/ React.createElement(\"nav\", {\n        ref: onNav\n    }, /*#__PURE__*/ React.createElement(\"button\", {\n        ref: buttonLeft,\n        type: \"button\",\n        disabled: previous == null ? true : undefined,\n        \"aria-disabled\": previous == null ? true : undefined,\n        onClick: previous != null ? previous : undefined\n    }, /*#__PURE__*/ React.createElement(\"svg\", {\n        viewBox: \"0 0 14 14\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /*#__PURE__*/ React.createElement(\"path\", {\n        d: \"M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }))), /*#__PURE__*/ React.createElement(\"button\", {\n        ref: buttonRight,\n        type: \"button\",\n        disabled: next == null ? true : undefined,\n        \"aria-disabled\": next == null ? true : undefined,\n        onClick: next != null ? next : undefined\n    }, /*#__PURE__*/ React.createElement(\"svg\", {\n        viewBox: \"0 0 14 14\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /*#__PURE__*/ React.createElement(\"path\", {\n        d: \"M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }))), \"\\xa0\", children), close ? /*#__PURE__*/ React.createElement(\"button\", {\n        \"data-nextjs-errors-dialog-left-right-close-button\": true,\n        ref: buttonClose,\n        type: \"button\",\n        onClick: close,\n        \"aria-label\": \"Close\"\n    }, /*#__PURE__*/ React.createElement(\"span\", {\n        \"aria-hidden\": \"true\"\n    }, /*#__PURE__*/ React.createElement(_closeIcon.CloseIcon, null))) : null);\n};\nexports.LeftRightDialogHeader = LeftRightDialogHeader;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=LeftRightDialogHeader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL0xlZnRSaWdodERpYWxvZ0hlYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JDLElBQUlHLDRCQUE0QkMsaUtBQWdFO0FBQ2hHLElBQUlFLFFBQVFILDBCQUEwQkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUMsbUlBQXVCO0FBQ2hELE1BQU1GLHdCQUF3QixTQUFTQSxzQkFBc0IsRUFBRU0sU0FBUSxFQUFHQyxVQUFTLEVBQUdDLFNBQVEsRUFBR0MsS0FBSSxFQUFHQyxNQUFLLEVBQUssRUFBRTtJQUNoSCxNQUFNQyxhQUFhUCxNQUFNUSxNQUFNLENBQUMsSUFBSTtJQUNwQyxNQUFNQyxjQUFjVCxNQUFNUSxNQUFNLENBQUMsSUFBSTtJQUNyQyxNQUFNRSxjQUFjVixNQUFNUSxNQUFNLENBQUMsSUFBSTtJQUNyQyxNQUFNLENBQUNHLEtBQUtDLE9BQU8sR0FBR1osTUFBTWEsUUFBUSxDQUFDLElBQUk7SUFDekMsTUFBTUMsUUFBUWQsTUFBTWUsV0FBVyxDQUFDLENBQUNDLEtBQUs7UUFDbENKLE9BQU9JO0lBQ1gsR0FBRyxFQUFFO0lBQ0xoQixNQUFNaUIsU0FBUyxDQUFDLElBQUk7UUFDaEIsSUFBSU4sT0FBTyxJQUFJLEVBQUU7WUFDYjtRQUNKLENBQUM7UUFDRCxNQUFNTyxPQUFPUCxJQUFJUSxXQUFXO1FBQzVCLE1BQU1DLElBQUlDLEtBQUtDLFFBQVE7UUFDdkIsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFO1lBQ2hCLElBQUlBLEVBQUVDLEdBQUcsS0FBSyxhQUFhO2dCQUN2QkQsRUFB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SUFDL0IwRCxPQUFPMUQsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9MZWZ0UmlnaHREaWFsb2dIZWFkZXIuanM/YjMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgUmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2Nsb3NlSWNvbiA9IHJlcXVpcmUoXCIuLi8uLi9pY29ucy9DbG9zZUljb25cIik7XG5jb25zdCBMZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBMZWZ0UmlnaHREaWFsb2dIZWFkZXIoeyBjaGlsZHJlbiAsIGNsYXNzTmFtZSAsIHByZXZpb3VzICwgbmV4dCAsIGNsb3NlICwgIH0pIHtcbiAgICBjb25zdCBidXR0b25MZWZ0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGJ1dHRvblJpZ2h0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGJ1dHRvbkNsb3NlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFtuYXYsIHNldE5hdl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBvbk5hdiA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgc2V0TmF2KGVsKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3QgPSBuYXYuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgY29uc3QgZCA9IHNlbGYuZG9jdW1lbnQ7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbkxlZnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgJiYgcHJldmlvdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJpZ2h0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uUmlnaHQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgYSAhPT0gYnV0dG9uQ2xvc2UuY3VycmVudCAmJiBhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcbiAgICAgICAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcbiAgICAgICAgICAgICAgICBkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNsb3NlLFxuICAgICAgICBuYXYsXG4gICAgICAgIG5leHQsXG4gICAgICAgIHByZXZpb3VzXG4gICAgXSk7XG4gICAgLy8gVW5sb2NrIGZvY3VzIGZvciBicm93c2VycyBsaWtlIEZpcmVmb3gsIHRoYXQgYnJlYWsgYWxsIHVzZXIgZm9jdXMgaWYgdGhlXG4gICAgLy8gY3VycmVudGx5IGZvY3VzZWQgaXRlbSBiZWNvbWVzIGRpc2FibGVkLlxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAobmF2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIC8vIEFsd2F5cyB0cnVlLCBidXQgd2UgZG8gdGhpcyBmb3IgVHlwZVNjcmlwdDpcbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uTGVmdC5jdXJyZW50ICYmIGEgPT09IGJ1dHRvbkxlZnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJpZ2h0LmN1cnJlbnQgJiYgYSA9PT0gYnV0dG9uUmlnaHQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25SaWdodC5jdXJyZW50LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG5hdixcbiAgICAgICAgbmV4dCxcbiAgICAgICAgcHJldmlvdXNcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodFwiOiB0cnVlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcIm5hdlwiLCB7XG4gICAgICAgIHJlZjogb25OYXZcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICByZWY6IGJ1dHRvbkxlZnQsXG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIGRpc2FibGVkOiBwcmV2aW91cyA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICBvbkNsaWNrOiBwcmV2aW91cyAhPSBudWxsID8gcHJldmlvdXMgOiB1bmRlZmluZWRcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLFxuICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSkpKSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgcmVmOiBidXR0b25SaWdodCxcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgZGlzYWJsZWQ6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBuZXh0ID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICBvbkNsaWNrOiBuZXh0ICE9IG51bGwgPyBuZXh0IDogdW5kZWZpbmVkXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMTQgMTRcIixcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNNi45OTk5NiAxLjE2NjY2TDEyLjgzMzMgNi45OTk5OUw2Ljk5OTk2IDEyLjgzMzNNMS4xNjY2MyA2Ljk5OTk5SDEySDEuMTY2NjNaXCIsXG4gICAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSkpLCBcIlxceGEwXCIsIGNoaWxkcmVuKSwgY2xvc2UgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLWVycm9ycy1kaWFsb2ctbGVmdC1yaWdodC1jbG9zZS1idXR0b25cIjogdHJ1ZSxcbiAgICAgICAgcmVmOiBidXR0b25DbG9zZSxcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgb25DbGljazogY2xvc2UsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcIkNsb3NlXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfY2xvc2VJY29uLkNsb3NlSWNvbiwgbnVsbCkpKSA6IG51bGwpO1xufTtcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZWZ0UmlnaHREaWFsb2dIZWFkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGVmdFJpZ2h0RGlhbG9nSGVhZGVyIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfY2xvc2VJY29uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJwcmV2aW91cyIsIm5leHQiLCJjbG9zZSIsImJ1dHRvbkxlZnQiLCJ1c2VSZWYiLCJidXR0b25SaWdodCIsImJ1dHRvbkNsb3NlIiwibmF2Iiwic2V0TmF2IiwidXNlU3RhdGUiLCJvbk5hdiIsInVzZUNhbGxiYWNrIiwiZWwiLCJ1c2VFZmZlY3QiLCJyb290IiwiZ2V0Um9vdE5vZGUiLCJkIiwic2VsZiIsImRvY3VtZW50IiwiaGFuZGxlciIsImUiLCJrZXkiLCJzdG9wUHJvcGFnYXRpb24iLCJjdXJyZW50IiwiZm9jdXMiLCJTaGFkb3dSb290IiwiYSIsImFjdGl2ZUVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImJsdXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJ0eXBlIiwiZGlzYWJsZWQiLCJ1bmRlZmluZWQiLCJvbkNsaWNrIiwidmlld0JveCIsImZpbGwiLCJ4bWxucyIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiQ2xvc2VJY29uIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/index.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"LeftRightDialogHeader\", ({\n    enumerable: true,\n    get: function() {\n        return _leftRightDialogHeader.LeftRightDialogHeader;\n    }\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return _styles.styles;\n    }\n}));\nvar _leftRightDialogHeader = __webpack_require__(/*! ./LeftRightDialogHeader */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js\");\nvar _styles = __webpack_require__(/*! ./styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/styles.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILHlEQUF3RDtJQUNwREksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyx1QkFBdUJDLHFCQUFxQjtJQUN2RDtBQUNKLENBQUMsRUFBQztBQUNGUCwwQ0FBeUM7SUFDckNJLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0csUUFBUUMsTUFBTTtJQUN6QjtBQUNKLENBQUMsRUFBQztBQUNGLElBQUlILHlCQUF5QkksbUJBQU9BLENBQUMsNEtBQXlCO0FBQzlELElBQUlGLFVBQVVFLG1CQUFPQSxDQUFDLDhJQUFVO0FBRWhDLElBQUksQ0FBQyxPQUFPUixRQUFRUyxPQUFPLEtBQUssY0FBZSxPQUFPVCxRQUFRUyxPQUFPLEtBQUssWUFBWVQsUUFBUVMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPVCxRQUFRUyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLWixPQUFPQyxjQUFjLENBQUNDLFFBQVFTLE9BQU8sRUFBRSxjQUFjO1FBQUVSLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYSxNQUFNLENBQUNYLFFBQVFTLE9BQU8sRUFBRVQ7SUFDL0JZLE9BQU9aLE9BQU8sR0FBR0EsUUFBUVMsT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvaW5kZXguanM/MmFjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxlZnRSaWdodERpYWxvZ0hlYWRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xlZnRSaWdodERpYWxvZ0hlYWRlci5MZWZ0UmlnaHREaWFsb2dIZWFkZXI7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHlsZXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdHlsZXMuc3R5bGVzO1xuICAgIH1cbn0pO1xudmFyIF9sZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSByZXF1aXJlKFwiLi9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XG52YXIgX3N0eWxlcyA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9sZWZ0UmlnaHREaWFsb2dIZWFkZXIiLCJMZWZ0UmlnaHREaWFsb2dIZWFkZXIiLCJfc3R5bGVzIiwic3R5bGVzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/styles.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/styles.js ***!
  \************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    margin-right: var(--size-gap);\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL3N0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxjQUFjLEdBQUcsS0FBSztBQUN0QixJQUFJRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLCtJQUE2QjtBQUN6RCxNQUFNRixTQUFTQyxjQUFjRSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOERsQyxDQUFDO0FBQ0RMLGNBQWMsR0FBR0U7QUFFakIsSUFBSSxDQUFDLE9BQU9GLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktULE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9VLE1BQU0sQ0FBQ1IsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQlMsT0FBT1QsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXMuanM/ZGI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYge1xuICAgIGZsZXg6IDE7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XG4gICAgZm9udC1zaXplOiAwO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uID4gc3ZnIHtcbiAgICB3aWR0aDogYXV0bztcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMik7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC40KTtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKSAwIDAgdmFyKC0tc2l6ZS1nYXAtaGFsZik7XG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xuICAgIGJvcmRlci1yYWRpdXM6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtaGFsZikgMDtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlIHtcbiAgICBib3JkZXI6IDA7XG4gICAgcGFkZGluZzogMDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGFwcGVhcmFuY2U6IG5vbmU7XG5cbiAgICBvcGFjaXR5OiAwLjQ7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcbiAgICBvcGFjaXR5OiAwLjc7XG4gIH1cbmA7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN0eWxlcyIsIl9ub29wVGVtcGxhdGUiLCJyZXF1aXJlIiwibm9vcCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Overlay = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _maintainTabFocus = _interop_require_default(__webpack_require__(/*! ./maintain--tab-focus */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js\"));\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _bodyLocker = __webpack_require__(/*! ./body-locker */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js\");\nconst Overlay = function Overlay({ className , children , fixed  }) {\n    React.useEffect(()=>{\n        (0, _bodyLocker).lock();\n        return ()=>{\n            (0, _bodyLocker).unlock();\n        };\n    }, []);\n    const [overlay, setOverlay] = React.useState(null);\n    const onOverlay = React.useCallback((el)=>{\n        setOverlay(el);\n    }, []);\n    React.useEffect(()=>{\n        if (overlay == null) {\n            return;\n        }\n        const handle2 = (0, _maintainTabFocus).default({\n            context: overlay\n        });\n        return ()=>{\n            handle2.disengage();\n        };\n    }, [\n        overlay\n    ]);\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-overlay\": true,\n        className: className,\n        ref: onOverlay\n    }, /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-dialog-backdrop\": true,\n        \"data-nextjs-dialog-backdrop-fixed\": fixed ? true : undefined\n    }), children);\n};\nexports.Overlay = Overlay;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Overlay.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlFLDRCQUE0QkYsaUtBQWdFO0FBQ2hHLElBQUlHLG9CQUFvQkoseUJBQXlCQyxtQkFBT0EsQ0FBQywwSkFBdUI7QUFDaEYsSUFBSUksUUFBUUYsMEJBQTBCRixtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJSyxjQUFjTCxtQkFBT0EsQ0FBQywwSUFBZTtBQUN6QyxNQUFNRixVQUFVLFNBQVNBLFFBQVEsRUFBRVEsVUFBUyxFQUFHQyxTQUFRLEVBQUdDLE1BQUssRUFBSyxFQUFFO0lBQ2xFSixNQUFNSyxTQUFTLENBQUMsSUFBSTtRQUNmLElBQUdKLFdBQVcsRUFBRUssSUFBSTtRQUNyQixPQUFPLElBQUk7WUFDTixJQUFHTCxXQUFXLEVBQUVNLE1BQU07UUFDM0I7SUFDSixHQUFHLEVBQUU7SUFDTCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1QsTUFBTVUsUUFBUSxDQUFDLElBQUk7SUFDakQsTUFBTUMsWUFBWVgsTUFBTVksV0FBVyxDQUFDLENBQUNDLEtBQUs7UUFDdENKLFdBQVdJO0lBQ2YsR0FBRyxFQUFFO0lBQ0xiLE1BQU1LLFNBQVMsQ0FBQyxJQUFJO1FBQ2hCLElBQUlHLFdBQVcsSUFBSSxFQUFFO1lBQ2pCO1FBQ0osQ0FBQztRQUNELE1BQU1NLFVBQVUsQ0FBQyxHQUFHZixpQkFBaUIsRUFBRUYsT0FBTyxDQUFDO1lBQzNDa0IsU0FBU1A7UUFDYjtRQUNBLE9BQU8sSUFBSTtZQUNQTSxRQUFRRSxTQUFTO1FBQ3JCO0lBQ0osR0FBRztRQUNDUjtLQUNIO0lBQ0QsT0FBTyxXQUFXLEdBQUdSLE1BQU1pQixhQUFhLENBQUMsT0FBTztRQUM1Qyw4QkFBOEIsSUFBSTtRQUNsQ2YsV0FBV0E7UUFDWGdCLEtBQUtQO0lBQ1QsR0FBRyxXQUFXLEdBQUdYLE1BQU1pQixhQUFhLENBQUMsT0FBTztRQUN4QywrQkFBK0IsSUFBSTtRQUNuQyxxQ0FBcUNiLFFBQVEsSUFBSSxHQUFHZSxTQUFTO0lBQ2pFLElBQUloQjtBQUNSO0FBQ0FYLGVBQWUsR0FBR0U7QUFFbEIsSUFBSSxDQUFDLE9BQU9GLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ3VCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytCLE1BQU0sQ0FBQzdCLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvT3ZlcmxheS5qcz9hYzIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5PdmVybGF5ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX21haW50YWluVGFiRm9jdXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vbWFpbnRhaW4tLXRhYi1mb2N1c1wiKSk7XG52YXIgUmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2JvZHlMb2NrZXIgPSByZXF1aXJlKFwiLi9ib2R5LWxvY2tlclwiKTtcbmNvbnN0IE92ZXJsYXkgPSBmdW5jdGlvbiBPdmVybGF5KHsgY2xhc3NOYW1lICwgY2hpbGRyZW4gLCBmaXhlZCAsICB9KSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfYm9keUxvY2tlcikubG9jaygpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICgwLCBfYm9keUxvY2tlcikudW5sb2NrKCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IFtvdmVybGF5LCBzZXRPdmVybGF5XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG9uT3ZlcmxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgc2V0T3ZlcmxheShlbCk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAob3ZlcmxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlMiA9ICgwLCBfbWFpbnRhaW5UYWJGb2N1cykuZGVmYXVsdCh7XG4gICAgICAgICAgICBjb250ZXh0OiBvdmVybGF5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGhhbmRsZTIuZGlzZW5nYWdlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvdmVybGF5XG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXlcIjogdHJ1ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHJlZjogb25PdmVybGF5XG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BcIjogdHJ1ZSxcbiAgICAgICAgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgfSksIGNoaWxkcmVuKTtcbn07XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdmVybGF5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk92ZXJsYXkiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfbWFpbnRhaW5UYWJGb2N1cyIsIlJlYWN0IiwiX2JvZHlMb2NrZXIiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImZpeGVkIiwidXNlRWZmZWN0IiwibG9jayIsInVubG9jayIsIm92ZXJsYXkiLCJzZXRPdmVybGF5IiwidXNlU3RhdGUiLCJvbk92ZXJsYXkiLCJ1c2VDYWxsYmFjayIsImVsIiwiaGFuZGxlMiIsImNvbnRleHQiLCJkaXNlbmdhZ2UiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwidW5kZWZpbmVkIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js ***!
  \***************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.lock = lock;\nexports.unlock = unlock;\nlet previousBodyPaddingRight;\nlet previousBodyOverflowSetting;\nlet activeLocks = 0;\nfunction lock() {\n    setTimeout(()=>{\n        if (activeLocks++ > 0) {\n            return;\n        }\n        const scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n        if (scrollBarGap > 0) {\n            previousBodyPaddingRight = document.body.style.paddingRight;\n            document.body.style.paddingRight = `${scrollBarGap}px`;\n        }\n        previousBodyOverflowSetting = document.body.style.overflow;\n        document.body.style.overflow = \"hidden\";\n    });\n}\nfunction unlock() {\n    setTimeout(()=>{\n        if (activeLocks === 0 || --activeLocks !== 0) {\n            return;\n        }\n        if (previousBodyPaddingRight !== undefined) {\n            document.body.style.paddingRight = previousBodyPaddingRight;\n            previousBodyPaddingRight = undefined;\n        }\n        if (previousBodyOverflowSetting !== undefined) {\n            document.body.style.overflow = previousBodyOverflowSetting;\n            previousBodyOverflowSetting = undefined;\n        }\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=body-locker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9ib2R5LWxvY2tlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUdFO0FBQ2ZGLGNBQWMsR0FBR0c7QUFDakIsSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDLGNBQWM7QUFDbEIsU0FBU0osT0FBTztJQUNaSyxXQUFXLElBQUk7UUFDWCxJQUFJRCxnQkFBZ0IsR0FBRztZQUNuQjtRQUNKLENBQUM7UUFDRCxNQUFNRSxlQUFlQyxPQUFPQyxVQUFVLEdBQUdDLFNBQVNDLGVBQWUsQ0FBQ0MsV0FBVztRQUM3RSxJQUFJTCxlQUFlLEdBQUc7WUFDbEJKLDJCQUEyQk8sU0FBU0csSUFBSSxDQUFDQyxLQUFLLENBQUNDLFlBQVk7WUFDM0RMLFNBQVNHLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxZQUFZLEdBQUcsQ0FBQyxFQUFFUixhQUFhLEVBQUUsQ0FBQztRQUMxRCxDQUFDO1FBQ0RILDhCQUE4Qk0sU0FBU0csSUFBSSxDQUFDQyxLQUFLLENBQUNFLFFBQVE7UUFDMUROLFNBQVNHLElBQUksQ0FBQ0MsS0FBSyxDQUFDRSxRQUFRLEdBQUc7SUFDbkM7QUFDSjtBQUNBLFNBQVNkLFNBQVM7SUFDZEksV0FBVyxJQUFJO1FBQ1gsSUFBSUQsZ0JBQWdCLEtBQUssRUFBRUEsZ0JBQWdCLEdBQUc7WUFDMUM7UUFDSixDQUFDO1FBQ0QsSUFBSUYsNkJBQTZCYyxXQUFXO1lBQ3hDUCxTQUFTRyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsWUFBWSxHQUFHWjtZQUNuQ0EsMkJBQTJCYztRQUMvQixDQUFDO1FBQ0QsSUFBSWIsZ0NBQWdDYSxXQUFXO1lBQzNDUCxTQUFTRyxJQUFJLENBQUNDLEtBQUssQ0FBQ0UsUUFBUSxHQUFHWjtZQUMvQkEsOEJBQThCYTtRQUNsQyxDQUFDO0lBQ0w7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPbEIsUUFBUW1CLE9BQU8sS0FBSyxjQUFlLE9BQU9uQixRQUFRbUIsT0FBTyxLQUFLLFlBQVluQixRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkIsUUFBUW1CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QixPQUFPQyxjQUFjLENBQUNDLFFBQVFtQixPQUFPLEVBQUUsY0FBYztRQUFFbEIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixRQUFRbUIsT0FBTyxFQUFFbkI7SUFDL0JzQixPQUFPdEIsT0FBTyxHQUFHQSxRQUFRbUIsT0FBTztBQUNsQyxDQUFDLENBRUQsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L2JvZHktbG9ja2VyLmpzPzhkMWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvY2sgPSBsb2NrO1xuZXhwb3J0cy51bmxvY2sgPSB1bmxvY2s7XG5sZXQgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xubGV0IHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcbmxldCBhY3RpdmVMb2NrcyA9IDA7XG5mdW5jdGlvbiBsb2NrKCkge1xuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgaWYgKGFjdGl2ZUxvY2tzKysgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsQmFyR2FwID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c2Nyb2xsQmFyR2FwfXB4YDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBpZiAoYWN0aXZlTG9ja3MgPT09IDAgfHwgLS1hY3RpdmVMb2NrcyAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nO1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvZHktbG9ja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImxvY2siLCJ1bmxvY2siLCJwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQiLCJwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmciLCJhY3RpdmVMb2NrcyIsInNldFRpbWVvdXQiLCJzY3JvbGxCYXJHYXAiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImJvZHkiLCJzdHlsZSIsInBhZGRpbmdSaWdodCIsIm92ZXJmbG93IiwidW5kZWZpbmVkIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js ***!
  \*********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Overlay\", ({\n    enumerable: true,\n    get: function() {\n        return _overlay.Overlay;\n    }\n}));\nvar _overlay = __webpack_require__(/*! ./Overlay */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVksSUFBSTtJQUNoQkMsS0FBSyxXQUFXO1FBQ1osT0FBT0MsU0FBU0MsT0FBTztJQUMzQjtBQUNKLENBQUMsRUFBQztBQUNGLElBQUlELFdBQVdFLG1CQUFPQSxDQUFDLGtJQUFXO0FBRWxDLElBQUksQ0FBQyxPQUFPTixRQUFRTyxPQUFPLEtBQUssY0FBZSxPQUFPUCxRQUFRTyxPQUFPLEtBQUssWUFBWVAsUUFBUU8sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUCxRQUFRTyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVixPQUFPQyxjQUFjLENBQUNDLFFBQVFPLE9BQU8sRUFBRSxjQUFjO1FBQUVOLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L2luZGV4LmpzP2E4OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPdmVybGF5XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfb3ZlcmxheS5PdmVybGF5O1xuICAgIH1cbn0pO1xudmFyIF9vdmVybGF5ID0gcmVxdWlyZShcIi4vT3ZlcmxheVwiKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9vdmVybGF5IiwiT3ZlcmxheSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = _default;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _platform = _interop_require_default(__webpack_require__(/*! next/dist/compiled/platform */ \"next/dist/compiled/platform\"));\nvar _cssEscape = _interop_require_default(__webpack_require__(/*! next/dist/compiled/css.escape */ \"next/dist/compiled/css.escape\"));\n// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes\n// yes, to some extent this is a bad replica of jQuery's constructor function\nfunction nodeArray(input) {\n    if (!input) {\n        return [];\n    }\n    if (Array.isArray(input)) {\n        return input;\n    }\n    // instanceof Node - does not work with iframes\n    if (input.nodeType !== undefined) {\n        return [\n            input\n        ];\n    }\n    if (typeof input === \"string\") {\n        input = document.querySelectorAll(input);\n    }\n    if (input.length !== undefined) {\n        return [].slice.call(input, 0);\n    }\n    throw new TypeError(\"unexpected input \" + String(input));\n}\nfunction contextToElement(_ref) {\n    var context = _ref.context, _ref$label = _ref.label, label = _ref$label === undefined ? \"context-to-element\" : _ref$label, resolveDocument = _ref.resolveDocument, defaultToDocument = _ref.defaultToDocument;\n    var element = nodeArray(context)[0];\n    if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {\n        element = element.documentElement;\n    }\n    if (!element && defaultToDocument) {\n        return document.documentElement;\n    }\n    if (!element) {\n        throw new TypeError(label + \" requires valid options.context\");\n    }\n    if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n        throw new TypeError(label + \" requires options.context to be an Element\");\n    }\n    return element;\n}\nfunction getShadowHost() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;\n    var element = contextToElement({\n        label: \"get/shadow-host\",\n        context: context\n    });\n    // walk up to the root\n    var container = null;\n    while(element){\n        container = element;\n        element = element.parentNode;\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n    // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)\n    if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {\n        // the root is attached to a fragment node that has a host\n        return container.host;\n    }\n    return null;\n}\nfunction getDocument(node) {\n    if (!node) {\n        return document;\n    }\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n        return node;\n    }\n    return node.ownerDocument || document;\n}\nfunction isActiveElement(context) {\n    var element = contextToElement({\n        label: \"is/active-element\",\n        resolveDocument: true,\n        context: context\n    });\n    var _document = getDocument(element);\n    if (_document.activeElement === element) {\n        return true;\n    }\n    var shadowHost = getShadowHost({\n        context: element\n    });\n    if (shadowHost && shadowHost.shadowRoot.activeElement === element) {\n        return true;\n    }\n    return false;\n}\n// [elem, elem.parent, elem.parent.parent, …, html]\n// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost\nfunction getParents() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;\n    var list = [];\n    var element = contextToElement({\n        label: \"get/parents\",\n        context: context\n    });\n    while(element){\n        list.push(element);\n        // IE does know support parentElement on SVGElement\n        element = element.parentNode;\n        if (element && element.nodeType !== Node.ELEMENT_NODE) {\n            element = null;\n        }\n    }\n    return list;\n}\n// Element.prototype.matches may be available at a different name\n// https://developer.mozilla.org/en/docs/Web/API/Element/matches\nvar names = [\n    \"matches\",\n    \"webkitMatchesSelector\",\n    \"mozMatchesSelector\",\n    \"msMatchesSelector\"\n];\nvar name = null;\nfunction findMethodName(element) {\n    names.some(function(_name) {\n        if (!element[_name]) {\n            return false;\n        }\n        name = _name;\n        return true;\n    });\n}\nfunction elementMatches(element, selector1) {\n    if (!name) {\n        findMethodName(element);\n    }\n    return element[name](selector1);\n}\n// deep clone of original platform\nvar platform = JSON.parse(JSON.stringify(_platform.default));\n// operating system\nvar os = platform.os.family || \"\";\nvar ANDROID = os === \"Android\";\nvar WINDOWS = os.slice(0, 7) === \"Windows\";\nvar OSX = os === \"OS X\";\nvar IOS = os === \"iOS\";\n// layout\nvar BLINK = platform.layout === \"Blink\";\nvar GECKO = platform.layout === \"Gecko\";\nvar TRIDENT = platform.layout === \"Trident\";\nvar EDGE = platform.layout === \"EdgeHTML\";\nvar WEBKIT = platform.layout === \"WebKit\";\n// browser version (not layout engine version!)\nvar version = parseFloat(platform.version);\nvar majorVersion = Math.floor(version);\nplatform.majorVersion = majorVersion;\nplatform.is = {\n    // operating system\n    ANDROID: ANDROID,\n    WINDOWS: WINDOWS,\n    OSX: OSX,\n    IOS: IOS,\n    // layout\n    BLINK: BLINK,\n    GECKO: GECKO,\n    TRIDENT: TRIDENT,\n    EDGE: EDGE,\n    WEBKIT: WEBKIT,\n    // INTERNET EXPLORERS\n    IE9: TRIDENT && majorVersion === 9,\n    IE10: TRIDENT && majorVersion === 10,\n    IE11: TRIDENT && majorVersion === 11\n};\nfunction before() {\n    var data = {\n        // remember what had focus to restore after test\n        activeElement: document.activeElement,\n        // remember scroll positions to restore after test\n        windowScrollTop: window.scrollTop,\n        windowScrollLeft: window.scrollLeft,\n        bodyScrollTop: document.body.scrollTop,\n        bodyScrollLeft: document.body.scrollLeft\n    };\n    // wrap tests in an element hidden from screen readers to prevent them\n    // from announcing focus, which can be quite irritating to the user\n    var iframe = document.createElement(\"iframe\");\n    iframe.setAttribute(\"style\", \"position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;\");\n    iframe.setAttribute(\"aria-live\", \"off\");\n    iframe.setAttribute(\"aria-busy\", \"true\");\n    iframe.setAttribute(\"aria-hidden\", \"true\");\n    document.body.appendChild(iframe);\n    var _window = iframe.contentWindow;\n    var _document = _window.document;\n    _document.open();\n    _document.close();\n    var wrapper = _document.createElement(\"div\");\n    _document.body.appendChild(wrapper);\n    data.iframe = iframe;\n    data.wrapper = wrapper;\n    data.window = _window;\n    data.document = _document;\n    return data;\n}\n// options.element:\n//  {string} element name\n//  {function} callback(wrapper, document) to generate an element\n// options.mutate: (optional)\n//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.\n//             Can return DOMElement to define focus target (default: element)\n// options.validate: (optional)\n//  {function} callback(element, focusTarget, document) to manipulate test-result\nfunction test(data, options) {\n    // make sure we operate on a clean slate\n    data.wrapper.innerHTML = \"\";\n    // create dummy element to test focusability of\n    var element = typeof options.element === \"string\" ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);\n    // allow callback to further specify dummy element\n    // and optionally define element to focus\n    var focus1 = options.mutate && options.mutate(element, data.wrapper, data.document);\n    if (!focus1 && focus1 !== false) {\n        focus1 = element;\n    }\n    // element needs to be part of the DOM to be focusable\n    !element.parentNode && data.wrapper.appendChild(element);\n    // test if the element with invalid tabindex can be focused\n    focus1 && focus1.focus && focus1.focus();\n    // validate test's result\n    return options.validate ? options.validate(element, focus1, data.document) : data.document.activeElement === focus1;\n}\nfunction after(data) {\n    // restore focus to what it was before test and cleanup\n    if (data.activeElement === document.body) {\n        document.activeElement && document.activeElement.blur && document.activeElement.blur();\n        if (platform.is.IE10) {\n            // IE10 does not redirect focus to <body> when the activeElement is removed\n            document.body.focus();\n        }\n    } else {\n        data.activeElement && data.activeElement.focus && data.activeElement.focus();\n    }\n    document.body.removeChild(data.iframe);\n    // restore scroll position\n    window.scrollTop = data.windowScrollTop;\n    window.scrollLeft = data.windowScrollLeft;\n    document.body.scrollTop = data.bodyScrollTop;\n    document.body.scrollLeft = data.bodyScrollLeft;\n}\nfunction detectFocus(tests) {\n    var data = before();\n    var results = {};\n    Object.keys(tests).map(function(key) {\n        results[key] = test(data, tests[key]);\n    });\n    after(data);\n    return results;\n}\n// this file is overwritten by `npm run build:pre`\nvar version$1 = \"1.4.1\";\n/*\n    Facility to cache test results in localStorage.\n\n    USAGE:\n      cache.get('key');\n      cache.set('key', 'value');\n */ function readLocalStorage(key) {\n    // allow reading from storage to retrieve previous support results\n    // even while the document does not have focus\n    var data = void 0;\n    try {\n        data = window.localStorage && window.localStorage.getItem(key);\n        data = data ? JSON.parse(data) : {};\n    } catch (e) {\n        data = {};\n    }\n    return data;\n}\nfunction writeLocalStorage(key, value) {\n    if (!document.hasFocus()) {\n        // if the document does not have focus when tests are executed, focus() may\n        // not be handled properly and events may not be dispatched immediately.\n        // This can happen when a document is reloaded while Developer Tools have focus.\n        try {\n            window.localStorage && window.localStorage.removeItem(key);\n        } catch (e) {\n        // ignore\n        }\n        return;\n    }\n    try {\n        window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (e) {\n    // ignore\n    }\n}\nvar userAgent =  false || \"\";\nvar cacheKey = \"ally-supports-cache\";\nvar cache = readLocalStorage(cacheKey);\n// update the cache if ally or the user agent changed (newer version, etc)\nif (cache.userAgent !== userAgent || cache.version !== version$1) {\n    cache = {};\n}\ncache.userAgent = userAgent;\ncache.version = version$1;\nvar cache$1 = {\n    get: function get() {\n        return cache;\n    },\n    set: function set(values) {\n        Object.keys(values).forEach(function(key) {\n            cache[key] = values[key];\n        });\n        cache.time = new Date().toISOString();\n        writeLocalStorage(cacheKey, cache);\n    }\n};\nfunction cssShadowPiercingDeepCombinator() {\n    var combinator = void 0;\n    // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572\n    // https://code.google.com/p/chromium/issues/detail?id=446051\n    try {\n        document.querySelector(\"html >>> :first-child\");\n        combinator = \">>>\";\n    } catch (noArrowArrowArrow) {\n        try {\n            // old syntax supported at least up to Chrome 41\n            // https://code.google.com/p/chromium/issues/detail?id=446051\n            document.querySelector(\"html /deep/ :first-child\");\n            combinator = \"/deep/\";\n        } catch (noDeep) {\n            combinator = \"\";\n        }\n    }\n    return combinator;\n}\nvar gif = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaImgTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\">' + '<area shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" src=\"' + gif + '\">';\n        return element.querySelector(\"area\");\n    }\n};\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\">' + '<area href=\"#void\" tabindex=\"-1\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" alt=\"\" src=\"' + gif + '\">';\n        return false;\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // fixes https://github.com/medialize/ally.js/issues/35\n            // Firefox loads the DataURI asynchronously, causing a false-negative\n            return true;\n        }\n        var focus2 = element.querySelector(\"area\");\n        focus2.focus();\n        return _document.activeElement === focus2;\n    }\n};\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaWithoutHref = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-area-href-test\">' + '<area shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-area-href-test\" alt=\"\" src=\"' + gif + '\">';\n        return element.querySelector(\"area\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // fixes https://github.com/medialize/ally.js/issues/35\n            // Firefox loads the DataURI asynchronously, causing a false-negative\n            return true;\n        }\n        return _document.activeElement === focusTarget;\n    }\n};\nvar focusAudioWithoutControls = {\n    name: \"can-focus-audio-without-controls\",\n    element: \"audio\",\n    mutate: function mutate(element) {\n        try {\n            // invalid media file can trigger warning in console, data-uri to prevent HTTP request\n            element.setAttribute(\"src\", gif);\n        } catch (e) {\n        // IE9 may throw \"Error: Not implemented\"\n        }\n    }\n};\nvar invalidGif = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\";\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\nvar focusBrokenImageMap = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"broken-image-map-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#broken-image-map-test\" alt=\"\" src=\"' + invalidGif + '\">';\n        return element.querySelector(\"area\");\n    }\n};\n// Children of focusable elements with display:flex are focusable in IE10-11\nvar focusChildrenOfFocusableFlexbox = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"-1\");\n        element.setAttribute(\"style\", \"display: -webkit-flex; display: -ms-flexbox; display: flex;\");\n        element.innerHTML = '<span style=\"display: block;\">hello</span>';\n        return element.querySelector(\"span\");\n    }\n};\n// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree\n// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled\n// @browser-issue Chromium https://crbug.com/453847\n// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086\nvar focusFieldsetDisabled = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", 0);\n        element.setAttribute(\"disabled\", \"disabled\");\n    }\n};\nvar focusFieldset = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.innerHTML = \"<legend>legend</legend><p>content</p>\";\n    }\n};\n// elements with display:flex are focusable in IE10-11\nvar focusFlexboxContainer = {\n    element: \"span\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"display: -webkit-flex; display: -ms-flexbox; display: flex;\");\n        element.innerHTML = '<span style=\"display: block;\">hello</span>';\n    }\n};\n// form[tabindex=0][disabled] should be focusable as the\n// specification doesn't know the disabled attribute on the form element\n// @specification https://www.w3.org/TR/html5/forms.html#the-form-element\nvar focusFormDisabled = {\n    element: \"form\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", 0);\n        element.setAttribute(\"disabled\", \"disabled\");\n    }\n};\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// fixes https://github.com/medialize/ally.js/issues/20\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap\nvar focusImgIsmap = {\n    element: \"a\",\n    mutate: function mutate(element) {\n        element.href = \"#void\";\n        element.innerHTML = '<img ismap src=\"' + gif + '\" alt=\"\">';\n        return element.querySelector(\"img\");\n    }\n};\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\nvar focusImgUsemapTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" ' + 'src=\"' + gif + '\">';\n        return element.querySelector(\"img\");\n    }\n};\nvar focusInHiddenIframe = {\n    element: function element(wrapper, _document) {\n        var iframe = _document.createElement(\"iframe\");\n        // iframe must be part of the DOM before accessing the contentWindow is possible\n        wrapper.appendChild(iframe);\n        // create the iframe's default document (<html><head></head><body></body></html>)\n        var iframeDocument = iframe.contentWindow.document;\n        iframeDocument.open();\n        iframeDocument.close();\n        return iframe;\n    },\n    mutate: function mutate(iframe) {\n        iframe.style.visibility = \"hidden\";\n        var iframeDocument = iframe.contentWindow.document;\n        var input = iframeDocument.createElement(\"input\");\n        iframeDocument.body.appendChild(input);\n        return input;\n    },\n    validate: function validate(iframe) {\n        var iframeDocument = iframe.contentWindow.document;\n        var focus3 = iframeDocument.querySelector(\"input\");\n        return iframeDocument.activeElement === focus3;\n    }\n};\nvar result = !platform.is.WEBKIT;\nfunction focusInZeroDimensionObject() {\n    return result;\n}\n// Firefox allows *any* value and treats invalid values like tabindex=\"-1\"\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\nvar focusInvalidTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"invalid-value\");\n    }\n};\nvar focusLabelTabindex = {\n    element: \"label\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"-1\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        // force layout in Chrome 49, otherwise the element won't be focusable\n        /* eslint-disable no-unused-vars */ var variableToPreventDeadCodeElimination = element.offsetHeight;\n        /* eslint-enable no-unused-vars */ element.focus();\n        return _document.activeElement === element;\n    }\n};\nvar svg = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb\" + \"G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ\" + \"zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==\";\n// Note: IE10 on BrowserStack does not like this test\nvar focusObjectSvgHidden = {\n    element: \"object\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"type\", \"image/svg+xml\");\n        element.setAttribute(\"data\", svg);\n        element.setAttribute(\"width\", \"200\");\n        element.setAttribute(\"height\", \"50\");\n        element.style.visibility = \"hidden\";\n    }\n};\n// Note: IE10 on BrowserStack does not like this test\nvar focusObjectSvg = {\n    name: \"can-focus-object-svg\",\n    element: \"object\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"type\", \"image/svg+xml\");\n        element.setAttribute(\"data\", svg);\n        element.setAttribute(\"width\", \"200\");\n        element.setAttribute(\"height\", \"50\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.\n            // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string\n            return true;\n        }\n        return _document.activeElement === element;\n    }\n};\n// Every Environment except IE9 considers SWF objects focusable\nvar result$1 = !platform.is.IE9;\nfunction focusObjectSwf() {\n    return result$1;\n}\nvar focusRedirectImgUsemap = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"focus-redirect-img-usemap\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#focus-redirect-img-usemap\" alt=\"\" ' + 'src=\"' + gif + '\">';\n        // focus the <img>, not the <div>\n        return element.querySelector(\"img\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        var target = element.querySelector(\"area\");\n        return _document.activeElement === target;\n    }\n};\n// see https://jsbin.com/nenirisage/edit?html,js,console,output\nvar focusRedirectLegend = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<legend>legend</legend><input tabindex=\"-1\"><input tabindex=\"0\">';\n        // take care of focus in validate();\n        return false;\n    },\n    validate: function validate(element, focusTarget, _document) {\n        var focusable = element.querySelector('input[tabindex=\"-1\"]');\n        var tabbable = element.querySelector('input[tabindex=\"0\"]');\n        // Firefox requires this test to focus the <fieldset> first, while this is not necessary in\n        // https://jsbin.com/nenirisage/edit?html,js,console,output\n        element.focus();\n        element.querySelector(\"legend\").focus();\n        return _document.activeElement === focusable && \"focusable\" || _document.activeElement === tabbable && \"tabbable\" || \"\";\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollBody = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px; overflow: auto;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n        return element.querySelector(\"div\");\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollContainerWithoutOverflow = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollContainer = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px; overflow: auto;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n    }\n};\nvar focusSummary = {\n    element: \"details\",\n    mutate: function mutate(element) {\n        element.innerHTML = \"<summary>foo</summary><p>content</p>\";\n        return element.firstElementChild;\n    }\n};\nfunction makeFocusableForeignObject() {\n    // Constructs <foreignObject width=\"30\" height=\"30\"><input type=\"text\"/></foreignObject>\n    // without raising a Trusted Types violation\n    var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n    foreignObject.width.baseVal.value = 30;\n    foreignObject.height.baseVal.value = 30;\n    foreignObject.appendChild(document.createElement(\"input\"));\n    foreignObject.lastChild.type = \"text\";\n    return foreignObject;\n}\nfunction focusSvgForeignObjectHack(element) {\n    // Edge13, Edge14: foreignObject focus hack\n    // https://jsbin.com/kunehinugi/edit?html,js,output\n    // https://jsbin.com/fajagi/3/edit?html,js,output\n    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === \"svg\";\n    if (!isSvgElement) {\n        return false;\n    }\n    // inject and focus an <input> element into the SVG element to receive focus\n    var foreignObject = makeFocusableForeignObject();\n    element.appendChild(foreignObject);\n    var input = foreignObject.querySelector(\"input\");\n    input.focus();\n    // upon disabling the activeElement, IE and Edge\n    // will not shift focus to <body> like all the other\n    // browsers, but instead find the first focusable\n    // ancestor and shift focus to that\n    input.disabled = true;\n    // clean up\n    element.removeChild(foreignObject);\n    return true;\n}\nfunction generate(element) {\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">' + element + \"</svg>\";\n}\nfunction focus(element) {\n    if (element.focus) {\n        return;\n    }\n    try {\n        HTMLElement.prototype.focus.call(element);\n    } catch (e) {\n        focusSvgForeignObjectHack(element);\n    }\n}\nfunction validate(element, focusTarget, _document) {\n    focus(focusTarget);\n    return _document.activeElement === focusTarget;\n}\nvar focusSvgFocusableAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text focusable=\"true\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgTabindexAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text tabindex=\"0\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgNegativeTabindexAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text tabindex=\"-1\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgUseTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate([\n            '<g id=\"ally-test-target\"><a xlink:href=\"#void\"><text>link</text></a></g>',\n            '<use xlink:href=\"#ally-test-target\" x=\"0\" y=\"0\" tabindex=\"-1\" />'\n        ].join(\"\"));\n        return element.querySelector(\"use\");\n    },\n    validate: validate\n};\nvar focusSvgForeignobjectTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<foreignObject tabindex=\"-1\"><input type=\"text\" /></foreignObject>');\n        // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can\n        return element.querySelector(\"foreignObject\") || element.getElementsByTagName(\"foreignObject\")[0];\n    },\n    validate: validate\n};\n// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously\n// and thereby produces a false negative test result. Thus the test is pointless\n// and we resort to UA sniffing once again.\n// see http://jsbin.com/vunadohoko/1/edit?js,console,output\nvar result$2 = Boolean(platform.is.GECKO && typeof SVGElement !== \"undefined\" && SVGElement.prototype.focus);\nfunction focusSvgInIframe() {\n    return result$2;\n}\nvar focusSvg = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate(\"\");\n        return element.firstChild;\n    },\n    validate: validate\n};\n// Firefox allows *any* value and treats invalid values like tabindex=\"-1\"\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\nvar focusTabindexTrailingCharacters = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"3x\");\n    }\n};\nvar focusTable = {\n    element: \"table\",\n    mutate: function mutate(element, wrapper, _document) {\n        // IE9 has a problem replacing TBODY contents with innerHTML.\n        // https://stackoverflow.com/a/8097055/515124\n        // element.innerHTML = '<tr><td>cell</td></tr>';\n        var fragment = _document.createDocumentFragment();\n        fragment.innerHTML = \"<tr><td>cell</td></tr>\";\n        element.appendChild(fragment);\n    }\n};\nvar focusVideoWithoutControls = {\n    element: \"video\",\n    mutate: function mutate(element) {\n        try {\n            // invalid media file can trigger warning in console, data-uri to prevent HTTP request\n            element.setAttribute(\"src\", gif);\n        } catch (e) {\n        // IE9 may throw \"Error: Not implemented\"\n        }\n    }\n};\n// https://jsbin.com/vafaba/3/edit?html,js,console,output\nvar result$3 = platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE;\nfunction tabsequenceAreaAtImgPosition() {\n    return result$3;\n}\nvar testCallbacks = {\n    cssShadowPiercingDeepCombinator: cssShadowPiercingDeepCombinator,\n    focusInZeroDimensionObject: focusInZeroDimensionObject,\n    focusObjectSwf: focusObjectSwf,\n    focusSvgInIframe: focusSvgInIframe,\n    tabsequenceAreaAtImgPosition: tabsequenceAreaAtImgPosition\n};\nvar testDescriptions = {\n    focusAreaImgTabindex: focusAreaImgTabindex,\n    focusAreaTabindex: focusAreaTabindex,\n    focusAreaWithoutHref: focusAreaWithoutHref,\n    focusAudioWithoutControls: focusAudioWithoutControls,\n    focusBrokenImageMap: focusBrokenImageMap,\n    focusChildrenOfFocusableFlexbox: focusChildrenOfFocusableFlexbox,\n    focusFieldsetDisabled: focusFieldsetDisabled,\n    focusFieldset: focusFieldset,\n    focusFlexboxContainer: focusFlexboxContainer,\n    focusFormDisabled: focusFormDisabled,\n    focusImgIsmap: focusImgIsmap,\n    focusImgUsemapTabindex: focusImgUsemapTabindex,\n    focusInHiddenIframe: focusInHiddenIframe,\n    focusInvalidTabindex: focusInvalidTabindex,\n    focusLabelTabindex: focusLabelTabindex,\n    focusObjectSvg: focusObjectSvg,\n    focusObjectSvgHidden: focusObjectSvgHidden,\n    focusRedirectImgUsemap: focusRedirectImgUsemap,\n    focusRedirectLegend: focusRedirectLegend,\n    focusScrollBody: focusScrollBody,\n    focusScrollContainerWithoutOverflow: focusScrollContainerWithoutOverflow,\n    focusScrollContainer: focusScrollContainer,\n    focusSummary: focusSummary,\n    focusSvgFocusableAttribute: focusSvgFocusableAttribute,\n    focusSvgTabindexAttribute: focusSvgTabindexAttribute,\n    focusSvgNegativeTabindexAttribute: focusSvgNegativeTabindexAttribute,\n    focusSvgUseTabindex: focusSvgUseTabindex,\n    focusSvgForeignobjectTabindex: focusSvgForeignobjectTabindex,\n    focusSvg: focusSvg,\n    focusTabindexTrailingCharacters: focusTabindexTrailingCharacters,\n    focusTable: focusTable,\n    focusVideoWithoutControls: focusVideoWithoutControls\n};\nfunction executeTests() {\n    var results = detectFocus(testDescriptions);\n    Object.keys(testCallbacks).forEach(function(key) {\n        results[key] = testCallbacks[key]();\n    });\n    return results;\n}\nvar supportsCache = null;\nfunction _supports() {\n    if (supportsCache) {\n        return supportsCache;\n    }\n    supportsCache = cache$1.get();\n    if (!supportsCache.time) {\n        cache$1.set(executeTests());\n        supportsCache = cache$1.get();\n    }\n    return supportsCache;\n}\nvar supports = void 0;\n// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers\n// NOTE: all browsers agree to allow trailing spaces as well\nvar validIntegerPatternNoTrailing = /^\\s*(-|\\+)?[0-9]+\\s*$/;\nvar validIntegerPatternWithTrailing = /^\\s*(-|\\+)?[0-9]+.*$/;\nfunction isValidTabindex(context) {\n    if (!supports) {\n        supports = _supports();\n    }\n    var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;\n    var element = contextToElement({\n        label: \"is/valid-tabindex\",\n        resolveDocument: true,\n        context: context\n    });\n    // Edge 14 has a capitalization problem on SVG elements,\n    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    var hasTabIndex = element.hasAttribute(\"tabIndex\");\n    if (!hasTabindex && !hasTabIndex) {\n        return false;\n    }\n    // older Firefox and Internet Explorer don't support tabindex on SVG elements\n    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === \"svg\";\n    if (isSvgElement && !supports.focusSvgTabindexAttribute) {\n        return false;\n    }\n    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    if (supports.focusInvalidTabindex) {\n        return true;\n    }\n    // an element matches the tabindex selector even if its value is invalid\n    var tabindex = element.getAttribute(hasTabindex ? \"tabindex\" : \"tabIndex\");\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965\n    if (tabindex === \"-32768\") {\n        return false;\n    }\n    return Boolean(tabindex && validIntegerPattern.test(tabindex));\n}\nfunction tabindexValue(element) {\n    if (!isValidTabindex(element)) {\n        return null;\n    }\n    // Edge 14 has a capitalization problem on SVG elements,\n    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    var attributeName = hasTabindex ? \"tabindex\" : \"tabIndex\";\n    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var tabindex = parseInt(element.getAttribute(attributeName), 10);\n    return isNaN(tabindex) ? -1 : tabindex;\n}\n// this is a shared utility file for focus-relevant.js and tabbable.js\n// separate testing of this file's functions is not necessary,\n// as they're implicitly tested by way of the consumers\nfunction isUserModifyWritable(style) {\n    // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify\n    // https://github.com/medialize/ally.js/issues/17\n    var userModify = style.webkitUserModify || \"\";\n    return Boolean(userModify && userModify.indexOf(\"write\") !== -1);\n}\nfunction hasCssOverflowScroll(style) {\n    return [\n        style.getPropertyValue(\"overflow\"),\n        style.getPropertyValue(\"overflow-x\"),\n        style.getPropertyValue(\"overflow-y\")\n    ].some(function(overflow) {\n        return overflow === \"auto\" || overflow === \"scroll\";\n    });\n}\nfunction hasCssDisplayFlex(style) {\n    return style.display.indexOf(\"flex\") > -1;\n}\nfunction isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {\n    if (nodeName !== \"div\" && nodeName !== \"span\") {\n        // Internet Explorer advances scrollable containers and bodies to focusable\n        // only if the scrollable container is <div> or <span> - this does *not*\n        // happen for <section>, <article>, …\n        return false;\n    }\n    if (parentNodeName && parentNodeName !== \"div\" && parentNodeName !== \"span\" && !hasCssOverflowScroll(parentStyle)) {\n        return false;\n    }\n    return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;\n}\nvar supports$1 = void 0;\nfunction isFocusRelevantRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        flexbox: false,\n        scrollable: false,\n        shadow: false\n    } : _ref$except;\n    if (!supports$1) {\n        supports$1 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/focus-relevant\",\n        resolveDocument: true,\n        context: context\n    });\n    if (!except.shadow && element.shadowRoot) {\n        // a ShadowDOM host receives focus when the focus moves to its content\n        return true;\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"input\" && element.type === \"hidden\") {\n        // input[type=\"hidden\"] supports.cannot be focused\n        return false;\n    }\n    if (nodeName === \"input\" || nodeName === \"select\" || nodeName === \"button\" || nodeName === \"textarea\") {\n        return true;\n    }\n    if (nodeName === \"legend\" && supports$1.focusRedirectLegend) {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"label\") {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"area\") {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"a\" && element.hasAttribute(\"href\")) {\n        return true;\n    }\n    if (nodeName === \"object\" && element.hasAttribute(\"usemap\")) {\n        // object[usemap] is not focusable in any browser\n        return false;\n    }\n    if (nodeName === \"object\") {\n        var svgType = element.getAttribute(\"type\");\n        if (!supports$1.focusObjectSvg && svgType === \"image/svg+xml\") {\n            // object[type=\"image/svg+xml\"] is not focusable in Internet Explorer\n            return false;\n        } else if (!supports$1.focusObjectSwf && svgType === \"application/x-shockwave-flash\") {\n            // object[type=\"application/x-shockwave-flash\"] is not focusable in Internet Explorer 9\n            return false;\n        }\n    }\n    if (nodeName === \"iframe\" || nodeName === \"object\") {\n        // browsing context containers\n        return true;\n    }\n    if (nodeName === \"embed\" || nodeName === \"keygen\") {\n        // embed is considered focus-relevant but not focusable\n        // see https://github.com/medialize/ally.js/issues/82\n        return true;\n    }\n    if (element.hasAttribute(\"contenteditable\")) {\n        // also see CSS property user-modify below\n        return true;\n    }\n    if (nodeName === \"audio\" && (supports$1.focusAudioWithoutControls || element.hasAttribute(\"controls\"))) {\n        return true;\n    }\n    if (nodeName === \"video\" && (supports$1.focusVideoWithoutControls || element.hasAttribute(\"controls\"))) {\n        return true;\n    }\n    if (supports$1.focusSummary && nodeName === \"summary\") {\n        return true;\n    }\n    var validTabindex = isValidTabindex(element);\n    if (nodeName === \"img\" && element.hasAttribute(\"usemap\")) {\n        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,\n        // it appears the tabindex is overruled so focus is still forwarded to the <map>\n        return validTabindex && supports$1.focusImgUsemapTabindex || supports$1.focusRedirectImgUsemap;\n    }\n    if (supports$1.focusTable && (nodeName === \"table\" || nodeName === \"td\")) {\n        // IE10-11 supports.can focus <table> and <td>\n        return true;\n    }\n    if (supports$1.focusFieldset && nodeName === \"fieldset\") {\n        // IE10-11 supports.can focus <fieldset>\n        return true;\n    }\n    var isSvgElement = nodeName === \"svg\";\n    var isSvgContent = element.ownerSVGElement;\n    var focusableAttribute = element.getAttribute(\"focusable\");\n    var tabindex = tabindexValue(element);\n    if (nodeName === \"use\" && tabindex !== null && !supports$1.focusSvgUseTabindex) {\n        // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit\n        return false;\n    }\n    if (nodeName === \"foreignobject\") {\n        // <use> can only be made focusable in Blink and WebKit\n        return tabindex !== null && supports$1.focusSvgForeignobjectTabindex;\n    }\n    if (elementMatches(element, \"svg a\") && element.hasAttribute(\"xlink:href\")) {\n        return true;\n    }\n    if ((isSvgElement || isSvgContent) && element.focus && !supports$1.focusSvgNegativeTabindexAttribute && tabindex < 0) {\n        // Firefox 51 and 52 treat any natively tabbable SVG element with\n        // tabindex=\"-1\" as tabbable and everything else as inert\n        // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340\n        return false;\n    }\n    if (isSvgElement) {\n        return validTabindex || supports$1.focusSvg || supports$1.focusSvgInIframe || // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n        Boolean(supports$1.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === \"true\");\n    }\n    if (isSvgContent) {\n        if (supports$1.focusSvgTabindexAttribute && validTabindex) {\n            return true;\n        }\n        if (supports$1.focusSvgFocusableAttribute) {\n            // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n            return focusableAttribute === \"true\";\n        }\n    }\n    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n    if (validTabindex) {\n        return true;\n    }\n    var style = window.getComputedStyle(element, null);\n    if (isUserModifyWritable(style)) {\n        return true;\n    }\n    if (supports$1.focusImgIsmap && nodeName === \"img\" && element.hasAttribute(\"ismap\")) {\n        // IE10-11 considers the <img> in <a href><img ismap> focusable\n        // https://github.com/medialize/ally.js/issues/20\n        var hasLinkParent = getParents({\n            context: element\n        }).some(function(parent) {\n            return parent.nodeName.toLowerCase() === \"a\" && parent.hasAttribute(\"href\");\n        });\n        if (hasLinkParent) {\n            return true;\n        }\n    }\n    // https://github.com/medialize/ally.js/issues/21\n    if (!except.scrollable && supports$1.focusScrollContainer) {\n        if (supports$1.focusScrollContainerWithoutOverflow) {\n            // Internet Explorer does will consider the scrollable area focusable\n            // if the element is a <div> or a <span> and it is in fact scrollable,\n            // regardless of the CSS overflow property\n            if (isScrollableContainer(element, nodeName)) {\n                return true;\n            }\n        } else if (hasCssOverflowScroll(style)) {\n            // Firefox requires proper overflow setting, IE does not necessarily\n            // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\n            return true;\n        }\n    }\n    if (!except.flexbox && supports$1.focusFlexboxContainer && hasCssDisplayFlex(style)) {\n        // elements with display:flex are focusable in IE10-11\n        return true;\n    }\n    var parent1 = element.parentElement;\n    if (!except.scrollable && parent1) {\n        var parentNodeName = parent1.nodeName.toLowerCase();\n        var parentStyle = window.getComputedStyle(parent1, null);\n        if (supports$1.focusScrollBody && isScrollableContainer(parent1, nodeName, parentNodeName, parentStyle)) {\n            // scrollable bodies are focusable Internet Explorer\n            // https://github.com/medialize/ally.js/issues/21\n            return true;\n        }\n        // Children of focusable elements with display:flex are focusable in IE10-11\n        if (supports$1.focusChildrenOfFocusableFlexbox) {\n            if (hasCssDisplayFlex(parentStyle)) {\n                return true;\n            }\n        }\n    }\n    // NOTE: elements marked as inert are not focusable,\n    // but that property is not exposed to the DOM\n    // https://www.w3.org/TR/html5/editing.html#inert\n    return false;\n}\n// bind exceptions to an iterator callback\nisFocusRelevantRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isFocusRelevant1 = function isFocusRelevant(context) {\n        return isFocusRelevantRules({\n            context: context,\n            except: except\n        });\n    };\n    isFocusRelevant1.rules = isFocusRelevantRules;\n    return isFocusRelevant1;\n};\n// provide isFocusRelevant(context) as default iterator callback\nvar isFocusRelevant = isFocusRelevantRules.except({});\nfunction findIndex(array, callback) {\n    // attempt to use native or polyfilled Array#findIndex first\n    if (array.findIndex) {\n        return array.findIndex(callback);\n    }\n    var length = array.length;\n    // shortcut if the array is empty\n    if (length === 0) {\n        return -1;\n    }\n    // otherwise loop over array\n    for(var i = 0; i < length; i++){\n        if (callback(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getContentDocument(node) {\n    try {\n        // works on <object> and <iframe>\n        return node.contentDocument || // works on <object> and <iframe>\n        node.contentWindow && node.contentWindow.document || // works on <object> and <iframe> that contain SVG\n        node.getSVGDocument && node.getSVGDocument() || null;\n    } catch (e) {\n        // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'\n        // also IE may throw member not found exception e.g. on <object type=\"image/png\">\n        return null;\n    }\n}\nfunction getWindow(node) {\n    var _document = getDocument(node);\n    return _document.defaultView || window;\n}\nvar shadowPrefix = void 0;\nfunction selectInShadows(selector2) {\n    if (typeof shadowPrefix !== \"string\") {\n        var operator = cssShadowPiercingDeepCombinator();\n        if (operator) {\n            shadowPrefix = \", html \" + operator + \" \";\n        }\n    }\n    if (!shadowPrefix) {\n        return selector2;\n    }\n    return selector2 + shadowPrefix + selector2.replace(/\\s*,\\s*/g, \",\").split(\",\").join(shadowPrefix);\n}\nvar selector = void 0;\nfunction findDocumentHostElement(_window) {\n    if (!selector) {\n        selector = selectInShadows(\"object, iframe\");\n    }\n    if (_window._frameElement !== undefined) {\n        return _window._frameElement;\n    }\n    _window._frameElement = null;\n    var potentialHosts = _window.parent.document.querySelectorAll(selector);\n    [].some.call(potentialHosts, function(element) {\n        var _document = getContentDocument(element);\n        if (_document !== _window.document) {\n            return false;\n        }\n        _window._frameElement = element;\n        return true;\n    });\n    return _window._frameElement;\n}\nfunction getFrameElement(element) {\n    var _window = getWindow(element);\n    if (!_window.parent || _window.parent === _window) {\n        // if there is no parent browsing context,\n        // we're not going to get a frameElement either way\n        return null;\n    }\n    try {\n        // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement\n        // does not work within <embed> anywhere, and not within in <object> in IE\n        return _window.frameElement || findDocumentHostElement(_window);\n    } catch (e) {\n        return null;\n    }\n}\n// https://www.w3.org/TR/html5/rendering.html#being-rendered\n// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage\nvar notRenderedElementsPattern = /^(area)$/;\nfunction computedStyle(element, property) {\n    return window.getComputedStyle(element, null).getPropertyValue(property);\n}\nfunction notDisplayed(_path) {\n    return _path.some(function(element) {\n        // display:none is not visible (optimized away at layout)\n        return computedStyle(element, \"display\") === \"none\";\n    });\n}\nfunction notVisible(_path) {\n    // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114\n    // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible\n    // NOTE: visibility can be [\"\", \"visible\", \"hidden\", \"collapse\"]\n    var hidden = findIndex(_path, function(element) {\n        var visibility = computedStyle(element, \"visibility\");\n        return visibility === \"hidden\" || visibility === \"collapse\";\n    });\n    if (hidden === -1) {\n        // there is no hidden element\n        return false;\n    }\n    var visible = findIndex(_path, function(element) {\n        return computedStyle(element, \"visibility\") === \"visible\";\n    });\n    if (visible === -1) {\n        // there is no visible element (but a hidden element)\n        return true;\n    }\n    if (hidden < visible) {\n        // there is a hidden element and it's closer than the first visible element\n        return true;\n    }\n    // there may be a hidden element, but the closest element is visible\n    return false;\n}\nfunction collapsedParent(_path) {\n    var offset = 1;\n    if (_path[0].nodeName.toLowerCase() === \"summary\") {\n        offset = 2;\n    }\n    return _path.slice(offset).some(function(element) {\n        // \"content children\" of a closed details element are not visible\n        return element.nodeName.toLowerCase() === \"details\" && element.open === false;\n    });\n}\nfunction isVisibleRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        notRendered: false,\n        cssDisplay: false,\n        cssVisibility: false,\n        detailsElement: false,\n        browsingContext: false\n    } : _ref$except;\n    var element = contextToElement({\n        label: \"is/visible\",\n        resolveDocument: true,\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {\n        return true;\n    }\n    var _path = getParents({\n        context: element\n    });\n    // in Internet Explorer <audio> has a default display: none, where others have display: inline\n    // but IE allows focusing <audio style=\"display:none\">, but not <div display:none><audio>\n    // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable\n    var isAudioWithoutControls = nodeName === \"audio\" && !element.hasAttribute(\"controls\");\n    if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {\n        return false;\n    }\n    if (!except.cssVisibility && notVisible(_path)) {\n        return false;\n    }\n    if (!except.detailsElement && collapsedParent(_path)) {\n        return false;\n    }\n    if (!except.browsingContext) {\n        // elements within a browsing context are affected by the\n        // browsing context host element's visibility and tabindex\n        var frameElement = getFrameElement(element);\n        var _isVisible = isVisibleRules.except(except);\n        if (frameElement && !_isVisible(frameElement)) {\n            return false;\n        }\n    }\n    return true;\n}\n// bind exceptions to an iterator callback\nisVisibleRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isVisible1 = function isVisible(context) {\n        return isVisibleRules({\n            context: context,\n            except: except\n        });\n    };\n    isVisible1.rules = isVisibleRules;\n    return isVisible1;\n};\n// provide isVisible(context) as default iterator callback\nvar isVisible = isVisibleRules.except({});\nfunction getMapByName(name1, _document) {\n    // apparently getElementsByName() also considers id attribute in IE & opera\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName\n    var map = _document.querySelector('map[name=\"' + (0, _cssEscape).default(name1) + '\"]');\n    return map || null;\n}\nfunction getImageOfArea(element) {\n    var map = element.parentElement;\n    if (!map.name || map.nodeName.toLowerCase() !== \"map\") {\n        return null;\n    }\n    // NOTE: image maps can also be applied to <object> with image content,\n    // but no browser supports this at the moment\n    // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all\n    // <img> and <object> referencing the <map> element, but no browser implements this\n    //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element\n    //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement\n    // the image must be valid and loaded for the map to take effect\n    var _document = getDocument(element);\n    return _document.querySelector('img[usemap=\"#' + (0, _cssEscape).default(map.name) + '\"]') || null;\n}\nvar supports$2 = void 0;\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\n// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107\nfunction isValidArea(context) {\n    if (!supports$2) {\n        supports$2 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/valid-area\",\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName !== \"area\") {\n        return false;\n    }\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    if (!supports$2.focusAreaTabindex && hasTabindex) {\n        // Blink and WebKit do not consider <area tabindex=\"-1\" href=\"#void\"> focusable\n        return false;\n    }\n    var img = getImageOfArea(element);\n    if (!img || !isVisible(img)) {\n        return false;\n    }\n    // Firefox only allows fully loaded images to reference image maps\n    // https://stereochro.me/ideas/detecting-broken-images-js\n    if (!supports$2.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {\n        return false;\n    }\n    // Firefox supports.can focus area elements even if they don't have an href attribute\n    if (!supports$2.focusAreaWithoutHref && !element.href) {\n        // Internet explorer supports.can focus area elements without href if either\n        // the area element or the image element has a tabindex attribute\n        return supports$2.focusAreaTabindex && hasTabindex || supports$2.focusAreaImgTabindex && img.hasAttribute(\"tabindex\");\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap\n    var childOfInteractive = getParents({\n        context: img\n    }).slice(1).some(function(_element) {\n        var name2 = _element.nodeName.toLowerCase();\n        return name2 === \"button\" || name2 === \"a\";\n    });\n    if (childOfInteractive) {\n        return false;\n    }\n    return true;\n}\nvar supports$3 = void 0;\n// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled\nvar disabledElementsPattern = void 0;\nvar disabledElements = {\n    input: true,\n    select: true,\n    textarea: true,\n    button: true,\n    fieldset: true,\n    form: true\n};\nfunction isNativeDisabledSupported(context) {\n    if (!supports$3) {\n        supports$3 = _supports();\n        if (supports$3.focusFieldsetDisabled) {\n            delete disabledElements.fieldset;\n        }\n        if (supports$3.focusFormDisabled) {\n            delete disabledElements.form;\n        }\n        disabledElementsPattern = new RegExp(\"^(\" + Object.keys(disabledElements).join(\"|\") + \")$\");\n    }\n    var element = contextToElement({\n        label: \"is/native-disabled-supported\",\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    return Boolean(disabledElementsPattern.test(nodeName));\n}\nvar supports$4 = void 0;\nfunction isDisabledFieldset(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    return nodeName === \"fieldset\" && element.disabled;\n}\nfunction isDisabledForm(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    return nodeName === \"form\" && element.disabled;\n}\nfunction isDisabled(context) {\n    if (!supports$4) {\n        supports$4 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/disabled\",\n        context: context\n    });\n    if (element.hasAttribute(\"data-ally-disabled\")) {\n        // treat ally's element/disabled like the DOM native element.disabled\n        return true;\n    }\n    if (!isNativeDisabledSupported(element)) {\n        // non-form elements do not support the disabled attribute\n        return false;\n    }\n    if (element.disabled) {\n        // the element itself is disabled\n        return true;\n    }\n    var parents = getParents({\n        context: element\n    });\n    if (parents.some(isDisabledFieldset)) {\n        // a parental <fieldset> is disabld and inherits the state onto this element\n        return true;\n    }\n    if (!supports$4.focusFormDisabled && parents.some(isDisabledForm)) {\n        // a parental <form> is disabld and inherits the state onto this element\n        return true;\n    }\n    return false;\n}\nfunction isOnlyTabbableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        onlyFocusableBrowsingContext: false,\n        visible: false\n    } : _ref$except;\n    var element = contextToElement({\n        label: \"is/only-tabbable\",\n        resolveDocument: true,\n        context: context\n    });\n    if (!except.visible && !isVisible(element)) {\n        return false;\n    }\n    if (!except.onlyFocusableBrowsingContext && (platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE)) {\n        var frameElement = getFrameElement(element);\n        if (frameElement) {\n            if (tabindexValue(frameElement) < 0) {\n                // iframe[tabindex=\"-1\"] and object[tabindex=\"-1\"] inherit the\n                // tabbable demotion onto elements of their browsing contexts\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    var tabindex = tabindexValue(element);\n    if (nodeName === \"label\" && platform.is.GECKO) {\n        // Firefox cannot focus, but tab to: label[tabindex=0]\n        return tabindex !== null && tabindex >= 0;\n    }\n    // SVG Elements were keyboard focusable but not script focusable before Firefox 51.\n    // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654\n    if (platform.is.GECKO && element.ownerSVGElement && !element.focus) {\n        if (nodeName === \"a\" && element.hasAttribute(\"xlink:href\")) {\n            // any focusable child of <svg> cannot be focused, but tabbed to\n            if (platform.is.GECKO) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// bind exceptions to an iterator callback\nisOnlyTabbableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isOnlyTabbable1 = function isOnlyTabbable(context) {\n        return isOnlyTabbableRules({\n            context: context,\n            except: except\n        });\n    };\n    isOnlyTabbable1.rules = isOnlyTabbableRules;\n    return isOnlyTabbable1;\n};\n// provide isOnlyTabbable(context) as default iterator callback\nvar isOnlyTabbable = isOnlyTabbableRules.except({});\nvar supports$5 = void 0;\nfunction isOnlyFocusRelevant(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"embed\" || nodeName === \"keygen\") {\n        // embed is considered focus-relevant but not focusable\n        // see https://github.com/medialize/ally.js/issues/82\n        return true;\n    }\n    var _tabindex = tabindexValue(element);\n    if (element.shadowRoot && _tabindex === null) {\n        // ShadowDOM host elements *may* receive focus\n        // even though they are not considered focuable\n        return true;\n    }\n    if (nodeName === \"label\") {\n        // <label tabindex=\"0\"> is only tabbable in Firefox, not script-focusable\n        // there's no way to make an element focusable other than by adding a tabindex,\n        // and focus behavior of the label element seems hard-wired to ignore tabindex\n        // in some browsers (like Gecko, Blink and WebKit)\n        return !supports$5.focusLabelTabindex || _tabindex === null;\n    }\n    if (nodeName === \"legend\") {\n        return _tabindex === null;\n    }\n    if (supports$5.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === \"svg\")) {\n        // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n        var focusableAttribute = element.getAttribute(\"focusable\");\n        return focusableAttribute && focusableAttribute === \"false\";\n    }\n    if (nodeName === \"img\" && element.hasAttribute(\"usemap\")) {\n        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,\n        // it appears the tabindex is overruled so focus is still forwarded to the <map>\n        return _tabindex === null || !supports$5.focusImgUsemapTabindex;\n    }\n    if (nodeName === \"area\") {\n        // all <area>s are considered relevant,\n        // but only the valid <area>s are focusable\n        return !isValidArea(element);\n    }\n    return false;\n}\nfunction isFocusableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        disabled: false,\n        visible: false,\n        onlyTabbable: false\n    } : _ref$except;\n    if (!supports$5) {\n        supports$5 = _supports();\n    }\n    var _isOnlyTabbable = isOnlyTabbable.rules.except({\n        onlyFocusableBrowsingContext: true,\n        visible: except.visible\n    });\n    var element = contextToElement({\n        label: \"is/focusable\",\n        resolveDocument: true,\n        context: context\n    });\n    var focusRelevant = isFocusRelevant.rules({\n        context: element,\n        except: except\n    });\n    if (!focusRelevant || isOnlyFocusRelevant(element)) {\n        return false;\n    }\n    if (!except.disabled && isDisabled(element)) {\n        return false;\n    }\n    if (!except.onlyTabbable && _isOnlyTabbable(element)) {\n        // some elements may be keyboard focusable, but not script focusable\n        return false;\n    }\n    // elements that are not rendered, cannot be focused\n    if (!except.visible) {\n        var visibilityOptions = {\n            context: element,\n            except: {}\n        };\n        if (supports$5.focusInHiddenIframe) {\n            // WebKit and Blink can focus content in hidden <iframe> and <object>\n            visibilityOptions.except.browsingContext = true;\n        }\n        if (supports$5.focusObjectSvgHidden) {\n            // Blink allows focusing the object element, even if it has visibility: hidden;\n            // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191\n            var _nodeName2 = element.nodeName.toLowerCase();\n            if (_nodeName2 === \"object\") {\n                visibilityOptions.except.cssVisibility = true;\n            }\n        }\n        if (!isVisible.rules(visibilityOptions)) {\n            return false;\n        }\n    }\n    var frameElement = getFrameElement(element);\n    if (frameElement) {\n        var _nodeName = frameElement.nodeName.toLowerCase();\n        if (_nodeName === \"object\" && !supports$5.focusInZeroDimensionObject) {\n            if (!frameElement.offsetWidth || !frameElement.offsetHeight) {\n                // WebKit can not focus content in <object> if it doesn't have dimensions\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"svg\" && supports$5.focusSvgInIframe && !frameElement && element.getAttribute(\"tabindex\") === null) {\n        return false;\n    }\n    return true;\n}\n// bind exceptions to an iterator callback\nisFocusableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isFocusable1 = function isFocusable(context) {\n        return isFocusableRules({\n            context: context,\n            except: except\n        });\n    };\n    isFocusable1.rules = isFocusableRules;\n    return isFocusable1;\n};\n// provide isFocusRelevant(context) as default iterator callback\nvar isFocusable = isFocusableRules.except({});\nfunction createFilter(condition) {\n    // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter\n    var filter = function filter(node) {\n        if (node.shadowRoot) {\n            // return ShadowRoot elements regardless of them being focusable,\n            // so they can be walked recursively later\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        if (condition(node)) {\n            // finds elements that could have been found by document.querySelectorAll()\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        return NodeFilter.FILTER_SKIP;\n    };\n    // IE requires a function, Browsers require {acceptNode: function}\n    // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm\n    filter.acceptNode = filter;\n    return filter;\n}\nvar PossiblyFocusableFilter = createFilter(isFocusRelevant);\nfunction queryFocusableStrict() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    if (!context) {\n        context = document.documentElement;\n    }\n    var _isFocusable = isFocusable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    var _document = getDocument(context);\n    // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker\n    var walker = _document.createTreeWalker(context, NodeFilter.SHOW_ELEMENT, strategy === \"all\" ? PossiblyFocusableFilter : createFilter(_isFocusable), false);\n    var list = [];\n    while(walker.nextNode()){\n        if (walker.currentNode.shadowRoot) {\n            if (_isFocusable(walker.currentNode)) {\n                list.push(walker.currentNode);\n            }\n            list = list.concat(queryFocusableStrict({\n                context: walker.currentNode.shadowRoot,\n                includeOnlyTabbable: includeOnlyTabbable,\n                strategy: strategy\n            }));\n        } else {\n            list.push(walker.currentNode);\n        }\n    }\n    // add context if requested and focusable\n    if (includeContext) {\n        if (strategy === \"all\") {\n            if (isFocusRelevant(context)) {\n                list.unshift(context);\n            }\n        } else if (_isFocusable(context)) {\n            list.unshift(context);\n        }\n    }\n    return list;\n}\n// NOTE: this selector MUST *never* be used directly,\nvar supports$6 = void 0;\nvar selector$1 = void 0;\nfunction selector$2() {\n    if (!supports$6) {\n        supports$6 = _supports();\n    }\n    if (typeof selector$1 === \"string\") {\n        return selector$1;\n    }\n    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n    selector$1 = \"\" + // IE11 supports.can focus <table> and <td>\n    (supports$6.focusTable ? \"table, td,\" : \"\") + // IE11 supports.can focus <fieldset>\n    (supports$6.focusFieldset ? \"fieldset,\" : \"\") + // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124\n    // svg a[*|href] does not match in IE9, but since we're filtering\n    // through is/focusable we can include all <a> from SVG\n    \"svg a,\" + // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable\n    // navigational elements\n    \"a[href],\" + // validity determined by is/valid-area.js\n    \"area[href],\" + // validity determined by is/disabled.js\n    \"input, select, textarea, button,\" + // browsing context containers\n    \"iframe, object, embed,\" + // interactive content\n    \"keygen,\" + (supports$6.focusAudioWithoutControls ? \"audio,\" : \"audio[controls],\") + (supports$6.focusVideoWithoutControls ? \"video,\" : \"video[controls],\") + (supports$6.focusSummary ? \"summary,\" : \"\") + // validity determined by is/valid-tabindex.js\n    \"[tabindex],\" + // editing hosts\n    \"[contenteditable]\";\n    // where ShadowDOM is supported, we also want the shadowed focusable elements (via \">>>\" or \"/deep/\")\n    selector$1 = selectInShadows(selector$1);\n    return selector$1;\n}\nfunction queryFocusableQuick() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable;\n    var _selector = selector$2();\n    var elements = context.querySelectorAll(_selector);\n    // the selector potentially matches more than really is focusable\n    var _isFocusable = isFocusable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    var result1 = [].filter.call(elements, _isFocusable);\n    // add context if requested and focusable\n    if (includeContext && _isFocusable(context)) {\n        result1.unshift(context);\n    }\n    return result1;\n}\nfunction queryFocusable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, _ref$strategy = _ref.strategy, strategy = _ref$strategy === undefined ? \"quick\" : _ref$strategy;\n    var element = contextToElement({\n        label: \"query/focusable\",\n        resolveDocument: true,\n        defaultToDocument: true,\n        context: context\n    });\n    var options = {\n        context: element,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    };\n    if (strategy === \"quick\") {\n        return queryFocusableQuick(options);\n    } else if (strategy === \"strict\" || strategy === \"all\") {\n        return queryFocusableStrict(options);\n    }\n    throw new TypeError('query/focusable requires option.strategy to be one of [\"quick\", \"strict\", \"all\"]');\n}\nvar supports$7 = void 0;\n// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable\n// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it\nvar focusableElementsPattern = /^(fieldset|table|td|body)$/;\nfunction isTabbableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        flexbox: false,\n        scrollable: false,\n        shadow: false,\n        visible: false,\n        onlyTabbable: false\n    } : _ref$except;\n    if (!supports$7) {\n        supports$7 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/tabbable\",\n        resolveDocument: true,\n        context: context\n    });\n    if (platform.is.BLINK && platform.is.ANDROID && platform.majorVersion > 42) {\n        // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.\n        // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).\n        // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).\n        return false;\n    }\n    var frameElement = getFrameElement(element);\n    if (frameElement) {\n        if (platform.is.WEBKIT && platform.is.IOS) {\n            // iOS only does not consider anything from another browsing context keyboard focusable\n            return false;\n        }\n        // iframe[tabindex=\"-1\"] and object[tabindex=\"-1\"] inherit the\n        // tabbable demotion onto elements of their browsing contexts\n        if (tabindexValue(frameElement) < 0) {\n            return false;\n        }\n        if (!except.visible && (platform.is.BLINK || platform.is.WEBKIT) && !isVisible(frameElement)) {\n            // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable\n            return false;\n        }\n        // Webkit and Blink don't consider anything in <object> tabbable\n        // Blink fixed that fixed in Chrome 54, Opera 41\n        var frameNodeName = frameElement.nodeName.toLowerCase();\n        if (frameNodeName === \"object\") {\n            var isFixedBlink = platform.name === \"Chrome\" && platform.majorVersion >= 54 || platform.name === \"Opera\" && platform.majorVersion >= 41;\n            if (platform.is.WEBKIT || platform.is.BLINK && !isFixedBlink) {\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    var _tabindex = tabindexValue(element);\n    var tabindex = _tabindex === null ? null : _tabindex >= 0;\n    if (platform.is.EDGE && platform.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {\n        // Edge 14+ considers <a xlink:href=\"…\" tabindex=\"-1\"> keyboard focusable\n        // if the element is in a nested browsing context\n        return true;\n    }\n    var hasTabbableTabindexOrNone = tabindex !== false;\n    var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;\n    // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it\n    // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657\n    if (element.hasAttribute(\"contenteditable\")) {\n        // tabbing can still be disabled by explicitly providing [tabindex=\"-1\"]\n        return hasTabbableTabindexOrNone;\n    }\n    if (focusableElementsPattern.test(nodeName) && tabindex !== true) {\n        return false;\n    }\n    if (platform.is.WEBKIT && platform.is.IOS) {\n        // iOS only considers a hand full of elements tabbable (keyboard focusable)\n        // this holds true even with external keyboards\n        var potentiallyTabbable = nodeName === \"input\" && element.type === \"text\" || element.type === \"password\" || nodeName === \"select\" || nodeName === \"textarea\" || element.hasAttribute(\"contenteditable\");\n        if (!potentiallyTabbable) {\n            var style = window.getComputedStyle(element, null);\n            potentiallyTabbable = isUserModifyWritable(style);\n        }\n        if (!potentiallyTabbable) {\n            return false;\n        }\n    }\n    if (nodeName === \"use\" && _tabindex !== null) {\n        if (platform.is.BLINK || platform.is.WEBKIT && platform.majorVersion === 9) {\n            // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex=\"-1\"\n            return true;\n        }\n    }\n    if (elementMatches(element, \"svg a\") && element.hasAttribute(\"xlink:href\")) {\n        if (hasTabbableTabindexOrNone) {\n            // in Trident and Gecko SVGElement does not handle the tabIndex property properly\n            return true;\n        }\n        if (element.focus && !supports$7.focusSvgNegativeTabindexAttribute) {\n            // Firefox 51 and 52 treat any natively tabbable SVG element with\n            // tabindex=\"-1\" as tabbable and everything else as inert\n            // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340\n            return true;\n        }\n    }\n    if (nodeName === \"svg\" && supports$7.focusSvgInIframe && hasTabbableTabindexOrNone) {\n        return true;\n    }\n    if (platform.is.TRIDENT || platform.is.EDGE) {\n        if (nodeName === \"svg\") {\n            if (supports$7.focusSvg) {\n                // older Internet Explorers consider <svg> keyboard focusable\n                // unless they have focsable=\"false\", but then they wouldn't\n                // be focusable and thus not even reach this filter\n                return true;\n            }\n            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n            return element.hasAttribute(\"focusable\") || hasTabbableTabindex;\n        }\n        if (element.ownerSVGElement) {\n            if (supports$7.focusSvgTabindexAttribute && hasTabbableTabindex) {\n                return true;\n            }\n            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n            return element.hasAttribute(\"focusable\");\n        }\n    }\n    if (element.tabIndex === undefined) {\n        return Boolean(except.onlyTabbable);\n    }\n    if (nodeName === \"audio\") {\n        if (!element.hasAttribute(\"controls\")) {\n            // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong\n            return false;\n        } else if (platform.is.BLINK) {\n            // In Chrome <audio controls tabindex=\"-1\"> remains keyboard focusable\n            return true;\n        }\n    }\n    if (nodeName === \"video\") {\n        if (!element.hasAttribute(\"controls\")) {\n            if (platform.is.TRIDENT || platform.is.EDGE) {\n                // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong\n                return false;\n            }\n        } else if (platform.is.BLINK || platform.is.GECKO) {\n            // In Chrome and Firefox <video controls tabindex=\"-1\"> remains keyboard focusable\n            return true;\n        }\n    }\n    if (nodeName === \"object\") {\n        if (platform.is.BLINK || platform.is.WEBKIT) {\n            // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex=\"0\" set\n            return false;\n        }\n    }\n    if (nodeName === \"iframe\") {\n        // In Internet Explorer all iframes are only focusable\n        // In WebKit, Blink and Gecko iframes may be tabbable depending on content.\n        // Since we can't reliably investigate iframe documents because of the\n        // SameOriginPolicy, we're declaring everything only focusable.\n        return false;\n    }\n    if (!except.scrollable && platform.is.GECKO) {\n        // Firefox considers scrollable containers keyboard focusable,\n        // even though their tabIndex property is -1\n        var _style = window.getComputedStyle(element, null);\n        if (hasCssOverflowScroll(_style)) {\n            return hasTabbableTabindexOrNone;\n        }\n    }\n    if (platform.is.TRIDENT || platform.is.EDGE) {\n        // IE and Edge degrade <area> to script focusable, if the image\n        // using the <map> has been given tabindex=\"-1\"\n        if (nodeName === \"area\") {\n            var img = getImageOfArea(element);\n            if (img && tabindexValue(img) < 0) {\n                return false;\n            }\n        }\n        var _style2 = window.getComputedStyle(element, null);\n        if (isUserModifyWritable(_style2)) {\n            // prevent being swallowed by the overzealous isScrollableContainer() below\n            return element.tabIndex >= 0;\n        }\n        if (!except.flexbox && hasCssDisplayFlex(_style2)) {\n            if (_tabindex !== null) {\n                return hasTabbableTabindex;\n            }\n            return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);\n        }\n        // IE considers scrollable containers script focusable only,\n        // even though their tabIndex property is 0\n        if (isScrollableContainer(element, nodeName)) {\n            return false;\n        }\n        var parent = element.parentElement;\n        if (parent) {\n            var parentNodeName = parent.nodeName.toLowerCase();\n            var parentStyle = window.getComputedStyle(parent, null);\n            // IE considers scrollable bodies script focusable only,\n            if (isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {\n                return false;\n            }\n            // Children of focusable elements with display:flex are focusable in IE10-11,\n            // even though their tabIndex property suggests otherwise\n            if (hasCssDisplayFlex(parentStyle)) {\n                // value of tabindex takes precedence\n                return hasTabbableTabindex;\n            }\n        }\n    }\n    // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex\n    return element.tabIndex >= 0;\n}\n// bind exceptions to an iterator callback\nisTabbableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isTabbable1 = function isTabbable(context) {\n        return isTabbableRules({\n            context: context,\n            except: except\n        });\n    };\n    isTabbable1.rules = isTabbableRules;\n    return isTabbable1;\n};\nvar isFocusRelevantWithoutFlexbox = isFocusRelevant.rules.except({\n    flexbox: true\n});\nvar isTabbableWithoutFlexbox = isTabbableRules.except({\n    flexbox: true\n});\n// provide isTabbable(context) as default iterator callback\nvar isTabbable = isTabbableRules.except({});\nfunction queryTabbable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    var _isTabbable = isTabbable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    return queryFocusable({\n        context: context,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    }).filter(_isTabbable);\n}\n// sorts a list of elements according to their order in the DOM\nfunction compareDomPosition(a, b) {\n    return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n}\nfunction sortDomOrder(elements) {\n    return elements.sort(compareDomPosition);\n}\nfunction getFirstSuccessorOffset(list, target) {\n    // find the first element that comes AFTER the target element\n    return findIndex(list, function(element) {\n        return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\n    });\n}\nfunction findInsertionOffsets(list, elements, resolveElement) {\n    // instead of mutating the elements list directly, remember position and map\n    // to inject later, when we can do this more efficiently\n    var insertions = [];\n    elements.forEach(function(element) {\n        var replace = true;\n        var offset = list.indexOf(element);\n        if (offset === -1) {\n            // element is not in target list\n            offset = getFirstSuccessorOffset(list, element);\n            replace = false;\n        }\n        if (offset === -1) {\n            // there is no successor in the tabsequence,\n            // meaning the image must be the last element\n            offset = list.length;\n        }\n        // allow the consumer to replace the injected element\n        var injections = nodeArray(resolveElement ? resolveElement(element) : element);\n        if (!injections.length) {\n            // we can't inject zero elements\n            return;\n        }\n        insertions.push({\n            offset: offset,\n            replace: replace,\n            elements: injections\n        });\n    });\n    return insertions;\n}\nfunction insertElementsAtOffsets(list, insertions) {\n    // remember the number of elements we have already injected\n    // so we account for the caused index offset\n    var inserted = 0;\n    // make sure that we insert the elements in sequence,\n    // otherwise the offset compensation won't work\n    insertions.sort(function(a, b) {\n        return a.offset - b.offset;\n    });\n    insertions.forEach(function(insertion) {\n        // array.splice has an annoying function signature :(\n        var remove = insertion.replace ? 1 : 0;\n        var args = [\n            insertion.offset + inserted,\n            remove\n        ].concat(insertion.elements);\n        list.splice.apply(list, args);\n        inserted += insertion.elements.length - remove;\n    });\n}\nfunction mergeInDomOrder() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, list = _ref.list, elements = _ref.elements, resolveElement = _ref.resolveElement;\n    // operate on a copy so we don't mutate the original array\n    var _list = list.slice(0);\n    // make sure the elements we're injecting are provided in DOM order\n    var _elements = nodeArray(elements).slice(0);\n    sortDomOrder(_elements);\n    // find the offsets within the target array (list) at which to inject\n    // each individual element (from elements)\n    var insertions = findInsertionOffsets(_list, _elements, resolveElement);\n    // actually inject the elements into the target array at the identified positions\n    insertElementsAtOffsets(_list, insertions);\n    return _list;\n}\nvar _createClass = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nvar Maps = function() {\n    function Maps1(context) {\n        _classCallCheck(this, Maps1);\n        this._document = getDocument(context);\n        this.maps = {};\n    }\n    _createClass(Maps1, [\n        {\n            key: \"getAreasFor\",\n            value: function getAreasFor(name3) {\n                if (!this.maps[name3]) {\n                    // the map is not defined within the context, so we\n                    // have to go find it elsewhere in the document\n                    this.addMapByName(name3);\n                }\n                return this.maps[name3];\n            }\n        },\n        {\n            key: \"addMapByName\",\n            value: function addMapByName(name4) {\n                var map = getMapByName(name4, this._document);\n                if (!map) {\n                    // if there is no map, the img[usemap] wasn't doing anything anyway\n                    return;\n                }\n                this.maps[map.name] = queryTabbable({\n                    context: map\n                });\n            }\n        },\n        {\n            key: \"extractAreasFromList\",\n            value: function extractAreasFromList(elements) {\n                // remove all <area> elements from the elements list,\n                // but put them the map for later retrieval\n                return elements.filter(function(element) {\n                    var nodeName = element.nodeName.toLowerCase();\n                    if (nodeName !== \"area\") {\n                        return true;\n                    }\n                    var map = element.parentNode;\n                    if (!this.maps[map.name]) {\n                        this.maps[map.name] = [];\n                    }\n                    this.maps[map.name].push(element);\n                    return false;\n                }, this);\n            }\n        }\n    ]);\n    return Maps1;\n}();\nfunction sortArea(elements, context) {\n    // images - unless they are focusable themselves, likely not\n    // part of the elements list, so we'll have to find them and\n    // sort them into the elements list manually\n    var usemaps = context.querySelectorAll(\"img[usemap]\");\n    var maps = new Maps(context);\n    // remove all <area> elements from the elements list,\n    // but put them the map for later retrieval\n    var _elements = maps.extractAreasFromList(elements);\n    if (!usemaps.length) {\n        // the context does not contain any <area>s so no need\n        // to replace anything, just remove any maps\n        return _elements;\n    }\n    return mergeInDomOrder({\n        list: _elements,\n        elements: usemaps,\n        resolveElement: function resolveElement(image) {\n            var name5 = image.getAttribute(\"usemap\").slice(1);\n            return maps.getAreasFor(name5);\n        }\n    });\n}\nvar _createClass$1 = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nfunction _classCallCheck$1(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nvar Shadows = function() {\n    function Shadows1(context, sortElements1) {\n        _classCallCheck$1(this, Shadows1);\n        // document context we're working with\n        this.context = context;\n        // callback that sorts an array of elements\n        this.sortElements = sortElements1;\n        // reference to create unique IDs for each ShadowHost\n        this.hostCounter = 1;\n        // reference map for child-ShadowHosts of a ShadowHost\n        this.inHost = {};\n        // reference map for child-ShadowHost of the document\n        this.inDocument = [];\n        // reference map for ShadowHosts\n        this.hosts = {};\n        // reference map for tabbable elements of a ShadowHost\n        this.elements = {};\n    }\n    // remember which hosts we have to sort within later\n    _createClass$1(Shadows1, [\n        {\n            key: \"_registerHost\",\n            value: function _registerHost(host) {\n                if (host._sortingId) {\n                    return;\n                }\n                // make the ShadowHost identifiable (see cleanup() for undo)\n                host._sortingId = \"shadow-\" + this.hostCounter++;\n                this.hosts[host._sortingId] = host;\n                // hosts may contain other hosts\n                var parentHost = getShadowHost({\n                    context: host\n                });\n                if (parentHost) {\n                    this._registerHost(parentHost);\n                    this._registerHostParent(host, parentHost);\n                } else {\n                    this.inDocument.push(host);\n                }\n            }\n        },\n        {\n            key: \"_registerHostParent\",\n            value: function _registerHostParent(host, parent) {\n                if (!this.inHost[parent._sortingId]) {\n                    this.inHost[parent._sortingId] = [];\n                }\n                this.inHost[parent._sortingId].push(host);\n            }\n        },\n        {\n            key: \"_registerElement\",\n            value: function _registerElement(element, host) {\n                if (!this.elements[host._sortingId]) {\n                    this.elements[host._sortingId] = [];\n                }\n                this.elements[host._sortingId].push(element);\n            }\n        },\n        {\n            key: \"extractElements\",\n            value: function extractElements(elements) {\n                return elements.filter(function(element) {\n                    var host = getShadowHost({\n                        context: element\n                    });\n                    if (!host) {\n                        return true;\n                    }\n                    this._registerHost(host);\n                    this._registerElement(element, host);\n                    return false;\n                }, this);\n            }\n        },\n        {\n            key: \"sort\",\n            value: function sort(elements) {\n                var _elements = this._injectHosts(elements);\n                _elements = this._replaceHosts(_elements);\n                this._cleanup();\n                return _elements;\n            }\n        },\n        {\n            key: \"_injectHosts\",\n            value: function _injectHosts(elements) {\n                Object.keys(this.hosts).forEach(function(_sortingId) {\n                    var _list = this.elements[_sortingId];\n                    var _elements = this.inHost[_sortingId];\n                    var _context = this.hosts[_sortingId].shadowRoot;\n                    this.elements[_sortingId] = this._merge(_list, _elements, _context);\n                }, this);\n                return this._merge(elements, this.inDocument, this.context);\n            }\n        },\n        {\n            key: \"_merge\",\n            value: function _merge(list, elements, context) {\n                var merged = mergeInDomOrder({\n                    list: list,\n                    elements: elements\n                });\n                return this.sortElements(merged, context);\n            }\n        },\n        {\n            key: \"_replaceHosts\",\n            value: function _replaceHosts(elements) {\n                return mergeInDomOrder({\n                    list: elements,\n                    elements: this.inDocument,\n                    resolveElement: this._resolveHostElement.bind(this)\n                });\n            }\n        },\n        {\n            key: \"_resolveHostElement\",\n            value: function _resolveHostElement(host) {\n                var merged = mergeInDomOrder({\n                    list: this.elements[host._sortingId],\n                    elements: this.inHost[host._sortingId],\n                    resolveElement: this._resolveHostElement.bind(this)\n                });\n                var _tabindex = tabindexValue(host);\n                if (_tabindex !== null && _tabindex > -1) {\n                    return [\n                        host\n                    ].concat(merged);\n                }\n                return merged;\n            }\n        },\n        {\n            key: \"_cleanup\",\n            value: function _cleanup() {\n                // remove those identifers we put on the ShadowHost to avoid using Map()\n                Object.keys(this.hosts).forEach(function(key) {\n                    delete this.hosts[key]._sortingId;\n                }, this);\n            }\n        }\n    ]);\n    return Shadows1;\n}();\nfunction sortShadowed(elements, context, sortElements2) {\n    var shadows = new Shadows(context, sortElements2);\n    var _elements = shadows.extractElements(elements);\n    if (_elements.length === elements.length) {\n        // no shadowed content found, no need to continue\n        return sortElements2(elements);\n    }\n    return shadows.sort(_elements);\n}\nfunction sortTabindex(elements) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex\n    // elements with tabIndex \"0\" (including tabbableElements without tabIndex) should be navigated in the order they appear.\n    // elements with a positive tabIndex:\n    //   Elements that have identical tabIndexes should be navigated in the order they appear.\n    //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.\n    // NOTE: sort implementation may be unstable and thus mess up DOM order,\n    // that's why we build a map that's being sorted instead. If we were able to rely\n    // on a stable sorting algorithm, sortTabindex() could be as simple as\n    // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });\n    // at this time Chrome does not use a stable sorting algorithm\n    // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability\n    // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition\n    var map = {};\n    var indexes = [];\n    var normal = elements.filter(function(element) {\n        // in Trident and Gecko SVGElement does not know about the tabIndex property\n        var tabIndex = element.tabIndex;\n        if (tabIndex === undefined) {\n            tabIndex = tabindexValue(element);\n        }\n        // extract elements that don't need sorting\n        if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {\n            return true;\n        }\n        if (!map[tabIndex]) {\n            // create sortable bucket for dom-order-preservation of elements with the same tabIndex\n            map[tabIndex] = [];\n            // maintain a list of unique tabIndexes\n            indexes.push(tabIndex);\n        }\n        // sort element into the proper bucket\n        map[tabIndex].push(element);\n        // element moved to sorting map, so not \"normal\" anymore\n        return false;\n    });\n    // sort the tabindex ascending,\n    // then resolve them to their appropriate buckets,\n    // then flatten the array of arrays to an array\n    var _elements = indexes.sort().map(function(tabIndex) {\n        return map[tabIndex];\n    }).reduceRight(function(previous, current) {\n        return current.concat(previous);\n    }, normal);\n    return _elements;\n}\nvar supports$8 = void 0;\nfunction moveContextToBeginning(elements, context) {\n    var pos = elements.indexOf(context);\n    if (pos > 0) {\n        var tmp = elements.splice(pos, 1);\n        return tmp.concat(elements);\n    }\n    return elements;\n}\nfunction sortElements(elements, _context) {\n    if (supports$8.tabsequenceAreaAtImgPosition) {\n        // Some browsers sort <area> in DOM order, some place the <area>s\n        // where the <img> referecing them would've been in DOM order.\n        // https://github.com/medialize/ally.js/issues/5\n        elements = sortArea(elements, _context);\n    }\n    elements = sortTabindex(elements);\n    return elements;\n}\nfunction queryTabsequence() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    if (!supports$8) {\n        supports$8 = _supports();\n    }\n    var _context = nodeArray(context)[0] || document.documentElement;\n    var elements = queryTabbable({\n        context: _context,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    });\n    if (document.body.createShadowRoot && platform.is.BLINK) {\n        // sort tabindex localized to shadow dom\n        // see https://github.com/medialize/ally.js/issues/6\n        elements = sortShadowed(elements, _context, sortElements);\n    } else {\n        elements = sortElements(elements, _context);\n    }\n    if (includeContext) {\n        // if we include the context itself, it has to be the first\n        // element of the sequence\n        elements = moveContextToBeginning(elements, _context);\n    }\n    return elements;\n}\n// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js\n// deliberately not exposing characters like <,.-#* because they vary *wildly*\n// across keyboard layouts and may cause various problems\n// (e.g. \"*\" is \"Shift +\" on a German Mac keyboard)\n// (e.g. \"@\" is \"Alt L\" on a German Mac keyboard)\nvar keycode = {\n    // Element Focus\n    tab: 9,\n    // Navigation\n    left: 37,\n    up: 38,\n    right: 39,\n    down: 40,\n    pageUp: 33,\n    \"page-up\": 33,\n    pageDown: 34,\n    \"page-down\": 34,\n    end: 35,\n    home: 36,\n    // Action\n    enter: 13,\n    escape: 27,\n    space: 32,\n    // Modifier\n    shift: 16,\n    capsLock: 20,\n    \"caps-lock\": 20,\n    ctrl: 17,\n    alt: 18,\n    meta: 91,\n    // in firefox: 224\n    // on mac (chrome): meta-left=91, meta-right=93\n    // on win (IE11): meta-left=91, meta-right=92\n    pause: 19,\n    // Content Manipulation\n    insert: 45,\n    delete: 46,\n    backspace: 8,\n    // the same logical key may be identified through different keyCodes\n    _alias: {\n        91: [\n            92,\n            93,\n            224\n        ]\n    }\n};\n// Function keys (112 - 137)\n// NOTE: not every keyboard knows F13+\nfor(var n = 1; n < 26; n++){\n    keycode[\"f\" + n] = n + 111;\n}\n// Number keys (48-57, numpad 96-105)\n// NOTE: not every keyboard knows num-0+\nfor(var _n = 0; _n < 10; _n++){\n    var code = _n + 48;\n    var numCode = _n + 96;\n    keycode[_n] = code;\n    keycode[\"num-\" + _n] = numCode;\n    keycode._alias[code] = [\n        numCode\n    ];\n}\n// Latin characters (65 - 90)\nfor(var _n2 = 0; _n2 < 26; _n2++){\n    var _code = _n2 + 65;\n    var name$1 = String.fromCharCode(_code).toLowerCase();\n    keycode[name$1] = _code;\n}\nvar modifier = {\n    alt: \"altKey\",\n    ctrl: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n};\nvar modifierSequence = Object.keys(modifier).map(function(name6) {\n    return modifier[name6];\n});\nfunction createExpectedModifiers(ignoreModifiers) {\n    var value = ignoreModifiers ? null : false;\n    return {\n        altKey: value,\n        ctrlKey: value,\n        metaKey: value,\n        shiftKey: value\n    };\n}\nfunction resolveModifiers(modifiers) {\n    var ignoreModifiers = modifiers.indexOf(\"*\") !== -1;\n    var expected = createExpectedModifiers(ignoreModifiers);\n    modifiers.forEach(function(token) {\n        if (token === \"*\") {\n            // we've already covered the all-in operator\n            return;\n        }\n        // we want the modifier pressed\n        var value = true;\n        var operator = token.slice(0, 1);\n        if (operator === \"?\") {\n            // we don't care if the modifier is pressed\n            value = null;\n        } else if (operator === \"!\") {\n            // we do not want the modifier pressed\n            value = false;\n        }\n        if (value !== true) {\n            // compensate for the modifier's operator\n            token = token.slice(1);\n        }\n        var propertyName = modifier[token];\n        if (!propertyName) {\n            throw new TypeError('Unknown modifier \"' + token + '\"');\n        }\n        expected[propertyName] = value;\n    });\n    return expected;\n}\nfunction resolveKey(key) {\n    var code = keycode[key] || parseInt(key, 10);\n    if (!code || typeof code !== \"number\" || isNaN(code)) {\n        throw new TypeError('Unknown key \"' + key + '\"');\n    }\n    return [\n        code\n    ].concat(keycode._alias[code] || []);\n}\nfunction matchModifiers(expected, event) {\n    // returns true on match\n    return !modifierSequence.some(function(prop) {\n        // returns true on mismatch\n        return typeof expected[prop] === \"boolean\" && Boolean(event[prop]) !== expected[prop];\n    });\n}\nfunction keyBinding(text) {\n    return text.split(/\\s+/).map(function(_text) {\n        var tokens = _text.split(\"+\");\n        var _modifiers = resolveModifiers(tokens.slice(0, -1));\n        var _keyCodes = resolveKey(tokens.slice(-1));\n        return {\n            keyCodes: _keyCodes,\n            modifiers: _modifiers,\n            matchModifiers: matchModifiers.bind(null, _modifiers)\n        };\n    });\n}\n// Node.compareDocumentPosition is available since IE9\n// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition\n// callback returns true when element is contained by parent or is the parent suited for use with Array.some()\n/*\n  USAGE:\n    var isChildOf = getParentComparator({parent: someNode});\n    listOfElements.some(isChildOf)\n*/ function getParentComparator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, parent = _ref.parent, element = _ref.element, includeSelf = _ref.includeSelf;\n    if (parent) {\n        return function isChildOf(node) {\n            return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n        };\n    } else if (element) {\n        return function isParentOf(node) {\n            return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n        };\n    }\n    throw new TypeError(\"util/compare-position#getParentComparator required either options.parent or options.element\");\n}\n// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933\nfunction whenKey() {\n    var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var bindings = {};\n    var context = nodeArray(map.context)[0] || document.documentElement;\n    delete map.context;\n    var filter = nodeArray(map.filter);\n    delete map.filter;\n    var mapKeys = Object.keys(map);\n    if (!mapKeys.length) {\n        throw new TypeError(\"when/key requires at least one option key\");\n    }\n    var registerBinding = function registerBinding(event) {\n        event.keyCodes.forEach(function(code) {\n            if (!bindings[code]) {\n                bindings[code] = [];\n            }\n            bindings[code].push(event);\n        });\n    };\n    mapKeys.forEach(function(text) {\n        if (typeof map[text] !== \"function\") {\n            throw new TypeError('when/key requires option[\"' + text + '\"] to be a function');\n        }\n        var addCallback = function addCallback(event) {\n            event.callback = map[text];\n            return event;\n        };\n        keyBinding(text).map(addCallback).forEach(registerBinding);\n    });\n    var handleKeyDown = function handleKeyDown(event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        if (filter.length) {\n            // ignore elements within the exempted sub-trees\n            var isParentOfElement = getParentComparator({\n                element: event.target,\n                includeSelf: true\n            });\n            if (filter.some(isParentOfElement)) {\n                return;\n            }\n        }\n        var key = event.keyCode || event.which;\n        if (!bindings[key]) {\n            return;\n        }\n        bindings[key].forEach(function(_event) {\n            if (!_event.matchModifiers(event)) {\n                return;\n            }\n            _event.callback.call(context, event, disengage);\n        });\n    };\n    context.addEventListener(\"keydown\", handleKeyDown, false);\n    var disengage = function disengage() {\n        context.removeEventListener(\"keydown\", handleKeyDown, false);\n    };\n    return {\n        disengage: disengage\n    };\n}\nfunction _default({ context  } = {}) {\n    if (!context) {\n        context = document.documentElement;\n    }\n    // Make sure the supports tests are run before intercepting the Tab key,\n    // or IE10 and IE11 will fail to process the first Tab key event. Not\n    // limiting this warm-up to IE because it may be a problem elsewhere, too.\n    queryTabsequence();\n    return whenKey({\n        // Safari on OSX may require ALT+TAB to reach links,\n        // see https://github.com/medialize/ally.js/issues/146\n        \"?alt+?shift+tab\": function altShiftTab(event) {\n            // we're completely taking over the Tab key handling\n            event.preventDefault();\n            var sequence = queryTabsequence({\n                context: context\n            });\n            var backward = event.shiftKey;\n            var first = sequence[0];\n            var last = sequence[sequence.length - 1];\n            // wrap around first to last, last to first\n            var source = backward ? first : last;\n            var target = backward ? last : first;\n            if (isActiveElement(source)) {\n                target.focus();\n                return;\n            }\n            // find current position in tabsequence\n            var currentIndex = void 0;\n            var found = sequence.some(function(element, index) {\n                if (!isActiveElement(element)) {\n                    return false;\n                }\n                currentIndex = index;\n                return true;\n            });\n            if (!found) {\n                // redirect to first as we're not in our tabsequence\n                first.focus();\n                return;\n            }\n            // shift focus to previous/next element in the sequence\n            var offset = backward ? -1 : 1;\n            sequence[currentIndex + offset].focus();\n        }\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=maintain--tab-focus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9tYWludGFpbi0tdGFiLWZvY3VzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCLElBQUlDLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlDLFlBQVlGLHlCQUF5QkMsbUJBQU9BLENBQUMsZ0VBQTZCO0FBQzlFLElBQUlFLGFBQWFILHlCQUF5QkMsbUJBQU9BLENBQUMsb0VBQStCO0FBQ2pGLHlGQUF5RjtBQUN6Riw2RUFBNkU7QUFDN0UsU0FBU0csVUFBVUMsS0FBSyxFQUFFO0lBQ3RCLElBQUksQ0FBQ0EsT0FBTztRQUNSLE9BQU8sRUFBRTtJQUNiLENBQUM7SUFDRCxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFFBQVE7UUFDdEIsT0FBT0E7SUFDWCxDQUFDO0lBQ0QsK0NBQStDO0lBQy9DLElBQUlBLE1BQU1HLFFBQVEsS0FBS0MsV0FBVztRQUM5QixPQUFPO1lBQ0hKO1NBQ0g7SUFDTCxDQUFDO0lBQ0QsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0JBLFFBQVFLLFNBQVNDLGdCQUFnQixDQUFDTjtJQUN0QyxDQUFDO0lBQ0QsSUFBSUEsTUFBTU8sTUFBTSxLQUFLSCxXQUFXO1FBQzVCLE9BQU8sRUFBRSxDQUFDSSxLQUFLLENBQUNDLElBQUksQ0FBQ1QsT0FBTztJQUNoQyxDQUFDO0lBQ0QsTUFBTSxJQUFJVSxVQUFVLHNCQUFzQkMsT0FBT1gsUUFBUTtBQUM3RDtBQUNBLFNBQVNZLGlCQUFpQkMsSUFBSSxFQUFFO0lBQzVCLElBQUlDLFVBQVVELEtBQUtDLE9BQU8sRUFBRUMsYUFBYUYsS0FBS0csS0FBSyxFQUFFQSxRQUFRRCxlQUFlWCxZQUFZLHVCQUF1Qlcs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QUk7WUFDcEMsSUFBSXpZLFNBQVN1WSxXQUFXRSxPQUFPRCxLQUFLO1lBQ3BDLElBQUkvZ0IsZ0JBQWdCaWhCLFNBQVM7Z0JBQ3pCMVksT0FBT3ZFLEtBQUs7Z0JBQ1o7WUFDSixDQUFDO1lBQ0QsdUNBQXVDO1lBQ3ZDLElBQUlrZCxlQUFlLEtBQUs7WUFDeEIsSUFBSUMsUUFBUU4sU0FBU2xnQixJQUFJLENBQUMsU0FBU3pCLE9BQU8sRUFBRWtpQixLQUFLLEVBQUU7Z0JBQy9DLElBQUksQ0FBQ3BoQixnQkFBZ0JkLFVBQVU7b0JBQzNCLE9BQU8sS0FBSztnQkFDaEIsQ0FBQztnQkFDRGdpQixlQUFlRTtnQkFDZixPQUFPLElBQUk7WUFDZjtZQUNBLElBQUksQ0FBQ0QsT0FBTztnQkFDUixvREFBb0Q7Z0JBQ3BESixNQUFNL2MsS0FBSztnQkFDWDtZQUNKLENBQUM7WUFDRCx1REFBdUQ7WUFDdkQsSUFBSXdNLFNBQVNzUSxXQUFXLENBQUMsSUFBSSxDQUFDO1lBQzlCRCxRQUFRLENBQUNLLGVBQWUxUSxPQUFPLENBQUN4TSxLQUFLO1FBQ3pDO0lBQ0o7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPMUcsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDNmpCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLamtCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9ra0IsTUFBTSxDQUFDaGtCLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0Jpa0IsT0FBT2prQixPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9tYWludGFpbi0tdGFiLWZvY3VzLmpzPzgyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcGxhdGZvcm0gPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wbGF0Zm9ybVwiKSk7XG52YXIgX2Nzc0VzY2FwZSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy5lc2NhcGVcIikpO1xuLy8gaW5wdXQgbWF5IGJlIHVuZGVmaW5lZCwgc2VsZWN0b3ItdHJpbmcsIE5vZGUsIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiwgYXJyYXkgb2YgTm9kZXNcbi8vIHllcywgdG8gc29tZSBleHRlbnQgdGhpcyBpcyBhIGJhZCByZXBsaWNhIG9mIGpRdWVyeSdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG5mdW5jdGlvbiBub2RlQXJyYXkoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgLy8gaW5zdGFuY2VvZiBOb2RlIC0gZG9lcyBub3Qgd29yayB3aXRoIGlmcmFtZXNcbiAgICBpZiAoaW5wdXQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGlucHV0LCAwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCBpbnB1dCAnICsgU3RyaW5nKGlucHV0KSk7XG59XG5mdW5jdGlvbiBjb250ZXh0VG9FbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRsYWJlbCA9IF9yZWYubGFiZWwsIGxhYmVsID0gX3JlZiRsYWJlbCA9PT0gdW5kZWZpbmVkID8gJ2NvbnRleHQtdG8tZWxlbWVudCcgOiBfcmVmJGxhYmVsLCByZXNvbHZlRG9jdW1lbnQgPSBfcmVmLnJlc29sdmVEb2N1bWVudCwgZGVmYXVsdFRvRG9jdW1lbnQgPSBfcmVmLmRlZmF1bHRUb0RvY3VtZW50O1xuICAgIHZhciBlbGVtZW50ID0gbm9kZUFycmF5KGNvbnRleHQpWzBdO1xuICAgIGlmIChyZXNvbHZlRG9jdW1lbnQgJiYgZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQgJiYgZGVmYXVsdFRvRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobGFiZWwgKyAnIHJlcXVpcmVzIHZhbGlkIG9wdGlvbnMuY29udGV4dCcpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobGFiZWwgKyAnIHJlcXVpcmVzIG9wdGlvbnMuY29udGV4dCB0byBiZSBhbiBFbGVtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0U2hhZG93SG9zdCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdnZXQvc2hhZG93LWhvc3QnLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgLy8gd2FsayB1cCB0byB0aGUgcm9vdFxuICAgIHZhciBjb250YWluZXIgPSBudWxsO1xuICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICBjb250YWluZXIgPSBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5ub2RlVHlwZVxuICAgIC8vIE5PVEU6IEZpcmVmb3ggMzQgZG9lcyBub3QgZXhwb3NlIFNoYWRvd1Jvb3QuaG9zdCAoYnV0IDM3IGRvZXMpXG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gY29udGFpbmVyLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgY29udGFpbmVyLmhvc3QpIHtcbiAgICAgICAgLy8gdGhlIHJvb3QgaXMgYXR0YWNoZWQgdG8gYSBmcmFnbWVudCBub2RlIHRoYXQgaGFzIGEgaG9zdFxuICAgICAgICByZXR1cm4gY29udGFpbmVyLmhvc3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0FjdGl2ZUVsZW1lbnQoY29udGV4dCkge1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvYWN0aXZlLWVsZW1lbnQnLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICB2YXIgX2RvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgc2hhZG93SG9zdCA9IGdldFNoYWRvd0hvc3Qoe1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKHNoYWRvd0hvc3QgJiYgc2hhZG93SG9zdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFtlbGVtLCBlbGVtLnBhcmVudCwgZWxlbS5wYXJlbnQucGFyZW50LCDigKYsIGh0bWxdXG4vLyB3aWxsIG5vdCBjb250YWluIHRoZSBzaGFkb3dSb290IChET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSBhbmQgc2hhZG93SG9zdFxuZnVuY3Rpb24gZ2V0UGFyZW50cygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2dldC9wYXJlbnRzJyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICBsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgIC8vIElFIGRvZXMga25vdyBzdXBwb3J0IHBhcmVudEVsZW1lbnQgb24gU1ZHRWxlbWVudFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vLyBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIG1heSBiZSBhdmFpbGFibGUgYXQgYSBkaWZmZXJlbnQgbmFtZVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlc1xudmFyIG5hbWVzID0gW1xuICAgICdtYXRjaGVzJyxcbiAgICAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJyxcbiAgICAnbW96TWF0Y2hlc1NlbGVjdG9yJyxcbiAgICAnbXNNYXRjaGVzU2VsZWN0b3InLCBcbl07XG52YXIgbmFtZSA9IG51bGw7XG5mdW5jdGlvbiBmaW5kTWV0aG9kTmFtZShlbGVtZW50KSB7XG4gICAgbmFtZXMuc29tZShmdW5jdGlvbihfbmFtZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnRbX25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IF9uYW1lO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yMSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICBmaW5kTWV0aG9kTmFtZShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRbbmFtZV0oc2VsZWN0b3IxKTtcbn1cbi8vIGRlZXAgY2xvbmUgb2Ygb3JpZ2luYWwgcGxhdGZvcm1cbnZhciBwbGF0Zm9ybSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX3BsYXRmb3JtLmRlZmF1bHQpKTtcbi8vIG9wZXJhdGluZyBzeXN0ZW1cbnZhciBvcyA9IHBsYXRmb3JtLm9zLmZhbWlseSB8fCAnJztcbnZhciBBTkRST0lEID0gb3MgPT09ICdBbmRyb2lkJztcbnZhciBXSU5ET1dTID0gb3Muc2xpY2UoMCwgNykgPT09ICdXaW5kb3dzJztcbnZhciBPU1ggPSBvcyA9PT0gJ09TIFgnO1xudmFyIElPUyA9IG9zID09PSAnaU9TJztcbi8vIGxheW91dFxudmFyIEJMSU5LID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnQmxpbmsnO1xudmFyIEdFQ0tPID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnR2Vja28nO1xudmFyIFRSSURFTlQgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdUcmlkZW50JztcbnZhciBFREdFID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnRWRnZUhUTUwnO1xudmFyIFdFQktJVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gJ1dlYktpdCc7XG4vLyBicm93c2VyIHZlcnNpb24gKG5vdCBsYXlvdXQgZW5naW5lIHZlcnNpb24hKVxudmFyIHZlcnNpb24gPSBwYXJzZUZsb2F0KHBsYXRmb3JtLnZlcnNpb24pO1xudmFyIG1ham9yVmVyc2lvbiA9IE1hdGguZmxvb3IodmVyc2lvbik7XG5wbGF0Zm9ybS5tYWpvclZlcnNpb24gPSBtYWpvclZlcnNpb247XG5wbGF0Zm9ybS5pcyA9IHtcbiAgICAvLyBvcGVyYXRpbmcgc3lzdGVtXG4gICAgQU5EUk9JRDogQU5EUk9JRCxcbiAgICBXSU5ET1dTOiBXSU5ET1dTLFxuICAgIE9TWDogT1NYLFxuICAgIElPUzogSU9TLFxuICAgIC8vIGxheW91dFxuICAgIEJMSU5LOiBCTElOSyxcbiAgICBHRUNLTzogR0VDS08sXG4gICAgVFJJREVOVDogVFJJREVOVCxcbiAgICBFREdFOiBFREdFLFxuICAgIFdFQktJVDogV0VCS0lULFxuICAgIC8vIElOVEVSTkVUIEVYUExPUkVSU1xuICAgIElFOTogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDksXG4gICAgSUUxMDogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDEwLFxuICAgIElFMTE6IFRSSURFTlQgJiYgbWFqb3JWZXJzaW9uID09PSAxMVxufTtcbmZ1bmN0aW9uIGJlZm9yZSgpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgLy8gcmVtZW1iZXIgd2hhdCBoYWQgZm9jdXMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgIC8vIHJlbWVtYmVyIHNjcm9sbCBwb3NpdGlvbnMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XG4gICAgICAgIHdpbmRvd1Njcm9sbFRvcDogd2luZG93LnNjcm9sbFRvcCxcbiAgICAgICAgd2luZG93U2Nyb2xsTGVmdDogd2luZG93LnNjcm9sbExlZnQsXG4gICAgICAgIGJvZHlTY3JvbGxUb3A6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICBib2R5U2Nyb2xsTGVmdDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XG4gICAgfTtcbiAgICAvLyB3cmFwIHRlc3RzIGluIGFuIGVsZW1lbnQgaGlkZGVuIGZyb20gc2NyZWVuIHJlYWRlcnMgdG8gcHJldmVudCB0aGVtXG4gICAgLy8gZnJvbSBhbm5vdW5jaW5nIGZvY3VzLCB3aGljaCBjYW4gYmUgcXVpdGUgaXJyaXRhdGluZyB0byB0aGUgdXNlclxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdwb3NpdGlvbjphYnNvbHV0ZTsgcG9zaXRpb246Zml4ZWQ7IHRvcDowOyBsZWZ0Oi0ycHg7IHdpZHRoOjFweDsgaGVpZ2h0OjFweDsgb3ZlcmZsb3c6aGlkZGVuOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCAndHJ1ZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdmFyIF93aW5kb3cgPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgX2RvY3VtZW50ID0gX3dpbmRvdy5kb2N1bWVudDtcbiAgICBfZG9jdW1lbnQub3BlbigpO1xuICAgIF9kb2N1bWVudC5jbG9zZSgpO1xuICAgIHZhciB3cmFwcGVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgIGRhdGEuaWZyYW1lID0gaWZyYW1lO1xuICAgIGRhdGEud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgZGF0YS53aW5kb3cgPSBfd2luZG93O1xuICAgIGRhdGEuZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBvcHRpb25zLmVsZW1lbnQ6XG4vLyAge3N0cmluZ30gZWxlbWVudCBuYW1lXG4vLyAge2Z1bmN0aW9ufSBjYWxsYmFjayh3cmFwcGVyLCBkb2N1bWVudCkgdG8gZ2VuZXJhdGUgYW4gZWxlbWVudFxuLy8gb3B0aW9ucy5tdXRhdGU6IChvcHRpb25hbClcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKGVsZW1lbnQsIHdyYXBwZXIsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIGVsZW1lbnQgcHJpb3IgdG8gZm9jdXMtdGVzdC5cbi8vICAgICAgICAgICAgIENhbiByZXR1cm4gRE9NRWxlbWVudCB0byBkZWZpbmUgZm9jdXMgdGFyZ2V0IChkZWZhdWx0OiBlbGVtZW50KVxuLy8gb3B0aW9ucy52YWxpZGF0ZTogKG9wdGlvbmFsKVxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2soZWxlbWVudCwgZm9jdXNUYXJnZXQsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIHRlc3QtcmVzdWx0XG5mdW5jdGlvbiB0ZXN0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBtYWtlIHN1cmUgd2Ugb3BlcmF0ZSBvbiBhIGNsZWFuIHNsYXRlXG4gICAgZGF0YS53cmFwcGVyLmlubmVySFRNTCA9ICcnO1xuICAgIC8vIGNyZWF0ZSBkdW1teSBlbGVtZW50IHRvIHRlc3QgZm9jdXNhYmlsaXR5IG9mXG4gICAgdmFyIGVsZW1lbnQgPSB0eXBlb2Ygb3B0aW9ucy5lbGVtZW50ID09PSAnc3RyaW5nJyA/IGRhdGEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvcHRpb25zLmVsZW1lbnQpIDogb3B0aW9ucy5lbGVtZW50KGRhdGEud3JhcHBlciwgZGF0YS5kb2N1bWVudCk7XG4gICAgLy8gYWxsb3cgY2FsbGJhY2sgdG8gZnVydGhlciBzcGVjaWZ5IGR1bW15IGVsZW1lbnRcbiAgICAvLyBhbmQgb3B0aW9uYWxseSBkZWZpbmUgZWxlbWVudCB0byBmb2N1c1xuICAgIHZhciBmb2N1czEgPSBvcHRpb25zLm11dGF0ZSAmJiBvcHRpb25zLm11dGF0ZShlbGVtZW50LCBkYXRhLndyYXBwZXIsIGRhdGEuZG9jdW1lbnQpO1xuICAgIGlmICghZm9jdXMxICYmIGZvY3VzMSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZm9jdXMxID0gZWxlbWVudDtcbiAgICB9XG4gICAgLy8gZWxlbWVudCBuZWVkcyB0byBiZSBwYXJ0IG9mIHRoZSBET00gdG8gYmUgZm9jdXNhYmxlXG4gICAgIWVsZW1lbnQucGFyZW50Tm9kZSAmJiBkYXRhLndyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgLy8gdGVzdCBpZiB0aGUgZWxlbWVudCB3aXRoIGludmFsaWQgdGFiaW5kZXggY2FuIGJlIGZvY3VzZWRcbiAgICBmb2N1czEgJiYgZm9jdXMxLmZvY3VzICYmIGZvY3VzMS5mb2N1cygpO1xuICAgIC8vIHZhbGlkYXRlIHRlc3QncyByZXN1bHRcbiAgICByZXR1cm4gb3B0aW9ucy52YWxpZGF0ZSA/IG9wdGlvbnMudmFsaWRhdGUoZWxlbWVudCwgZm9jdXMxLCBkYXRhLmRvY3VtZW50KSA6IGRhdGEuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXMxO1xufVxuZnVuY3Rpb24gYWZ0ZXIoZGF0YSkge1xuICAgIC8vIHJlc3RvcmUgZm9jdXMgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHRlc3QgYW5kIGNsZWFudXBcbiAgICBpZiAoZGF0YS5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICBpZiAocGxhdGZvcm0uaXMuSUUxMCkge1xuICAgICAgICAgICAgLy8gSUUxMCBkb2VzIG5vdCByZWRpcmVjdCBmb2N1cyB0byA8Ym9keT4gd2hlbiB0aGUgYWN0aXZlRWxlbWVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmFjdGl2ZUVsZW1lbnQgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzICYmIGRhdGEuYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRhdGEuaWZyYW1lKTtcbiAgICAvLyByZXN0b3JlIHNjcm9sbCBwb3NpdGlvblxuICAgIHdpbmRvdy5zY3JvbGxUb3AgPSBkYXRhLndpbmRvd1Njcm9sbFRvcDtcbiAgICB3aW5kb3cuc2Nyb2xsTGVmdCA9IGRhdGEud2luZG93U2Nyb2xsTGVmdDtcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IGRhdGEuYm9keVNjcm9sbFRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgPSBkYXRhLmJvZHlTY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gZGV0ZWN0Rm9jdXModGVzdHMpIHtcbiAgICB2YXIgZGF0YSA9IGJlZm9yZSgpO1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgT2JqZWN0LmtleXModGVzdHMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmVzdWx0c1trZXldID0gdGVzdChkYXRhLCB0ZXN0c1trZXldKTtcbiAgICB9KTtcbiAgICBhZnRlcihkYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8vIHRoaXMgZmlsZSBpcyBvdmVyd3JpdHRlbiBieSBgbnBtIHJ1biBidWlsZDpwcmVgXG52YXIgdmVyc2lvbiQxID0gJzEuNC4xJztcbi8qXG4gICAgRmFjaWxpdHkgdG8gY2FjaGUgdGVzdCByZXN1bHRzIGluIGxvY2FsU3RvcmFnZS5cblxuICAgIFVTQUdFOlxuICAgICAgY2FjaGUuZ2V0KCdrZXknKTtcbiAgICAgIGNhY2hlLnNldCgna2V5JywgJ3ZhbHVlJyk7XG4gKi8gZnVuY3Rpb24gcmVhZExvY2FsU3RvcmFnZShrZXkpIHtcbiAgICAvLyBhbGxvdyByZWFkaW5nIGZyb20gc3RvcmFnZSB0byByZXRyaWV2ZSBwcmV2aW91cyBzdXBwb3J0IHJlc3VsdHNcbiAgICAvLyBldmVuIHdoaWxlIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGRhdGEgPSBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIHdyaXRlTG9jYWxTdG9yYWdlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWRvY3VtZW50Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMgd2hlbiB0ZXN0cyBhcmUgZXhlY3V0ZWQsIGZvY3VzKCkgbWF5XG4gICAgICAgIC8vIG5vdCBiZSBoYW5kbGVkIHByb3Blcmx5IGFuZCBldmVudHMgbWF5IG5vdCBiZSBkaXNwYXRjaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGRvY3VtZW50IGlzIHJlbG9hZGVkIHdoaWxlIERldmVsb3BlciBUb29scyBoYXZlIGZvY3VzLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gICAgfVxufVxudmFyIHVzZXJBZ2VudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xudmFyIGNhY2hlS2V5ID0gJ2FsbHktc3VwcG9ydHMtY2FjaGUnO1xudmFyIGNhY2hlID0gcmVhZExvY2FsU3RvcmFnZShjYWNoZUtleSk7XG4vLyB1cGRhdGUgdGhlIGNhY2hlIGlmIGFsbHkgb3IgdGhlIHVzZXIgYWdlbnQgY2hhbmdlZCAobmV3ZXIgdmVyc2lvbiwgZXRjKVxuaWYgKGNhY2hlLnVzZXJBZ2VudCAhPT0gdXNlckFnZW50IHx8IGNhY2hlLnZlcnNpb24gIT09IHZlcnNpb24kMSkge1xuICAgIGNhY2hlID0ge307XG59XG5jYWNoZS51c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG5jYWNoZS52ZXJzaW9uID0gdmVyc2lvbiQxO1xudmFyIGNhY2hlJDEgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBjYWNoZVtrZXldID0gdmFsdWVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBjYWNoZS50aW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB3cml0ZUxvY2FsU3RvcmFnZShjYWNoZUtleSwgY2FjaGUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCkge1xuICAgIHZhciBjb21iaW5hdG9yID0gdm9pZCAwO1xuICAgIC8vIHNlZSBodHRwczovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXNjb3BpbmctMS8jZGVlcC1jb21iaW5hdG9yXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTExNzU3MlxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcbiAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sID4+PiA6Zmlyc3QtY2hpbGQnKTtcbiAgICAgICAgY29tYmluYXRvciA9ICc+Pj4nO1xuICAgIH0gY2F0Y2ggKG5vQXJyb3dBcnJvd0Fycm93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBvbGQgc3ludGF4IHN1cHBvcnRlZCBhdCBsZWFzdCB1cCB0byBDaHJvbWUgNDFcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZCcpO1xuICAgICAgICAgICAgY29tYmluYXRvciA9ICcvZGVlcC8nO1xuICAgICAgICB9IGNhdGNoIChub0RlZXApIHtcbiAgICAgICAgICAgIGNvbWJpbmF0b3IgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tYmluYXRvcjtcbn1cbnZhciBnaWYgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3Jztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbnZhciBmb2N1c0FyZWFJbWdUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JyArICc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiIHNyYz1cIicgKyBnaWYgKyAnXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgIH1cbn07XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNBcmVhVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPicgKyAnPGFyZWEgaHJlZj1cIiN2b2lkXCIgdGFiaW5kZXg9XCItMVwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICsgZ2lmICsgJ1wiPic7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuICAgICAgICAgICAgLy8gRmlyZWZveCBsb2FkcyB0aGUgRGF0YVVSSSBhc3luY2hyb25vdXNseSwgY2F1c2luZyBhIGZhbHNlLW5lZ2F0aXZlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9jdXMyID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgICAgIGZvY3VzMi5mb2N1cygpO1xuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzMjtcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxudmFyIGZvY3VzQXJlYVdpdGhvdXRIcmVmID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCI+JyArICc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC1hcmVhLWhyZWYtdGVzdFwiIGFsdD1cIlwiIHNyYz1cIicgKyBnaWYgKyAnXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4gICAgICAgICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNUYXJnZXQ7XG4gICAgfVxufTtcbnZhciBmb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID0ge1xuICAgIG5hbWU6ICdjYW4tZm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scycsXG4gICAgZWxlbWVudDogJ2F1ZGlvJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIG1lZGlhIGZpbGUgY2FuIHRyaWdnZXIgd2FybmluZyBpbiBjb25zb2xlLCBkYXRhLXVyaSB0byBwcmV2ZW50IEhUVFAgcmVxdWVzdFxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGdpZik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSUU5IG1heSB0aHJvdyBcIkVycm9yOiBOb3QgaW1wbGVtZW50ZWRcIlxuICAgICAgICB9XG4gICAgfVxufTtcbnZhciBpbnZhbGlkR2lmID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWic7XG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNCcm9rZW5JbWFnZU1hcCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImJyb2tlbi1pbWFnZS1tYXAtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIGludmFsaWRHaWYgKyAnXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgIH1cbn07XG4vLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXG52YXIgZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIj5oZWxsbzwvc3Bhbj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgfVxufTtcbi8vIGZpZWxkc2V0W3RhYmluZGV4PTBdW2Rpc2FibGVkXSBzaG91bGQgbm90IGJlIGZvY3VzYWJsZSwgYnV0IEJsaW5rIGFuZCBXZWJLaXQgZGlzYWdyZWVcbi8vIEBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxuLy8gQGJyb3dzZXItaXNzdWUgQ2hyb21pdW0gaHR0cHM6Ly9jcmJ1Zy5jb20vNDUzODQ3XG4vLyBAYnJvd3Nlci1pc3N1ZSBXZWJLaXQgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTA4NlxudmFyIGZvY3VzRmllbGRzZXREaXNhYmxlZCA9IHtcbiAgICBlbGVtZW50OiAnZmllbGRzZXQnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH1cbn07XG52YXIgZm9jdXNGaWVsZHNldCA9IHtcbiAgICBlbGVtZW50OiAnZmllbGRzZXQnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPic7XG4gICAgfVxufTtcbi8vIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxudmFyIGZvY3VzRmxleGJveENvbnRhaW5lciA9IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIj5oZWxsbzwvc3Bhbj4nO1xuICAgIH1cbn07XG4vLyBmb3JtW3RhYmluZGV4PTBdW2Rpc2FibGVkXSBzaG91bGQgYmUgZm9jdXNhYmxlIGFzIHRoZVxuLy8gc3BlY2lmaWNhdGlvbiBkb2Vzbid0IGtub3cgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSBvbiB0aGUgZm9ybSBlbGVtZW50XG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN0aGUtZm9ybS1lbGVtZW50XG52YXIgZm9jdXNGb3JtRGlzYWJsZWQgPSB7XG4gICAgZWxlbWVudDogJ2Zvcm0nLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH1cbn07XG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItaXNtYXBcbnZhciBmb2N1c0ltZ0lzbWFwID0ge1xuICAgIGVsZW1lbnQ6ICdhJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaHJlZiA9ICcjdm9pZCc7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxpbWcgaXNtYXAgc3JjPVwiJyArIGdpZiArICdcIiBhbHQ9XCJcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICB9XG59O1xuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxudmFyIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgJyArICdzcmM9XCInICsgZ2lmICsgJ1wiPic7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgIH1cbn07XG52YXIgZm9jdXNJbkhpZGRlbklmcmFtZSA9IHtcbiAgICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KHdyYXBwZXIsIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAvLyBpZnJhbWUgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gYmVmb3JlIGFjY2Vzc2luZyB0aGUgY29udGVudFdpbmRvdyBpcyBwb3NzaWJsZVxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lJ3MgZGVmYXVsdCBkb2N1bWVudCAoPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+KVxuICAgICAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gaWZyYW1lO1xuICAgIH0sXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoaWZyYW1lKSB7XG4gICAgICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgICB2YXIgaW5wdXQgPSBpZnJhbWVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpZnJhbWVEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGlmcmFtZSkge1xuICAgICAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgdmFyIGZvY3VzMyA9IGlmcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1czM7XG4gICAgfVxufTtcbnZhciByZXN1bHQgPSAhcGxhdGZvcm0uaXMuV0VCS0lUO1xuZnVuY3Rpb24gZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEZpcmVmb3ggYWxsb3dzICphbnkqIHZhbHVlIGFuZCB0cmVhdHMgaW52YWxpZCB2YWx1ZXMgbGlrZSB0YWJpbmRleD1cIi0xXCJcbi8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbnZhciBmb2N1c0ludmFsaWRUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICdpbnZhbGlkLXZhbHVlJyk7XG4gICAgfVxufTtcbnZhciBmb2N1c0xhYmVsVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogJ2xhYmVsJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICAgICAgLy8gZm9yY2UgbGF5b3V0IGluIENocm9tZSA0OSwgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IHdvbid0IGJlIGZvY3VzYWJsZVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqLyB2YXIgdmFyaWFibGVUb1ByZXZlbnREZWFkQ29kZUVsaW1pbmF0aW9uID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi8gZWxlbWVudC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgfVxufTtcbnZhciBzdmcgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGInICsgJ0c1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQnBaRDBpYzNabklqNDhkR1Y0ZENCNFBTSXhNQ0lnZVQwaU1qQWlJR2xrUFNKJyArICd6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT0nO1xuLy8gTm90ZTogSUUxMCBvbiBCcm93c2VyU3RhY2sgZG9lcyBub3QgbGlrZSB0aGlzIHRlc3RcbnZhciBmb2N1c09iamVjdFN2Z0hpZGRlbiA9IHtcbiAgICBlbGVtZW50OiAnb2JqZWN0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBzdmcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxufTtcbi8vIE5vdGU6IElFMTAgb24gQnJvd3NlclN0YWNrIGRvZXMgbm90IGxpa2UgdGhpcyB0ZXN0XG52YXIgZm9jdXNPYmplY3RTdmcgPSB7XG4gICAgbmFtZTogJ2Nhbi1mb2N1cy1vYmplY3Qtc3ZnJyxcbiAgICBlbGVtZW50OiAnb2JqZWN0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBzdmcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBiZSBoYW5kbGluZyB0aGUgb2JqZWN0IGNyZWF0aW9uIGFzeW5jaHJvbm91c2x5IGFuZCB0aGVyZWJ5IHByb2R1Y2VzIGEgZmFsc2UgbmVnYXRpdmUgdGVzdCByZXN1bHQuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGtub3cgRmlyZWZveCBpcyBhYmxlIHRvIGZvY3VzIG9iamVjdCBlbGVtZW50cyByZWZlcmVuY2luZyBTVkdzLCB3ZSBzaW1wbHkgY2hlYXQgYnkgc25pZmZpbmcgdGhlIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgfVxufTtcbi8vIEV2ZXJ5IEVudmlyb25tZW50IGV4Y2VwdCBJRTkgY29uc2lkZXJzIFNXRiBvYmplY3RzIGZvY3VzYWJsZVxudmFyIHJlc3VsdCQxID0gIXBsYXRmb3JtLmlzLklFOTtcbmZ1bmN0aW9uIGZvY3VzT2JqZWN0U3dmKCkge1xuICAgIHJldHVybiByZXN1bHQkMTtcbn1cbnZhciBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiIGFsdD1cIlwiICcgKyAnc3JjPVwiJyArIGdpZiArICdcIj4nO1xuICAgICAgICAvLyBmb2N1cyB0aGUgPGltZz4sIG5vdCB0aGUgPGRpdj5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0O1xuICAgIH1cbn07XG4vLyBzZWUgaHR0cHM6Ly9qc2Jpbi5jb20vbmVuaXJpc2FnZS9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbnZhciBmb2N1c1JlZGlyZWN0TGVnZW5kID0ge1xuICAgIGVsZW1lbnQ6ICdmaWVsZHNldCcsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7XG4gICAgICAgIC8vIHRha2UgY2FyZSBvZiBmb2N1cyBpbiB2YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgZm9jdXNhYmxlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIi0xXCJdJyk7XG4gICAgICAgIHZhciB0YWJiYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhpcyB0ZXN0IHRvIGZvY3VzIHRoZSA8ZmllbGRzZXQ+IGZpcnN0LCB3aGlsZSB0aGlzIGlzIG5vdCBuZWNlc3NhcnkgaW5cbiAgICAgICAgLy8gaHR0cHM6Ly9qc2Jpbi5jb20vbmVuaXJpc2FnZS9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xlZ2VuZCcpLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNhYmxlICYmICdmb2N1c2FibGUnIHx8IF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0YWJiYWJsZSAmJiAndGFiYmFibGUnIHx8ICcnO1xuICAgIH1cbn07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG52YXIgZm9jdXNTY3JvbGxCb2R5ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIH1cbn07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG52YXIgZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3cgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7Jyk7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xuICAgIH1cbn07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG52YXIgZm9jdXNTY3JvbGxDb250YWluZXIgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvOycpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgICB9XG59O1xudmFyIGZvY3VzU3VtbWFyeSA9IHtcbiAgICBlbGVtZW50OiAnZGV0YWlscycsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3VtbWFyeT5mb288L3N1bW1hcnk+PHA+Y29udGVudDwvcD4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG59O1xuZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKSB7XG4gICAgLy8gQ29uc3RydWN0cyA8Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIj48aW5wdXQgdHlwZT1cInRleHRcIi8+PC9mb3JlaWduT2JqZWN0PlxuICAgIC8vIHdpdGhvdXQgcmFpc2luZyBhIFRydXN0ZWQgVHlwZXMgdmlvbGF0aW9uXG4gICAgdmFyIGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICBmb3JlaWduT2JqZWN0LndpZHRoLmJhc2VWYWwudmFsdWUgPSAzMDtcbiAgICBmb3JlaWduT2JqZWN0LmhlaWdodC5iYXNlVmFsLnZhbHVlID0gMzA7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpKTtcbiAgICBmb3JlaWduT2JqZWN0Lmxhc3RDaGlsZC50eXBlID0gJ3RleHQnO1xuICAgIHJldHVybiBmb3JlaWduT2JqZWN0O1xufVxuZnVuY3Rpb24gZm9jdXNTdmdGb3JlaWduT2JqZWN0SGFjayhlbGVtZW50KSB7XG4gICAgLy8gRWRnZTEzLCBFZGdlMTQ6IGZvcmVpZ25PYmplY3QgZm9jdXMgaGFja1xuICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL2t1bmVoaW51Z2kvZWRpdD9odG1sLGpzLG91dHB1dFxuICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL2ZhamFnaS8zL2VkaXQ/aHRtbCxqcyxvdXRwdXRcbiAgICB2YXIgaXNTdmdFbGVtZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcbiAgICBpZiAoIWlzU3ZnRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGluamVjdCBhbmQgZm9jdXMgYW4gPGlucHV0PiBlbGVtZW50IGludG8gdGhlIFNWRyBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICB2YXIgZm9yZWlnbk9iamVjdCA9IG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICB2YXIgaW5wdXQgPSBmb3JlaWduT2JqZWN0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgaW5wdXQuZm9jdXMoKTtcbiAgICAvLyB1cG9uIGRpc2FibGluZyB0aGUgYWN0aXZlRWxlbWVudCwgSUUgYW5kIEVkZ2VcbiAgICAvLyB3aWxsIG5vdCBzaGlmdCBmb2N1cyB0byA8Ym9keT4gbGlrZSBhbGwgdGhlIG90aGVyXG4gICAgLy8gYnJvd3NlcnMsIGJ1dCBpbnN0ZWFkIGZpbmQgdGhlIGZpcnN0IGZvY3VzYWJsZVxuICAgIC8vIGFuY2VzdG9yIGFuZCBzaGlmdCBmb2N1cyB0byB0aGF0XG4gICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgIC8vIGNsZWFuIHVwXG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPicgKyBlbGVtZW50ICsgJzwvc3ZnPic7XG59XG5mdW5jdGlvbiBmb2N1cyhlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbChlbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZvY3VzU3ZnRm9yZWlnbk9iamVjdEhhY2soZWxlbWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIGZvY3VzKGZvY3VzVGFyZ2V0KTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xufVxudmFyIGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPHRleHQgZm9jdXNhYmxlPVwidHJ1ZVwiPmE8L3RleHQ+Jyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHQnKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbnZhciBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPHRleHQgdGFiaW5kZXg9XCIwXCI+YTwvdGV4dD4nKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoJzx0ZXh0IHRhYmluZGV4PVwiLTFcIj5hPC90ZXh0PicpO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0Jyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG52YXIgZm9jdXNTdmdVc2VUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoW1xuICAgICAgICAgICAgJzxnIGlkPVwiYWxseS10ZXN0LXRhcmdldFwiPjxhIHhsaW5rOmhyZWY9XCIjdm9pZFwiPjx0ZXh0Pmxpbms8L3RleHQ+PC9hPjwvZz4nLFxuICAgICAgICAgICAgJzx1c2UgeGxpbms6aHJlZj1cIiNhbGx5LXRlc3QtdGFyZ2V0XCIgeD1cIjBcIiB5PVwiMFwiIHRhYmluZGV4PVwiLTFcIiAvPicsIFxuICAgICAgICBdLmpvaW4oJycpKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndXNlJyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG52YXIgZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGdlbmVyYXRlKCc8Zm9yZWlnbk9iamVjdCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz48L2ZvcmVpZ25PYmplY3Q+Jyk7XG4gICAgICAgIC8vIFNhZmFyaSA4J3MgcXVlcnNTZWxlY3RvcigpIGNhbid0IGlkZW50aWZ5IGZvcmVpZ25PYmplY3QsIGJ1dCBnZXRFbGVtZW50eUJ5VGFnTmFtZSgpIGNhblxuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdmb3JlaWduT2JqZWN0JykgfHwgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9yZWlnbk9iamVjdCcpWzBdO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xuLy8gRmlyZWZveCBzZWVtcyB0byBiZSBoYW5kbGluZyB0aGUgU1ZHLWRvY3VtZW50LWluLWlmcmFtZSBjcmVhdGlvbiBhc3luY2hyb25vdXNseVxuLy8gYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC4gVGh1cyB0aGUgdGVzdCBpcyBwb2ludGxlc3Ncbi8vIGFuZCB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmcgb25jZSBhZ2Fpbi5cbi8vIHNlZSBodHRwOi8vanNiaW4uY29tL3Z1bmFkb2hva28vMS9lZGl0P2pzLGNvbnNvbGUsb3V0cHV0XG52YXIgcmVzdWx0JDIgPSBCb29sZWFuKHBsYXRmb3JtLmlzLkdFQ0tPICYmIHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7XG5mdW5jdGlvbiBmb2N1c1N2Z0luSWZyYW1lKCkge1xuICAgIHJldHVybiByZXN1bHQkMjtcbn1cbnZhciBmb2N1c1N2ZyA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoJycpO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5maXJzdENoaWxkO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xuLy8gRmlyZWZveCBhbGxvd3MgKmFueSogdmFsdWUgYW5kIHRyZWF0cyBpbnZhbGlkIHZhbHVlcyBsaWtlIHRhYmluZGV4PVwiLTFcIlxuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxudmFyIGZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnM3gnKTtcbiAgICB9XG59O1xudmFyIGZvY3VzVGFibGUgPSB7XG4gICAgZWxlbWVudDogJ3RhYmxlJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50LCB3cmFwcGVyLCBfZG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSUU5IGhhcyBhIHByb2JsZW0gcmVwbGFjaW5nIFRCT0RZIGNvbnRlbnRzIHdpdGggaW5uZXJIVE1MLlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA5NzA1NS81MTUxMjRcbiAgICAgICAgLy8gZWxlbWVudC5pbm5lckhUTUwgPSAnPHRyPjx0ZD5jZWxsPC90ZD48L3RyPic7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWdtZW50LmlubmVySFRNTCA9ICc8dHI+PHRkPmNlbGw8L3RkPjwvdHI+JztcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgfVxufTtcbnZhciBmb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID0ge1xuICAgIGVsZW1lbnQ6ICd2aWRlbycsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBtZWRpYSBmaWxlIGNhbiB0cmlnZ2VyIHdhcm5pbmcgaW4gY29uc29sZSwgZGF0YS11cmkgdG8gcHJldmVudCBIVFRQIHJlcXVlc3RcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBnaWYpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyBodHRwczovL2pzYmluLmNvbS92YWZhYmEvMy9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbnZhciByZXN1bHQkMyA9IHBsYXRmb3JtLmlzLkdFQ0tPIHx8IHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRTtcbmZ1bmN0aW9uIHRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHJlc3VsdCQzO1xufVxudmFyIHRlc3RDYWxsYmFja3MgPSB7XG4gICAgY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjogY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcixcbiAgICBmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDogZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QsXG4gICAgZm9jdXNPYmplY3RTd2Y6IGZvY3VzT2JqZWN0U3dmLFxuICAgIGZvY3VzU3ZnSW5JZnJhbWU6IGZvY3VzU3ZnSW5JZnJhbWUsXG4gICAgdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjogdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvblxufTtcbnZhciB0ZXN0RGVzY3JpcHRpb25zID0ge1xuICAgIGZvY3VzQXJlYUltZ1RhYmluZGV4OiBmb2N1c0FyZWFJbWdUYWJpbmRleCxcbiAgICBmb2N1c0FyZWFUYWJpbmRleDogZm9jdXNBcmVhVGFiaW5kZXgsXG4gICAgZm9jdXNBcmVhV2l0aG91dEhyZWY6IGZvY3VzQXJlYVdpdGhvdXRIcmVmLFxuICAgIGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM6IGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMsXG4gICAgZm9jdXNCcm9rZW5JbWFnZU1hcDogZm9jdXNCcm9rZW5JbWFnZU1hcCxcbiAgICBmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94OiBmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94LFxuICAgIGZvY3VzRmllbGRzZXREaXNhYmxlZDogZm9jdXNGaWVsZHNldERpc2FibGVkLFxuICAgIGZvY3VzRmllbGRzZXQ6IGZvY3VzRmllbGRzZXQsXG4gICAgZm9jdXNGbGV4Ym94Q29udGFpbmVyOiBmb2N1c0ZsZXhib3hDb250YWluZXIsXG4gICAgZm9jdXNGb3JtRGlzYWJsZWQ6IGZvY3VzRm9ybURpc2FibGVkLFxuICAgIGZvY3VzSW1nSXNtYXA6IGZvY3VzSW1nSXNtYXAsXG4gICAgZm9jdXNJbWdVc2VtYXBUYWJpbmRleDogZm9jdXNJbWdVc2VtYXBUYWJpbmRleCxcbiAgICBmb2N1c0luSGlkZGVuSWZyYW1lOiBmb2N1c0luSGlkZGVuSWZyYW1lLFxuICAgIGZvY3VzSW52YWxpZFRhYmluZGV4OiBmb2N1c0ludmFsaWRUYWJpbmRleCxcbiAgICBmb2N1c0xhYmVsVGFiaW5kZXg6IGZvY3VzTGFiZWxUYWJpbmRleCxcbiAgICBmb2N1c09iamVjdFN2ZzogZm9jdXNPYmplY3RTdmcsXG4gICAgZm9jdXNPYmplY3RTdmdIaWRkZW46IGZvY3VzT2JqZWN0U3ZnSGlkZGVuLFxuICAgIGZvY3VzUmVkaXJlY3RJbWdVc2VtYXA6IGZvY3VzUmVkaXJlY3RJbWdVc2VtYXAsXG4gICAgZm9jdXNSZWRpcmVjdExlZ2VuZDogZm9jdXNSZWRpcmVjdExlZ2VuZCxcbiAgICBmb2N1c1Njcm9sbEJvZHk6IGZvY3VzU2Nyb2xsQm9keSxcbiAgICBmb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzogZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3csXG4gICAgZm9jdXNTY3JvbGxDb250YWluZXI6IGZvY3VzU2Nyb2xsQ29udGFpbmVyLFxuICAgIGZvY3VzU3VtbWFyeTogZm9jdXNTdW1tYXJ5LFxuICAgIGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlOiBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSxcbiAgICBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlOiBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlLFxuICAgIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTogZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlLFxuICAgIGZvY3VzU3ZnVXNlVGFiaW5kZXg6IGZvY3VzU3ZnVXNlVGFiaW5kZXgsXG4gICAgZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg6IGZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4LFxuICAgIGZvY3VzU3ZnOiBmb2N1c1N2ZyxcbiAgICBmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzOiBmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzLFxuICAgIGZvY3VzVGFibGU6IGZvY3VzVGFibGUsXG4gICAgZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczogZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sc1xufTtcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cygpIHtcbiAgICB2YXIgcmVzdWx0cyA9IGRldGVjdEZvY3VzKHRlc3REZXNjcmlwdGlvbnMpO1xuICAgIE9iamVjdC5rZXlzKHRlc3RDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IHRlc3RDYWxsYmFja3Nba2V5XSgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxudmFyIHN1cHBvcnRzQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gX3N1cHBvcnRzKCkge1xuICAgIGlmIChzdXBwb3J0c0NhY2hlKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0NhY2hlO1xuICAgIH1cbiAgICBzdXBwb3J0c0NhY2hlID0gY2FjaGUkMS5nZXQoKTtcbiAgICBpZiAoIXN1cHBvcnRzQ2FjaGUudGltZSkge1xuICAgICAgICBjYWNoZSQxLnNldChleGVjdXRlVGVzdHMoKSk7XG4gICAgICAgIHN1cHBvcnRzQ2FjaGUgPSBjYWNoZSQxLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcbn1cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3J1bGVzLWZvci1wYXJzaW5nLWludGVnZXJzXG4vLyBOT1RFOiBhbGwgYnJvd3NlcnMgYWdyZWUgdG8gYWxsb3cgdHJhaWxpbmcgc3BhY2VzIGFzIHdlbGxcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuTm9UcmFpbGluZyA9IC9eXFxzKigtfFxcKyk/WzAtOV0rXFxzKiQvO1xudmFyIHZhbGlkSW50ZWdlclBhdHRlcm5XaXRoVHJhaWxpbmcgPSAvXlxccyooLXxcXCspP1swLTldKy4qJC87XG5mdW5jdGlvbiBpc1ZhbGlkVGFiaW5kZXgoY29udGV4dCkge1xuICAgIGlmICghc3VwcG9ydHMpIHtcbiAgICAgICAgc3VwcG9ydHMgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIHZhbGlkSW50ZWdlclBhdHRlcm4gPSBzdXBwb3J0cy5mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzID8gdmFsaWRJbnRlZ2VyUGF0dGVybldpdGhUcmFpbGluZyA6IHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nO1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvdmFsaWQtdGFiaW5kZXgnLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xuICAgIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIHZhciBoYXNUYWJJbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGlmICghaGFzVGFiaW5kZXggJiYgIWhhc1RhYkluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb2xkZXIgRmlyZWZveCBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgZG9uJ3Qgc3VwcG9ydCB0YWJpbmRleCBvbiBTVkcgZWxlbWVudHNcbiAgICB2YXIgaXNTdmdFbGVtZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJztcbiAgICBpZiAoaXNTdmdFbGVtZW50ICYmICFzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxuICAgIGlmIChzdXBwb3J0cy5mb2N1c0ludmFsaWRUYWJpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYW4gZWxlbWVudCBtYXRjaGVzIHRoZSB0YWJpbmRleCBzZWxlY3RvciBldmVuIGlmIGl0cyB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgdmFyIHRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4Jyk7XG4gICAgLy8gSUUxMSBwYXJzZXMgdGFiaW5kZXg9XCJcIiBhcyB0aGUgdmFsdWUgXCItMzI3NjhcIlxuICAgIC8vIEBicm93c2VyLWlzc3VlIFRyaWRlbnQgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xMDcyOTY1XG4gICAgaWYgKHRhYmluZGV4ID09PSAnLTMyNzY4Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKHRhYmluZGV4ICYmIHZhbGlkSW50ZWdlclBhdHRlcm4udGVzdCh0YWJpbmRleCkpO1xufVxuZnVuY3Rpb24gdGFiaW5kZXhWYWx1ZShlbGVtZW50KSB7XG4gICAgaWYgKCFpc1ZhbGlkVGFiaW5kZXgoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEVkZ2UgMTQgaGFzIGEgY2FwaXRhbGl6YXRpb24gcHJvYmxlbSBvbiBTVkcgZWxlbWVudHMsXG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzkyODIwNTgvXG4gICAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBoYXNUYWJpbmRleCA/ICd0YWJpbmRleCcgOiAndGFiSW5kZXgnO1xuICAgIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgICB2YXIgdGFiaW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSwgMTApO1xuICAgIHJldHVybiBpc05hTih0YWJpbmRleCkgPyAtMSA6IHRhYmluZGV4O1xufVxuLy8gdGhpcyBpcyBhIHNoYXJlZCB1dGlsaXR5IGZpbGUgZm9yIGZvY3VzLXJlbGV2YW50LmpzIGFuZCB0YWJiYWJsZS5qc1xuLy8gc2VwYXJhdGUgdGVzdGluZyBvZiB0aGlzIGZpbGUncyBmdW5jdGlvbnMgaXMgbm90IG5lY2Vzc2FyeSxcbi8vIGFzIHRoZXkncmUgaW1wbGljaXRseSB0ZXN0ZWQgYnkgd2F5IG9mIHRoZSBjb25zdW1lcnNcbmZ1bmN0aW9uIGlzVXNlck1vZGlmeVdyaXRhYmxlKHN0eWxlKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvV0QtY3NzMy11c2VyaW50LTE5OTkwOTE2I3VzZXItbW9kaWZ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8xN1xuICAgIHZhciB1c2VyTW9kaWZ5ID0gc3R5bGUud2Via2l0VXNlck1vZGlmeSB8fCAnJztcbiAgICByZXR1cm4gQm9vbGVhbih1c2VyTW9kaWZ5ICYmIHVzZXJNb2RpZnkuaW5kZXhPZignd3JpdGUnKSAhPT0gLTEpO1xufVxuZnVuY3Rpb24gaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoc3R5bGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpLFxuICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14JyksXG4gICAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSwgXG4gICAgXS5zb21lKGZ1bmN0aW9uKG92ZXJmbG93KSB7XG4gICAgICAgIHJldHVybiBvdmVyZmxvdyA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93ID09PSAnc2Nyb2xsJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0Nzc0Rpc3BsYXlGbGV4KHN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlLmRpc3BsYXkuaW5kZXhPZignZmxleCcpID4gLTE7XG59XG5mdW5jdGlvbiBpc1Njcm9sbGFibGVDb250YWluZXIoZWxlbWVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkge1xuICAgIGlmIChub2RlTmFtZSAhPT0gJ2RpdicgJiYgbm9kZU5hbWUgIT09ICdzcGFuJykge1xuICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhZHZhbmNlcyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgYW5kIGJvZGllcyB0byBmb2N1c2FibGVcbiAgICAgICAgLy8gb25seSBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgPGRpdj4gb3IgPHNwYW4+IC0gdGhpcyBkb2VzICpub3QqXG4gICAgICAgIC8vIGhhcHBlbiBmb3IgPHNlY3Rpb24+LCA8YXJ0aWNsZT4sIOKAplxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlTmFtZSAmJiBwYXJlbnROb2RlTmFtZSAhPT0gJ2RpdicgJiYgcGFyZW50Tm9kZU5hbWUgIT09ICdzcGFuJyAmJiAhaGFzQ3NzT3ZlcmZsb3dTY3JvbGwocGFyZW50U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZWxlbWVudC5vZmZzZXRXaWR0aCA8IGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG59XG52YXIgc3VwcG9ydHMkMSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRm9jdXNSZWxldmFudFJ1bGVzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCwgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgZmxleGJveDogZmFsc2UsXG4gICAgICAgIHNjcm9sbGFibGU6IGZhbHNlLFxuICAgICAgICBzaGFkb3c6IGZhbHNlXG4gICAgfSA6IF9yZWYkZXhjZXB0O1xuICAgIGlmICghc3VwcG9ydHMkMSkge1xuICAgICAgICBzdXBwb3J0cyQxID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvZm9jdXMtcmVsZXZhbnQnLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoIWV4Y2VwdC5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGEgU2hhZG93RE9NIGhvc3QgcmVjZWl2ZXMgZm9jdXMgd2hlbiB0aGUgZm9jdXMgbW92ZXMgdG8gaXRzIGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBpbnB1dFt0eXBlPVwiaGlkZGVuXCJdIHN1cHBvcnRzLmNhbm5vdCBiZSBmb2N1c2VkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2J1dHRvbicgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2xlZ2VuZCcgJiYgc3VwcG9ydHMkMS5mb2N1c1JlZGlyZWN0TGVnZW5kKSB7XG4gICAgICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdhcmVhJykge1xuICAgICAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdhJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdvYmplY3QnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xuICAgICAgICAvLyBvYmplY3RbdXNlbWFwXSBpcyBub3QgZm9jdXNhYmxlIGluIGFueSBicm93c2VyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgc3ZnVHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgIGlmICghc3VwcG9ydHMkMS5mb2N1c09iamVjdFN2ZyAmJiBzdmdUeXBlID09PSAnaW1hZ2Uvc3ZnK3htbCcpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdFt0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiXSBpcyBub3QgZm9jdXNhYmxlIGluIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN1cHBvcnRzJDEuZm9jdXNPYmplY3RTd2YgJiYgc3ZnVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJykge1xuICAgICAgICAgICAgLy8gb2JqZWN0W3R5cGU9XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiXSBpcyBub3QgZm9jdXNhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnIHx8IG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBicm93c2luZyBjb250ZXh0IGNvbnRhaW5lcnNcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2VtYmVkJyB8fCBub2RlTmFtZSA9PT0gJ2tleWdlbicpIHtcbiAgICAgICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy84MlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAvLyBhbHNvIHNlZSBDU1MgcHJvcGVydHkgdXNlci1tb2RpZnkgYmVsb3dcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJyAmJiAoc3VwcG9ydHMkMS5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nICYmIChzdXBwb3J0cyQxLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c1N1bW1hcnkgJiYgbm9kZU5hbWUgPT09ICdzdW1tYXJ5Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHZhbGlkVGFiaW5kZXggPSBpc1ZhbGlkVGFiaW5kZXgoZWxlbWVudCk7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAgICAgLy8gR2Vja28sIFRyaWRlbnQgYW5kIEVkZ2UgZG8gbm90IGFsbG93IGFuIGltYWdlIHdpdGggYW4gaW1hZ2UgbWFwIGFuZCB0YWJpbmRleCB0byBiZSBmb2N1c2VkLFxuICAgICAgICAvLyBpdCBhcHBlYXJzIHRoZSB0YWJpbmRleCBpcyBvdmVycnVsZWQgc28gZm9jdXMgaXMgc3RpbGwgZm9yd2FyZGVkIHRvIHRoZSA8bWFwPlxuICAgICAgICByZXR1cm4gdmFsaWRUYWJpbmRleCAmJiBzdXBwb3J0cyQxLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXggfHwgc3VwcG9ydHMkMS5mb2N1c1JlZGlyZWN0SW1nVXNlbWFwO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c1RhYmxlICYmIChub2RlTmFtZSA9PT0gJ3RhYmxlJyB8fCBub2RlTmFtZSA9PT0gJ3RkJykpIHtcbiAgICAgICAgLy8gSUUxMC0xMSBzdXBwb3J0cy5jYW4gZm9jdXMgPHRhYmxlPiBhbmQgPHRkPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNGaWVsZHNldCAmJiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0Jykge1xuICAgICAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaXNTdmdFbGVtZW50ID0gbm9kZU5hbWUgPT09ICdzdmcnO1xuICAgIHZhciBpc1N2Z0NvbnRlbnQgPSBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudDtcbiAgICB2YXIgZm9jdXNhYmxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xuICAgIHZhciB0YWJpbmRleCA9IHRhYmluZGV4VmFsdWUoZWxlbWVudCk7XG4gICAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiB0YWJpbmRleCAhPT0gbnVsbCAmJiAhc3VwcG9ydHMkMS5mb2N1c1N2Z1VzZVRhYmluZGV4KSB7XG4gICAgICAgIC8vIDx1c2U+IGNhbm5vdCBiZSBtYWRlIGZvY3VzYWJsZSBieSBhZGRpbmcgYSB0YWJpbmRleCBhdHRyaWJ1dGUgYW55d2hlcmUgYnV0IEJsaW5rIGFuZCBXZWJLaXRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgICAvLyA8dXNlPiBjYW4gb25seSBiZSBtYWRlIGZvY3VzYWJsZSBpbiBCbGluayBhbmQgV2ViS2l0XG4gICAgICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiBzdXBwb3J0cyQxLmZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWxlbWVudCwgJ3N2ZyBhJykgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKChpc1N2Z0VsZW1lbnQgfHwgaXNTdmdDb250ZW50KSAmJiBlbGVtZW50LmZvY3VzICYmICFzdXBwb3J0cyQxLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSAmJiB0YWJpbmRleCA8IDApIHtcbiAgICAgICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcbiAgICAgICAgLy8gdGFiaW5kZXg9XCItMVwiIGFzIHRhYmJhYmxlIGFuZCBldmVyeXRoaW5nIGVsc2UgYXMgaW5lcnRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzMDIzNDBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNTdmdFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB2YWxpZFRhYmluZGV4IHx8IHN1cHBvcnRzJDEuZm9jdXNTdmcgfHwgc3VwcG9ydHMkMS5mb2N1c1N2Z0luSWZyYW1lIHx8IC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgICAgIEJvb2xlYW4oc3VwcG9ydHMkMS5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSAmJiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAndHJ1ZScpO1xuICAgIH1cbiAgICBpZiAoaXNTdmdDb250ZW50KSB7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgdmFsaWRUYWJpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlID09PSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcbiAgICBpZiAodmFsaWRUYWJpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgaWYgKGlzVXNlck1vZGlmeVdyaXRhYmxlKHN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNJbWdJc21hcCAmJiBub2RlTmFtZSA9PT0gJ2ltZycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2lzbWFwJykpIHtcbiAgICAgICAgLy8gSUUxMC0xMSBjb25zaWRlcnMgdGhlIDxpbWc+IGluIDxhIGhyZWY+PGltZyBpc21hcD4gZm9jdXNhYmxlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjBcbiAgICAgICAgdmFyIGhhc0xpbmtQYXJlbnQgPSBnZXRQYXJlbnRzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsZW1lbnRcbiAgICAgICAgfSkuc29tZShmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnICYmIHBhcmVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNMaW5rUGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG4gICAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBzdXBwb3J0cyQxLmZvY3VzU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KSB7XG4gICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2VzIHdpbGwgY29uc2lkZXIgdGhlIHNjcm9sbGFibGUgYXJlYSBmb2N1c2FibGVcbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGEgPGRpdj4gb3IgYSA8c3Bhbj4gYW5kIGl0IGlzIGluIGZhY3Qgc2Nyb2xsYWJsZSxcbiAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIENTUyBvdmVyZmxvdyBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50LCBub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYXNDc3NPdmVyZmxvd1Njcm9sbChzdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgcHJvcGVyIG92ZXJmbG93IHNldHRpbmcsIElFIGRvZXMgbm90IG5lY2Vzc2FyaWx5XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb3ZlcmZsb3dcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZXhjZXB0LmZsZXhib3ggJiYgc3VwcG9ydHMkMS5mb2N1c0ZsZXhib3hDb250YWluZXIgJiYgaGFzQ3NzRGlzcGxheUZsZXgoc3R5bGUpKSB7XG4gICAgICAgIC8vIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHBhcmVudDEgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBwYXJlbnQxKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudDEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50MSwgbnVsbCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU2Nyb2xsQm9keSAmJiBpc1Njcm9sbGFibGVDb250YWluZXIocGFyZW50MSwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbGFibGUgYm9kaWVzIGFyZSBmb2N1c2FibGUgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbiAgICAgICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCkge1xuICAgICAgICAgICAgaWYgKGhhc0Nzc0Rpc3BsYXlGbGV4KHBhcmVudFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5PVEU6IGVsZW1lbnRzIG1hcmtlZCBhcyBpbmVydCBhcmUgbm90IGZvY3VzYWJsZSxcbiAgICAvLyBidXQgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZXhwb3NlZCB0byB0aGUgRE9NXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNpbmVydFxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGlzRm9jdXNSZWxldmFudDEgPSBmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50UnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNGb2N1c1JlbGV2YW50MS5ydWxlcyA9IGlzRm9jdXNSZWxldmFudFJ1bGVzO1xuICAgIHJldHVybiBpc0ZvY3VzUmVsZXZhbnQxO1xufTtcbi8vIHByb3ZpZGUgaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc0ZvY3VzUmVsZXZhbnQgPSBpc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQoe30pO1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIC8vIGF0dGVtcHQgdG8gdXNlIG5hdGl2ZSBvciBwb2x5ZmlsbGVkIEFycmF5I2ZpbmRJbmRleCBmaXJzdFxuICAgIGlmIChhcnJheS5maW5kSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZpbmRJbmRleChjYWxsYmFjayk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgLy8gc2hvcnRjdXQgaWYgdGhlIGFycmF5IGlzIGVtcHR5XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBsb29wIG92ZXIgYXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudERvY3VtZW50KG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT5cbiAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudERvY3VtZW50IHx8IC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPlxuICAgICAgICAobm9kZS5jb250ZW50V2luZG93ICYmIG5vZGUuY29udGVudFdpbmRvdy5kb2N1bWVudCkgfHwgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+IHRoYXQgY29udGFpbiBTVkdcbiAgICAgICAgKG5vZGUuZ2V0U1ZHRG9jdW1lbnQgJiYgbm9kZS5nZXRTVkdEb2N1bWVudCgpKSB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU2VjdXJpdHlFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdjb250ZW50RG9jdW1lbnQnIHByb3BlcnR5IGZyb20gJ0hUTUxPYmplY3RFbGVtZW50J1xuICAgICAgICAvLyBhbHNvIElFIG1heSB0aHJvdyBtZW1iZXIgbm90IGZvdW5kIGV4Y2VwdGlvbiBlLmcuIG9uIDxvYmplY3QgdHlwZT1cImltYWdlL3BuZ1wiPlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChub2RlKTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbnZhciBzaGFkb3dQcmVmaXggPSB2b2lkIDA7XG5mdW5jdGlvbiBzZWxlY3RJblNoYWRvd3Moc2VsZWN0b3IyKSB7XG4gICAgaWYgKHR5cGVvZiBzaGFkb3dQcmVmaXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IoKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBzaGFkb3dQcmVmaXggPSAnLCBodG1sICcgKyBvcGVyYXRvciArICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNoYWRvd1ByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IyO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IyICsgc2hhZG93UHJlZml4ICsgc2VsZWN0b3IyLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCcpLnNwbGl0KCcsJykuam9pbihzaGFkb3dQcmVmaXgpO1xufVxudmFyIHNlbGVjdG9yID0gdm9pZCAwO1xuZnVuY3Rpb24gZmluZERvY3VtZW50SG9zdEVsZW1lbnQoX3dpbmRvdykge1xuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RJblNoYWRvd3MoJ29iamVjdCwgaWZyYW1lJyk7XG4gICAgfVxuICAgIGlmIChfd2luZG93Ll9mcmFtZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3dpbmRvdy5fZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBudWxsO1xuICAgIHZhciBwb3RlbnRpYWxIb3N0cyA9IF93aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIFtdLnNvbWUuY2FsbChwb3RlbnRpYWxIb3N0cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgX2RvY3VtZW50ID0gZ2V0Q29udGVudERvY3VtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAoX2RvY3VtZW50ICE9PSBfd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3dpbmRvdy5fZnJhbWVFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIF93aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gICAgaWYgKCFfd2luZG93LnBhcmVudCB8fCBfd2luZG93LnBhcmVudCA9PT0gX3dpbmRvdykge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgYnJvd3NpbmcgY29udGV4dCxcbiAgICAgICAgLy8gd2UncmUgbm90IGdvaW5nIHRvIGdldCBhIGZyYW1lRWxlbWVudCBlaXRoZXIgd2F5XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9mcmFtZUVsZW1lbnRcbiAgICAgICAgLy8gZG9lcyBub3Qgd29yayB3aXRoaW4gPGVtYmVkPiBhbnl3aGVyZSwgYW5kIG5vdCB3aXRoaW4gaW4gPG9iamVjdD4gaW4gSUVcbiAgICAgICAgcmV0dXJuIF93aW5kb3cuZnJhbWVFbGVtZW50IHx8IGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3JlbmRlcmluZy5odG1sI2JlaW5nLXJlbmRlcmVkXG4vLyA8YXJlYT4gaXMgbm90IHJlbmRlcmVkLCBidXQgd2UgKmNvbnNpZGVyKiBpdCB2aXNpYmxlIHRvIHNpbXBsZml5IHRoaXMgZnVuY3Rpb24ncyB1c2FnZVxudmFyIG5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuID0gL14oYXJlYSkkLztcbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBub3REaXNwbGF5ZWQoX3BhdGgpIHtcbiAgICByZXR1cm4gX3BhdGguc29tZShmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIC8vIGRpc3BsYXk6bm9uZSBpcyBub3QgdmlzaWJsZSAob3B0aW1pemVkIGF3YXkgYXQgbGF5b3V0KVxuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAnZGlzcGxheScpID09PSAnbm9uZSc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3RWaXNpYmxlKF9wYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvY29yZS5qcyNMMTA5LUwxMTRcbiAgICAvLyBOT1RFOiBhIG5lc3RlZCBlbGVtZW50IGNhbiByZXZlcnNlIHZpc2liaWxpdHk6aGlkZGVufGNvbGxhcHNlIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB2aXNpYmlsaXR5OnZpc2libGVcbiAgICAvLyBOT1RFOiB2aXNpYmlsaXR5IGNhbiBiZSBbXCJcIiwgXCJ2aXNpYmxlXCIsIFwiaGlkZGVuXCIsIFwiY29sbGFwc2VcIl1cbiAgICB2YXIgaGlkZGVuID0gZmluZEluZGV4KF9wYXRoLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciB2aXNpYmlsaXR5ID0gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpO1xuICAgICAgICByZXR1cm4gdmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgdmlzaWJpbGl0eSA9PT0gJ2NvbGxhcHNlJztcbiAgICB9KTtcbiAgICBpZiAoaGlkZGVuID09PSAtMSkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBoaWRkZW4gZWxlbWVudFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2aXNpYmxlID0gZmluZEluZGV4KF9wYXRoLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsICd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJztcbiAgICB9KTtcbiAgICBpZiAodmlzaWJsZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gdmlzaWJsZSBlbGVtZW50IChidXQgYSBoaWRkZW4gZWxlbWVudClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChoaWRkZW4gPCB2aXNpYmxlKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIGEgaGlkZGVuIGVsZW1lbnQgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdGhlIGZpcnN0IHZpc2libGUgZWxlbWVudFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdGhlcmUgbWF5IGJlIGEgaGlkZGVuIGVsZW1lbnQsIGJ1dCB0aGUgY2xvc2VzdCBlbGVtZW50IGlzIHZpc2libGVcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMTtcbiAgICBpZiAoX3BhdGhbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgICAgIG9mZnNldCA9IDI7XG4gICAgfVxuICAgIHJldHVybiBfcGF0aC5zbGljZShvZmZzZXQpLnNvbWUoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyBcImNvbnRlbnQgY2hpbGRyZW5cIiBvZiBhIGNsb3NlZCBkZXRhaWxzIGVsZW1lbnQgYXJlIG5vdCB2aXNpYmxlXG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkZXRhaWxzJyAmJiBlbGVtZW50Lm9wZW4gPT09IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNWaXNpYmxlUnVsZXMoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LCBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBub3RSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxuICAgICAgICBjc3NWaXNpYmlsaXR5OiBmYWxzZSxcbiAgICAgICAgZGV0YWlsc0VsZW1lbnQ6IGZhbHNlLFxuICAgICAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXG4gICAgfSA6IF9yZWYkZXhjZXB0O1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvdmlzaWJsZScsXG4gICAgICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIWV4Y2VwdC5ub3RSZW5kZXJlZCAmJiBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIF9wYXRoID0gZ2V0UGFyZW50cyh7XG4gICAgICAgIGNvbnRleHQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgICAvLyBpbiBJbnRlcm5ldCBFeHBsb3JlciA8YXVkaW8+IGhhcyBhIGRlZmF1bHQgZGlzcGxheTogbm9uZSwgd2hlcmUgb3RoZXJzIGhhdmUgZGlzcGxheTogaW5saW5lXG4gICAgLy8gYnV0IElFIGFsbG93cyBmb2N1c2luZyA8YXVkaW8gc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj4sIGJ1dCBub3QgPGRpdiBkaXNwbGF5Om5vbmU+PGF1ZGlvPlxuICAgIC8vIHRoaXMgaXMgaXJyZWxldmFudCB0byBvdGhlciBicm93c2VycywgYXMgdGhlIGNvbnRyb2xzIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCB0byBtYWtlIDxhdWRpbz4gZm9jdXNhYmxlXG4gICAgdmFyIGlzQXVkaW9XaXRob3V0Q29udHJvbHMgPSBub2RlTmFtZSA9PT0gJ2F1ZGlvJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XG4gICAgaWYgKCFleGNlcHQuY3NzRGlzcGxheSAmJiBub3REaXNwbGF5ZWQoaXNBdWRpb1dpdGhvdXRDb250cm9scyA/IF9wYXRoLnNsaWNlKDEpIDogX3BhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNlcHQuY3NzVmlzaWJpbGl0eSAmJiBub3RWaXNpYmxlKF9wYXRoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LmRldGFpbHNFbGVtZW50ICYmIGNvbGxhcHNlZFBhcmVudChfcGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5icm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gZWxlbWVudHMgd2l0aGluIGEgYnJvd3NpbmcgY29udGV4dCBhcmUgYWZmZWN0ZWQgYnkgdGhlXG4gICAgICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgaG9zdCBlbGVtZW50J3MgdmlzaWJpbGl0eSBhbmQgdGFiaW5kZXhcbiAgICAgICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdmFyIF9pc1Zpc2libGUgPSBpc1Zpc2libGVSdWxlcy5leGNlcHQoZXhjZXB0KTtcbiAgICAgICAgaWYgKGZyYW1lRWxlbWVudCAmJiAhX2lzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzVmlzaWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc1Zpc2libGUxID0gZnVuY3Rpb24gaXNWaXNpYmxlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZVJ1bGVzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlzVmlzaWJsZTEucnVsZXMgPSBpc1Zpc2libGVSdWxlcztcbiAgICByZXR1cm4gaXNWaXNpYmxlMTtcbn07XG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGdldE1hcEJ5TmFtZShuYW1lMSwgX2RvY3VtZW50KSB7XG4gICAgLy8gYXBwYXJlbnRseSBnZXRFbGVtZW50c0J5TmFtZSgpIGFsc28gY29uc2lkZXJzIGlkIGF0dHJpYnV0ZSBpbiBJRSAmIG9wZXJhXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2dldEVsZW1lbnRzQnlOYW1lXG4gICAgdmFyIG1hcCA9IF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYXBbbmFtZT1cIicgKyAoMCwgX2Nzc0VzY2FwZSkuZGVmYXVsdChuYW1lMSkgKyAnXCJdJyk7XG4gICAgcmV0dXJuIG1hcCB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCkge1xuICAgIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFtYXAubmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ21hcCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE5PVEU6IGltYWdlIG1hcHMgY2FuIGFsc28gYmUgYXBwbGllZCB0byA8b2JqZWN0PiB3aXRoIGltYWdlIGNvbnRlbnQsXG4gICAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XG4gICAgLy8gSFRNTDUgc3BlY2lmaWVzIEhUTUxNYXBFbGVtZW50LmltYWdlcyB0byBiZSBhbiBIVE1MQ29sbGVjdGlvbiBvZiBhbGxcbiAgICAvLyA8aW1nPiBhbmQgPG9iamVjdD4gcmVmZXJlbmNpbmcgdGhlIDxtYXA+IGVsZW1lbnQsIGJ1dCBubyBicm93c2VyIGltcGxlbWVudHMgdGhpc1xuICAgIC8vICAgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3RoZS1tYXAtZWxlbWVudFxuICAgIC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNYXBFbGVtZW50XG4gICAgLy8gdGhlIGltYWdlIG11c3QgYmUgdmFsaWQgYW5kIGxvYWRlZCBmb3IgdGhlIG1hcCB0byB0YWtlIGVmZmVjdFxuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcbiAgICByZXR1cm4gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZ1t1c2VtYXA9XCIjJyArICgwLCBfY3NzRXNjYXBlKS5kZWZhdWx0KG1hcC5uYW1lKSArICdcIl0nKSB8fCBudWxsO1xufVxudmFyIHN1cHBvcnRzJDIgPSB2b2lkIDA7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvbWFwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0w4OC1MMTA3XG5mdW5jdGlvbiBpc1ZhbGlkQXJlYShjb250ZXh0KSB7XG4gICAgaWYgKCFzdXBwb3J0cyQyKSB7XG4gICAgICAgIHN1cHBvcnRzJDIgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy92YWxpZC1hcmVhJyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZU5hbWUgIT09ICdhcmVhJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIGlmICghc3VwcG9ydHMkMi5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCkge1xuICAgICAgICAvLyBCbGluayBhbmQgV2ViS2l0IGRvIG5vdCBjb25zaWRlciA8YXJlYSB0YWJpbmRleD1cIi0xXCIgaHJlZj1cIiN2b2lkXCI+IGZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbWcgPSBnZXRJbWFnZU9mQXJlYShlbGVtZW50KTtcbiAgICBpZiAoIWltZyB8fCAhaXNWaXNpYmxlKGltZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IG9ubHkgYWxsb3dzIGZ1bGx5IGxvYWRlZCBpbWFnZXMgdG8gcmVmZXJlbmNlIGltYWdlIG1hcHNcbiAgICAvLyBodHRwczovL3N0ZXJlb2Nocm8ubWUvaWRlYXMvZGV0ZWN0aW5nLWJyb2tlbi1pbWFnZXMtanNcbiAgICBpZiAoIXN1cHBvcnRzJDIuZm9jdXNCcm9rZW5JbWFnZU1hcCAmJiAoIWltZy5jb21wbGV0ZSB8fCAhaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHwgaW1nLm9mZnNldEhlaWdodCA8PSAwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgZXZlbiBpZiB0aGV5IGRvbid0IGhhdmUgYW4gaHJlZiBhdHRyaWJ1dGVcbiAgICBpZiAoIXN1cHBvcnRzJDIuZm9jdXNBcmVhV2l0aG91dEhyZWYgJiYgIWVsZW1lbnQuaHJlZikge1xuICAgICAgICAvLyBJbnRlcm5ldCBleHBsb3JlciBzdXBwb3J0cy5jYW4gZm9jdXMgYXJlYSBlbGVtZW50cyB3aXRob3V0IGhyZWYgaWYgZWl0aGVyXG4gICAgICAgIC8vIHRoZSBhcmVhIGVsZW1lbnQgb3IgdGhlIGltYWdlIGVsZW1lbnQgaGFzIGEgdGFiaW5kZXggYXR0cmlidXRlXG4gICAgICAgIHJldHVybiBzdXBwb3J0cyQyLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4IHx8IHN1cHBvcnRzJDIuZm9jdXNBcmVhSW1nVGFiaW5kZXggJiYgaW1nLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuICAgIHZhciBjaGlsZE9mSW50ZXJhY3RpdmUgPSBnZXRQYXJlbnRzKHtcbiAgICAgICAgY29udGV4dDogaW1nXG4gICAgfSkuc2xpY2UoMSkuc29tZShmdW5jdGlvbihfZWxlbWVudCkge1xuICAgICAgICB2YXIgbmFtZTIgPSBfZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbmFtZTIgPT09ICdidXR0b24nIHx8IG5hbWUyID09PSAnYSc7XG4gICAgfSk7XG4gICAgaWYgKGNoaWxkT2ZJbnRlcmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIHN1cHBvcnRzJDMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbnZhciBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IHZvaWQgMDtcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xuICAgIGlucHV0OiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBidXR0b246IHRydWUsXG4gICAgZmllbGRzZXQ6IHRydWUsXG4gICAgZm9ybTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQoY29udGV4dCkge1xuICAgIGlmICghc3VwcG9ydHMkMykge1xuICAgICAgICBzdXBwb3J0cyQzID0gX3N1cHBvcnRzKCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZmllbGRzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRzJDMuZm9jdXNGb3JtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXNhYmxlZEVsZW1lbnRzLmZvcm07XG4gICAgICAgIH1cbiAgICAgICAgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKCcgKyBPYmplY3Qua2V5cyhkaXNhYmxlZEVsZW1lbnRzKS5qb2luKCd8JykgKyAnKSQnKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkJyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gQm9vbGVhbihkaXNhYmxlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSk7XG59XG52YXIgc3VwcG9ydHMkNCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0JyAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNEaXNhYmxlZEZvcm0oZWxlbWVudCkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgPT09ICdmb3JtJyAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNEaXNhYmxlZChjb250ZXh0KSB7XG4gICAgaWYgKCFzdXBwb3J0cyQ0KSB7XG4gICAgICAgIHN1cHBvcnRzJDQgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy9kaXNhYmxlZCcsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpKSB7XG4gICAgICAgIC8vIHRyZWF0IGFsbHkncyBlbGVtZW50L2Rpc2FibGVkIGxpa2UgdGhlIERPTSBuYXRpdmUgZWxlbWVudC5kaXNhYmxlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc05hdGl2ZURpc2FibGVkU3VwcG9ydGVkKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vIG5vbi1mb3JtIGVsZW1lbnRzIGRvIG5vdCBzdXBwb3J0IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgICAvLyB0aGUgZWxlbWVudCBpdHNlbGYgaXMgZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnRzID0gZ2V0UGFyZW50cyh7XG4gICAgICAgIGNvbnRleHQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAocGFyZW50cy5zb21lKGlzRGlzYWJsZWRGaWVsZHNldCkpIHtcbiAgICAgICAgLy8gYSBwYXJlbnRhbCA8ZmllbGRzZXQ+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzdXBwb3J0cyQ0LmZvY3VzRm9ybURpc2FibGVkICYmIHBhcmVudHMuc29tZShpc0Rpc2FibGVkRm9ybSkpIHtcbiAgICAgICAgLy8gYSBwYXJlbnRhbCA8Zm9ybT4gaXMgZGlzYWJsZCBhbmQgaW5oZXJpdHMgdGhlIHN0YXRlIG9udG8gdGhpcyBlbGVtZW50XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09ubHlUYWJiYWJsZVJ1bGVzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCwgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgb25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDogZmFsc2UsXG4gICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgfSA6IF9yZWYkZXhjZXB0O1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvb25seS10YWJiYWJsZScsXG4gICAgICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0Lm9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQgJiYgKHBsYXRmb3JtLmlzLkdFQ0tPIHx8IHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkpIHtcbiAgICAgICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgaWYgKGZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRhYmluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcbiAgICAgICAgICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJyAmJiBwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAvLyBGaXJlZm94IGNhbm5vdCBmb2N1cywgYnV0IHRhYiB0bzogbGFiZWxbdGFiaW5kZXg9MF1cbiAgICAgICAgcmV0dXJuIHRhYmluZGV4ICE9PSBudWxsICYmIHRhYmluZGV4ID49IDA7XG4gICAgfVxuICAgIC8vIFNWRyBFbGVtZW50cyB3ZXJlIGtleWJvYXJkIGZvY3VzYWJsZSBidXQgbm90IHNjcmlwdCBmb2N1c2FibGUgYmVmb3JlIEZpcmVmb3ggNTEuXG4gICAgLy8gRmlyZWZveCA1MSBhZGRlZCB0aGUgZm9jdXMgbWFuYWdlbWVudCBET00gQVBJICguZm9jdXMgYW5kIC5ibHVyKSB0byBTVkdFbGVtZW50LFxuICAgIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Nzg2NTRcbiAgICBpZiAocGxhdGZvcm0uaXMuR0VDS08gJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQgJiYgIWVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgICAgICAgICAgLy8gYW55IGZvY3VzYWJsZSBjaGlsZCBvZiA8c3ZnPiBjYW5ub3QgYmUgZm9jdXNlZCwgYnV0IHRhYmJlZCB0b1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc09ubHlUYWJiYWJsZTEgPSBmdW5jdGlvbiBpc09ubHlUYWJiYWJsZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBpc09ubHlUYWJiYWJsZVJ1bGVzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlzT25seVRhYmJhYmxlMS5ydWxlcyA9IGlzT25seVRhYmJhYmxlUnVsZXM7XG4gICAgcmV0dXJuIGlzT25seVRhYmJhYmxlMTtcbn07XG4vLyBwcm92aWRlIGlzT25seVRhYmJhYmxlKGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc09ubHlUYWJiYWJsZSA9IGlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbnZhciBzdXBwb3J0cyQ1ID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNPbmx5Rm9jdXNSZWxldmFudChlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ2VtYmVkJyB8fCBub2RlTmFtZSA9PT0gJ2tleWdlbicpIHtcbiAgICAgICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy84MlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIF90YWJpbmRleCA9IHRhYmluZGV4VmFsdWUoZWxlbWVudCk7XG4gICAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCAmJiBfdGFiaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgLy8gU2hhZG93RE9NIGhvc3QgZWxlbWVudHMgKm1heSogcmVjZWl2ZSBmb2N1c1xuICAgICAgICAvLyBldmVuIHRob3VnaCB0aGV5IGFyZSBub3QgY29uc2lkZXJlZCBmb2N1YWJsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnbGFiZWwnKSB7XG4gICAgICAgIC8vIDxsYWJlbCB0YWJpbmRleD1cIjBcIj4gaXMgb25seSB0YWJiYWJsZSBpbiBGaXJlZm94LCBub3Qgc2NyaXB0LWZvY3VzYWJsZVxuICAgICAgICAvLyB0aGVyZSdzIG5vIHdheSB0byBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIG90aGVyIHRoYW4gYnkgYWRkaW5nIGEgdGFiaW5kZXgsXG4gICAgICAgIC8vIGFuZCBmb2N1cyBiZWhhdmlvciBvZiB0aGUgbGFiZWwgZWxlbWVudCBzZWVtcyBoYXJkLXdpcmVkIHRvIGlnbm9yZSB0YWJpbmRleFxuICAgICAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEdlY2tvLCBCbGluayBhbmQgV2ViS2l0KVxuICAgICAgICByZXR1cm4gIXN1cHBvcnRzJDUuZm9jdXNMYWJlbFRhYmluZGV4IHx8IF90YWJpbmRleCA9PT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnbGVnZW5kJykge1xuICAgICAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkNS5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSAmJiAoZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgbm9kZU5hbWUgPT09ICdzdmcnKSkge1xuICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciB1bmRlcnN0YW5kcyB0aGUgZm9jdXNhYmxlIGF0dHJpYnV0ZSBpbnRyb2R1Y2VkIGluIFNWRyBUaW55IDEuMlxuICAgICAgICB2YXIgZm9jdXNhYmxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xuICAgICAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJztcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAgICAgLy8gR2Vja28sIFRyaWRlbnQgYW5kIEVkZ2UgZG8gbm90IGFsbG93IGFuIGltYWdlIHdpdGggYW4gaW1hZ2UgbWFwIGFuZCB0YWJpbmRleCB0byBiZSBmb2N1c2VkLFxuICAgICAgICAvLyBpdCBhcHBlYXJzIHRoZSB0YWJpbmRleCBpcyBvdmVycnVsZWQgc28gZm9jdXMgaXMgc3RpbGwgZm9yd2FyZGVkIHRvIHRoZSA8bWFwPlxuICAgICAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsIHx8ICFzdXBwb3J0cyQ1LmZvY3VzSW1nVXNlbWFwVGFiaW5kZXg7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgIC8vIGFsbCA8YXJlYT5zIGFyZSBjb25zaWRlcmVkIHJlbGV2YW50LFxuICAgICAgICAvLyBidXQgb25seSB0aGUgdmFsaWQgPGFyZWE+cyBhcmUgZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiAhaXNWYWxpZEFyZWEoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LCBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICBvbmx5VGFiYmFibGU6IGZhbHNlXG4gICAgfSA6IF9yZWYkZXhjZXB0O1xuICAgIGlmICghc3VwcG9ydHMkNSkge1xuICAgICAgICBzdXBwb3J0cyQ1ID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciBfaXNPbmx5VGFiYmFibGUgPSBpc09ubHlUYWJiYWJsZS5ydWxlcy5leGNlcHQoe1xuICAgICAgICBvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OiB0cnVlLFxuICAgICAgICB2aXNpYmxlOiBleGNlcHQudmlzaWJsZVxuICAgIH0pO1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvZm9jdXNhYmxlJyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIGZvY3VzUmVsZXZhbnQgPSBpc0ZvY3VzUmVsZXZhbnQucnVsZXMoe1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgIH0pO1xuICAgIGlmICghZm9jdXNSZWxldmFudCB8fCBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNlcHQuZGlzYWJsZWQgJiYgaXNEaXNhYmxlZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0Lm9ubHlUYWJiYWJsZSAmJiBfaXNPbmx5VGFiYmFibGUoZWxlbWVudCkpIHtcbiAgICAgICAgLy8gc29tZSBlbGVtZW50cyBtYXkgYmUga2V5Ym9hcmQgZm9jdXNhYmxlLCBidXQgbm90IHNjcmlwdCBmb2N1c2FibGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBub3QgcmVuZGVyZWQsIGNhbm5vdCBiZSBmb2N1c2VkXG4gICAgaWYgKCFleGNlcHQudmlzaWJsZSkge1xuICAgICAgICB2YXIgdmlzaWJpbGl0eU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICAgICAgZXhjZXB0OiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHMkNS5mb2N1c0luSGlkZGVuSWZyYW1lKSB7XG4gICAgICAgICAgICAvLyBXZWJLaXQgYW5kIEJsaW5rIGNhbiBmb2N1cyBjb250ZW50IGluIGhpZGRlbiA8aWZyYW1lPiBhbmQgPG9iamVjdD5cbiAgICAgICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5icm93c2luZ0NvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwb3J0cyQ1LmZvY3VzT2JqZWN0U3ZnSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBCbGluayBhbGxvd3MgZm9jdXNpbmcgdGhlIG9iamVjdCBlbGVtZW50LCBldmVuIGlmIGl0IGhhcyB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgICAgICAvLyBAYnJvd3Nlci1pc3N1ZSBCbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg2MTkxXG4gICAgICAgICAgICB2YXIgX25vZGVOYW1lMiA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChfbm9kZU5hbWUyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmlzaWJsZS5ydWxlcyh2aXNpYmlsaXR5T3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoX25vZGVOYW1lID09PSAnb2JqZWN0JyAmJiAhc3VwcG9ydHMkNS5mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFmcmFtZUVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWZyYW1lRWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWJLaXQgY2FuIG5vdCBmb2N1cyBjb250ZW50IGluIDxvYmplY3Q+IGlmIGl0IGRvZXNuJ3QgaGF2ZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdzdmcnICYmIHN1cHBvcnRzJDUuZm9jdXNTdmdJbklmcmFtZSAmJiAhZnJhbWVFbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGlzRm9jdXNhYmxlMSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRm9jdXNhYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNGb2N1c2FibGUxLnJ1bGVzID0gaXNGb2N1c2FibGVSdWxlcztcbiAgICByZXR1cm4gaXNGb2N1c2FibGUxO1xufTtcbi8vIHByb3ZpZGUgaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihjb25kaXRpb24pIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVGaWx0ZXJcbiAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIFNoYWRvd1Jvb3QgZWxlbWVudHMgcmVnYXJkbGVzcyBvZiB0aGVtIGJlaW5nIGZvY3VzYWJsZSxcbiAgICAgICAgICAgIC8vIHNvIHRoZXkgY2FuIGJlIHdhbGtlZCByZWN1cnNpdmVseSBsYXRlclxuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmaW5kcyBlbGVtZW50cyB0aGF0IGNvdWxkIGhhdmUgYmVlbiBmb3VuZCBieSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKClcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfTtcbiAgICAvLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cbiAgICAvLyBzZWUgaHR0cDovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjA3LWZpbmRpbmctaHRtbC1jb21tZW50LW5vZGVzLWluLXRoZS1kb20tdXNpbmctdHJlZXdhbGtlci5odG1cbiAgICBmaWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcbiAgICByZXR1cm4gZmlsdGVyO1xufVxudmFyIFBvc3NpYmx5Rm9jdXNhYmxlRmlsdGVyID0gY3JlYXRlRmlsdGVyKGlzRm9jdXNSZWxldmFudCk7XG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVN0cmljdCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICB2YXIgX2lzRm9jdXNhYmxlID0gaXNGb2N1c2FibGUucnVsZXMuZXhjZXB0KHtcbiAgICAgICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gICAgfSk7XG4gICAgdmFyIF9kb2N1bWVudCA9IGdldERvY3VtZW50KGNvbnRleHQpO1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlVHJlZVdhbGtlclxuICAgIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcigvLyByb290IGVsZW1lbnQgdG8gc3RhcnQgc2VhcmNoIGluXG4gICAgY29udGV4dCwgLy8gZWxlbWVudCB0eXBlIGZpbHRlclxuICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcbiAgICBzdHJhdGVneSA9PT0gJ2FsbCcgPyBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA6IGNyZWF0ZUZpbHRlcihfaXNGb2N1c2FibGUpLCAvLyBkZXByZWNhdGVkLCBidXQgSUUgcmVxdWlyZXMgaXRcbiAgICBmYWxzZSk7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB3aGlsZSh3YWxrZXIubmV4dE5vZGUoKSl7XG4gICAgICAgIGlmICh3YWxrZXIuY3VycmVudE5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgaWYgKF9pc0ZvY3VzYWJsZSh3YWxrZXIuY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlGb2N1c2FibGVTdHJpY3Qoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHdhbGtlci5jdXJyZW50Tm9kZS5zaGFkb3dSb290LFxuICAgICAgICAgICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxuICAgIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBpZiAoaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xuICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLy8gTk9URTogdGhpcyBzZWxlY3RvciBNVVNUICpuZXZlciogYmUgdXNlZCBkaXJlY3RseSxcbnZhciBzdXBwb3J0cyQ2ID0gdm9pZCAwO1xudmFyIHNlbGVjdG9yJDEgPSB2b2lkIDA7XG5mdW5jdGlvbiBzZWxlY3RvciQyKCkge1xuICAgIGlmICghc3VwcG9ydHMkNikge1xuICAgICAgICBzdXBwb3J0cyQ2ID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yJDE7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXG4gICAgc2VsZWN0b3IkMSA9ICcnICsgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPHRhYmxlPiBhbmQgPHRkPlxuICAgIChzdXBwb3J0cyQ2LmZvY3VzVGFibGUgPyAndGFibGUsIHRkLCcgOiAnJykgKyAvLyBJRTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XG4gICAgKHN1cHBvcnRzJDYuZm9jdXNGaWVsZHNldCA/ICdmaWVsZHNldCwnIDogJycpICsgLy8gTmFtZXNwYWNlIHByb2JsZW1zIG9mIFt4bGluazpocmVmXSBleHBsYWluZWQgaW4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzMDQ3ODg4LzUxNTEyNFxuICAgIC8vIHN2ZyBhWyp8aHJlZl0gZG9lcyBub3QgbWF0Y2ggaW4gSUU5LCBidXQgc2luY2Ugd2UncmUgZmlsdGVyaW5nXG4gICAgLy8gdGhyb3VnaCBpcy9mb2N1c2FibGUgd2UgY2FuIGluY2x1ZGUgYWxsIDxhPiBmcm9tIFNWR1xuICAgICdzdmcgYSwnICsgLy8gbWF5IGJlaGF2ZSBhcyAnc3ZnLCBzdmcgKiwnIGluIGNocm9tZSBhcyAqZXZlcnkqIHN2ZyBlbGVtZW50IHdpdGggYSBmb2N1cyBldmVudCBsaXN0ZW5lciBpcyBmb2N1c2FibGVcbiAgICAvLyBuYXZpZ2F0aW9uYWwgZWxlbWVudHNcbiAgICAnYVtocmVmXSwnICsgLy8gdmFsaWRpdHkgZGV0ZXJtaW5lZCBieSBpcy92YWxpZC1hcmVhLmpzXG4gICAgJ2FyZWFbaHJlZl0sJyArIC8vIHZhbGlkaXR5IGRldGVybWluZWQgYnkgaXMvZGlzYWJsZWQuanNcbiAgICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwnICsgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXG4gICAgJ2lmcmFtZSwgb2JqZWN0LCBlbWJlZCwnICsgLy8gaW50ZXJhY3RpdmUgY29udGVudFxuICAgICdrZXlnZW4sJyArIChzdXBwb3J0cyQ2LmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgPyAnYXVkaW8sJyA6ICdhdWRpb1tjb250cm9sc10sJykgKyAoc3VwcG9ydHMkNi5mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID8gJ3ZpZGVvLCcgOiAndmlkZW9bY29udHJvbHNdLCcpICsgKHN1cHBvcnRzJDYuZm9jdXNTdW1tYXJ5ID8gJ3N1bW1hcnksJyA6ICcnKSArIC8vIHZhbGlkaXR5IGRldGVybWluZWQgYnkgaXMvdmFsaWQtdGFiaW5kZXguanNcbiAgICAnW3RhYmluZGV4XSwnICsgLy8gZWRpdGluZyBob3N0c1xuICAgICdbY29udGVudGVkaXRhYmxlXSc7XG4gICAgLy8gd2hlcmUgU2hhZG93RE9NIGlzIHN1cHBvcnRlZCwgd2UgYWxzbyB3YW50IHRoZSBzaGFkb3dlZCBmb2N1c2FibGUgZWxlbWVudHMgKHZpYSBcIj4+PlwiIG9yIFwiL2RlZXAvXCIpXG4gICAgc2VsZWN0b3IkMSA9IHNlbGVjdEluU2hhZG93cyhzZWxlY3RvciQxKTtcbiAgICByZXR1cm4gc2VsZWN0b3IkMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlUXVpY2soKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGU7XG4gICAgdmFyIF9zZWxlY3RvciA9IHNlbGVjdG9yJDIoKTtcbiAgICB2YXIgZWxlbWVudHMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoX3NlbGVjdG9yKTtcbiAgICAvLyB0aGUgc2VsZWN0b3IgcG90ZW50aWFsbHkgbWF0Y2hlcyBtb3JlIHRoYW4gcmVhbGx5IGlzIGZvY3VzYWJsZVxuICAgIHZhciBfaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZS5ydWxlcy5leGNlcHQoe1xuICAgICAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0MSA9IFtdLmZpbHRlci5jYWxsKGVsZW1lbnRzLCBfaXNGb2N1c2FibGUpO1xuICAgIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXG4gICAgaWYgKGluY2x1ZGVDb250ZXh0ICYmIF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xuICAgICAgICByZXN1bHQxLnVuc2hpZnQoY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQxO1xufVxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsIF9yZWYkc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5LCBzdHJhdGVneSA9IF9yZWYkc3RyYXRlZ3kgPT09IHVuZGVmaW5lZCA/ICdxdWljaycgOiBfcmVmJHN0cmF0ZWd5O1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAncXVlcnkvZm9jdXNhYmxlJyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgIH07XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAncXVpY2snKSB7XG4gICAgICAgIHJldHVybiBxdWVyeUZvY3VzYWJsZVF1aWNrKG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdzdHJpY3QnIHx8IHN0cmF0ZWd5ID09PSAnYWxsJykge1xuICAgICAgICByZXR1cm4gcXVlcnlGb2N1c2FibGVTdHJpY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3F1ZXJ5L2ZvY3VzYWJsZSByZXF1aXJlcyBvcHRpb24uc3RyYXRlZ3kgdG8gYmUgb25lIG9mIFtcInF1aWNrXCIsIFwic3RyaWN0XCIsIFwiYWxsXCJdJyk7XG59XG52YXIgc3VwcG9ydHMkNyA9IHZvaWQgMDtcbi8vIEludGVybmV0IEV4cGxvcmVyIDExIGNvbnNpZGVycyBmaWVsZHNldCwgdGFibGUsIHRkIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTEgY29uc2lkZXJzIGJvZHkgdG8gaGF2ZSBbdGFiaW5kZXg9MF0sIGJ1dCBkb2VzIG5vdCBhbGxvdyB0YWJiaW5nIHRvIGl0XG52YXIgZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuID0gL14oZmllbGRzZXR8dGFibGV8dGR8Ym9keSkkLztcbmZ1bmN0aW9uIGlzVGFiYmFibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgIGZsZXhib3g6IGZhbHNlLFxuICAgICAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICAgICAgc2hhZG93OiBmYWxzZSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgICB9IDogX3JlZiRleGNlcHQ7XG4gICAgaWYgKCFzdXBwb3J0cyQ3KSB7XG4gICAgICAgIHN1cHBvcnRzJDcgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy90YWJiYWJsZScsXG4gICAgICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIGlmIChwbGF0Zm9ybS5pcy5CTElOSyAmJiBwbGF0Zm9ybS5pcy5BTkRST0lEICYmIHBsYXRmb3JtLm1ham9yVmVyc2lvbiA+IDQyKSB7XG4gICAgICAgIC8vIEV4dGVybmFsIGtleWJvYXJkIHN1cHBvcnQgd29ya2VkIGZpbmUgaW4gQ0hyb21lIDQyLCBidXQgc3RvcHBlZCB3b3JraW5nIGluIENocm9tZSA0NS5cbiAgICAgICAgLy8gVGhlIG9uLXNjcmVlbiBrZXlib2FyZCBkb2VzIG5vdCBwcm92aWRlIGEgd2F5IHRvIGZvY3VzIHRoZSBuZXh0IGlucHV0IGVsZW1lbnQgKGxpa2UgaU9TIGRvZXMpLlxuICAgICAgICAvLyBUaGF0IGxlYXZlcyB1cyB3aXRoIG5vIG9wdGlvbiB0byBhZHZhbmNlIGZvY3VzIGJ5IGtleWJvYXJkLCBlcmdvIG5vdGhpbmcgaXMgdGFiYmFibGUgKGtleWJvYXJkIGZvY3VzYWJsZSkuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5XRUJLSVQgJiYgcGxhdGZvcm0uaXMuSU9TKSB7XG4gICAgICAgICAgICAvLyBpT1Mgb25seSBkb2VzIG5vdCBjb25zaWRlciBhbnl0aGluZyBmcm9tIGFub3RoZXIgYnJvd3NpbmcgY29udGV4dCBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcbiAgICAgICAgLy8gdGFiYmFibGUgZGVtb3Rpb24gb250byBlbGVtZW50cyBvZiB0aGVpciBicm93c2luZyBjb250ZXh0c1xuICAgICAgICBpZiAodGFiaW5kZXhWYWx1ZShmcmFtZUVsZW1lbnQpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLldFQktJVCkgJiYgIWlzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBCbGluayBhbmQgV2ViS2l0IGNvbnNpZGVyIGVsZW1lbnRzIGluIGhpZGRlbiBicm93c2luZyBjb250ZXh0cyBmb2N1c2FibGUsIGJ1dCBub3QgdGFiYmFibGVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGRvbid0IGNvbnNpZGVyIGFueXRoaW5nIGluIDxvYmplY3Q+IHRhYmJhYmxlXG4gICAgICAgIC8vIEJsaW5rIGZpeGVkIHRoYXQgZml4ZWQgaW4gQ2hyb21lIDU0LCBPcGVyYSA0MVxuICAgICAgICB2YXIgZnJhbWVOb2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZnJhbWVOb2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBpc0ZpeGVkQmxpbmsgPSBwbGF0Zm9ybS5uYW1lID09PSAnQ2hyb21lJyAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gNTQgfHwgcGxhdGZvcm0ubmFtZSA9PT0gJ09wZXJhJyAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gNDE7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm0uaXMuV0VCS0lUIHx8IHBsYXRmb3JtLmlzLkJMSU5LICYmICFpc0ZpeGVkQmxpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBfdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIHZhciB0YWJpbmRleCA9IF90YWJpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfdGFiaW5kZXggPj0gMDtcbiAgICBpZiAocGxhdGZvcm0uaXMuRURHRSAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gMTQgJiYgZnJhbWVFbGVtZW50ICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50ICYmIF90YWJpbmRleCA8IDApIHtcbiAgICAgICAgLy8gRWRnZSAxNCsgY29uc2lkZXJzIDxhIHhsaW5rOmhyZWY9XCLigKZcIiB0YWJpbmRleD1cIi0xXCI+IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBpbiBhIG5lc3RlZCBicm93c2luZyBjb250ZXh0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSA9IHRhYmluZGV4ICE9PSBmYWxzZTtcbiAgICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleCA9IF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPj0gMDtcbiAgICAvLyBOT1RFOiBGaXJlZm94IDMxIGNvbnNpZGVycyBbY29udGVudGVkaXRhYmxlXSB0byBoYXZlIFt0YWJpbmRleD0tMV0sIGJ1dCBhbGxvd3MgdGFiYmluZyB0byBpdFxuICAgIC8vIGZpeGVkIGluIEZpcmVmb3ggNDAgdGhlIGxhdGVzdCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExODU2NTdcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgIC8vIHRhYmJpbmcgY2FuIHN0aWxsIGJlIGRpc2FibGVkIGJ5IGV4cGxpY2l0bHkgcHJvdmlkaW5nIFt0YWJpbmRleD1cIi0xXCJdXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lO1xuICAgIH1cbiAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpICYmIHRhYmluZGV4ICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLldFQktJVCAmJiBwbGF0Zm9ybS5pcy5JT1MpIHtcbiAgICAgICAgLy8gaU9TIG9ubHkgY29uc2lkZXJzIGEgaGFuZCBmdWxsIG9mIGVsZW1lbnRzIHRhYmJhYmxlIChrZXlib2FyZCBmb2N1c2FibGUpXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdHJ1ZSBldmVuIHdpdGggZXh0ZXJuYWwga2V5Ym9hcmRzXG4gICAgICAgIHZhciBwb3RlbnRpYWxseVRhYmJhYmxlID0gbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlID09PSAndGV4dCcgfHwgZWxlbWVudC50eXBlID09PSAncGFzc3dvcmQnIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgICAgICBwb3RlbnRpYWxseVRhYmJhYmxlID0gaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ3VzZScgJiYgX3RhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5CTElOSyB8fCBwbGF0Zm9ybS5pcy5XRUJLSVQgJiYgcGxhdGZvcm0ubWFqb3JWZXJzaW9uID09PSA5KSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIFNhZmFyaSA5IHRoZSA8dXNlPiBlbGVtZW50IGlzIGtleWJvYXJkIGZvY3VzYWJsZSBldmVuIGZvciB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgICAgIGlmIChoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XG4gICAgICAgICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGhhbmRsZSB0aGUgdGFiSW5kZXggcHJvcGVydHkgcHJvcGVybHlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmZvY3VzICYmICFzdXBwb3J0cyQ3LmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcbiAgICAgICAgICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJyAmJiBzdXBwb3J0cyQ3LmZvY3VzU3ZnSW5JZnJhbWUgJiYgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHMkNy5mb2N1c1N2Zykge1xuICAgICAgICAgICAgICAgIC8vIG9sZGVyIEludGVybmV0IEV4cGxvcmVycyBjb25zaWRlciA8c3ZnPiBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhleSBoYXZlIGZvY3NhYmxlPVwiZmFsc2VcIiwgYnV0IHRoZW4gdGhleSB3b3VsZG4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGZvY3VzYWJsZSBhbmQgdGh1cyBub3QgZXZlbiByZWFjaCB0aGlzIGZpbHRlclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdmb2N1c2FibGUnKSB8fCBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzJDcuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSAmJiBoYXNUYWJiYWJsZVRhYmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGhhdmUgW2ZvY3VzYWJsZV0gYXJlIGF1dG9tYXRpY2FsbHkga2V5Ym9hcmQgZm9jdXNhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZXhjZXB0Lm9ubHlUYWJiYWJsZSk7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSB7XG4gICAgICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciB0aGUgPGF1ZGlvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocGxhdGZvcm0uaXMuQkxJTkspIHtcbiAgICAgICAgICAgIC8vIEluIENocm9tZSA8YXVkaW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nKSB7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybS5pcy5UUklERU5UIHx8IHBsYXRmb3JtLmlzLkVER0UpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSB0aGUgPHZpZGVvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gcmVtYWlucyBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLldFQktJVCkge1xuICAgICAgICAgICAgLy8gSW4gYWxsIEJsaW5rIGFuZCBXZWJLaXQgYmFzZWQgYnJvd3NlcnMgPGVtYmVkPiBhbmQgPG9iamVjdD4gYXJlIG5ldmVyIGtleWJvYXJkIGZvY3VzYWJsZSwgZXZlbiB3aXRoIHRhYmluZGV4PVwiMFwiIHNldFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXG4gICAgICAgIC8vIEluIFdlYktpdCwgQmxpbmsgYW5kIEdlY2tvIGlmcmFtZXMgbWF5IGJlIHRhYmJhYmxlIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCByZWxpYWJseSBpbnZlc3RpZ2F0ZSBpZnJhbWUgZG9jdW1lbnRzIGJlY2F1c2Ugb2YgdGhlXG4gICAgICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgLy8gRmlyZWZveCBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGtleWJvYXJkIGZvY3VzYWJsZSxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgLTFcbiAgICAgICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoX3N0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICAvLyBJRSBhbmQgRWRnZSBkZWdyYWRlIDxhcmVhPiB0byBzY3JpcHQgZm9jdXNhYmxlLCBpZiB0aGUgaW1hZ2VcbiAgICAgICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdhcmVhJykge1xuICAgICAgICAgICAgdmFyIGltZyA9IGdldEltYWdlT2ZBcmVhKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGltZyAmJiB0YWJpbmRleFZhbHVlKGltZykgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfc3R5bGUyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgIGlmIChpc1VzZXJNb2RpZnlXcml0YWJsZShfc3R5bGUyKSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBiZWluZyBzd2FsbG93ZWQgYnkgdGhlIG92ZXJ6ZWFsb3VzIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcigpIGJlbG93XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjZXB0LmZsZXhib3ggJiYgaGFzQ3NzRGlzcGxheUZsZXgoX3N0eWxlMikpIHtcbiAgICAgICAgICAgIGlmIChfdGFiaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0ZvY3VzUmVsZXZhbnRXaXRob3V0RmxleGJveChlbGVtZW50KSAmJiBpc1RhYmJhYmxlV2l0aG91dEZsZXhib3goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgY29uc2lkZXJzIHNjcm9sbGFibGUgY29udGFpbmVycyBzY3JpcHQgZm9jdXNhYmxlIG9ubHksXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IGlzIDBcbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50LCBub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZU5hbWUgPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBJRSBjb25zaWRlcnMgc2Nyb2xsYWJsZSBib2RpZXMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihwYXJlbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMSxcbiAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IHN1Z2dlc3RzIG90aGVyd2lzZVxuICAgICAgICAgICAgaWYgKGhhc0Nzc0Rpc3BsYXlGbGV4KHBhcmVudFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIG9mIHRhYmluZGV4IHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNmb2N1c190YWJpbmRleFxuICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzVGFiYmFibGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgaXNUYWJiYWJsZTEgPSBmdW5jdGlvbiBpc1RhYmJhYmxlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzVGFiYmFibGVSdWxlcyh7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpc1RhYmJhYmxlMS5ydWxlcyA9IGlzVGFiYmFibGVSdWxlcztcbiAgICByZXR1cm4gaXNUYWJiYWJsZTE7XG59O1xudmFyIGlzRm9jdXNSZWxldmFudFdpdGhvdXRGbGV4Ym94ID0gaXNGb2N1c1JlbGV2YW50LnJ1bGVzLmV4Y2VwdCh7XG4gICAgZmxleGJveDogdHJ1ZVxufSk7XG52YXIgaXNUYWJiYWJsZVdpdGhvdXRGbGV4Ym94ID0gaXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7XG4gICAgZmxleGJveDogdHJ1ZVxufSk7XG4vLyBwcm92aWRlIGlzVGFiYmFibGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzVGFiYmFibGUgPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIHF1ZXJ5VGFiYmFibGUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcbiAgICB2YXIgX2lzVGFiYmFibGUgPSBpc1RhYmJhYmxlLnJ1bGVzLmV4Y2VwdCh7XG4gICAgICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeUZvY3VzYWJsZSh7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcbiAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgfSkuZmlsdGVyKF9pc1RhYmJhYmxlKTtcbn1cbi8vIHNvcnRzIGEgbGlzdCBvZiBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlaXIgb3JkZXIgaW4gdGhlIERPTVxuZnVuY3Rpb24gY29tcGFyZURvbVBvc2l0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gc29ydERvbU9yZGVyKGVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzLnNvcnQoY29tcGFyZURvbVBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIHRhcmdldCkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBjb21lcyBBRlRFUiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICByZXR1cm4gZmluZEluZGV4KGxpc3QsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbk9mZnNldHMobGlzdCwgZWxlbWVudHMsIHJlc29sdmVFbGVtZW50KSB7XG4gICAgLy8gaW5zdGVhZCBvZiBtdXRhdGluZyB0aGUgZWxlbWVudHMgbGlzdCBkaXJlY3RseSwgcmVtZW1iZXIgcG9zaXRpb24gYW5kIG1hcFxuICAgIC8vIHRvIGluamVjdCBsYXRlciwgd2hlbiB3ZSBjYW4gZG8gdGhpcyBtb3JlIGVmZmljaWVudGx5XG4gICAgdmFyIGluc2VydGlvbnMgPSBbXTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbGlzdC5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgaW4gdGFyZ2V0IGxpc3RcbiAgICAgICAgICAgIG9mZnNldCA9IGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIGVsZW1lbnQpO1xuICAgICAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBzdWNjZXNzb3IgaW4gdGhlIHRhYnNlcXVlbmNlLFxuICAgICAgICAgICAgLy8gbWVhbmluZyB0aGUgaW1hZ2UgbXVzdCBiZSB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICBvZmZzZXQgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyB0aGUgY29uc3VtZXIgdG8gcmVwbGFjZSB0aGUgaW5qZWN0ZWQgZWxlbWVudFxuICAgICAgICB2YXIgaW5qZWN0aW9ucyA9IG5vZGVBcnJheShyZXNvbHZlRWxlbWVudCA/IHJlc29sdmVFbGVtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgICAgIGlmICghaW5qZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbid0IGluamVjdCB6ZXJvIGVsZW1lbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBpbmplY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpbnNlcnRpb25zO1xufVxuZnVuY3Rpb24gaW5zZXJ0RWxlbWVudHNBdE9mZnNldHMobGlzdCwgaW5zZXJ0aW9ucykge1xuICAgIC8vIHJlbWVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgd2UgaGF2ZSBhbHJlYWR5IGluamVjdGVkXG4gICAgLy8gc28gd2UgYWNjb3VudCBmb3IgdGhlIGNhdXNlZCBpbmRleCBvZmZzZXRcbiAgICB2YXIgaW5zZXJ0ZWQgPSAwO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGluc2VydCB0aGUgZWxlbWVudHMgaW4gc2VxdWVuY2UsXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSBvZmZzZXQgY29tcGVuc2F0aW9uIHdvbid0IHdvcmtcbiAgICBpbnNlcnRpb25zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICB9KTtcbiAgICBpbnNlcnRpb25zLmZvckVhY2goZnVuY3Rpb24oaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIGFycmF5LnNwbGljZSBoYXMgYW4gYW5ub3lpbmcgZnVuY3Rpb24gc2lnbmF0dXJlIDooXG4gICAgICAgIHZhciByZW1vdmUgPSBpbnNlcnRpb24ucmVwbGFjZSA/IDEgOiAwO1xuICAgICAgICB2YXIgYXJncyA9IFtcbiAgICAgICAgICAgIGluc2VydGlvbi5vZmZzZXQgKyBpbnNlcnRlZCxcbiAgICAgICAgICAgIHJlbW92ZVxuICAgICAgICBdLmNvbmNhdChpbnNlcnRpb24uZWxlbWVudHMpO1xuICAgICAgICBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBhcmdzKTtcbiAgICAgICAgaW5zZXJ0ZWQgKz0gaW5zZXJ0aW9uLmVsZW1lbnRzLmxlbmd0aCAtIHJlbW92ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5Eb21PcmRlcigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGxpc3QgPSBfcmVmLmxpc3QsIGVsZW1lbnRzID0gX3JlZi5lbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQgPSBfcmVmLnJlc29sdmVFbGVtZW50O1xuICAgIC8vIG9wZXJhdGUgb24gYSBjb3B5IHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICB2YXIgX2xpc3QgPSBsaXN0LnNsaWNlKDApO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgZWxlbWVudHMgd2UncmUgaW5qZWN0aW5nIGFyZSBwcm92aWRlZCBpbiBET00gb3JkZXJcbiAgICB2YXIgX2VsZW1lbnRzID0gbm9kZUFycmF5KGVsZW1lbnRzKS5zbGljZSgwKTtcbiAgICBzb3J0RG9tT3JkZXIoX2VsZW1lbnRzKTtcbiAgICAvLyBmaW5kIHRoZSBvZmZzZXRzIHdpdGhpbiB0aGUgdGFyZ2V0IGFycmF5IChsaXN0KSBhdCB3aGljaCB0byBpbmplY3RcbiAgICAvLyBlYWNoIGluZGl2aWR1YWwgZWxlbWVudCAoZnJvbSBlbGVtZW50cylcbiAgICB2YXIgaW5zZXJ0aW9ucyA9IGZpbmRJbnNlcnRpb25PZmZzZXRzKF9saXN0LCBfZWxlbWVudHMsIHJlc29sdmVFbGVtZW50KTtcbiAgICAvLyBhY3R1YWxseSBpbmplY3QgdGhlIGVsZW1lbnRzIGludG8gdGhlIHRhcmdldCBhcnJheSBhdCB0aGUgaWRlbnRpZmllZCBwb3NpdGlvbnNcbiAgICBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhfbGlzdCwgaW5zZXJ0aW9ucyk7XG4gICAgcmV0dXJuIF9saXN0O1xufVxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbn1cbnZhciBNYXBzID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFwczEoY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwczEpO1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGdldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICB0aGlzLm1hcHMgPSB7fTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE1hcHMxLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ2dldEFyZWFzRm9yJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcmVhc0ZvcihuYW1lMykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXBzW25hbWUzXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWFwIGlzIG5vdCBkZWZpbmVkIHdpdGhpbiB0aGUgY29udGV4dCwgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBnbyBmaW5kIGl0IGVsc2V3aGVyZSBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXBCeU5hbWUobmFtZTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBzW25hbWUzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnYWRkTWFwQnlOYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXBCeU5hbWUobmFtZTQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gZ2V0TWFwQnlOYW1lKG5hbWU0LCB0aGlzLl9kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbWFwLCB0aGUgaW1nW3VzZW1hcF0gd2Fzbid0IGRvaW5nIGFueXRoaW5nIGFueXdheVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSBxdWVyeVRhYmJhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbWFwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ2V4dHJhY3RBcmVhc0Zyb21MaXN0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0QXJlYXNGcm9tTGlzdChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwc1ttYXAubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgXSk7XG4gICAgcmV0dXJuIE1hcHMxO1xufSgpO1xuZnVuY3Rpb24gc29ydEFyZWEoZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICAvLyBpbWFnZXMgLSB1bmxlc3MgdGhleSBhcmUgZm9jdXNhYmxlIHRoZW1zZWx2ZXMsIGxpa2VseSBub3RcbiAgICAvLyBwYXJ0IG9mIHRoZSBlbGVtZW50cyBsaXN0LCBzbyB3ZSdsbCBoYXZlIHRvIGZpbmQgdGhlbSBhbmRcbiAgICAvLyBzb3J0IHRoZW0gaW50byB0aGUgZWxlbWVudHMgbGlzdCBtYW51YWxseVxuICAgIHZhciB1c2VtYXBzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbdXNlbWFwXScpO1xuICAgIHZhciBtYXBzID0gbmV3IE1hcHMoY29udGV4dCk7XG4gICAgLy8gcmVtb3ZlIGFsbCA8YXJlYT4gZWxlbWVudHMgZnJvbSB0aGUgZWxlbWVudHMgbGlzdCxcbiAgICAvLyBidXQgcHV0IHRoZW0gdGhlIG1hcCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgdmFyIF9lbGVtZW50cyA9IG1hcHMuZXh0cmFjdEFyZWFzRnJvbUxpc3QoZWxlbWVudHMpO1xuICAgIGlmICghdXNlbWFwcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gdGhlIGNvbnRleHQgZG9lcyBub3QgY29udGFpbiBhbnkgPGFyZWE+cyBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIHJlcGxhY2UgYW55dGhpbmcsIGp1c3QgcmVtb3ZlIGFueSBtYXBzXG4gICAgICAgIHJldHVybiBfZWxlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUluRG9tT3JkZXIoe1xuICAgICAgICBsaXN0OiBfZWxlbWVudHMsXG4gICAgICAgIGVsZW1lbnRzOiB1c2VtYXBzLFxuICAgICAgICByZXNvbHZlRWxlbWVudDogZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBuYW1lNSA9IGltYWdlLmdldEF0dHJpYnV0ZSgndXNlbWFwJykuc2xpY2UoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWFwcy5nZXRBcmVhc0ZvcihuYW1lNSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciBfY3JlYXRlQ2xhc3MkMSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJDEoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxudmFyIFNoYWRvd3MgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dzMShjb250ZXh0LCBzb3J0RWxlbWVudHMxKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayQxKHRoaXMsIFNoYWRvd3MxKTtcbiAgICAgICAgLy8gZG9jdW1lbnQgY29udGV4dCB3ZSdyZSB3b3JraW5nIHdpdGhcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gY2FsbGJhY2sgdGhhdCBzb3J0cyBhbiBhcnJheSBvZiBlbGVtZW50c1xuICAgICAgICB0aGlzLnNvcnRFbGVtZW50cyA9IHNvcnRFbGVtZW50czE7XG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byBjcmVhdGUgdW5pcXVlIElEcyBmb3IgZWFjaCBTaGFkb3dIb3N0XG4gICAgICAgIHRoaXMuaG9zdENvdW50ZXIgPSAxO1xuICAgICAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0cyBvZiBhIFNoYWRvd0hvc3RcbiAgICAgICAgdGhpcy5pbkhvc3QgPSB7fTtcbiAgICAgICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgY2hpbGQtU2hhZG93SG9zdCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgdGhpcy5pbkRvY3VtZW50ID0gW107XG4gICAgICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIFNoYWRvd0hvc3RzXG4gICAgICAgIHRoaXMuaG9zdHMgPSB7fTtcbiAgICAgICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgdGFiYmFibGUgZWxlbWVudHMgb2YgYSBTaGFkb3dIb3N0XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB9XG4gICAgLy8gcmVtZW1iZXIgd2hpY2ggaG9zdHMgd2UgaGF2ZSB0byBzb3J0IHdpdGhpbiBsYXRlclxuICAgIF9jcmVhdGVDbGFzcyQxKFNoYWRvd3MxLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ19yZWdpc3Rlckhvc3QnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3QoaG9zdCkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0Ll9zb3J0aW5nSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBTaGFkb3dIb3N0IGlkZW50aWZpYWJsZSAoc2VlIGNsZWFudXAoKSBmb3IgdW5kbylcbiAgICAgICAgICAgICAgICBob3N0Ll9zb3J0aW5nSWQgPSAnc2hhZG93LScgKyB0aGlzLmhvc3RDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0c1tob3N0Ll9zb3J0aW5nSWRdID0gaG9zdDtcbiAgICAgICAgICAgICAgICAvLyBob3N0cyBtYXkgY29udGFpbiBvdGhlciBob3N0c1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRIb3N0ID0gZ2V0U2hhZG93SG9zdCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGhvc3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SG9zdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QocGFyZW50SG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdFBhcmVudChob3N0LCBwYXJlbnRIb3N0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRG9jdW1lbnQucHVzaChob3N0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ19yZWdpc3Rlckhvc3RQYXJlbnQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3RQYXJlbnQoaG9zdCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkhvc3RbcGFyZW50Ll9zb3J0aW5nSWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXS5wdXNoKGhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfcmVnaXN0ZXJFbGVtZW50JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQsIGhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ2V4dHJhY3RFbGVtZW50cycsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0ID0gZ2V0U2hhZG93SG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdChob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQsIGhvc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ3NvcnQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5faW5qZWN0SG9zdHMoZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIF9lbGVtZW50cyA9IHRoaXMuX3JlcGxhY2VIb3N0cyhfZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VsZW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfaW5qZWN0SG9zdHMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmplY3RIb3N0cyhlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goZnVuY3Rpb24oX3NvcnRpbmdJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5pbkhvc3RbX3NvcnRpbmdJZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCA9IHRoaXMuaG9zdHNbX3NvcnRpbmdJZF0uc2hhZG93Um9vdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tfc29ydGluZ0lkXSA9IHRoaXMuX21lcmdlKF9saXN0LCBfZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZWxlbWVudHMsIHRoaXMuaW5Eb2N1bWVudCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnX21lcmdlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVyZ2UobGlzdCwgZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkID0gbWVyZ2VJbkRvbU9yZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogbGlzdCxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ydEVsZW1lbnRzKG1lcmdlZCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ19yZXBsYWNlSG9zdHMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBsYWNlSG9zdHMoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VJbkRvbU9yZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGlzLmluRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfcmVzb2x2ZUhvc3RFbGVtZW50JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzb2x2ZUhvc3RFbGVtZW50KGhvc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkID0gbWVyZ2VJbkRvbU9yZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogdGhpcy5pbkhvc3RbaG9zdC5fc29ydGluZ0lkXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUVsZW1lbnQ6IHRoaXMuX3Jlc29sdmVIb3N0RWxlbWVudC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIF90YWJpbmRleCA9IHRhYmluZGV4VmFsdWUoaG9zdCk7XG4gICAgICAgICAgICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChtZXJnZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfY2xlYW51cCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRob3NlIGlkZW50aWZlcnMgd2UgcHV0IG9uIHRoZSBTaGFkb3dIb3N0IHRvIGF2b2lkIHVzaW5nIE1hcCgpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5ob3N0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG9zdHNba2V5XS5fc29ydGluZ0lkO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBcbiAgICBdKTtcbiAgICByZXR1cm4gU2hhZG93czE7XG59KCk7XG5mdW5jdGlvbiBzb3J0U2hhZG93ZWQoZWxlbWVudHMsIGNvbnRleHQsIHNvcnRFbGVtZW50czIpIHtcbiAgICB2YXIgc2hhZG93cyA9IG5ldyBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50czIpO1xuICAgIHZhciBfZWxlbWVudHMgPSBzaGFkb3dzLmV4dHJhY3RFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgaWYgKF9lbGVtZW50cy5sZW5ndGggPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBubyBzaGFkb3dlZCBjb250ZW50IGZvdW5kLCBubyBuZWVkIHRvIGNvbnRpbnVlXG4gICAgICAgIHJldHVybiBzb3J0RWxlbWVudHMyKGVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvd3Muc29ydChfZWxlbWVudHMpO1xufVxuZnVuY3Rpb24gc29ydFRhYmluZGV4KGVsZW1lbnRzKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50LnRhYkluZGV4XG4gICAgLy8gZWxlbWVudHMgd2l0aCB0YWJJbmRleCBcIjBcIiAoaW5jbHVkaW5nIHRhYmJhYmxlRWxlbWVudHMgd2l0aG91dCB0YWJJbmRleCkgc2hvdWxkIGJlIG5hdmlnYXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIuXG4gICAgLy8gZWxlbWVudHMgd2l0aCBhIHBvc2l0aXZlIHRhYkluZGV4OlxuICAgIC8vICAgRWxlbWVudHMgdGhhdCBoYXZlIGlkZW50aWNhbCB0YWJJbmRleGVzIHNob3VsZCBiZSBuYXZpZ2F0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyLlxuICAgIC8vICAgTmF2aWdhdGlvbiBwcm9jZWVkcyBmcm9tIHRoZSBsb3dlc3QgdGFiSW5kZXggdG8gdGhlIGhpZ2hlc3QgdGFiSW5kZXguXG4gICAgLy8gTk9URTogc29ydCBpbXBsZW1lbnRhdGlvbiBtYXkgYmUgdW5zdGFibGUgYW5kIHRodXMgbWVzcyB1cCBET00gb3JkZXIsXG4gICAgLy8gdGhhdCdzIHdoeSB3ZSBidWlsZCBhIG1hcCB0aGF0J3MgYmVpbmcgc29ydGVkIGluc3RlYWQuIElmIHdlIHdlcmUgYWJsZSB0byByZWx5XG4gICAgLy8gb24gYSBzdGFibGUgc29ydGluZyBhbGdvcml0aG0sIHNvcnRUYWJpbmRleCgpIGNvdWxkIGJlIGFzIHNpbXBsZSBhc1xuICAgIC8vIGVsZW1lbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS50YWJJbmRleCAtIGIudGFiSW5kZXg7IH0pO1xuICAgIC8vIGF0IHRoaXMgdGltZSBDaHJvbWUgZG9lcyBub3QgdXNlIGEgc3RhYmxlIHNvcnRpbmcgYWxnb3JpdGhtXG4gICAgLy8gc2VlIGh0dHA6Ly9ibG9nLnJvZG5leXJlaG0uZGUvYXJjaGl2ZXMvMTQtU29ydGluZy1XZXJlLURvaW5nLUl0LVdyb25nLmh0bWwjc3RhYmlsaXR5XG4gICAgLy8gTk9URTogY29tcGFyZURvY3VtZW50UG9zaXRpb24gc2VlbWVkIGxpa2UgbW9yZSBvdmVyaGVhZCB0aGFuIGp1c3Qgc29ydGluZyB0aGlzIHdpdGggYnVja2V0c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBpbmRleGVzID0gW107XG4gICAgdmFyIG5vcm1hbCA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIC8vIGluIFRyaWRlbnQgYW5kIEdlY2tvIFNWR0VsZW1lbnQgZG9lcyBub3Qga25vdyBhYm91dCB0aGUgdGFiSW5kZXggcHJvcGVydHlcbiAgICAgICAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgaWYgKHRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhYkluZGV4ID0gdGFiaW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHRyYWN0IGVsZW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCBzb3J0aW5nXG4gICAgICAgIGlmICh0YWJJbmRleCA8PSAwIHx8IHRhYkluZGV4ID09PSBudWxsIHx8IHRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWFwW3RhYkluZGV4XSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHNvcnRhYmxlIGJ1Y2tldCBmb3IgZG9tLW9yZGVyLXByZXNlcnZhdGlvbiBvZiBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHRhYkluZGV4XG4gICAgICAgICAgICBtYXBbdGFiSW5kZXhdID0gW107XG4gICAgICAgICAgICAvLyBtYWludGFpbiBhIGxpc3Qgb2YgdW5pcXVlIHRhYkluZGV4ZXNcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCh0YWJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBlbGVtZW50IGludG8gdGhlIHByb3BlciBidWNrZXRcbiAgICAgICAgbWFwW3RhYkluZGV4XS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAvLyBlbGVtZW50IG1vdmVkIHRvIHNvcnRpbmcgbWFwLCBzbyBub3QgXCJub3JtYWxcIiBhbnltb3JlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICAvLyBzb3J0IHRoZSB0YWJpbmRleCBhc2NlbmRpbmcsXG4gICAgLy8gdGhlbiByZXNvbHZlIHRoZW0gdG8gdGhlaXIgYXBwcm9wcmlhdGUgYnVja2V0cyxcbiAgICAvLyB0aGVuIGZsYXR0ZW4gdGhlIGFycmF5IG9mIGFycmF5cyB0byBhbiBhcnJheVxuICAgIHZhciBfZWxlbWVudHMgPSBpbmRleGVzLnNvcnQoKS5tYXAoZnVuY3Rpb24odGFiSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1hcFt0YWJJbmRleF07XG4gICAgfSkucmVkdWNlUmlnaHQoZnVuY3Rpb24ocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuY29uY2F0KHByZXZpb3VzKTtcbiAgICB9LCBub3JtYWwpO1xuICAgIHJldHVybiBfZWxlbWVudHM7XG59XG52YXIgc3VwcG9ydHMkOCA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1vdmVDb250ZXh0VG9CZWdpbm5pbmcoZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcG9zID0gZWxlbWVudHMuaW5kZXhPZihjb250ZXh0KTtcbiAgICBpZiAocG9zID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gZWxlbWVudHMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgIHJldHVybiB0bXAuY29uY2F0KGVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuZnVuY3Rpb24gc29ydEVsZW1lbnRzKGVsZW1lbnRzLCBfY29udGV4dCkge1xuICAgIGlmIChzdXBwb3J0cyQ4LnRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyBzb3J0IDxhcmVhPiBpbiBET00gb3JkZXIsIHNvbWUgcGxhY2UgdGhlIDxhcmVhPnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIDxpbWc+IHJlZmVyZWNpbmcgdGhlbSB3b3VsZCd2ZSBiZWVuIGluIERPTSBvcmRlci5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy81XG4gICAgICAgIGVsZW1lbnRzID0gc29ydEFyZWEoZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICB9XG4gICAgZWxlbWVudHMgPSBzb3J0VGFiaW5kZXgoZWxlbWVudHMpO1xuICAgIHJldHVybiBlbGVtZW50cztcbn1cbmZ1bmN0aW9uIHF1ZXJ5VGFic2VxdWVuY2UoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcbiAgICBpZiAoIXN1cHBvcnRzJDgpIHtcbiAgICAgICAgc3VwcG9ydHMkOCA9IF9zdXBwb3J0cygpO1xuICAgIH1cbiAgICB2YXIgX2NvbnRleHQgPSBub2RlQXJyYXkoY29udGV4dClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50cyA9IHF1ZXJ5VGFiYmFibGUoe1xuICAgICAgICBjb250ZXh0OiBfY29udGV4dCxcbiAgICAgICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxuICAgICAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICB9KTtcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jcmVhdGVTaGFkb3dSb290ICYmIHBsYXRmb3JtLmlzLkJMSU5LKSB7XG4gICAgICAgIC8vIHNvcnQgdGFiaW5kZXggbG9jYWxpemVkIHRvIHNoYWRvdyBkb21cbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvNlxuICAgICAgICBlbGVtZW50cyA9IHNvcnRTaGFkb3dlZChlbGVtZW50cywgX2NvbnRleHQsIHNvcnRFbGVtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMgPSBzb3J0RWxlbWVudHMoZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XG4gICAgICAgIC8vIGlmIHdlIGluY2x1ZGUgdGhlIGNvbnRleHQgaXRzZWxmLCBpdCBoYXMgdG8gYmUgdGhlIGZpcnN0XG4gICAgICAgIC8vIGVsZW1lbnQgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgIGVsZW1lbnRzID0gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgX2NvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG59XG4vLyBjb2RlcyBtb3N0bHkgY2xvbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tlaXRoYW11cy9qd2VydHkvYmxvYi9tYXN0ZXIvandlcnR5LmpzXG4vLyBkZWxpYmVyYXRlbHkgbm90IGV4cG9zaW5nIGNoYXJhY3RlcnMgbGlrZSA8LC4tIyogYmVjYXVzZSB0aGV5IHZhcnkgKndpbGRseSpcbi8vIGFjcm9zcyBrZXlib2FyZCBsYXlvdXRzIGFuZCBtYXkgY2F1c2UgdmFyaW91cyBwcm9ibGVtc1xuLy8gKGUuZy4gXCIqXCIgaXMgXCJTaGlmdCArXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxuLy8gKGUuZy4gXCJAXCIgaXMgXCJBbHQgTFwiIG9uIGEgR2VybWFuIE1hYyBrZXlib2FyZClcbnZhciBrZXljb2RlID0ge1xuICAgIC8vIEVsZW1lbnQgRm9jdXNcbiAgICB0YWI6IDksXG4gICAgLy8gTmF2aWdhdGlvblxuICAgIGxlZnQ6IDM3LFxuICAgIHVwOiAzOCxcbiAgICByaWdodDogMzksXG4gICAgZG93bjogNDAsXG4gICAgcGFnZVVwOiAzMyxcbiAgICAncGFnZS11cCc6IDMzLFxuICAgIHBhZ2VEb3duOiAzNCxcbiAgICAncGFnZS1kb3duJzogMzQsXG4gICAgZW5kOiAzNSxcbiAgICBob21lOiAzNixcbiAgICAvLyBBY3Rpb25cbiAgICBlbnRlcjogMTMsXG4gICAgZXNjYXBlOiAyNyxcbiAgICBzcGFjZTogMzIsXG4gICAgLy8gTW9kaWZpZXJcbiAgICBzaGlmdDogMTYsXG4gICAgY2Fwc0xvY2s6IDIwLFxuICAgICdjYXBzLWxvY2snOiAyMCxcbiAgICBjdHJsOiAxNyxcbiAgICBhbHQ6IDE4LFxuICAgIG1ldGE6IDkxLFxuICAgIC8vIGluIGZpcmVmb3g6IDIyNFxuICAgIC8vIG9uIG1hYyAoY2hyb21lKTogbWV0YS1sZWZ0PTkxLCBtZXRhLXJpZ2h0PTkzXG4gICAgLy8gb24gd2luIChJRTExKTogbWV0YS1sZWZ0PTkxLCBtZXRhLXJpZ2h0PTkyXG4gICAgcGF1c2U6IDE5LFxuICAgIC8vIENvbnRlbnQgTWFuaXB1bGF0aW9uXG4gICAgaW5zZXJ0OiA0NSxcbiAgICBkZWxldGU6IDQ2LFxuICAgIGJhY2tzcGFjZTogOCxcbiAgICAvLyB0aGUgc2FtZSBsb2dpY2FsIGtleSBtYXkgYmUgaWRlbnRpZmllZCB0aHJvdWdoIGRpZmZlcmVudCBrZXlDb2Rlc1xuICAgIF9hbGlhczoge1xuICAgICAgICA5MTogW1xuICAgICAgICAgICAgOTIsXG4gICAgICAgICAgICA5MyxcbiAgICAgICAgICAgIDIyNFxuICAgICAgICBdXG4gICAgfVxufTtcbi8vIEZ1bmN0aW9uIGtleXMgKDExMiAtIDEzNylcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBGMTMrXG5mb3IodmFyIG4gPSAxOyBuIDwgMjY7IG4rKyl7XG4gICAga2V5Y29kZVsnZicgKyBuXSA9IG4gKyAxMTE7XG59XG4vLyBOdW1iZXIga2V5cyAoNDgtNTcsIG51bXBhZCA5Ni0xMDUpXG4vLyBOT1RFOiBub3QgZXZlcnkga2V5Ym9hcmQga25vd3MgbnVtLTArXG5mb3IodmFyIF9uID0gMDsgX24gPCAxMDsgX24rKyl7XG4gICAgdmFyIGNvZGUgPSBfbiArIDQ4O1xuICAgIHZhciBudW1Db2RlID0gX24gKyA5NjtcbiAgICBrZXljb2RlW19uXSA9IGNvZGU7XG4gICAga2V5Y29kZVsnbnVtLScgKyBfbl0gPSBudW1Db2RlO1xuICAgIGtleWNvZGUuX2FsaWFzW2NvZGVdID0gW1xuICAgICAgICBudW1Db2RlXG4gICAgXTtcbn1cbi8vIExhdGluIGNoYXJhY3RlcnMgKDY1IC0gOTApXG5mb3IodmFyIF9uMiA9IDA7IF9uMiA8IDI2OyBfbjIrKyl7XG4gICAgdmFyIF9jb2RlID0gX24yICsgNjU7XG4gICAgdmFyIG5hbWUkMSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2NvZGUpLnRvTG93ZXJDYXNlKCk7XG4gICAga2V5Y29kZVtuYW1lJDFdID0gX2NvZGU7XG59XG52YXIgbW9kaWZpZXIgPSB7XG4gICAgYWx0OiAnYWx0S2V5JyxcbiAgICBjdHJsOiAnY3RybEtleScsXG4gICAgbWV0YTogJ21ldGFLZXknLFxuICAgIHNoaWZ0OiAnc2hpZnRLZXknXG59O1xudmFyIG1vZGlmaWVyU2VxdWVuY2UgPSBPYmplY3Qua2V5cyhtb2RpZmllcikubWFwKGZ1bmN0aW9uKG5hbWU2KSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyW25hbWU2XTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMoaWdub3JlTW9kaWZpZXJzKSB7XG4gICAgdmFyIHZhbHVlID0gaWdub3JlTW9kaWZpZXJzID8gbnVsbCA6IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsdEtleTogdmFsdWUsXG4gICAgICAgIGN0cmxLZXk6IHZhbHVlLFxuICAgICAgICBtZXRhS2V5OiB2YWx1ZSxcbiAgICAgICAgc2hpZnRLZXk6IHZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gICAgdmFyIGlnbm9yZU1vZGlmaWVycyA9IG1vZGlmaWVycy5pbmRleE9mKCcqJykgIT09IC0xO1xuICAgIHZhciBleHBlY3RlZCA9IGNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKGlnbm9yZU1vZGlmaWVycyk7XG4gICAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09PSAnKicpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgY292ZXJlZCB0aGUgYWxsLWluIG9wZXJhdG9yXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxuICAgICAgICB2YXIgdmFsdWUgPSB0cnVlO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi5zbGljZSgwLCAxKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmUgaWYgdGhlIG1vZGlmaWVyIGlzIHByZXNzZWRcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJyEnKSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBtb2RpZmllcidzIG9wZXJhdG9yXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBtb2RpZmllclt0b2tlbl07XG4gICAgICAgIGlmICghcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIG1vZGlmaWVyIFwiJyArIHRva2VuICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0ZWRbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBleHBlY3RlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXkoa2V5KSB7XG4gICAgdmFyIGNvZGUgPSBrZXljb2RlW2tleV0gfHwgcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgaWYgKCFjb2RlIHx8IHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCBpc05hTihjb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29kZVxuICAgIF0uY29uY2F0KGtleWNvZGUuX2FsaWFzW2NvZGVdIHx8IFtdKTtcbn1cbmZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGV4cGVjdGVkLCBldmVudCkge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvbiBtYXRjaFxuICAgIHJldHVybiAhbW9kaWZpZXJTZXF1ZW5jZS5zb21lKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIG9uIG1pc21hdGNoXG4gICAgICAgIHJldHVybiB0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09ICdib29sZWFuJyAmJiBCb29sZWFuKGV2ZW50W3Byb3BdKSAhPT0gZXhwZWN0ZWRbcHJvcF07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBrZXlCaW5kaW5nKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihfdGV4dCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gX3RleHQuc3BsaXQoJysnKTtcbiAgICAgICAgdmFyIF9tb2RpZmllcnMgPSByZXNvbHZlTW9kaWZpZXJzKHRva2Vucy5zbGljZSgwLCAtMSkpO1xuICAgICAgICB2YXIgX2tleUNvZGVzID0gcmVzb2x2ZUtleSh0b2tlbnMuc2xpY2UoLTEpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleUNvZGVzOiBfa2V5Q29kZXMsXG4gICAgICAgICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXG4gICAgICAgICAgICBtYXRjaE1vZGlmaWVyczogbWF0Y2hNb2RpZmllcnMuYmluZChudWxsLCBfbW9kaWZpZXJzKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8gTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpcyBhdmFpbGFibGUgc2luY2UgSUU5XG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cbi8vIGNhbGxiYWNrIHJldHVybnMgdHJ1ZSB3aGVuIGVsZW1lbnQgaXMgY29udGFpbmVkIGJ5IHBhcmVudCBvciBpcyB0aGUgcGFyZW50IHN1aXRlZCBmb3IgdXNlIHdpdGggQXJyYXkuc29tZSgpXG4vKlxuICBVU0FHRTpcbiAgICB2YXIgaXNDaGlsZE9mID0gZ2V0UGFyZW50Q29tcGFyYXRvcih7cGFyZW50OiBzb21lTm9kZX0pO1xuICAgIGxpc3RPZkVsZW1lbnRzLnNvbWUoaXNDaGlsZE9mKVxuKi8gZnVuY3Rpb24gZ2V0UGFyZW50Q29tcGFyYXRvcigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIHBhcmVudCA9IF9yZWYucGFyZW50LCBlbGVtZW50ID0gX3JlZi5lbGVtZW50LCBpbmNsdWRlU2VsZiA9IF9yZWYuaW5jbHVkZVNlbGY7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGluY2x1ZGVTZWxmICYmIG5vZGUgPT09IHBhcmVudCB8fCBwYXJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpc1BhcmVudE9mKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGluY2x1ZGVTZWxmICYmIGVsZW1lbnQgPT09IG5vZGUgfHwgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndXRpbC9jb21wYXJlLXBvc2l0aW9uI2dldFBhcmVudENvbXBhcmF0b3IgcmVxdWlyZWQgZWl0aGVyIG9wdGlvbnMucGFyZW50IG9yIG9wdGlvbnMuZWxlbWVudCcpO1xufVxuLy8gQnVnIDI4NjkzMyAtIEtleSBldmVudHMgaW4gdGhlIGF1dG9jb21wbGV0ZSBwb3B1cCBzaG91bGQgYmUgaGlkZGVuIGZyb20gcGFnZSBzY3JpcHRzXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yODY5MzNcbmZ1bmN0aW9uIHdoZW5LZXkoKSB7XG4gICAgdmFyIG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGJpbmRpbmdzID0ge307XG4gICAgdmFyIGNvbnRleHQgPSBub2RlQXJyYXkobWFwLmNvbnRleHQpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBkZWxldGUgbWFwLmNvbnRleHQ7XG4gICAgdmFyIGZpbHRlciA9IG5vZGVBcnJheShtYXAuZmlsdGVyKTtcbiAgICBkZWxldGUgbWFwLmZpbHRlcjtcbiAgICB2YXIgbWFwS2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgaWYgKCFtYXBLZXlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aGVuL2tleSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgb3B0aW9uIGtleScpO1xuICAgIH1cbiAgICB2YXIgcmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gcmVnaXN0ZXJCaW5kaW5nKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmtleUNvZGVzLmZvckVhY2goZnVuY3Rpb24oY29kZSkge1xuICAgICAgICAgICAgaWYgKCFiaW5kaW5nc1tjb2RlXSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzW2NvZGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5nc1tjb2RlXS5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtYXBLZXlzLmZvckVhY2goZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hcFt0ZXh0XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2hlbi9rZXkgcmVxdWlyZXMgb3B0aW9uW1wiJyArIHRleHQgKyAnXCJdIHRvIGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbiBhZGRDYWxsYmFjayhldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2sgPSBtYXBbdGV4dF07XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGtleUJpbmRpbmcodGV4dCkubWFwKGFkZENhbGxiYWNrKS5mb3JFYWNoKHJlZ2lzdGVyQmluZGluZyk7XG4gICAgfSk7XG4gICAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlbGVtZW50cyB3aXRoaW4gdGhlIGV4ZW1wdGVkIHN1Yi10cmVlc1xuICAgICAgICAgICAgdmFyIGlzUGFyZW50T2ZFbGVtZW50ID0gZ2V0UGFyZW50Q29tcGFyYXRvcih7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XG4gICAgICAgIGlmICghYmluZGluZ3Nba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmdzW2tleV0uZm9yRWFjaChmdW5jdGlvbihfZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghX2V2ZW50Lm1hdGNoTW9kaWZpZXJzKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9ldmVudC5jYWxsYmFjay5jYWxsKGNvbnRleHQsIGV2ZW50LCBkaXNlbmdhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICB2YXIgZGlzZW5nYWdlID0gZnVuY3Rpb24gZGlzZW5nYWdlKCkge1xuICAgICAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNlbmdhZ2U6IGRpc2VuZ2FnZVxuICAgIH07XG59XG5mdW5jdGlvbiBfZGVmYXVsdCh7IGNvbnRleHQgIH0gPSB7fSkge1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHN1cHBvcnRzIHRlc3RzIGFyZSBydW4gYmVmb3JlIGludGVyY2VwdGluZyB0aGUgVGFiIGtleSxcbiAgICAvLyBvciBJRTEwIGFuZCBJRTExIHdpbGwgZmFpbCB0byBwcm9jZXNzIHRoZSBmaXJzdCBUYWIga2V5IGV2ZW50LiBOb3RcbiAgICAvLyBsaW1pdGluZyB0aGlzIHdhcm0tdXAgdG8gSUUgYmVjYXVzZSBpdCBtYXkgYmUgYSBwcm9ibGVtIGVsc2V3aGVyZSwgdG9vLlxuICAgIHF1ZXJ5VGFic2VxdWVuY2UoKTtcbiAgICByZXR1cm4gd2hlbktleSh7XG4gICAgICAgIC8vIFNhZmFyaSBvbiBPU1ggbWF5IHJlcXVpcmUgQUxUK1RBQiB0byByZWFjaCBsaW5rcyxcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMTQ2XG4gICAgICAgICc/YWx0Kz9zaGlmdCt0YWInOiBmdW5jdGlvbiBhbHRTaGlmdFRhYihldmVudCkge1xuICAgICAgICAgICAgLy8gd2UncmUgY29tcGxldGVseSB0YWtpbmcgb3ZlciB0aGUgVGFiIGtleSBoYW5kbGluZ1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IHF1ZXJ5VGFic2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGJhY2t3YXJkID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBzZXF1ZW5jZVswXTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gc2VxdWVuY2Vbc2VxdWVuY2UubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAvLyB3cmFwIGFyb3VuZCBmaXJzdCB0byBsYXN0LCBsYXN0IHRvIGZpcnN0XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYmFja3dhcmQgPyBmaXJzdCA6IGxhc3Q7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gYmFja3dhcmQgPyBsYXN0IDogZmlyc3Q7XG4gICAgICAgICAgICBpZiAoaXNBY3RpdmVFbGVtZW50KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5kIGN1cnJlbnQgcG9zaXRpb24gaW4gdGFic2VxdWVuY2VcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBzZXF1ZW5jZS5zb21lKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FjdGl2ZUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIHJlZGlyZWN0IHRvIGZpcnN0IGFzIHdlJ3JlIG5vdCBpbiBvdXIgdGFic2VxdWVuY2VcbiAgICAgICAgICAgICAgICBmaXJzdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNoaWZ0IGZvY3VzIHRvIHByZXZpb3VzL25leHQgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBiYWNrd2FyZCA/IC0xIDogMTtcbiAgICAgICAgICAgIHNlcXVlbmNlW2N1cnJlbnRJbmRleCArIG9mZnNldF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWludGFpbi0tdGFiLWZvY3VzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcGxhdGZvcm0iLCJfY3NzRXNjYXBlIiwibm9kZUFycmF5IiwiaW5wdXQiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlVHlwZSIsInVuZGVmaW5lZCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsInNsaWNlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsImNvbnRleHRUb0VsZW1lbnQiLCJfcmVmIiwiY29udGV4dCIsIl9yZWYkbGFiZWwiLCJsYWJlbCIsInJlc29sdmVEb2N1bWVudCIsImRlZmF1bHRUb0RvY3VtZW50IiwiZWxlbWVudCIsIk5vZGUiLCJET0NVTUVOVF9OT0RFIiwiZG9jdW1lbnRFbGVtZW50IiwiRUxFTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldFNoYWRvd0hvc3QiLCJhcmd1bWVudHMiLCJjb250YWluZXIiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldERvY3VtZW50Iiwibm9kZSIsIm93bmVyRG9jdW1lbnQiLCJpc0FjdGl2ZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50Iiwic2hhZG93SG9zdCIsInNoYWRvd1Jvb3QiLCJnZXRQYXJlbnRzIiwibGlzdCIsInB1c2giLCJuYW1lcyIsIm5hbWUiLCJmaW5kTWV0aG9kTmFtZSIsInNvbWUiLCJfbmFtZSIsImVsZW1lbnRNYXRjaGVzIiwic2VsZWN0b3IxIiwicGxhdGZvcm0iLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJvcyIsImZhbWlseSIsIkFORFJPSUQiLCJXSU5ET1dTIiwiT1NYIiwiSU9TIiwiQkxJTksiLCJsYXlvdXQiLCJHRUNLTyIsIlRSSURFTlQiLCJFREdFIiwiV0VCS0lUIiwidmVyc2lvbiIsInBhcnNlRmxvYXQiLCJtYWpvclZlcnNpb24iLCJNYXRoIiwiZmxvb3IiLCJpcyIsIklFOSIsIklFMTAiLCJJRTExIiwiYmVmb3JlIiwiZGF0YSIsIndpbmRvd1Njcm9sbFRvcCIsIndpbmRvdyIsInNjcm9sbFRvcCIsIndpbmRvd1Njcm9sbExlZnQiLCJzY3JvbGxMZWZ0IiwiYm9keVNjcm9sbFRvcCIsImJvZHkiLCJib2R5U2Nyb2xsTGVmdCIsImlmcmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsIl93aW5kb3ciLCJjb250ZW50V2luZG93Iiwib3BlbiIsImNsb3NlIiwid3JhcHBlciIsInRlc3QiLCJvcHRpb25zIiwiaW5uZXJIVE1MIiwiZm9jdXMxIiwibXV0YXRlIiwiZm9jdXMiLCJ2YWxpZGF0ZSIsImFmdGVyIiwiYmx1ciIsInJlbW92ZUNoaWxkIiwiZGV0ZWN0Rm9jdXMiLCJ0ZXN0cyIsInJlc3VsdHMiLCJrZXlzIiwibWFwIiwia2V5IiwidmVyc2lvbiQxIiwicmVhZExvY2FsU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJlIiwid3JpdGVMb2NhbFN0b3JhZ2UiLCJoYXNGb2N1cyIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwiY2FjaGVLZXkiLCJjYWNoZSIsImNhY2hlJDEiLCJnZXQiLCJzZXQiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwidGltZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwicXVlcnlTZWxlY3RvciIsIm5vQXJyb3dBcnJvd0Fycm93Iiwibm9EZWVwIiwiZ2lmIiwiZm9jdXNBcmVhSW1nVGFiaW5kZXgiLCJmb2N1c0FyZWFUYWJpbmRleCIsImZvY3VzVGFyZ2V0IiwiZm9jdXMyIiwiZm9jdXNBcmVhV2l0aG91dEhyZWYiLCJmb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzIiwiaW52YWxpZEdpZiIsImZvY3VzQnJva2VuSW1hZ2VNYXAiLCJmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94IiwiZm9jdXNGaWVsZHNldERpc2FibGVkIiwiZm9jdXNGaWVsZHNldCIsImZvY3VzRmxleGJveENvbnRhaW5lciIsImZvY3VzRm9ybURpc2FibGVkIiwiZm9jdXNJbWdJc21hcCIsImhyZWYiLCJmb2N1c0ltZ1VzZW1hcFRhYmluZGV4IiwiZm9jdXNJbkhpZGRlbklmcmFtZSIsImlmcmFtZURvY3VtZW50Iiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiZm9jdXMzIiwicmVzdWx0IiwiZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QiLCJmb2N1c0ludmFsaWRUYWJpbmRleCIsImZvY3VzTGFiZWxUYWJpbmRleCIsInZhcmlhYmxlVG9QcmV2ZW50RGVhZENvZGVFbGltaW5hdGlvbiIsIm9mZnNldEhlaWdodCIsInN2ZyIsImZvY3VzT2JqZWN0U3ZnSGlkZGVuIiwiZm9jdXNPYmplY3RTdmciLCJyZXN1bHQkMSIsImZvY3VzT2JqZWN0U3dmIiwiZm9jdXNSZWRpcmVjdEltZ1VzZW1hcCIsInRhcmdldCIsImZvY3VzUmVkaXJlY3RMZWdlbmQiLCJmb2N1c2FibGUiLCJ0YWJiYWJsZSIsImZvY3VzU2Nyb2xsQm9keSIsImZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93IiwiZm9jdXNTY3JvbGxDb250YWluZXIiLCJmb2N1c1N1bW1hcnkiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIm1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0IiwiZm9yZWlnbk9iamVjdCIsImNyZWF0ZUVsZW1lbnROUyIsIndpZHRoIiwiYmFzZVZhbCIsImhlaWdodCIsImxhc3RDaGlsZCIsInR5cGUiLCJmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrIiwiaXNTdmdFbGVtZW50Iiwib3duZXJTVkdFbGVtZW50Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImRpc2FibGVkIiwiZ2VuZXJhdGUiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsImZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlIiwiZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSIsImZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSIsImZvY3VzU3ZnVXNlVGFiaW5kZXgiLCJqb2luIiwiZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXgiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInJlc3VsdCQyIiwiQm9vbGVhbiIsIlNWR0VsZW1lbnQiLCJmb2N1c1N2Z0luSWZyYW1lIiwiZm9jdXNTdmciLCJmaXJzdENoaWxkIiwiZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyIsImZvY3VzVGFibGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJmb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzIiwicmVzdWx0JDMiLCJ0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uIiwidGVzdENhbGxiYWNrcyIsInRlc3REZXNjcmlwdGlvbnMiLCJleGVjdXRlVGVzdHMiLCJzdXBwb3J0c0NhY2hlIiwiX3N1cHBvcnRzIiwic3VwcG9ydHMiLCJ2YWxpZEludGVnZXJQYXR0ZXJuTm9UcmFpbGluZyIsInZhbGlkSW50ZWdlclBhdHRlcm5XaXRoVHJhaWxpbmciLCJpc1ZhbGlkVGFiaW5kZXgiLCJ2YWxpZEludGVnZXJQYXR0ZXJuIiwiaGFzVGFiaW5kZXgiLCJoYXNBdHRyaWJ1dGUiLCJoYXNUYWJJbmRleCIsInRhYmluZGV4IiwiZ2V0QXR0cmlidXRlIiwidGFiaW5kZXhWYWx1ZSIsImF0dHJpYnV0ZU5hbWUiLCJwYXJzZUludCIsImlzTmFOIiwiaXNVc2VyTW9kaWZ5V3JpdGFibGUiLCJ1c2VyTW9kaWZ5Iiwid2Via2l0VXNlck1vZGlmeSIsImluZGV4T2YiLCJoYXNDc3NPdmVyZmxvd1Njcm9sbCIsImdldFByb3BlcnR5VmFsdWUiLCJvdmVyZmxvdyIsImhhc0Nzc0Rpc3BsYXlGbGV4IiwiZGlzcGxheSIsImlzU2Nyb2xsYWJsZUNvbnRhaW5lciIsInBhcmVudE5vZGVOYW1lIiwicGFyZW50U3R5bGUiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInNjcm9sbFdpZHRoIiwic3VwcG9ydHMkMSIsImlzRm9jdXNSZWxldmFudFJ1bGVzIiwiX3JlZiRleGNlcHQiLCJleGNlcHQiLCJmbGV4Ym94Iiwic2Nyb2xsYWJsZSIsInNoYWRvdyIsInN2Z1R5cGUiLCJ2YWxpZFRhYmluZGV4IiwiaXNTdmdDb250ZW50IiwiZm9jdXNhYmxlQXR0cmlidXRlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhhc0xpbmtQYXJlbnQiLCJwYXJlbnQiLCJwYXJlbnQxIiwicGFyZW50RWxlbWVudCIsImlzRm9jdXNSZWxldmFudDEiLCJpc0ZvY3VzUmVsZXZhbnQiLCJydWxlcyIsImZpbmRJbmRleCIsImFycmF5IiwiY2FsbGJhY2siLCJpIiwiZ2V0Q29udGVudERvY3VtZW50IiwiY29udGVudERvY3VtZW50IiwiZ2V0U1ZHRG9jdW1lbnQiLCJnZXRXaW5kb3ciLCJkZWZhdWx0VmlldyIsInNoYWRvd1ByZWZpeCIsInNlbGVjdEluU2hhZG93cyIsInNlbGVjdG9yMiIsIm9wZXJhdG9yIiwicmVwbGFjZSIsInNwbGl0Iiwic2VsZWN0b3IiLCJmaW5kRG9jdW1lbnRIb3N0RWxlbWVudCIsIl9mcmFtZUVsZW1lbnQiLCJwb3RlbnRpYWxIb3N0cyIsImdldEZyYW1lRWxlbWVudCIsImZyYW1lRWxlbWVudCIsIm5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuIiwiY29tcHV0ZWRTdHlsZSIsInByb3BlcnR5Iiwibm90RGlzcGxheWVkIiwiX3BhdGgiLCJub3RWaXNpYmxlIiwiaGlkZGVuIiwidmlzaWJsZSIsImNvbGxhcHNlZFBhcmVudCIsIm9mZnNldCIsImlzVmlzaWJsZVJ1bGVzIiwibm90UmVuZGVyZWQiLCJjc3NEaXNwbGF5IiwiY3NzVmlzaWJpbGl0eSIsImRldGFpbHNFbGVtZW50IiwiYnJvd3NpbmdDb250ZXh0IiwiaXNBdWRpb1dpdGhvdXRDb250cm9scyIsIl9pc1Zpc2libGUiLCJpc1Zpc2libGUxIiwiaXNWaXNpYmxlIiwiZ2V0TWFwQnlOYW1lIiwibmFtZTEiLCJnZXRJbWFnZU9mQXJlYSIsInN1cHBvcnRzJDIiLCJpc1ZhbGlkQXJlYSIsImltZyIsImNvbXBsZXRlIiwibmF0dXJhbEhlaWdodCIsImNoaWxkT2ZJbnRlcmFjdGl2ZSIsIl9lbGVtZW50IiwibmFtZTIiLCJzdXBwb3J0cyQzIiwiZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4iLCJkaXNhYmxlZEVsZW1lbnRzIiwic2VsZWN0IiwidGV4dGFyZWEiLCJidXR0b24iLCJmaWVsZHNldCIsImZvcm0iLCJpc05hdGl2ZURpc2FibGVkU3VwcG9ydGVkIiwiUmVnRXhwIiwic3VwcG9ydHMkNCIsImlzRGlzYWJsZWRGaWVsZHNldCIsImlzRGlzYWJsZWRGb3JtIiwiaXNEaXNhYmxlZCIsInBhcmVudHMiLCJpc09ubHlUYWJiYWJsZVJ1bGVzIiwib25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dCIsImlzT25seVRhYmJhYmxlMSIsImlzT25seVRhYmJhYmxlIiwic3VwcG9ydHMkNSIsImlzT25seUZvY3VzUmVsZXZhbnQiLCJfdGFiaW5kZXgiLCJpc0ZvY3VzYWJsZVJ1bGVzIiwib25seVRhYmJhYmxlIiwiX2lzT25seVRhYmJhYmxlIiwiZm9jdXNSZWxldmFudCIsInZpc2liaWxpdHlPcHRpb25zIiwiX25vZGVOYW1lMiIsIl9ub2RlTmFtZSIsImlzRm9jdXNhYmxlMSIsImlzRm9jdXNhYmxlIiwiY3JlYXRlRmlsdGVyIiwiY29uZGl0aW9uIiwiZmlsdGVyIiwiTm9kZUZpbHRlciIsIkZJTFRFUl9BQ0NFUFQiLCJGSUxURVJfU0tJUCIsImFjY2VwdE5vZGUiLCJQb3NzaWJseUZvY3VzYWJsZUZpbHRlciIsInF1ZXJ5Rm9jdXNhYmxlU3RyaWN0IiwiaW5jbHVkZUNvbnRleHQiLCJpbmNsdWRlT25seVRhYmJhYmxlIiwic3RyYXRlZ3kiLCJfaXNGb2N1c2FibGUiLCJ3YWxrZXIiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiU0hPV19FTEVNRU5UIiwibmV4dE5vZGUiLCJjdXJyZW50Tm9kZSIsImNvbmNhdCIsInVuc2hpZnQiLCJzdXBwb3J0cyQ2Iiwic2VsZWN0b3IkMSIsInNlbGVjdG9yJDIiLCJxdWVyeUZvY3VzYWJsZVF1aWNrIiwiX3NlbGVjdG9yIiwiZWxlbWVudHMiLCJyZXN1bHQxIiwicXVlcnlGb2N1c2FibGUiLCJfcmVmJHN0cmF0ZWd5Iiwic3VwcG9ydHMkNyIsImZvY3VzYWJsZUVsZW1lbnRzUGF0dGVybiIsImlzVGFiYmFibGVSdWxlcyIsImZyYW1lTm9kZU5hbWUiLCJpc0ZpeGVkQmxpbmsiLCJoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lIiwiaGFzVGFiYmFibGVUYWJpbmRleCIsInBvdGVudGlhbGx5VGFiYmFibGUiLCJ0YWJJbmRleCIsIl9zdHlsZSIsIl9zdHlsZTIiLCJpc0ZvY3VzUmVsZXZhbnRXaXRob3V0RmxleGJveCIsImlzVGFiYmFibGVXaXRob3V0RmxleGJveCIsImlzVGFiYmFibGUxIiwiaXNUYWJiYWJsZSIsInF1ZXJ5VGFiYmFibGUiLCJfaXNUYWJiYWJsZSIsImNvbXBhcmVEb21Qb3NpdGlvbiIsImEiLCJiIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJzb3J0RG9tT3JkZXIiLCJzb3J0IiwiZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQiLCJmaW5kSW5zZXJ0aW9uT2Zmc2V0cyIsInJlc29sdmVFbGVtZW50IiwiaW5zZXJ0aW9ucyIsImluamVjdGlvbnMiLCJpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyIsImluc2VydGVkIiwiaW5zZXJ0aW9uIiwicmVtb3ZlIiwiYXJncyIsInNwbGljZSIsImFwcGx5IiwibWVyZ2VJbkRvbU9yZGVyIiwiX2xpc3QiLCJfZWxlbWVudHMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIk1hcHMiLCJNYXBzMSIsIm1hcHMiLCJnZXRBcmVhc0ZvciIsIm5hbWUzIiwiYWRkTWFwQnlOYW1lIiwibmFtZTQiLCJleHRyYWN0QXJlYXNGcm9tTGlzdCIsInNvcnRBcmVhIiwidXNlbWFwcyIsImltYWdlIiwibmFtZTUiLCJfY3JlYXRlQ2xhc3MkMSIsIl9jbGFzc0NhbGxDaGVjayQxIiwiU2hhZG93cyIsIlNoYWRvd3MxIiwic29ydEVsZW1lbnRzMSIsInNvcnRFbGVtZW50cyIsImhvc3RDb3VudGVyIiwiaW5Ib3N0IiwiaW5Eb2N1bWVudCIsImhvc3RzIiwiX3JlZ2lzdGVySG9zdCIsIl9zb3J0aW5nSWQiLCJwYXJlbnRIb3N0IiwiX3JlZ2lzdGVySG9zdFBhcmVudCIsIl9yZWdpc3RlckVsZW1lbnQiLCJleHRyYWN0RWxlbWVudHMiLCJfaW5qZWN0SG9zdHMiLCJfcmVwbGFjZUhvc3RzIiwiX2NsZWFudXAiLCJfY29udGV4dCIsIl9tZXJnZSIsIm1lcmdlZCIsIl9yZXNvbHZlSG9zdEVsZW1lbnQiLCJiaW5kIiwic29ydFNoYWRvd2VkIiwic29ydEVsZW1lbnRzMiIsInNoYWRvd3MiLCJzb3J0VGFiaW5kZXgiLCJpbmRleGVzIiwibm9ybWFsIiwicmVkdWNlUmlnaHQiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJzdXBwb3J0cyQ4IiwibW92ZUNvbnRleHRUb0JlZ2lubmluZyIsInBvcyIsInRtcCIsInF1ZXJ5VGFic2VxdWVuY2UiLCJjcmVhdGVTaGFkb3dSb290Iiwia2V5Y29kZSIsInRhYiIsImxlZnQiLCJ1cCIsInJpZ2h0IiwiZG93biIsInBhZ2VVcCIsInBhZ2VEb3duIiwiZW5kIiwiaG9tZSIsImVudGVyIiwiZXNjYXBlIiwic3BhY2UiLCJzaGlmdCIsImNhcHNMb2NrIiwiY3RybCIsImFsdCIsIm1ldGEiLCJwYXVzZSIsImluc2VydCIsImRlbGV0ZSIsImJhY2tzcGFjZSIsIl9hbGlhcyIsIm4iLCJfbiIsImNvZGUiLCJudW1Db2RlIiwiX24yIiwiX2NvZGUiLCJuYW1lJDEiLCJmcm9tQ2hhckNvZGUiLCJtb2RpZmllciIsIm1vZGlmaWVyU2VxdWVuY2UiLCJuYW1lNiIsImNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzIiwiaWdub3JlTW9kaWZpZXJzIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInJlc29sdmVNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJleHBlY3RlZCIsInRva2VuIiwicHJvcGVydHlOYW1lIiwicmVzb2x2ZUtleSIsIm1hdGNoTW9kaWZpZXJzIiwiZXZlbnQiLCJwcm9wIiwia2V5QmluZGluZyIsInRleHQiLCJfdGV4dCIsInRva2VucyIsIl9tb2RpZmllcnMiLCJfa2V5Q29kZXMiLCJrZXlDb2RlcyIsImdldFBhcmVudENvbXBhcmF0b3IiLCJpbmNsdWRlU2VsZiIsImlzQ2hpbGRPZiIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsImlzUGFyZW50T2YiLCJ3aGVuS2V5IiwiYmluZGluZ3MiLCJtYXBLZXlzIiwicmVnaXN0ZXJCaW5kaW5nIiwiYWRkQ2FsbGJhY2siLCJoYW5kbGVLZXlEb3duIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzUGFyZW50T2ZFbGVtZW50Iiwia2V5Q29kZSIsIndoaWNoIiwiX2V2ZW50IiwiZGlzZW5nYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhbHRTaGlmdFRhYiIsInByZXZlbnREZWZhdWx0Iiwic2VxdWVuY2UiLCJiYWNrd2FyZCIsImZpcnN0IiwibGFzdCIsInNvdXJjZSIsImN1cnJlbnRJbmRleCIsImZvdW5kIiwiaW5kZXgiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js ***!
  \**********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      padding: 15px 15px 0;\n    }\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsSUFBSUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrSUFBNkI7QUFDekQsTUFBTUYsU0FBU0MsY0FBY0UsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q2xDLENBQUM7QUFDREwsY0FBYyxHQUFHRTtBQUVqQixJQUFJLENBQUMsT0FBT0YsUUFBUU0sT0FBTyxLQUFLLGNBQWUsT0FBT04sUUFBUU0sT0FBTyxLQUFLLFlBQVlOLFFBQVFNLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT04sUUFBUU0sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTSxPQUFPLEVBQUUsY0FBYztRQUFFTCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1UsTUFBTSxDQUFDUixRQUFRTSxPQUFPLEVBQUVOO0lBQy9CUyxPQUFPVCxPQUFPLEdBQUdBLFFBQVFNLE9BQU87QUFDbEMsQ0FBQyxDQUVELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXMuanM/ZTJiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG92ZXJmbG93OiBhdXRvO1xuICAgIHotaW5kZXg6IDkwMDA7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XG4gIH1cblxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XG4gICAgICBwYWRkaW5nOiAxNXB4IDE1cHggMDtcbiAgICB9XG4gIH1cblxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgICB6LWluZGV4OiAtMTtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRdIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XG4gIH1cbmA7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN0eWxlcyIsIl9ub29wVGVtcGxhdGUiLCJyZXF1aXJlIiwibm9vcCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ShadowPortal = ShadowPortal;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _reactDom = __webpack_require__(/*! react-dom */ \"react-dom\");\nfunction ShadowPortal({ children  }) {\n    let portalNode = React.useRef(null);\n    let shadowNode = React.useRef(null);\n    let [, forceUpdate] = React.useState();\n    React.useLayoutEffect(()=>{\n        const ownerDocument = document;\n        portalNode.current = ownerDocument.createElement(\"nextjs-portal\");\n        shadowNode.current = portalNode.current.attachShadow({\n            mode: \"open\"\n        });\n        ownerDocument.body.appendChild(portalNode.current);\n        forceUpdate({});\n        return ()=>{\n            if (portalNode.current && portalNode.current.ownerDocument) {\n                portalNode.current.ownerDocument.body.removeChild(portalNode.current);\n            }\n        };\n    }, []);\n    return shadowNode.current ? /*#__PURE__*/ (0, _reactDom).createPortal(children, shadowNode.current) : null;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ShadowPortal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvU2hhZG93UG9ydGFsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QixJQUFJQyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLFlBQVlILG1CQUFPQSxDQUFDLDRCQUFXO0FBQ25DLFNBQVNGLGFBQWEsRUFBRU0sU0FBUSxFQUFHLEVBQUU7SUFDakMsSUFBSUMsYUFBYUgsTUFBTUksTUFBTSxDQUFDLElBQUk7SUFDbEMsSUFBSUMsYUFBYUwsTUFBTUksTUFBTSxDQUFDLElBQUk7SUFDbEMsSUFBSSxHQUFHRSxZQUFZLEdBQUdOLE1BQU1PLFFBQVE7SUFDcENQLE1BQU1RLGVBQWUsQ0FBQyxJQUFJO1FBQ3RCLE1BQU1DLGdCQUFnQkM7UUFDdEJQLFdBQVdRLE9BQU8sR0FBR0YsY0FBY0csYUFBYSxDQUFDO1FBQ2pEUCxXQUFXTSxPQUFPLEdBQUdSLFdBQVdRLE9BQU8sQ0FBQ0UsWUFBWSxDQUFDO1lBQ2pEQyxNQUFNO1FBQ1Y7UUFDQUwsY0FBY00sSUFBSSxDQUFDQyxXQUFXLENBQUNiLFdBQVdRLE9BQU87UUFDakRMLFlBQVksQ0FBQztRQUNiLE9BQU8sSUFBSTtZQUNQLElBQUlILFdBQVdRLE9BQU8sSUFBSVIsV0FBV1EsT0FBTyxDQUFDRixhQUFhLEVBQUU7Z0JBQ3hETixXQUFXUSxPQUFPLENBQUNGLGFBQWEsQ0FBQ00sSUFBSSxDQUFDRSxXQUFXLENBQUNkLFdBQVdRLE9BQU87WUFDeEUsQ0FBQztRQUNMO0lBQ0osR0FBRyxFQUFFO0lBQ0wsT0FBT04sV0FBV00sT0FBTyxHQUFpQixXQUFILEdBQUksSUFBR1YsU0FBUyxFQUFFaUIsWUFBWSxDQUFDaEIsVUFBVUcsV0FBV00sT0FBTyxJQUFJLElBQUk7QUFDOUc7QUFFQSxJQUFJLENBQUMsT0FBT2pCLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ29CLFVBQVUsS0FBSyxhQUFhO0lBQ3JLM0IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzRCLE1BQU0sQ0FBQzFCLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0IyQixPQUFPM0IsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1NoYWRvd1BvcnRhbC5qcz8xZjExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBTaGFkb3dQb3J0YWw7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuZnVuY3Rpb24gU2hhZG93UG9ydGFsKHsgY2hpbGRyZW4gIH0pIHtcbiAgICBsZXQgcG9ydGFsTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBsZXQgc2hhZG93Tm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBsZXQgWywgZm9yY2VVcGRhdGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICBwb3J0YWxOb2RlLmN1cnJlbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25leHRqcy1wb3J0YWwnKTtcbiAgICAgICAgc2hhZG93Tm9kZS5jdXJyZW50ID0gcG9ydGFsTm9kZS5jdXJyZW50LmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICBtb2RlOiAnb3BlbidcbiAgICAgICAgfSk7XG4gICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVVwZGF0ZSh7fSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKHBvcnRhbE5vZGUuY3VycmVudCAmJiBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdERvbSkuY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBzaGFkb3dOb2RlLmN1cnJlbnQpIDogbnVsbDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhZG93UG9ydGFsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNoYWRvd1BvcnRhbCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlJlYWN0IiwiX3JlYWN0RG9tIiwiY2hpbGRyZW4iLCJwb3J0YWxOb2RlIiwidXNlUmVmIiwic2hhZG93Tm9kZSIsImZvcmNlVXBkYXRlIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJjdXJyZW50IiwiY3JlYXRlRWxlbWVudCIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js ***!
  \***************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EditorLink = EditorLink;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _useOpenInEditor = __webpack_require__(/*! ../../helpers/use-open-in-editor */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\");\nfunction EditorLink({ file  }) {\n    const open = (0, _useOpenInEditor).useOpenInEditor({\n        file,\n        column: 1,\n        lineNumber: 1\n    });\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        \"data-with-open-in-editor-link\": true,\n        tabIndex: 10,\n        role: \"link\",\n        onClick: open,\n        title: \"Click to open in your editor\"\n    }, file, /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }, /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"\n    }), /*#__PURE__*/ _react.default.createElement(\"polyline\", {\n        points: \"15 3 21 3 21 9\"\n    }), /*#__PURE__*/ _react.default.createElement(\"line\", {\n        x1: \"10\",\n        y1: \"14\",\n        x2: \"21\",\n        y2: \"3\"\n    })));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=EditorLink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvRWRpdG9yTGluay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBR0U7QUFDckIsSUFBSUMsMkJBQTJCQywrSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJRyxtQkFBbUJILG1CQUFPQSxDQUFDLHlKQUFrQztBQUNqRSxTQUFTRixXQUFXLEVBQUVNLEtBQUksRUFBRyxFQUFFO0lBQzNCLE1BQU1DLE9BQU8sQ0FBQyxHQUFHRixnQkFBZ0IsRUFBRUcsZUFBZSxDQUFDO1FBQy9DRjtRQUNBRyxRQUFRO1FBQ1JDLFlBQVk7SUFDaEI7SUFDQSxPQUFPLFdBQVcsR0FBR04sT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsT0FBTztRQUNyRCxpQ0FBaUMsSUFBSTtRQUNyQ0MsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFNBQVNQO1FBQ1RRLE9BQU87SUFDWCxHQUFHVCxNQUFNLFdBQVcsR0FBR0YsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsT0FBTztRQUN2REssT0FBTztRQUNQQyxTQUFTO1FBQ1RDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxhQUFhO1FBQ2JDLGVBQWU7UUFDZkMsZ0JBQWdCO0lBQ3BCLEdBQUcsV0FBVyxHQUFHbEIsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsUUFBUTtRQUNsRFksR0FBRztJQUNQLElBQUksV0FBVyxHQUFHbkIsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsWUFBWTtRQUN2RGEsUUFBUTtJQUNaLElBQUksV0FBVyxHQUFHcEIsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsUUFBUTtRQUNuRGMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsSUFBSTtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBTzlCLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQzBCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tDLE1BQU0sQ0FBQ2hDLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JpQyxPQUFPakMsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL0VkaXRvckxpbmsuanM/OTZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRWRpdG9yTGluayA9IEVkaXRvckxpbms7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3VzZU9wZW5JbkVkaXRvciA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3VzZS1vcGVuLWluLWVkaXRvclwiKTtcbmZ1bmN0aW9uIEVkaXRvckxpbmsoeyBmaWxlICB9KSB7XG4gICAgY29uc3Qgb3BlbiA9ICgwLCBfdXNlT3BlbkluRWRpdG9yKS51c2VPcGVuSW5FZGl0b3Ioe1xuICAgICAgICBmaWxlLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIGxpbmVOdW1iZXI6IDFcbiAgICB9KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLXdpdGgtb3Blbi1pbi1lZGl0b3ItbGlua1wiOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogMTAsXG4gICAgICAgIHJvbGU6ICdsaW5rJyxcbiAgICAgICAgb25DbGljazogb3BlbixcbiAgICAgICAgdGl0bGU6ICdDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yJ1xuICAgIH0sIGZpbGUsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIlxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7XG4gICAgICAgIHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgICAgICB4MTogXCIxMFwiLFxuICAgICAgICB5MTogXCIxNFwiLFxuICAgICAgICB4MjogXCIyMVwiLFxuICAgICAgICB5MjogXCIzXCJcbiAgICB9KSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FZGl0b3JMaW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkVkaXRvckxpbmsiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl91c2VPcGVuSW5FZGl0b3IiLCJmaWxlIiwib3BlbiIsInVzZU9wZW5JbkVkaXRvciIsImNvbHVtbiIsImxpbmVOdW1iZXIiLCJjcmVhdGVFbGVtZW50IiwidGFiSW5kZXgiLCJyb2xlIiwib25DbGljayIsInRpdGxlIiwieG1sbnMiLCJ2aWV3Qm94IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiZCIsInBvaW50cyIsIngxIiwieTEiLCJ4MiIsInkyIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js ***!
  \*************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Terminal = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _anser = _interop_require_default(__webpack_require__(/*! next/dist/compiled/anser */ \"next/dist/compiled/anser\"));\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _hotLinkedText = __webpack_require__(/*! ../hot-linked-text */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js\");\nvar _editorLink = __webpack_require__(/*! ./EditorLink */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js\");\nfunction getImportTraceFiles(content) {\n    if (/ReactServerComponentsError:/.test(content) || /Import trace for requested module:/.test(content)) {\n        // It's an RSC Build Error\n        const lines = content.split(\"\\n\");\n        // Grab the lines at the end containing the files\n        const files = [];\n        while(/.+\\..+/.test(lines[lines.length - 1]) && !lines[lines.length - 1].includes(\":\")){\n            const file = lines.pop().trim();\n            files.unshift(file);\n        }\n        return [\n            lines.join(\"\\n\"),\n            files\n        ];\n    }\n    return [\n        content,\n        []\n    ];\n}\nconst Terminal = function Terminal({ content  }) {\n    const [source, editorLinks] = React.useMemo(()=>getImportTraceFiles(content), [\n        content\n    ]);\n    const decoded = React.useMemo(()=>{\n        return _anser.default.ansiToJson(source, {\n            json: true,\n            use_classes: true,\n            remove_empty: true\n        });\n    }, [\n        source\n    ]);\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-terminal\": true\n    }, /*#__PURE__*/ React.createElement(\"pre\", null, decoded.map((entry, index)=>/*#__PURE__*/ React.createElement(\"span\", {\n            key: `terminal-entry-${index}`,\n            style: _extends({\n                color: entry.fg ? `var(--color-${entry.fg})` : undefined\n            }, entry.decoration === \"bold\" ? {\n                fontWeight: 800\n            } : entry.decoration === \"italic\" ? {\n                fontStyle: \"italic\"\n            } : undefined)\n        }, /*#__PURE__*/ React.createElement(_hotLinkedText.HotlinkedText, {\n            text: entry.content\n        }))), editorLinks.map((file)=>/*#__PURE__*/ React.createElement(_editorLink.EditorLink, {\n            key: file,\n            file: file\n        }))));\n};\nexports.Terminal = Terminal;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Terminal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvVGVybWluYWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixJQUFJRyxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUUsMkJBQTJCRiwrSkFBK0Q7QUFDOUYsSUFBSUcsNEJBQTRCSCxpS0FBZ0U7QUFDaEcsSUFBSUksU0FBU0YseUJBQXlCRixtQkFBT0EsQ0FBQywwREFBMEI7QUFDeEUsSUFBSUssUUFBUUYsMEJBQTBCSCxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJTSxpQkFBaUJOLG1CQUFPQSxDQUFDLGlKQUFvQjtBQUNqRCxJQUFJTyxjQUFjUCxtQkFBT0EsQ0FBQyx5SUFBYztBQUN4QyxTQUFTUSxvQkFBb0JDLE9BQU8sRUFBRTtJQUNsQyxJQUFJLDhCQUE4QkMsSUFBSSxDQUFDRCxZQUFZLHFDQUFxQ0MsSUFBSSxDQUFDRCxVQUFVO1FBQ25HLDBCQUEwQjtRQUMxQixNQUFNRSxRQUFRRixRQUFRRyxLQUFLLENBQUM7UUFDNUIsaURBQWlEO1FBQ2pELE1BQU1DLFFBQVEsRUFBRTtRQUNoQixNQUFNLFNBQVNILElBQUksQ0FBQ0MsS0FBSyxDQUFDQSxNQUFNRyxNQUFNLEdBQUcsRUFBRSxLQUFLLENBQUNILEtBQUssQ0FBQ0EsTUFBTUcsTUFBTSxHQUFHLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDLEtBQUs7WUFDbkYsTUFBTUMsT0FBT0wsTUFBTU0sR0FBRyxHQUFHQyxJQUFJO1lBQzdCTCxNQUFNTSxPQUFPLENBQUNIO1FBQ2xCO1FBQ0EsT0FBTztZQUNITCxNQUFNUyxJQUFJLENBQUM7WUFDWFA7U0FDSDtJQUNMLENBQUM7SUFDRCxPQUFPO1FBQ0hKO1FBQ0EsRUFBRTtLQUNMO0FBQ0w7QUFDQSxNQUFNWCxXQUFXLFNBQVNBLFNBQVMsRUFBRVcsUUFBTyxFQUFLLEVBQUU7SUFDL0MsTUFBTSxDQUFDWSxRQUFRQyxZQUFZLEdBQUdqQixNQUFNa0IsT0FBTyxDQUFDLElBQUlmLG9CQUFvQkMsVUFBVTtRQUMxRUE7S0FDSDtJQUNELE1BQU1lLFVBQVVuQixNQUFNa0IsT0FBTyxDQUFDLElBQUk7UUFDOUIsT0FBT25CLE9BQU9ILE9BQU8sQ0FBQ3dCLFVBQVUsQ0FBQ0osUUFBUTtZQUNyQ0ssTUFBTSxJQUFJO1lBQ1ZDLGFBQWEsSUFBSTtZQUNqQkMsY0FBYyxJQUFJO1FBQ3RCO0lBQ0osR0FBRztRQUNDUDtLQUNIO0lBQ0QsT0FBTyxXQUFXLEdBQUdoQixNQUFNd0IsYUFBYSxDQUFDLE9BQU87UUFDNUMsd0JBQXdCLElBQUk7SUFDaEMsR0FBRyxXQUFXLEdBQUd4QixNQUFNd0IsYUFBYSxDQUFDLE9BQU8sSUFBSSxFQUFFTCxRQUFRTSxHQUFHLENBQUMsQ0FBQ0MsT0FBT0MsUUFBUSxXQUFXLEdBQUczQixNQUFNd0IsYUFBYSxDQUFDLFFBQVE7WUFDaEhJLEtBQUssQ0FBQyxlQUFlLEVBQUVELE1BQU0sQ0FBQztZQUM5QkUsT0FBT25DLFNBQVM7Z0JBQ1pvQyxPQUFPSixNQUFNSyxFQUFFLEdBQUcsQ0FBQyxZQUFZLEVBQUVMLE1BQU1LLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBR0MsU0FBUztZQUM1RCxHQUFHTixNQUFNTyxVQUFVLEtBQUssU0FBUztnQkFDN0JDLFlBQVk7WUFDaEIsSUFBSVIsTUFBTU8sVUFBVSxLQUFLLFdBQVc7Z0JBQ2hDRSxXQUFXO1lBQ2YsSUFBSUgsU0FBUztRQUNqQixHQUFHLFdBQVcsR0FBR2hDLE1BQU13QixhQUFhLENBQUN2QixlQUFlbUMsYUFBYSxFQUFFO1lBQy9EQyxNQUFNWCxNQUFNdEIsT0FBTztRQUN2QixNQUFNYSxZQUFZUSxHQUFHLENBQUMsQ0FBQ2QsT0FBTyxXQUFXLEdBQUdYLE1BQU13QixhQUFhLENBQUN0QixZQUFZb0MsVUFBVSxFQUFFO1lBQ3BGVixLQUFLakI7WUFDTEEsTUFBTUE7UUFDVjtBQUNSO0FBQ0FwQixnQkFBZ0IsR0FBR0U7QUFFbkIsSUFBSSxDQUFDLE9BQU9GLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQzJDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT21ELE1BQU0sQ0FBQ2pELFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JrRCxPQUFPbEQsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL1Rlcm1pbmFsLmpzPzI0YTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRlcm1pbmFsID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9hbnNlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Fuc2VyXCIpKTtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaG90TGlua2VkVGV4dCA9IHJlcXVpcmUoXCIuLi9ob3QtbGlua2VkLXRleHRcIik7XG52YXIgX2VkaXRvckxpbmsgPSByZXF1aXJlKFwiLi9FZGl0b3JMaW5rXCIpO1xuZnVuY3Rpb24gZ2V0SW1wb3J0VHJhY2VGaWxlcyhjb250ZW50KSB7XG4gICAgaWYgKC9SZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvcjovLnRlc3QoY29udGVudCkgfHwgL0ltcG9ydCB0cmFjZSBmb3IgcmVxdWVzdGVkIG1vZHVsZTovLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgLy8gSXQncyBhbiBSU0MgQnVpbGQgRXJyb3JcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgLy8gR3JhYiB0aGUgbGluZXMgYXQgdGhlIGVuZCBjb250YWluaW5nIHRoZSBmaWxlc1xuICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICB3aGlsZSgvLitcXC4uKy8udGVzdChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkgJiYgIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmluY2x1ZGVzKCc6Jykpe1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGxpbmVzLnBvcCgpLnRyaW0oKTtcbiAgICAgICAgICAgIGZpbGVzLnVuc2hpZnQoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxpbmVzLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgW11cbiAgICBdO1xufVxuY29uc3QgVGVybWluYWwgPSBmdW5jdGlvbiBUZXJtaW5hbCh7IGNvbnRlbnQgLCAgfSkge1xuICAgIGNvbnN0IFtzb3VyY2UsIGVkaXRvckxpbmtzXSA9IFJlYWN0LnVzZU1lbW8oKCk9PmdldEltcG9ydFRyYWNlRmlsZXMoY29udGVudCksIFtcbiAgICAgICAgY29udGVudFxuICAgIF0pO1xuICAgIGNvbnN0IGRlY29kZWQgPSBSZWFjdC51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiBfYW5zZXIuZGVmYXVsdC5hbnNpVG9Kc29uKHNvdXJjZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgc291cmNlXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtdGVybWluYWxcIjogdHJ1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLCBkZWNvZGVkLm1hcCgoZW50cnksIGluZGV4KT0+LyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgICBrZXk6IGB0ZXJtaW5hbC1lbnRyeS0ke2luZGV4fWAsXG4gICAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiBlbnRyeS5mZyA/IGB2YXIoLS1jb2xvci0ke2VudHJ5LmZnfSlgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCBlbnRyeS5kZWNvcmF0aW9uID09PSAnYm9sZCcgPyB7XG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogODAwXG4gICAgICAgICAgICB9IDogZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2l0YWxpYycgPyB7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiAnaXRhbGljJ1xuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZClcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9ob3RMaW5rZWRUZXh0LkhvdGxpbmtlZFRleHQsIHtcbiAgICAgICAgICAgIHRleHQ6IGVudHJ5LmNvbnRlbnRcbiAgICAgICAgfSkpKSwgZWRpdG9yTGlua3MubWFwKChmaWxlKT0+LyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9lZGl0b3JMaW5rLkVkaXRvckxpbmssIHtcbiAgICAgICAgICAgIGtleTogZmlsZSxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVcbiAgICAgICAgfSkpKSk7XG59O1xuZXhwb3J0cy5UZXJtaW5hbCA9IFRlcm1pbmFsO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXJtaW5hbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUZXJtaW5hbCIsIl9leHRlbmRzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2Fuc2VyIiwiUmVhY3QiLCJfaG90TGlua2VkVGV4dCIsIl9lZGl0b3JMaW5rIiwiZ2V0SW1wb3J0VHJhY2VGaWxlcyIsImNvbnRlbnQiLCJ0ZXN0IiwibGluZXMiLCJzcGxpdCIsImZpbGVzIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJmaWxlIiwicG9wIiwidHJpbSIsInVuc2hpZnQiLCJqb2luIiwic291cmNlIiwiZWRpdG9yTGlua3MiLCJ1c2VNZW1vIiwiZGVjb2RlZCIsImFuc2lUb0pzb24iLCJqc29uIiwidXNlX2NsYXNzZXMiLCJyZW1vdmVfZW1wdHkiLCJjcmVhdGVFbGVtZW50IiwibWFwIiwiZW50cnkiLCJpbmRleCIsImtleSIsInN0eWxlIiwiY29sb3IiLCJmZyIsInVuZGVmaW5lZCIsImRlY29yYXRpb24iLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiSG90bGlua2VkVGV4dCIsInRleHQiLCJFZGl0b3JMaW5rIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js ***!
  \**********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Terminal\", ({\n    enumerable: true,\n    get: function() {\n        return _terminal.Terminal;\n    }\n}));\nvar _terminal = __webpack_require__(/*! ./Terminal */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkgsNENBQTJDO0lBQ3ZDSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9DLFVBQVVDLFFBQVE7SUFDN0I7QUFDSixDQUFDLEVBQUM7QUFDRixJQUFJRCxZQUFZRSxtQkFBT0EsQ0FBQyxxSUFBWTtBQUVwQyxJQUFJLENBQUMsT0FBT04sUUFBUU8sT0FBTyxLQUFLLGNBQWUsT0FBT1AsUUFBUU8sT0FBTyxLQUFLLFlBQVlQLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1AsUUFBUU8sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTyxPQUFPLEVBQUUsY0FBYztRQUFFTixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1csTUFBTSxDQUFDVCxRQUFRTyxPQUFPLEVBQUVQO0lBQy9CVSxPQUFPVixPQUFPLEdBQUdBLFFBQVFPLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvaW5kZXguanM/OTUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRlcm1pbmFsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGVybWluYWwuVGVybWluYWw7XG4gICAgfVxufSk7XG52YXIgX3Rlcm1pbmFsID0gcmVxdWlyZShcIi4vVGVybWluYWxcIik7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfdGVybWluYWwiLCJUZXJtaW5hbCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n\n  [data-with-open-in-editor-link] svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n  }\n  [data-with-open-in-editor-link] {\n    cursor: pointer;\n  }\n  [data-with-open-in-editor-link]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-with-open-in-editor-link] {\n    margin-left: var(--size-gap-double);\n  }\n  [data-nextjs-terminal] a {\n    color: inherit;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvc3R5bGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLGdCQUFnQkMsbUJBQU9BLENBQUMsK0lBQTZCO0FBQ3pELE1BQU1GLFNBQVNDLGNBQWNFLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDbEMsQ0FBQztBQUNETCxjQUFjLEdBQUdFO0FBRWpCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVCxPQUFPQyxjQUFjLENBQUNDLFFBQVFNLE9BQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanM/N2Q3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xuICB9XG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIH1cblxuICBbZGF0YS13aXRoLW9wZW4taW4tZWRpdG9yLWxpbmtdIHN2ZyB7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XG4gIH1cbiAgW2RhdGEtd2l0aC1vcGVuLWluLWVkaXRvci1saW5rXSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIFtkYXRhLXdpdGgtb3Blbi1pbi1lZGl0b3ItbGlua106aG92ZXIge1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbiAgfVxuICBbZGF0YS13aXRoLW9wZW4taW4tZWRpdG9yLWxpbmtdIHtcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIGEge1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICB9XG5gO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHlsZXMiLCJfbm9vcFRlbXBsYXRlIiwicmVxdWlyZSIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Toast = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nconst Toast = function Toast({ onClick , children , className  }) {\n    return /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-toast\": true,\n        onClick: onClick,\n        className: className\n    }, /*#__PURE__*/ React.createElement(\"div\", {\n        \"data-nextjs-toast-wrapper\": true\n    }, children));\n};\nexports.Toast = Toast;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Toast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvVG9hc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFDckIsSUFBSUcsNEJBQTRCQyxpS0FBZ0U7QUFDaEcsSUFBSUUsUUFBUUgsMEJBQTBCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxNQUFNRixRQUFRLFNBQVNBLE1BQU0sRUFBRUssUUFBTyxFQUFHQyxTQUFRLEVBQUdDLFVBQVMsRUFBSyxFQUFFO0lBQ2hFLE9BQU8sV0FBVyxHQUFHSCxNQUFNSSxhQUFhLENBQUMsT0FBTztRQUM1QyxxQkFBcUIsSUFBSTtRQUN6QkgsU0FBU0E7UUFDVEUsV0FBV0E7SUFDZixHQUFHLFdBQVcsR0FBR0gsTUFBTUksYUFBYSxDQUFDLE9BQU87UUFDeEMsNkJBQTZCLElBQUk7SUFDckMsR0FBR0Y7QUFDUDtBQUNBUixhQUFhLEdBQUdFO0FBRWhCLElBQUksQ0FBQyxPQUFPRixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNNLFVBQVUsS0FBSyxhQUFhO0lBQ3JLYixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPYyxNQUFNLENBQUNaLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JhLE9BQU9iLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9Ub2FzdC5qcz9kYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Ub2FzdCA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgVG9hc3QgPSBmdW5jdGlvbiBUb2FzdCh7IG9uQ2xpY2sgLCBjaGlsZHJlbiAsIGNsYXNzTmFtZSAsICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSxcbiAgICAgICAgb25DbGljazogb25DbGljayxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLXRvYXN0LXdyYXBwZXJcIjogdHJ1ZVxuICAgIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5Ub2FzdCA9IFRvYXN0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2FzdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUb2FzdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlJlYWN0Iiwib25DbGljayIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return _styles.styles;\n    }\n}));\nObject.defineProperty(exports, \"Toast\", ({\n    enumerable: true,\n    get: function() {\n        return _toast.Toast;\n    }\n}));\nvar _styles = __webpack_require__(/*! ./styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js\");\nvar _toast = __webpack_require__(/*! ./Toast */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkgsMENBQXlDO0lBQ3JDSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9DLFFBQVFDLE1BQU07SUFDekI7QUFDSixDQUFDLEVBQUM7QUFDRlAseUNBQXdDO0lBQ3BDSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9HLE9BQU9DLEtBQUs7SUFDdkI7QUFDSixDQUFDLEVBQUM7QUFDRixJQUFJSCxVQUFVSSxtQkFBT0EsQ0FBQyw4SEFBVTtBQUNoQyxJQUFJRixTQUFTRSxtQkFBT0EsQ0FBQyw0SEFBUztBQUU5QixJQUFJLENBQUMsT0FBT1IsUUFBUVMsT0FBTyxLQUFLLGNBQWUsT0FBT1QsUUFBUVMsT0FBTyxLQUFLLFlBQVlULFFBQVFTLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1QsUUFBUVMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1osT0FBT0MsY0FBYyxDQUFDQyxRQUFRUyxPQUFPLEVBQUUsY0FBYztRQUFFUixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2EsTUFBTSxDQUFDWCxRQUFRUyxPQUFPLEVBQUVUO0lBQy9CWSxPQUFPWixPQUFPLEdBQUdBLFFBQVFTLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvaW5kZXguanM/ZDNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0eWxlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0eWxlcy5zdHlsZXM7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2FzdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RvYXN0LlRvYXN0O1xuICAgIH1cbn0pO1xudmFyIF9zdHlsZXMgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG52YXIgX3RvYXN0ID0gcmVxdWlyZShcIi4vVG9hc3RcIik7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc3R5bGVzIiwic3R5bGVzIiwiX3RvYXN0IiwiVG9hc3QiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 16px;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3Qvc3R5bGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLGdCQUFnQkMsbUJBQU9BLENBQUMsK0lBQTZCO0FBQ3pELE1BQU1GLFNBQVNDLGNBQWNFLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCbEMsQ0FBQztBQUNETCxjQUFjLEdBQUdFO0FBRWpCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVCxPQUFPQyxjQUFjLENBQUNDLFFBQVFNLE9BQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9zdHlsZXMuanM/N2ZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xuICAgIGxlZnQ6IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XG4gICAgbWF4LXdpZHRoOiA0MjBweDtcbiAgICB6LWluZGV4OiA5MDAwO1xuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XG4gICAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XG4gICAgICBsZWZ0OiA1dnc7XG4gICAgfVxuICB9XG5cbiAgW2RhdGEtbmV4dGpzLXRvYXN0LXdyYXBwZXJdIHtcbiAgICBwYWRkaW5nOiAxNnB4O1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XG4gICAgYm94LXNoYWRvdzogMHB4IHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgdmFyKC0tc2l6ZS1nYXAtcXVhZClcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gIH1cbmA7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN0eWxlcyIsIl9ub29wVGVtcGxhdGUiLCJyZXF1aXJlIiwibm9vcCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.VersionStalenessInfo = VersionStalenessInfo;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nfunction VersionStalenessInfo(props) {\n    if (!props) return null;\n    const { staleness , installed , expected  } = props;\n    let text = \"\";\n    let title = \"\";\n    let indicatorClass = \"\";\n    switch(staleness){\n        case \"fresh\":\n            text = \"Next.js is up to date\";\n            title = `Latest available version is detected (${installed}).`;\n            indicatorClass = \"fresh\";\n            break;\n        case \"stale-patch\":\n        case \"stale-minor\":\n            text = `Next.js (${installed}) out of date`;\n            title = `There is a newer version (${expected}) available, upgrade recommended! `;\n            indicatorClass = \"stale\";\n            break;\n        case \"stale-major\":\n            {\n                text = `Next.js (${installed}) is outdated`;\n                title = `An outdated version detected (latest is ${expected}), upgrade is highly recommended!`;\n                indicatorClass = \"outdated\";\n                break;\n            }\n        case \"stale-prerelease\":\n            {\n                text = `Next.js (${installed}) is outdated`;\n                title = `There is a newer canary version (${expected}) available, please upgrade! `;\n                indicatorClass = \"stale\";\n                break;\n            }\n        case \"newer-than-npm\":\n        case \"unknown\":\n            break;\n        default:\n            break;\n    }\n    if (!text) return null;\n    return /*#__PURE__*/ _react.default.createElement(\"small\", {\n        className: \"nextjs-container-build-error-version-status\"\n    }, /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: indicatorClass\n    }), /*#__PURE__*/ _react.default.createElement(\"small\", {\n        className: \"nextjs-container-build-error-version-status\",\n        title: title\n    }, text), \" \", /*#__PURE__*/ _react.default.createElement(\"a\", {\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        href: \"https://nextjs.org/docs/messages/version-staleness\"\n    }, \"(learn more)\"));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=VersionStalenessInfo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm8vVmVyc2lvblN0YWxlbmVzc0luZm8uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsNEJBQTRCLEdBQUdFO0FBQy9CLElBQUlDLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlFLFNBQVNILHlCQUF5QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsU0FBU0YscUJBQXFCSyxLQUFLLEVBQUU7SUFDakMsSUFBSSxDQUFDQSxPQUFPLE9BQU8sSUFBSTtJQUN2QixNQUFNLEVBQUVDLFVBQVMsRUFBR0MsVUFBUyxFQUFHQyxTQUFRLEVBQUcsR0FBR0g7SUFDOUMsSUFBSUksT0FBTztJQUNYLElBQUlDLFFBQVE7SUFDWixJQUFJQyxpQkFBaUI7SUFDckIsT0FBT0w7UUFDSCxLQUFLO1lBQ0RHLE9BQU87WUFDUEMsUUFBUSxDQUFDLHNDQUFzQyxFQUFFSCxVQUFVLEVBQUUsQ0FBQztZQUM5REksaUJBQWlCO1lBQ2pCLEtBQU07UUFDVixLQUFLO1FBQ0wsS0FBSztZQUNERixPQUFPLENBQUMsU0FBUyxFQUFFRixVQUFVLGFBQWEsQ0FBQztZQUMzQ0csUUFBUSxDQUFDLDBCQUEwQixFQUFFRixTQUFTLGtDQUFrQyxDQUFDO1lBQ2pGRyxpQkFBaUI7WUFDakIsS0FBTTtRQUNWLEtBQUs7WUFDRDtnQkFDSUYsT0FBTyxDQUFDLFNBQVMsRUFBRUYsVUFBVSxhQUFhLENBQUM7Z0JBQzNDRyxRQUFRLENBQUMsd0NBQXdDLEVBQUVGLFNBQVMsaUNBQWlDLENBQUM7Z0JBQzlGRyxpQkFBaUI7Z0JBQ2pCLEtBQU07WUFDVjtRQUNKLEtBQUs7WUFDRDtnQkFDSUYsT0FBTyxDQUFDLFNBQVMsRUFBRUYsVUFBVSxhQUFhLENBQUM7Z0JBQzNDRyxRQUFRLENBQUMsaUNBQWlDLEVBQUVGLFNBQVMsNkJBQTZCLENBQUM7Z0JBQ25GRyxpQkFBaUI7Z0JBQ2pCLEtBQU07WUFDVjtRQUNKLEtBQUs7UUFDTCxLQUFLO1lBQ0QsS0FBTTtRQUNWO1lBQ0ksS0FBTTtJQUNkO0lBQ0EsSUFBSSxDQUFDRixNQUFNLE9BQU8sSUFBSTtJQUN0QixPQUFPLFdBQVcsR0FBR0wsT0FBT0QsT0FBTyxDQUFDUyxhQUFhLENBQUMsU0FBUztRQUN2REMsV0FBVztJQUNmLEdBQUcsV0FBVyxHQUFHVCxPQUFPRCxPQUFPLENBQUNTLGFBQWEsQ0FBQyxRQUFRO1FBQ2xEQyxXQUFXRjtJQUNmLElBQUksV0FBVyxHQUFHUCxPQUFPRCxPQUFPLENBQUNTLGFBQWEsQ0FBQyxTQUFTO1FBQ3BEQyxXQUFXO1FBQ1hILE9BQU9BO0lBQ1gsR0FBR0QsT0FBTyxLQUFLLFdBQVcsR0FBR0wsT0FBT0QsT0FBTyxDQUFDUyxhQUFhLENBQUMsS0FBSztRQUMzREUsUUFBUTtRQUNSQyxLQUFLO1FBQ0xDLE1BQU07SUFDVixHQUFHO0FBQ1A7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ2MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUUssT0FBTyxFQUFFTDtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm8vVmVyc2lvblN0YWxlbmVzc0luZm8uanM/YjdkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVmVyc2lvblN0YWxlbmVzc0luZm8gPSBWZXJzaW9uU3RhbGVuZXNzSW5mbztcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFZlcnNpb25TdGFsZW5lc3NJbmZvKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBzdGFsZW5lc3MgLCBpbnN0YWxsZWQgLCBleHBlY3RlZCAgfSA9IHByb3BzO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IHRpdGxlID0gJyc7XG4gICAgbGV0IGluZGljYXRvckNsYXNzID0gJyc7XG4gICAgc3dpdGNoKHN0YWxlbmVzcyl7XG4gICAgICAgIGNhc2UgJ2ZyZXNoJzpcbiAgICAgICAgICAgIHRleHQgPSAnTmV4dC5qcyBpcyB1cCB0byBkYXRlJztcbiAgICAgICAgICAgIHRpdGxlID0gYExhdGVzdCBhdmFpbGFibGUgdmVyc2lvbiBpcyBkZXRlY3RlZCAoJHtpbnN0YWxsZWR9KS5gO1xuICAgICAgICAgICAgaW5kaWNhdG9yQ2xhc3MgPSAnZnJlc2gnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YWxlLXBhdGNoJzpcbiAgICAgICAgY2FzZSAnc3RhbGUtbWlub3InOlxuICAgICAgICAgICAgdGV4dCA9IGBOZXh0LmpzICgke2luc3RhbGxlZH0pIG91dCBvZiBkYXRlYDtcbiAgICAgICAgICAgIHRpdGxlID0gYFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiAoJHtleHBlY3RlZH0pIGF2YWlsYWJsZSwgdXBncmFkZSByZWNvbW1lbmRlZCEgYDtcbiAgICAgICAgICAgIGluZGljYXRvckNsYXNzID0gJ3N0YWxlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGFsZS1tYWpvcic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGBOZXh0LmpzICgke2luc3RhbGxlZH0pIGlzIG91dGRhdGVkYDtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGBBbiBvdXRkYXRlZCB2ZXJzaW9uIGRldGVjdGVkIChsYXRlc3QgaXMgJHtleHBlY3RlZH0pLCB1cGdyYWRlIGlzIGhpZ2hseSByZWNvbW1lbmRlZCFgO1xuICAgICAgICAgICAgICAgIGluZGljYXRvckNsYXNzID0gJ291dGRhdGVkJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RhbGUtcHJlcmVsZWFzZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGBOZXh0LmpzICgke2luc3RhbGxlZH0pIGlzIG91dGRhdGVkYDtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGBUaGVyZSBpcyBhIG5ld2VyIGNhbmFyeSB2ZXJzaW9uICgke2V4cGVjdGVkfSkgYXZhaWxhYmxlLCBwbGVhc2UgdXBncmFkZSEgYDtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JDbGFzcyA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25ld2VyLXRoYW4tbnBtJzpcbiAgICAgICAgY2FzZSAndW5rbm93bic6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXRleHQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLXZlcnNpb24tc3RhdHVzXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBpbmRpY2F0b3JDbGFzc1xuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLXZlcnNpb24tc3RhdHVzXCIsXG4gICAgICAgIHRpdGxlOiB0aXRsZVxuICAgIH0sIHRleHQpLCAnICcsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdmVyc2lvbi1zdGFsZW5lc3NcIlxuICAgIH0sIFwiKGxlYXJuIG1vcmUpXCIpKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVyc2lvblN0YWxlbmVzc0luZm8uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVmVyc2lvblN0YWxlbmVzc0luZm8iLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsInByb3BzIiwic3RhbGVuZXNzIiwiaW5zdGFsbGVkIiwiZXhwZWN0ZWQiLCJ0ZXh0IiwidGl0bGUiLCJpbmRpY2F0b3JDbGFzcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ0YXJnZXQiLCJyZWwiLCJocmVmIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js ***!
  \**********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return _styles.styles;\n    }\n}));\nObject.defineProperty(exports, \"VersionStalenessInfo\", ({\n    enumerable: true,\n    get: function() {\n        return _versionStalenessInfo.VersionStalenessInfo;\n    }\n}));\nvar _styles = __webpack_require__(/*! ./styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js\");\nvar _versionStalenessInfo = __webpack_require__(/*! ./VersionStalenessInfo */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm8vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkgsMENBQXlDO0lBQ3JDSSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9DLFFBQVFDLE1BQU07SUFDekI7QUFDSixDQUFDLEVBQUM7QUFDRlAsd0RBQXVEO0lBQ25ESSxZQUFZLElBQUk7SUFDaEJDLEtBQUssV0FBVztRQUNaLE9BQU9HLHNCQUFzQkMsb0JBQW9CO0lBQ3JEO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBSUgsVUFBVUksbUJBQU9BLENBQUMsNklBQVU7QUFDaEMsSUFBSUYsd0JBQXdCRSxtQkFBT0EsQ0FBQyx5S0FBd0I7QUFFNUQsSUFBSSxDQUFDLE9BQU9SLFFBQVFTLE9BQU8sS0FBSyxjQUFlLE9BQU9ULFFBQVFTLE9BQU8sS0FBSyxZQUFZVCxRQUFRUyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9ULFFBQVFTLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktaLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVMsT0FBTyxFQUFFLGNBQWM7UUFBRVIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9hLE1BQU0sQ0FBQ1gsUUFBUVMsT0FBTyxFQUFFVDtJQUMvQlksT0FBT1osT0FBTyxHQUFHQSxRQUFRUyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1ZlcnNpb25TdGFsZW5lc3NJbmZvL2luZGV4LmpzPzFmM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHlsZXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdHlsZXMuc3R5bGVzO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmVyc2lvblN0YWxlbmVzc0luZm9cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJzaW9uU3RhbGVuZXNzSW5mby5WZXJzaW9uU3RhbGVuZXNzSW5mbztcbiAgICB9XG59KTtcbnZhciBfc3R5bGVzID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xudmFyIF92ZXJzaW9uU3RhbGVuZXNzSW5mbyA9IHJlcXVpcmUoXCIuL1ZlcnNpb25TdGFsZW5lc3NJbmZvXCIpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3N0eWxlcyIsInN0eWxlcyIsIl92ZXJzaW9uU3RhbGVuZXNzSW5mbyIsIlZlcnNpb25TdGFsZW5lc3NJbmZvIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = void 0;\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst styles = _noopTemplate.noop`\n  .nextjs-container-build-error-version-status {\n    flex: 1;\n    text-align: right;\n  }\n  .nextjs-container-build-error-version-status small {\n    margin-left: var(--size-gap);\n    font-size: var(--size-font-small);\n  }\n  .nextjs-container-build-error-version-status a {\n    font-size: var(--size-font-small);\n  }\n  .nextjs-container-build-error-version-status span {\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border-radius: 5px;\n    background: var(--color-ansi-bright-black);\n  }\n  .nextjs-container-build-error-version-status span.fresh {\n    background: var(--color-ansi-green);\n  }\n  .nextjs-container-build-error-version-status span.stale {\n    background: var(--color-ansi-yellow);\n  }\n  .nextjs-container-build-error-version-status span.outdated {\n    background: var(--color-ansi-red);\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm8vc3R5bGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLGdCQUFnQkMsbUJBQU9BLENBQUMsK0lBQTZCO0FBQ3pELE1BQU1GLFNBQVNDLGNBQWNFLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCbEMsQ0FBQztBQUNETCxjQUFjLEdBQUdFO0FBRWpCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVCxPQUFPQyxjQUFjLENBQUNDLFFBQVFNLE9BQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9zdHlsZXMuanM/MThmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gdm9pZCAwO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyB7XG4gICAgZmxleDogMTtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBzbWFsbCB7XG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXMgYSB7XG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLXZlcnNpb24tc3RhdHVzIHNwYW4ge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3aWR0aDogMTBweDtcbiAgICBoZWlnaHQ6IDEwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBzcGFuLmZyZXNoIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1hbnNpLWdyZWVuKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBzcGFuLnN0YWxlIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXMgc3Bhbi5vdXRkYXRlZCB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xuICB9XG5gO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHlsZXMiLCJfbm9vcFRlbXBsYXRlIiwicmVxdWlyZSIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getWordsAndWhitespaces = getWordsAndWhitespaces;\nfunction isWhitespace(char) {\n    return char === \" \" || char === \"\\n\";\n}\nfunction getWordsAndWhitespaces(text) {\n    const wordsAndWhitespaces = [];\n    let current = \"\";\n    let currentIsWhitespace = false;\n    for (const char of text){\n        if (current.length === 0) {\n            current += char;\n            currentIsWhitespace = isWhitespace(char);\n            continue;\n        }\n        const nextIsWhitespace = isWhitespace(char);\n        if (currentIsWhitespace === nextIsWhitespace) {\n            current += char;\n        } else {\n            wordsAndWhitespaces.push(current);\n            current = char;\n            currentIsWhitespace = nextIsWhitespace;\n        }\n    }\n    if (current.length > 0) {\n        wordsAndWhitespaces.push(current);\n    }\n    return wordsAndWhitespaces;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-words-and-whitespaces.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvaG90LWxpbmtlZC10ZXh0L2dldC13b3Jkcy1hbmQtd2hpdGVzcGFjZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdFO0FBQ2pDLFNBQVNDLGFBQWFDLElBQUksRUFBRTtJQUN4QixPQUFPQSxTQUFTLE9BQU9BLFNBQVM7QUFDcEM7QUFDQSxTQUFTRix1QkFBdUJHLElBQUksRUFBRTtJQUNsQyxNQUFNQyxzQkFBc0IsRUFBRTtJQUM5QixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsc0JBQXNCLEtBQUs7SUFDL0IsS0FBSyxNQUFNSixRQUFRQyxLQUFLO1FBQ3BCLElBQUlFLFFBQVFFLE1BQU0sS0FBSyxHQUFHO1lBQ3RCRixXQUFXSDtZQUNYSSxzQkFBc0JMLGFBQWFDO1lBQ25DLFFBQVM7UUFDYixDQUFDO1FBQ0QsTUFBTU0sbUJBQW1CUCxhQUFhQztRQUN0QyxJQUFJSSx3QkFBd0JFLGtCQUFrQjtZQUMxQ0gsV0FBV0g7UUFDZixPQUFPO1lBQ0hFLG9CQUFvQkssSUFBSSxDQUFDSjtZQUN6QkEsVUFBVUg7WUFDVkksc0JBQXNCRTtRQUMxQixDQUFDO0lBQ0w7SUFDQSxJQUFJSCxRQUFRRSxNQUFNLEdBQUcsR0FBRztRQUNwQkgsb0JBQW9CSyxJQUFJLENBQUNKO0lBQzdCLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVFZLE9BQU8sS0FBSyxjQUFlLE9BQU9aLFFBQVFZLE9BQU8sS0FBSyxZQUFZWixRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9aLFFBQVFZLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVksT0FBTyxFQUFFLGNBQWM7UUFBRVgsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLFFBQVFZLE9BQU8sRUFBRVo7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsUUFBUVksT0FBTztBQUNsQyxDQUFDLENBRUQscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHQvZ2V0LXdvcmRzLWFuZC13aGl0ZXNwYWNlcy5qcz8yNDZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRXb3Jkc0FuZFdoaXRlc3BhY2VzID0gZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcztcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnXFxuJztcbn1cbmZ1bmN0aW9uIGdldFdvcmRzQW5kV2hpdGVzcGFjZXModGV4dCkge1xuICAgIGNvbnN0IHdvcmRzQW5kV2hpdGVzcGFjZXMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgIGxldCBjdXJyZW50SXNXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHRleHQpe1xuICAgICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgICAgICAgIGN1cnJlbnRJc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2UoY2hhcik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0SXNXaGl0ZXNwYWNlID0gaXNXaGl0ZXNwYWNlKGNoYXIpO1xuICAgICAgICBpZiAoY3VycmVudElzV2hpdGVzcGFjZSA9PT0gbmV4dElzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29yZHNBbmRXaGl0ZXNwYWNlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IGNoYXI7XG4gICAgICAgICAgICBjdXJyZW50SXNXaGl0ZXNwYWNlID0gbmV4dElzV2hpdGVzcGFjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdvcmRzQW5kV2hpdGVzcGFjZXMucHVzaChjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmRzQW5kV2hpdGVzcGFjZXM7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC13b3Jkcy1hbmQtd2hpdGVzcGFjZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcyIsImlzV2hpdGVzcGFjZSIsImNoYXIiLCJ0ZXh0Iiwid29yZHNBbmRXaGl0ZXNwYWNlcyIsImN1cnJlbnQiLCJjdXJyZW50SXNXaGl0ZXNwYWNlIiwibGVuZ3RoIiwibmV4dElzV2hpdGVzcGFjZSIsInB1c2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js ***!
  \*****************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.HotlinkedText = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _getWordsAndWhitespaces = __webpack_require__(/*! ./get-words-and-whitespaces */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js\");\nconst linkRegex = /https?:\\/\\/[^\\s/$.?#].[^\\s\"]*/i;\nconst HotlinkedText = function HotlinkedText(props) {\n    const { text  } = props;\n    const wordsAndWhitespaces = (0, _getWordsAndWhitespaces).getWordsAndWhitespaces(text);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, linkRegex.test(text) ? wordsAndWhitespaces.map((word, index)=>{\n        if (linkRegex.test(word)) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, {\n                key: `link-${index}`\n            }, /*#__PURE__*/ _react.default.createElement(\"a\", {\n                href: word\n            }, word));\n        }\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, {\n            key: `text-${index}`\n        }, word);\n    }) : text);\n};\nexports.HotlinkedText = HotlinkedText;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvaG90LWxpbmtlZC10ZXh0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUcsMkJBQTJCQywrSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJRywwQkFBMEJILG1CQUFPQSxDQUFDLDhLQUE2QjtBQUNuRSxNQUFNSSxZQUFZO0FBQ2xCLE1BQU1OLGdCQUFnQixTQUFTQSxjQUFjTyxLQUFLLEVBQUU7SUFDaEQsTUFBTSxFQUFFQyxLQUFJLEVBQUcsR0FBR0Q7SUFDbEIsTUFBTUUsc0JBQXNCLENBQUMsR0FBR0osdUJBQXVCLEVBQUVLLHNCQUFzQixDQUFDRjtJQUNoRixPQUFPLFdBQVcsR0FBR0osT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNQLE9BQU9ELE9BQU8sQ0FBQ1MsUUFBUSxFQUFFLElBQUksRUFBRU4sVUFBVU8sSUFBSSxDQUFDTCxRQUFRQyxvQkFBb0JLLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxRQUFRO1FBQzNJLElBQUlWLFVBQVVPLElBQUksQ0FBQ0UsT0FBTztZQUN0QixPQUFPLFdBQVcsR0FBR1gsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNQLE9BQU9ELE9BQU8sQ0FBQ1MsUUFBUSxFQUFFO2dCQUN2RUssS0FBSyxDQUFDLEtBQUssRUFBRUQsTUFBTSxDQUFDO1lBQ3hCLEdBQUcsV0FBVyxHQUFHWixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxLQUFLO2dCQUMvQ08sTUFBTUg7WUFDVixHQUFHQTtRQUNQLENBQUM7UUFDRCxPQUFPLFdBQVcsR0FBR1gsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNQLE9BQU9ELE9BQU8sQ0FBQ1MsUUFBUSxFQUFFO1lBQ3ZFSyxLQUFLLENBQUMsS0FBSyxFQUFFRCxNQUFNLENBQUM7UUFDeEIsR0FBR0Q7SUFDUCxLQUFLUCxJQUFJO0FBQ2I7QUFDQVYscUJBQXFCLEdBQUdFO0FBRXhCLElBQUksQ0FBQyxPQUFPRixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNnQixVQUFVLEtBQUssYUFBYTtJQUNyS3ZCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU93QixNQUFNLENBQUN0QixRQUFRSyxPQUFPLEVBQUVMO0lBQy9CdUIsT0FBT3ZCLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHQvaW5kZXguanM/OTVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuSG90bGlua2VkVGV4dCA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcyA9IHJlcXVpcmUoXCIuL2dldC13b3Jkcy1hbmQtd2hpdGVzcGFjZXNcIik7XG5jb25zdCBsaW5rUmVnZXggPSAvaHR0cHM/OlxcL1xcL1teXFxzLyQuPyNdLlteXFxzXCJdKi9pO1xuY29uc3QgSG90bGlua2VkVGV4dCA9IGZ1bmN0aW9uIEhvdGxpbmtlZFRleHQocHJvcHMpIHtcbiAgICBjb25zdCB7IHRleHQgIH0gPSBwcm9wcztcbiAgICBjb25zdCB3b3Jkc0FuZFdoaXRlc3BhY2VzID0gKDAsIF9nZXRXb3Jkc0FuZFdoaXRlc3BhY2VzKS5nZXRXb3Jkc0FuZFdoaXRlc3BhY2VzKHRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGxpbmtSZWdleC50ZXN0KHRleHQpID8gd29yZHNBbmRXaGl0ZXNwYWNlcy5tYXAoKHdvcmQsIGluZGV4KT0+e1xuICAgICAgICBpZiAobGlua1JlZ2V4LnRlc3Qod29yZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGBsaW5rLSR7aW5kZXh9YFxuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogd29yZFxuICAgICAgICAgICAgfSwgd29yZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgIGtleTogYHRleHQtJHtpbmRleH1gXG4gICAgICAgIH0sIHdvcmQpO1xuICAgIH0pIDogdGV4dCk7XG59O1xuZXhwb3J0cy5Ib3RsaW5rZWRUZXh0ID0gSG90bGlua2VkVGV4dDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSG90bGlua2VkVGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiX2dldFdvcmRzQW5kV2hpdGVzcGFjZXMiLCJsaW5rUmVnZXgiLCJwcm9wcyIsInRleHQiLCJ3b3Jkc0FuZFdoaXRlc3BhY2VzIiwiZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInRlc3QiLCJtYXAiLCJ3b3JkIiwiaW5kZXgiLCJrZXkiLCJocmVmIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/BuildError.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/BuildError.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = exports.BuildError = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _dialog = __webpack_require__(/*! ../components/Dialog */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js\");\nvar _overlay = __webpack_require__(/*! ../components/Overlay */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js\");\nvar _terminal = __webpack_require__(/*! ../components/Terminal */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js\");\nvar _versionStalenessInfo = __webpack_require__(/*! ../components/VersionStalenessInfo */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js\");\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst BuildError = function BuildError({ message , versionInfo  }) {\n    const noop = React.useCallback(()=>{}, []);\n    return /*#__PURE__*/ React.createElement(_overlay.Overlay, {\n        fixed: true\n    }, /*#__PURE__*/ React.createElement(_dialog.Dialog, {\n        type: \"error\",\n        \"aria-labelledby\": \"nextjs__container_build_error_label\",\n        \"aria-describedby\": \"nextjs__container_build_error_desc\",\n        onClose: noop\n    }, /*#__PURE__*/ React.createElement(_dialog.DialogContent, null, /*#__PURE__*/ React.createElement(_dialog.DialogHeader, {\n        className: \"nextjs-container-build-error-header\"\n    }, /*#__PURE__*/ React.createElement(\"h4\", {\n        id: \"nextjs__container_build_error_label\"\n    }, \"Failed to compile\"), versionInfo ? /*#__PURE__*/ React.createElement(_versionStalenessInfo.VersionStalenessInfo, Object.assign({}, versionInfo)) : null), /*#__PURE__*/ React.createElement(_dialog.DialogBody, {\n        className: \"nextjs-container-build-error-body\"\n    }, /*#__PURE__*/ React.createElement(_terminal.Terminal, {\n        content: message\n    }), /*#__PURE__*/ React.createElement(\"footer\", null, /*#__PURE__*/ React.createElement(\"p\", {\n        id: \"nextjs__container_build_error_desc\"\n    }, /*#__PURE__*/ React.createElement(\"small\", null, \"This error occurred during the build process and can only be dismissed by fixing the error.\")))))));\n};\nexports.BuildError = BuildError;\nconst styles = _noopTemplate.noop`\n  .nextjs-container-build-error-header {\n    display: flex;\n    align-items: center;\n  }\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=BuildError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9CdWlsZEVycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUMzQyxJQUFJSSw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLDBJQUFzQjtBQUM1QyxJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQyw0SUFBdUI7QUFDOUMsSUFBSUssWUFBWUwsbUJBQU9BLENBQUMsOElBQXdCO0FBQ2hELElBQUlNLHdCQUF3Qk4sbUJBQU9BLENBQUMsc0tBQW9DO0FBQ3hFLElBQUlPLGdCQUFnQlAsbUJBQU9BLENBQUMsNElBQTBCO0FBQ3RELE1BQU1GLGFBQWEsU0FBU0EsV0FBVyxFQUFFVSxRQUFPLEVBQUdDLFlBQVcsRUFBSyxFQUFFO0lBQ2pFLE1BQU1DLE9BQU9SLE1BQU1TLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO0lBQ3pDLE9BQU8sV0FBVyxHQUFHVCxNQUFNVSxhQUFhLENBQUNSLFNBQVNTLE9BQU8sRUFBRTtRQUN2REMsT0FBTyxJQUFJO0lBQ2YsR0FBRyxXQUFXLEdBQUdaLE1BQU1VLGFBQWEsQ0FBQ1QsUUFBUVksTUFBTSxFQUFFO1FBQ2pEQyxNQUFNO1FBQ04sbUJBQW1CO1FBQ25CLG9CQUFvQjtRQUNwQkMsU0FBU1A7SUFDYixHQUFHLFdBQVcsR0FBR1IsTUFBTVUsYUFBYSxDQUFDVCxRQUFRZSxhQUFhLEVBQUUsSUFBSSxFQUFFLFdBQVcsR0FBR2hCLE1BQU1VLGFBQWEsQ0FBQ1QsUUFBUWdCLFlBQVksRUFBRTtRQUN0SEMsV0FBVztJQUNmLEdBQUcsV0FBVyxHQUFHbEIsTUFBTVUsYUFBYSxDQUFDLE1BQU07UUFDdkNTLElBQUk7SUFDUixHQUFHLHNCQUFzQlosY0FBYyxXQUFXLEdBQUdQLE1BQU1VLGFBQWEsQ0FBQ04sc0JBQXNCZ0Isb0JBQW9CLEVBQUU3QixPQUFPOEIsTUFBTSxDQUFDLENBQUMsR0FBR2QsZ0JBQWdCLElBQUksR0FBRyxXQUFXLEdBQUdQLE1BQU1VLGFBQWEsQ0FBQ1QsUUFBUXFCLFVBQVUsRUFBRTtRQUNoTkosV0FBVztJQUNmLEdBQUcsV0FBVyxHQUFHbEIsTUFBTVUsYUFBYSxDQUFDUCxVQUFVb0IsUUFBUSxFQUFFO1FBQ3JEQyxTQUFTbEI7SUFDYixJQUFJLFdBQVcsR0FBR04sTUFBTVUsYUFBYSxDQUFDLFVBQVUsSUFBSSxFQUFFLFdBQVcsR0FBR1YsTUFBTVUsYUFBYSxDQUFDLEtBQUs7UUFDekZTLElBQUk7SUFDUixHQUFHLFdBQVcsR0FBR25CLE1BQU1VLGFBQWEsQ0FBQyxTQUFTLElBQUksRUFBRTtBQUN4RDtBQUNBakIsa0JBQWtCLEdBQUdHO0FBQ3JCLE1BQU1ELFNBQVNVLGNBQWNHLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJsQyxDQUFDO0FBQ0RmLGNBQWMsR0FBR0U7QUFFakIsSUFBSSxDQUFDLE9BQU9GLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQzBCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTSxPQUFPLEVBQUUsY0FBYztRQUFFTCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzhCLE1BQU0sQ0FBQzVCLFFBQVFNLE9BQU8sRUFBRU47SUFDL0JpQyxPQUFPakMsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb250YWluZXIvQnVpbGRFcnJvci5qcz81YmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdHlsZXMgPSBleHBvcnRzLkJ1aWxkRXJyb3IgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZGlhbG9nID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvRGlhbG9nXCIpO1xudmFyIF9vdmVybGF5ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBfdGVybWluYWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbFwiKTtcbnZhciBfdmVyc2lvblN0YWxlbmVzc0luZm8gPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mb1wiKTtcbnZhciBfbm9vcFRlbXBsYXRlID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbmNvbnN0IEJ1aWxkRXJyb3IgPSBmdW5jdGlvbiBCdWlsZEVycm9yKHsgbWVzc2FnZSAsIHZlcnNpb25JbmZvICwgIH0pIHtcbiAgICBjb25zdCBub29wID0gUmVhY3QudXNlQ2FsbGJhY2soKCk9Pnt9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfb3ZlcmxheS5PdmVybGF5LCB7XG4gICAgICAgIGZpeGVkOiB0cnVlXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nLCB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9sYWJlbFwiLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogXCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9kZXNjXCIsXG4gICAgICAgIG9uQ2xvc2U6IG5vb3BcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2RpYWxvZy5EaWFsb2dDb250ZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2RpYWxvZy5EaWFsb2dIZWFkZXIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7XG4gICAgICAgIGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCJcbiAgICB9LCBcIkZhaWxlZCB0byBjb21waWxlXCIpLCB2ZXJzaW9uSW5mbyA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfdmVyc2lvblN0YWxlbmVzc0luZm8uVmVyc2lvblN0YWxlbmVzc0luZm8sIE9iamVjdC5hc3NpZ24oe30sIHZlcnNpb25JbmZvKSkgOiBudWxsKSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nQm9keSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5XCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX3Rlcm1pbmFsLlRlcm1pbmFsLCB7XG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgICB9KSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgICBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9kZXNjXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzIGFuZCBjYW4gb25seSBiZSBkaXNtaXNzZWQgYnkgZml4aW5nIHRoZSBlcnJvci5cIikpKSkpKSk7XG59O1xuZXhwb3J0cy5CdWlsZEVycm9yID0gQnVpbGRFcnJvcjtcbmNvbnN0IHN0eWxlcyA9IF9ub29wVGVtcGxhdGUubm9vcGBcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cblxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXApO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgc21hbGwge1xuICAgIGNvbG9yOiAjNzU3NTc1O1xuICB9XG5gO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1aWxkRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3R5bGVzIiwiQnVpbGRFcnJvciIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlJlYWN0IiwiX2RpYWxvZyIsIl9vdmVybGF5IiwiX3Rlcm1pbmFsIiwiX3ZlcnNpb25TdGFsZW5lc3NJbmZvIiwiX25vb3BUZW1wbGF0ZSIsIm1lc3NhZ2UiLCJ2ZXJzaW9uSW5mbyIsIm5vb3AiLCJ1c2VDYWxsYmFjayIsImNyZWF0ZUVsZW1lbnQiLCJPdmVybGF5IiwiZml4ZWQiLCJEaWFsb2ciLCJ0eXBlIiwib25DbG9zZSIsIkRpYWxvZ0NvbnRlbnQiLCJEaWFsb2dIZWFkZXIiLCJjbGFzc05hbWUiLCJpZCIsIlZlcnNpb25TdGFsZW5lc3NJbmZvIiwiYXNzaWduIiwiRGlhbG9nQm9keSIsIlRlcm1pbmFsIiwiY29udGVudCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/BuildError.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/Errors.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/Errors.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = exports.Errors = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _errorOverlayReducer = __webpack_require__(/*! ../error-overlay-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\");\nvar _dialog = __webpack_require__(/*! ../components/Dialog */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js\");\nvar _leftRightDialogHeader = __webpack_require__(/*! ../components/LeftRightDialogHeader */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/index.js\");\nvar _overlay = __webpack_require__(/*! ../components/Overlay */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js\");\nvar _toast = __webpack_require__(/*! ../components/Toast */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js\");\nvar _getErrorByType = __webpack_require__(/*! ../helpers/getErrorByType */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/getErrorByType.js\");\nvar _nodeStackFrames = __webpack_require__(/*! ../helpers/nodeStackFrames */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js\");\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nvar _closeIcon = __webpack_require__(/*! ../icons/CloseIcon */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/icons/CloseIcon.js\");\nvar _runtimeError = __webpack_require__(/*! ./RuntimeError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/index.js\");\nvar _versionStalenessInfo = __webpack_require__(/*! ../components/VersionStalenessInfo */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js\");\nvar _hotLinkedText = __webpack_require__(/*! ../components/hot-linked-text */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js\");\nfunction getErrorSignature(ev) {\n    const { event  } = ev;\n    switch(event.type){\n        case _errorOverlayReducer.ACTION_UNHANDLED_ERROR:\n        case _errorOverlayReducer.ACTION_UNHANDLED_REJECTION:\n            {\n                return `${event.reason.name}::${event.reason.message}::${event.reason.stack}`;\n            }\n        default:\n            {}\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const _ = event;\n    return \"\";\n}\nconst Errors = function Errors({ errors , initialDisplayState , versionInfo  }) {\n    const [lookups, setLookups] = React.useState({});\n    const [readyErrors, nextError] = React.useMemo(()=>{\n        let ready = [];\n        let next = null;\n        // Ensure errors are displayed in the order they occurred in:\n        for(let idx = 0; idx < errors.length; ++idx){\n            const e = errors[idx];\n            const { id  } = e;\n            if (id in lookups) {\n                ready.push(lookups[id]);\n                continue;\n            }\n            // Check for duplicate errors\n            if (idx > 0) {\n                const prev = errors[idx - 1];\n                if (getErrorSignature(prev) === getErrorSignature(e)) {\n                    continue;\n                }\n            }\n            next = e;\n            break;\n        }\n        return [\n            ready,\n            next\n        ];\n    }, [\n        errors,\n        lookups\n    ]);\n    const isLoading = React.useMemo(()=>{\n        return readyErrors.length < 1 && Boolean(errors.length);\n    }, [\n        errors.length,\n        readyErrors.length\n    ]);\n    React.useEffect(()=>{\n        if (nextError == null) {\n            return;\n        }\n        let mounted = true;\n        (0, _getErrorByType).getErrorByType(nextError).then((resolved)=>{\n            // We don't care if the desired error changed while we were resolving,\n            // thus we're not tracking it using a ref. Once the work has been done,\n            // we'll store it.\n            if (mounted) {\n                setLookups((m)=>_extends({}, m, {\n                        [resolved.id]: resolved\n                    }));\n            }\n        }, ()=>{\n        // TODO: handle this, though an edge case\n        });\n        return ()=>{\n            mounted = false;\n        };\n    }, [\n        nextError\n    ]);\n    const [displayState, setDisplayState] = React.useState(initialDisplayState);\n    const [activeIdx, setActiveIndex] = React.useState(0);\n    const previous = React.useCallback((e)=>{\n        e == null ? void 0 : e.preventDefault();\n        setActiveIndex((v)=>Math.max(0, v - 1));\n    }, []);\n    const next1 = React.useCallback((e)=>{\n        e == null ? void 0 : e.preventDefault();\n        setActiveIndex((v)=>Math.max(0, Math.min(readyErrors.length - 1, v + 1)));\n    }, [\n        readyErrors.length\n    ]);\n    var _activeIdx;\n    const activeError = React.useMemo(()=>(_activeIdx = readyErrors[activeIdx]) != null ? _activeIdx : null, [\n        activeIdx,\n        readyErrors\n    ]);\n    // Reset component state when there are no errors to be displayed.\n    // This should never happen, but lets handle it.\n    React.useEffect(()=>{\n        if (errors.length < 1) {\n            setLookups({});\n            setDisplayState(\"hidden\");\n            setActiveIndex(0);\n        }\n    }, [\n        errors.length\n    ]);\n    const minimize = React.useCallback((e)=>{\n        e == null ? void 0 : e.preventDefault();\n        setDisplayState(\"minimized\");\n    }, []);\n    const hide = React.useCallback((e)=>{\n        e == null ? void 0 : e.preventDefault();\n        setDisplayState(\"hidden\");\n    }, []);\n    const fullscreen = React.useCallback((e)=>{\n        e == null ? void 0 : e.preventDefault();\n        setDisplayState(\"fullscreen\");\n    }, []);\n    // This component shouldn't be rendered with no errors, but if it is, let's\n    // handle it gracefully by rendering nothing.\n    if (errors.length < 1 || activeError == null) {\n        return null;\n    }\n    if (isLoading) {\n        // TODO: better loading state\n        return /*#__PURE__*/ React.createElement(_overlay.Overlay, null);\n    }\n    if (displayState === \"hidden\") {\n        return null;\n    }\n    if (displayState === \"minimized\") {\n        return /*#__PURE__*/ React.createElement(_toast.Toast, {\n            className: \"nextjs-toast-errors-parent\",\n            onClick: fullscreen\n        }, /*#__PURE__*/ React.createElement(\"div\", {\n            className: \"nextjs-toast-errors\"\n        }, /*#__PURE__*/ React.createElement(\"svg\", {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"24\",\n            height: \"24\",\n            viewBox: \"0 0 24 24\",\n            fill: \"none\",\n            stroke: \"currentColor\",\n            strokeWidth: \"2\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\"\n        }, /*#__PURE__*/ React.createElement(\"circle\", {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\"\n        }), /*#__PURE__*/ React.createElement(\"line\", {\n            x1: \"12\",\n            y1: \"8\",\n            x2: \"12\",\n            y2: \"12\"\n        }), /*#__PURE__*/ React.createElement(\"line\", {\n            x1: \"12\",\n            y1: \"16\",\n            x2: \"12.01\",\n            y2: \"16\"\n        })), /*#__PURE__*/ React.createElement(\"span\", null, readyErrors.length, \" error\", readyErrors.length > 1 ? \"s\" : \"\"), /*#__PURE__*/ React.createElement(\"button\", {\n            \"data-nextjs-toast-errors-hide-button\": true,\n            className: \"nextjs-toast-errors-hide-button\",\n            type: \"button\",\n            onClick: (e)=>{\n                e.stopPropagation();\n                hide();\n            },\n            \"aria-label\": \"Hide Errors\"\n        }, /*#__PURE__*/ React.createElement(_closeIcon.CloseIcon, null))));\n    }\n    const isServerError = [\n        \"server\",\n        \"edge-server\"\n    ].includes((0, _nodeStackFrames).getErrorSource(activeError.error) || \"\");\n    return /*#__PURE__*/ React.createElement(_overlay.Overlay, null, /*#__PURE__*/ React.createElement(_dialog.Dialog, {\n        type: \"error\",\n        \"aria-labelledby\": \"nextjs__container_errors_label\",\n        \"aria-describedby\": \"nextjs__container_errors_desc\",\n        onClose: isServerError ? undefined : minimize\n    }, /*#__PURE__*/ React.createElement(_dialog.DialogContent, null, /*#__PURE__*/ React.createElement(_dialog.DialogHeader, {\n        className: \"nextjs-container-errors-header\"\n    }, /*#__PURE__*/ React.createElement(_leftRightDialogHeader.LeftRightDialogHeader, {\n        previous: activeIdx > 0 ? previous : null,\n        next: activeIdx < readyErrors.length - 1 ? next1 : null,\n        close: isServerError ? undefined : minimize\n    }, /*#__PURE__*/ React.createElement(\"small\", null, /*#__PURE__*/ React.createElement(\"span\", null, activeIdx + 1), \" of\", \" \", /*#__PURE__*/ React.createElement(\"span\", null, readyErrors.length), \" unhandled error\", readyErrors.length < 2 ? \"\" : \"s\"), versionInfo ? /*#__PURE__*/ React.createElement(_versionStalenessInfo.VersionStalenessInfo, Object.assign({}, versionInfo)) : null), /*#__PURE__*/ React.createElement(\"h1\", {\n        id: \"nextjs__container_errors_label\"\n    }, isServerError ? \"Server Error\" : \"Unhandled Runtime Error\"), /*#__PURE__*/ React.createElement(\"p\", {\n        id: \"nextjs__container_errors_desc\"\n    }, activeError.error.name, \":\", \" \", /*#__PURE__*/ React.createElement(_hotLinkedText.HotlinkedText, {\n        text: activeError.error.message\n    })), isServerError ? /*#__PURE__*/ React.createElement(\"div\", null, /*#__PURE__*/ React.createElement(\"small\", null, \"This error happened while generating the page. Any console logs will be displayed in the terminal window.\")) : undefined), /*#__PURE__*/ React.createElement(_dialog.DialogBody, {\n        className: \"nextjs-container-errors-body\"\n    }, /*#__PURE__*/ React.createElement(_runtimeError.RuntimeError, {\n        key: activeError.id.toString(),\n        error: activeError\n    })))));\n};\nexports.Errors = Errors;\nconst styles = _noopTemplate.noop`\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n  .nextjs-container-errors-header > p > a {\n    color: var(--color-ansi-red);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n  .nextjs-toast-errors-hide-button {\n    margin-left: var(--size-gap-triple);\n    border: none;\n    background: none;\n    color: var(--color-ansi-bright-white);\n    padding: 0;\n    transition: opacity 0.25s ease;\n    opacity: 0.7;\n  }\n  .nextjs-toast-errors-hide-button:hover {\n    opacity: 1;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9FcnJvcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN2QyxJQUFJSSxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUUsNEJBQTRCRixpS0FBZ0U7QUFDaEcsSUFBSUcsUUFBUUQsMEJBQTBCRixtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJSSx1QkFBdUJKLG1CQUFPQSxDQUFDLDRJQUEwQjtBQUM3RCxJQUFJSyxVQUFVTCxtQkFBT0EsQ0FBQywwSUFBc0I7QUFDNUMsSUFBSU0seUJBQXlCTixtQkFBT0EsQ0FBQyx3S0FBcUM7QUFDMUUsSUFBSU8sV0FBV1AsbUJBQU9BLENBQUMsNElBQXVCO0FBQzlDLElBQUlRLFNBQVNSLG1CQUFPQSxDQUFDLHdJQUFxQjtBQUMxQyxJQUFJUyxrQkFBa0JULG1CQUFPQSxDQUFDLDhJQUEyQjtBQUN6RCxJQUFJVSxtQkFBbUJWLG1CQUFPQSxDQUFDLGdKQUE0QjtBQUMzRCxJQUFJVyxnQkFBZ0JYLG1CQUFPQSxDQUFDLDRJQUEwQjtBQUN0RCxJQUFJWSxhQUFhWixtQkFBT0EsQ0FBQyxnSUFBb0I7QUFDN0MsSUFBSWEsZ0JBQWdCYixtQkFBT0EsQ0FBQyx5SUFBZ0I7QUFDNUMsSUFBSWMsd0JBQXdCZCxtQkFBT0EsQ0FBQyxzS0FBb0M7QUFDeEUsSUFBSWUsaUJBQWlCZixtQkFBT0EsQ0FBQyw0SkFBK0I7QUFDNUQsU0FBU2dCLGtCQUFrQkMsRUFBRSxFQUFFO0lBQzNCLE1BQU0sRUFBRUMsTUFBSyxFQUFHLEdBQUdEO0lBQ25CLE9BQU9DLE1BQU1DLElBQUk7UUFDYixLQUFLZixxQkFBcUJnQixzQkFBc0I7UUFDaEQsS0FB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0VsQyxDQUFDO0FBQ0RwSCxjQUFjLEdBQUdFO0FBRWpCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUMrRyxVQUFVLEtBQUssYUFBYTtJQUNyS3ZILE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8rRyxNQUFNLENBQUM3RyxRQUFRTSxPQUFPLEVBQUVOO0lBQy9Cc0gsT0FBT3RILE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29udGFpbmVyL0Vycm9ycy5qcz80ZDJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdHlsZXMgPSBleHBvcnRzLkVycm9ycyA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZXJyb3JPdmVybGF5UmVkdWNlciA9IHJlcXVpcmUoXCIuLi9lcnJvci1vdmVybGF5LXJlZHVjZXJcIik7XG52YXIgX2RpYWxvZyA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBfbGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXCIpO1xudmFyIF9vdmVybGF5ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBfdG9hc3QgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9Ub2FzdFwiKTtcbnZhciBfZ2V0RXJyb3JCeVR5cGUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9nZXRFcnJvckJ5VHlwZVwiKTtcbnZhciBfbm9kZVN0YWNrRnJhbWVzID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzXCIpO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIF9jbG9zZUljb24gPSByZXF1aXJlKFwiLi4vaWNvbnMvQ2xvc2VJY29uXCIpO1xudmFyIF9ydW50aW1lRXJyb3IgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XG52YXIgX3ZlcnNpb25TdGFsZW5lc3NJbmZvID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm9cIik7XG52YXIgX2hvdExpbmtlZFRleHQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHRcIik7XG5mdW5jdGlvbiBnZXRFcnJvclNpZ25hdHVyZShldikge1xuICAgIGNvbnN0IHsgZXZlbnQgIH0gPSBldjtcbiAgICBzd2l0Y2goZXZlbnQudHlwZSl7XG4gICAgICAgIGNhc2UgX2Vycm9yT3ZlcmxheVJlZHVjZXIuQUNUSU9OX1VOSEFORExFRF9FUlJPUjpcbiAgICAgICAgY2FzZSBfZXJyb3JPdmVybGF5UmVkdWNlci5BQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZXZlbnQucmVhc29uLm5hbWV9Ojoke2V2ZW50LnJlYXNvbi5tZXNzYWdlfTo6JHtldmVudC5yZWFzb24uc3RhY2t9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHt9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBfID0gZXZlbnQ7XG4gICAgcmV0dXJuICcnO1xufVxuY29uc3QgRXJyb3JzID0gZnVuY3Rpb24gRXJyb3JzKHsgZXJyb3JzICwgaW5pdGlhbERpc3BsYXlTdGF0ZSAsIHZlcnNpb25JbmZvICwgIH0pIHtcbiAgICBjb25zdCBbbG9va3Vwcywgc2V0TG9va3Vwc10gPSBSZWFjdC51c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgW3JlYWR5RXJyb3JzLCBuZXh0RXJyb3JdID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICBsZXQgcmVhZHkgPSBbXTtcbiAgICAgICAgbGV0IG5leHQgPSBudWxsO1xuICAgICAgICAvLyBFbnN1cmUgZXJyb3JzIGFyZSBkaXNwbGF5ZWQgaW4gdGhlIG9yZGVyIHRoZXkgb2NjdXJyZWQgaW46XG4gICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgZXJyb3JzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgY29uc3QgZSA9IGVycm9yc1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgeyBpZCAgfSA9IGU7XG4gICAgICAgICAgICBpZiAoaWQgaW4gbG9va3Vwcykge1xuICAgICAgICAgICAgICAgIHJlYWR5LnB1c2gobG9va3Vwc1tpZF0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBlcnJvcnNcbiAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGVycm9yc1tpZHggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RXJyb3JTaWduYXR1cmUocHJldikgPT09IGdldEVycm9yU2lnbmF0dXJlKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJlYWR5LFxuICAgICAgICAgICAgbmV4dFxuICAgICAgICBdO1xuICAgIH0sIFtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb29rdXBzXG4gICAgXSk7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gcmVhZHlFcnJvcnMubGVuZ3RoIDwgMSAmJiBCb29sZWFuKGVycm9ycy5sZW5ndGgpO1xuICAgIH0sIFtcbiAgICAgICAgZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgcmVhZHlFcnJvcnMubGVuZ3RoXG4gICAgXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChuZXh0RXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIF9nZXRFcnJvckJ5VHlwZSkuZ2V0RXJyb3JCeVR5cGUobmV4dEVycm9yKS50aGVuKChyZXNvbHZlZCk9PntcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgaWYgdGhlIGRlc2lyZWQgZXJyb3IgY2hhbmdlZCB3aGlsZSB3ZSB3ZXJlIHJlc29sdmluZyxcbiAgICAgICAgICAgIC8vIHRodXMgd2UncmUgbm90IHRyYWNraW5nIGl0IHVzaW5nIGEgcmVmLiBPbmNlIHRoZSB3b3JrIGhhcyBiZWVuIGRvbmUsXG4gICAgICAgICAgICAvLyB3ZSdsbCBzdG9yZSBpdC5cbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0TG9va3VwcygobSk9Pl9leHRlbmRzKHt9LCBtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbcmVzb2x2ZWQuaWRdOiByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICgpPT57XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSB0aGlzLCB0aG91Z2ggYW4gZWRnZSBjYXNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG5leHRFcnJvclxuICAgIF0pO1xuICAgIGNvbnN0IFtkaXNwbGF5U3RhdGUsIHNldERpc3BsYXlTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsRGlzcGxheVN0YXRlKTtcbiAgICBjb25zdCBbYWN0aXZlSWR4LCBzZXRBY3RpdmVJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IFJlYWN0LnVzZUNhbGxiYWNrKChlKT0+e1xuICAgICAgICBlID09IG51bGwgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldEFjdGl2ZUluZGV4KCh2KT0+TWF0aC5tYXgoMCwgdiAtIDEpKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgbmV4dDEgPSBSZWFjdC51c2VDYWxsYmFjaygoZSk9PntcbiAgICAgICAgZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRBY3RpdmVJbmRleCgodik9Pk1hdGgubWF4KDAsIE1hdGgubWluKHJlYWR5RXJyb3JzLmxlbmd0aCAtIDEsIHYgKyAxKSkpO1xuICAgIH0sIFtcbiAgICAgICAgcmVhZHlFcnJvcnMubGVuZ3RoXG4gICAgXSk7XG4gICAgdmFyIF9hY3RpdmVJZHg7XG4gICAgY29uc3QgYWN0aXZlRXJyb3IgPSBSZWFjdC51c2VNZW1vKCgpPT4oX2FjdGl2ZUlkeCA9IHJlYWR5RXJyb3JzW2FjdGl2ZUlkeF0pICE9IG51bGwgPyBfYWN0aXZlSWR4IDogbnVsbCwgW1xuICAgICAgICBhY3RpdmVJZHgsXG4gICAgICAgIHJlYWR5RXJyb3JzXG4gICAgXSk7XG4gICAgLy8gUmVzZXQgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlcmUgYXJlIG5vIGVycm9ycyB0byBiZSBkaXNwbGF5ZWQuXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgbGV0cyBoYW5kbGUgaXQuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgc2V0TG9va3Vwcyh7fSk7XG4gICAgICAgICAgICBzZXREaXNwbGF5U3RhdGUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgc2V0QWN0aXZlSW5kZXgoMCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGVycm9ycy5sZW5ndGhcbiAgICBdKTtcbiAgICBjb25zdCBtaW5pbWl6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChlKT0+e1xuICAgICAgICBlID09IG51bGwgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldERpc3BsYXlTdGF0ZSgnbWluaW1pemVkJyk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGhpZGUgPSBSZWFjdC51c2VDYWxsYmFjaygoZSk9PntcbiAgICAgICAgZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXREaXNwbGF5U3RhdGUoJ2hpZGRlbicpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBmdWxsc2NyZWVuID0gUmVhY3QudXNlQ2FsbGJhY2soKGUpPT57XG4gICAgICAgIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0RGlzcGxheVN0YXRlKCdmdWxsc2NyZWVuJyk7XG4gICAgfSwgW10pO1xuICAgIC8vIFRoaXMgY29tcG9uZW50IHNob3VsZG4ndCBiZSByZW5kZXJlZCB3aXRoIG5vIGVycm9ycywgYnV0IGlmIGl0IGlzLCBsZXQnc1xuICAgIC8vIGhhbmRsZSBpdCBncmFjZWZ1bGx5IGJ5IHJlbmRlcmluZyBub3RoaW5nLlxuICAgIGlmIChlcnJvcnMubGVuZ3RoIDwgMSB8fCBhY3RpdmVFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgICAgIC8vIFRPRE86IGJldHRlciBsb2FkaW5nIHN0YXRlXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX292ZXJsYXkuT3ZlcmxheSwgbnVsbCk7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheVN0YXRlID09PSAnbWluaW1pemVkJykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF90b2FzdC5Ub2FzdCwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50XCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBmdWxsc2NyZWVuXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9yc1wiXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgICAgIGhlaWdodDogXCIyNFwiLFxuICAgICAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgICAgICAgICAgY3g6IFwiMTJcIixcbiAgICAgICAgICAgIGN5OiBcIjEyXCIsXG4gICAgICAgICAgICByOiBcIjEwXCJcbiAgICAgICAgfSksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgICAgICAgICAgeDE6IFwiMTJcIixcbiAgICAgICAgICAgIHkxOiBcIjhcIixcbiAgICAgICAgICAgIHgyOiBcIjEyXCIsXG4gICAgICAgICAgICB5MjogXCIxMlwiXG4gICAgICAgIH0pLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICAgICAgICAgIHgxOiBcIjEyXCIsXG4gICAgICAgICAgICB5MTogXCIxNlwiLFxuICAgICAgICAgICAgeDI6IFwiMTIuMDFcIixcbiAgICAgICAgICAgIHkyOiBcIjE2XCJcbiAgICAgICAgfSkpLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIHJlYWR5RXJyb3JzLmxlbmd0aCwgXCIgZXJyb3JcIiwgcmVhZHlFcnJvcnMubGVuZ3RoID4gMSA/ICdzJyA6ICcnKSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIFwiZGF0YS1uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uXCI6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9ycy1oaWRlLWJ1dHRvblwiLFxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IChlKT0+e1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcIkhpZGUgRXJyb3JzXCJcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9jbG9zZUljb24uQ2xvc2VJY29uLCBudWxsKSkpKTtcbiAgICB9XG4gICAgY29uc3QgaXNTZXJ2ZXJFcnJvciA9IFtcbiAgICAgICAgJ3NlcnZlcicsXG4gICAgICAgICdlZGdlLXNlcnZlcidcbiAgICBdLmluY2x1ZGVzKCgwLCBfbm9kZVN0YWNrRnJhbWVzKS5nZXRFcnJvclNvdXJjZShhY3RpdmVFcnJvci5lcnJvcikgfHwgJycpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX292ZXJsYXkuT3ZlcmxheSwgbnVsbCwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nLCB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIixcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2Rlc2NcIixcbiAgICAgICAgb25DbG9zZTogaXNTZXJ2ZXJFcnJvciA/IHVuZGVmaW5lZCA6IG1pbmltaXplXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nQ29udGVudCwgbnVsbCwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nSGVhZGVyLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXJcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfbGVmdFJpZ2h0RGlhbG9nSGVhZGVyLkxlZnRSaWdodERpYWxvZ0hlYWRlciwge1xuICAgICAgICBwcmV2aW91czogYWN0aXZlSWR4ID4gMCA/IHByZXZpb3VzIDogbnVsbCxcbiAgICAgICAgbmV4dDogYWN0aXZlSWR4IDwgcmVhZHlFcnJvcnMubGVuZ3RoIC0gMSA/IG5leHQxIDogbnVsbCxcbiAgICAgICAgY2xvc2U6IGlzU2VydmVyRXJyb3IgPyB1bmRlZmluZWQgOiBtaW5pbWl6ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgYWN0aXZlSWR4ICsgMSksIFwiIG9mXCIsICcgJywgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCByZWFkeUVycm9ycy5sZW5ndGgpLCBcIiB1bmhhbmRsZWQgZXJyb3JcIiwgcmVhZHlFcnJvcnMubGVuZ3RoIDwgMiA/ICcnIDogJ3MnKSwgdmVyc2lvbkluZm8gPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX3ZlcnNpb25TdGFsZW5lc3NJbmZvLlZlcnNpb25TdGFsZW5lc3NJbmZvLCBPYmplY3QuYXNzaWduKHt9LCB2ZXJzaW9uSW5mbykpIDogbnVsbCksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtcbiAgICAgICAgaWQ6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCJcbiAgICB9LCBpc1NlcnZlckVycm9yID8gJ1NlcnZlciBFcnJvcicgOiAnVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3InKSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7XG4gICAgICAgIGlkOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCJcbiAgICB9LCBhY3RpdmVFcnJvci5lcnJvci5uYW1lLCBcIjpcIiwgJyAnLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2hvdExpbmtlZFRleHQuSG90bGlua2VkVGV4dCwge1xuICAgICAgICB0ZXh0OiBhY3RpdmVFcnJvci5lcnJvci5tZXNzYWdlXG4gICAgfSkpLCBpc1NlcnZlckVycm9yID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBoYXBwZW5lZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBwYWdlLiBBbnkgY29uc29sZSBsb2dzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0ZXJtaW5hbCB3aW5kb3cuXCIpKSA6IHVuZGVmaW5lZCksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfZGlhbG9nLkRpYWxvZ0JvZHksIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHlcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfcnVudGltZUVycm9yLlJ1bnRpbWVFcnJvciwge1xuICAgICAgICBrZXk6IGFjdGl2ZUVycm9yLmlkLnRvU3RyaW5nKCksXG4gICAgICAgIGVycm9yOiBhY3RpdmVFcnJvclxuICAgIH0pKSkpKTtcbn07XG5leHBvcnRzLkVycm9ycyA9IEVycm9ycztcbmNvbnN0IHN0eWxlcyA9IF9ub29wVGVtcGxhdGUubm9vcGBcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IGgxIHtcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBtYXJnaW46IDA7XG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0xKTtcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyIHNtYWxsID4gc3BhbiB7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gcCB7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWcpO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIG1hcmdpbjogMDtcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xuICAgIG1hcmdpbjogMDtcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gcCA+IGEge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XG4gIH1cblxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcbiAgfVxuXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudCB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XG4gIH1cbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XG4gIH1cbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gIH1cbiAgLm5leHRqcy10b2FzdC1lcnJvcnMgPiBzdmcge1xuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xuICB9XG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uIHtcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtdHJpcGxlKTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xuICAgIG9wYWNpdHk6IDAuNztcbiAgfVxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1oaWRlLWJ1dHRvbjpob3ZlciB7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuYDtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3R5bGVzIiwiRXJyb3JzIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJSZWFjdCIsIl9lcnJvck92ZXJsYXlSZWR1Y2VyIiwiX2RpYWxvZyIsIl9sZWZ0UmlnaHREaWFsb2dIZWFkZXIiLCJfb3ZlcmxheSIsIl90b2FzdCIsIl9nZXRFcnJvckJ5VHlwZSIsIl9ub2RlU3RhY2tGcmFtZXMiLCJfbm9vcFRlbXBsYXRlIiwiX2Nsb3NlSWNvbiIsIl9ydW50aW1lRXJyb3IiLCJfdmVyc2lvblN0YWxlbmVzc0luZm8iLCJfaG90TGlua2VkVGV4dCIsImdldEVycm9yU2lnbmF0dXJlIiwiZXYiLCJldmVudCIsInR5cGUiLCJBQ1RJT05fVU5IQU5ETEVEX0VSUk9SIiwiQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04iLCJyZWFzb24iLCJuYW1lIiwibWVzc2FnZSIsInN0YWNrIiwiXyIsImVycm9ycyIsImluaXRpYWxEaXNwbGF5U3RhdGUiLCJ2ZXJzaW9uSW5mbyIsImxvb2t1cHMiLCJzZXRMb29rdXBzIiwidXNlU3RhdGUiLCJyZWFkeUVycm9ycyIsIm5leHRFcnJvciIsInVzZU1lbW8iLCJyZWFkeSIsIm5leHQiLCJpZHgiLCJsZW5ndGgiLCJlIiwiaWQiLCJwdXNoIiwicHJldiIsImlzTG9hZGluZyIsIkJvb2xlYW4iLCJ1c2VFZmZlY3QiLCJtb3VudGVkIiwiZ2V0RXJyb3JCeVR5cGUiLCJ0aGVuIiwicmVzb2x2ZWQiLCJtIiwiZGlzcGxheVN0YXRlIiwic2V0RGlzcGxheVN0YXRlIiwiYWN0aXZlSWR4Iiwic2V0QWN0aXZlSW5kZXgiLCJwcmV2aW91cyIsInVzZUNhbGxiYWNrIiwicHJldmVudERlZmF1bHQiLCJ2IiwiTWF0aCIsIm1heCIsIm5leHQxIiwibWluIiwiX2FjdGl2ZUlkeCIsImFjdGl2ZUVycm9yIiwibWluaW1pemUiLCJoaWRlIiwiZnVsbHNjcmVlbiIsImNyZWF0ZUVsZW1lbnQiLCJPdmVybGF5IiwiVG9hc3QiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwieG1sbnMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJjeCIsImN5IiwiciIsIngxIiwieTEiLCJ4MiIsInkyIiwic3RvcFByb3BhZ2F0aW9uIiwiQ2xvc2VJY29uIiwiaXNTZXJ2ZXJFcnJvciIsImluY2x1ZGVzIiwiZ2V0RXJyb3JTb3VyY2UiLCJlcnJvciIsIkRpYWxvZyIsIm9uQ2xvc2UiLCJ1bmRlZmluZWQiLCJEaWFsb2dDb250ZW50IiwiRGlhbG9nSGVhZGVyIiwiTGVmdFJpZ2h0RGlhbG9nSGVhZGVyIiwiY2xvc2UiLCJWZXJzaW9uU3RhbGVuZXNzSW5mbyIsImFzc2lnbiIsIkhvdGxpbmtlZFRleHQiLCJ0ZXh0IiwiRGlhbG9nQm9keSIsIlJ1bnRpbWVFcnJvciIsImtleSIsInRvU3RyaW5nIiwibm9vcCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/Errors.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RootLayoutError.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RootLayoutError.js ***!
  \**********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = exports.RootLayoutError = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _dialog = __webpack_require__(/*! ../components/Dialog */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js\");\nvar _overlay = __webpack_require__(/*! ../components/Overlay */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js\");\nvar _terminal = __webpack_require__(/*! ../components/Terminal */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js\");\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nconst RootLayoutError = function BuildError({ missingTags  }) {\n    const message = \"Please make sure to include the following tags in your root layout: <html>, <body>.\\n\\n\" + `Missing required root layout tag${missingTags.length === 1 ? \"\" : \"s\"}: ` + missingTags.join(\", \");\n    const noop = _react.default.useCallback(()=>{}, []);\n    return /*#__PURE__*/ _react.default.createElement(_overlay.Overlay, {\n        fixed: true\n    }, /*#__PURE__*/ _react.default.createElement(_dialog.Dialog, {\n        type: \"error\",\n        \"aria-labelledby\": \"nextjs__container_root_layout_error_label\",\n        \"aria-describedby\": \"nextjs__container_root_layout_error_desc\",\n        onClose: noop\n    }, /*#__PURE__*/ _react.default.createElement(_dialog.DialogContent, null, /*#__PURE__*/ _react.default.createElement(_dialog.DialogHeader, {\n        className: \"nextjs-container-root-layout-error-header\"\n    }, /*#__PURE__*/ _react.default.createElement(\"h4\", {\n        id: \"nextjs__container_root_layout_error_label\"\n    }, \"Missing required tags\")), /*#__PURE__*/ _react.default.createElement(_dialog.DialogBody, {\n        className: \"nextjs-container-root-layout-error-body\"\n    }, /*#__PURE__*/ _react.default.createElement(_terminal.Terminal, {\n        content: message\n    }), /*#__PURE__*/ _react.default.createElement(\"footer\", null, /*#__PURE__*/ _react.default.createElement(\"p\", {\n        id: \"nextjs__container_root_layout_error_desc\"\n    }, /*#__PURE__*/ _react.default.createElement(\"small\", null, \"This error and can only be dismissed by providing all required tags.\")))))));\n};\nexports.RootLayoutError = RootLayoutError;\nconst styles = _noopTemplate.noop`\n  .nextjs-container-root-layout-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-root-layout-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-root-layout-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-root-layout-error-body small {\n    color: #757575;\n  }\n`;\nexports.styles = styles;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=RootLayoutError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9Sb290TGF5b3V0RXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ2hELElBQUlJLDJCQUEyQkMsK0pBQStEO0FBQzlGLElBQUlFLFNBQVNILHlCQUF5QkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsSUFBSUcsVUFBVUgsbUJBQU9BLENBQUMsMElBQXNCO0FBQzVDLElBQUlJLFdBQVdKLG1CQUFPQSxDQUFDLDRJQUF1QjtBQUM5QyxJQUFJSyxZQUFZTCxtQkFBT0EsQ0FBQyw4SUFBd0I7QUFDaEQsSUFBSU0sZ0JBQWdCTixtQkFBT0EsQ0FBQyw0SUFBMEI7QUFDdEQsTUFBTUYsa0JBQWtCLFNBQVNTLFdBQVcsRUFBRUMsWUFBVyxFQUFHLEVBQUU7SUFDMUQsTUFBTUMsVUFBVSw0RkFBNEYsQ0FBQyxnQ0FBZ0MsRUFBRUQsWUFBWUUsTUFBTSxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUdGLFlBQVlHLElBQUksQ0FBQztJQUMxTSxNQUFNQyxPQUFPVixPQUFPRCxPQUFPLENBQUNZLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO0lBQ2xELE9BQU8sV0FBVyxHQUFHWCxPQUFPRCxPQUFPLENBQUNhLGFBQWEsQ0FBQ1YsU0FBU1csT0FBTyxFQUFFO1FBQ2hFQyxPQUFPLElBQUk7SUFDZixHQUFHLFdBQVcsR0FBR2QsT0FBT0QsT0FBTyxDQUFDYSxhQUFhLENBQUNYLFFBQVFjLE1BQU0sRUFBRTtRQUMxREMsTUFBTTtRQUNOLG1CQUFtQjtRQUNuQixvQkFBb0I7UUFDcEJDLFNBQVNQO0lBQ2IsR0FBRyxXQUFXLEdBQUdWLE9BQU9ELE9BQU8sQ0FBQ2EsYUFBYSxDQUFDWCxRQUFRaUIsYUFBYSxFQUFFLElBQUksRUFBRSxXQUFXLEdBQUdsQixPQUFPRCxPQUFPLENBQUNhLGFBQWEsQ0FBQ1gsUUFBUWtCLFlBQVksRUFBRTtRQUN4SUMsV0FBVztJQUNmLEdBQUcsV0FBVyxHQUFHcEIsT0FBT0QsT0FBTyxDQUFDYSxhQUFhLENBQUMsTUFBTTtRQUNoRFMsSUFBSTtJQUNSLEdBQUcsMkJBQTJCLFdBQVcsR0FBR3JCLE9BQU9ELE9BQU8sQ0FBQ2EsYUFBYSxDQUFDWCxRQUFRcUIsVUFBVSxFQUFFO1FBQ3pGRixXQUFXO0lBQ2YsR0FBRyxXQUFXLEdBQUdwQixPQUFPRCxPQUFPLENBQUNhLGFBQWEsQ0FBQ1QsVUFBVW9CLFFBQVEsRUFBRTtRQUM5REMsU0FBU2pCO0lBQ2IsSUFBSSxXQUFXLEdBQUdQLE9BQU9ELE9BQU8sQ0FBQ2EsYUFBYSxDQUFDLFVBQVUsSUFBSSxFQUFFLFdBQVcsR0FBR1osT0FBT0QsT0FBTyxDQUFDYSxhQUFhLENBQUMsS0FBSztRQUMzR1MsSUFBSTtJQUNSLEdBQUcsV0FBVyxHQUFHckIsT0FBT0QsT0FBTyxDQUFDYSxhQUFhLENBQUMsU0FBUyxJQUFJLEVBQUU7QUFDakU7QUFDQW5CLHVCQUF1QixHQUFHRztBQUMxQixNQUFNRCxTQUFTUyxjQUFjTSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJsQyxDQUFDO0FBQ0RqQixjQUFjLEdBQUdFO0FBRWpCLElBQUksQ0FBQyxPQUFPRixRQUFRTSxPQUFPLEtBQUssY0FBZSxPQUFPTixRQUFRTSxPQUFPLEtBQUssWUFBWU4sUUFBUU0sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTixRQUFRTSxPQUFPLENBQUMwQixVQUFVLEtBQUssYUFBYTtJQUNyS2xDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9tQyxNQUFNLENBQUNqQyxRQUFRTSxPQUFPLEVBQUVOO0lBQy9Ca0MsT0FBT2xDLE9BQU8sR0FBR0EsUUFBUU0sT0FBTztBQUNsQyxDQUFDLENBRUQsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29udGFpbmVyL1Jvb3RMYXlvdXRFcnJvci5qcz9mYjg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdHlsZXMgPSBleHBvcnRzLlJvb3RMYXlvdXRFcnJvciA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZGlhbG9nID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvRGlhbG9nXCIpO1xudmFyIF9vdmVybGF5ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBfdGVybWluYWwgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbFwiKTtcbnZhciBfbm9vcFRlbXBsYXRlID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbmNvbnN0IFJvb3RMYXlvdXRFcnJvciA9IGZ1bmN0aW9uIEJ1aWxkRXJyb3IoeyBtaXNzaW5nVGFncyAgfSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgdGFncyBpbiB5b3VyIHJvb3QgbGF5b3V0OiA8aHRtbD4sIDxib2R5Pi5cXG5cXG4nICsgYE1pc3NpbmcgcmVxdWlyZWQgcm9vdCBsYXlvdXQgdGFnJHttaXNzaW5nVGFncy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ306IGAgKyBtaXNzaW5nVGFncy5qb2luKCcsICcpO1xuICAgIGNvbnN0IG5vb3AgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoKT0+e30sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9vdmVybGF5Lk92ZXJsYXksIHtcbiAgICAgICAgZml4ZWQ6IHRydWVcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2RpYWxvZy5EaWFsb2csIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX3Jvb3RfbGF5b3V0X2Vycm9yX2xhYmVsXCIsXG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX3Jvb3RfbGF5b3V0X2Vycm9yX2Rlc2NcIixcbiAgICAgICAgb25DbG9zZTogbm9vcFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZGlhbG9nLkRpYWxvZ0NvbnRlbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZGlhbG9nLkRpYWxvZ0hlYWRlciwge1xuICAgICAgICBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1yb290LWxheW91dC1lcnJvci1oZWFkZXJcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImg0XCIsIHtcbiAgICAgICAgaWQ6IFwibmV4dGpzX19jb250YWluZXJfcm9vdF9sYXlvdXRfZXJyb3JfbGFiZWxcIlxuICAgIH0sIFwiTWlzc2luZyByZXF1aXJlZCB0YWdzXCIpKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9kaWFsb2cuRGlhbG9nQm9keSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1yb290LWxheW91dC1lcnJvci1ib2R5XCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3Rlcm1pbmFsLlRlcm1pbmFsLCB7XG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgICBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9yb290X2xheW91dF9lcnJvcl9kZXNjXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3IgYW5kIGNhbiBvbmx5IGJlIGRpc21pc3NlZCBieSBwcm92aWRpbmcgYWxsIHJlcXVpcmVkIHRhZ3MuXCIpKSkpKSkpO1xufTtcbmV4cG9ydHMuUm9vdExheW91dEVycm9yID0gUm9vdExheW91dEVycm9yO1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICAubmV4dGpzLWNvbnRhaW5lci1yb290LWxheW91dC1lcnJvci1oZWFkZXIgPiBoNCB7XG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuXG4gIC5uZXh0anMtY29udGFpbmVyLXJvb3QtbGF5b3V0LWVycm9yLWJvZHkgZm9vdGVyIHtcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcCk7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItcm9vdC1sYXlvdXQtZXJyb3ItYm9keSBmb290ZXIgcCB7XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgLm5leHRqcy1jb250YWluZXItcm9vdC1sYXlvdXQtZXJyb3ItYm9keSBzbWFsbCB7XG4gICAgY29sb3I6ICM3NTc1NzU7XG4gIH1cbmA7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9vdExheW91dEVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN0eWxlcyIsIlJvb3RMYXlvdXRFcnJvciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiX2RpYWxvZyIsIl9vdmVybGF5IiwiX3Rlcm1pbmFsIiwiX25vb3BUZW1wbGF0ZSIsIkJ1aWxkRXJyb3IiLCJtaXNzaW5nVGFncyIsIm1lc3NhZ2UiLCJsZW5ndGgiLCJqb2luIiwibm9vcCIsInVzZUNhbGxiYWNrIiwiY3JlYXRlRWxlbWVudCIsIk92ZXJsYXkiLCJmaXhlZCIsIkRpYWxvZyIsInR5cGUiLCJvbkNsb3NlIiwiRGlhbG9nQ29udGVudCIsIkRpYWxvZ0hlYWRlciIsImNsYXNzTmFtZSIsImlkIiwiRGlhbG9nQm9keSIsIlRlcm1pbmFsIiwiY29udGVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RootLayoutError.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/CallStackFrame.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/CallStackFrame.js ***!
  \**********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallStackFrame = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _stackFrame = __webpack_require__(/*! ../../helpers/stack-frame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js\");\nvar _useOpenInEditor = __webpack_require__(/*! ../../helpers/use-open-in-editor */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\");\nconst CallStackFrame = function CallStackFrame({ frame  }) {\n    var _originalStackFrame;\n    // TODO: ability to expand resolved frames\n    // TODO: render error or external indicator\n    const f = (_originalStackFrame = frame.originalStackFrame) != null ? _originalStackFrame : frame.sourceStackFrame;\n    const hasSource = Boolean(frame.originalCodeFrame);\n    const open = (0, _useOpenInEditor).useOpenInEditor(hasSource ? {\n        file: f.file,\n        lineNumber: f.lineNumber,\n        column: f.column\n    } : undefined);\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        \"data-nextjs-call-stack-frame\": true\n    }, /*#__PURE__*/ _react.default.createElement(\"h6\", {\n        \"data-nextjs-frame-expanded\": Boolean(frame.expanded)\n    }, f.methodName), /*#__PURE__*/ _react.default.createElement(\"div\", {\n        \"data-has-source\": hasSource ? \"true\" : undefined,\n        tabIndex: hasSource ? 10 : undefined,\n        role: hasSource ? \"link\" : undefined,\n        onClick: open,\n        title: hasSource ? \"Click to open in your editor\" : undefined\n    }, /*#__PURE__*/ _react.default.createElement(\"span\", null, (0, _stackFrame).getFrameSource(f)), /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }, /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"\n    }), /*#__PURE__*/ _react.default.createElement(\"polyline\", {\n        points: \"15 3 21 3 21 9\"\n    }), /*#__PURE__*/ _react.default.createElement(\"line\", {\n        x1: \"10\",\n        y1: \"14\",\n        x2: \"21\",\n        y2: \"3\"\n    }))));\n};\nexports.CallStackFrame = CallStackFrame;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=CallStackFrame.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvQ2FsbFN0YWNrRnJhbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUcsS0FBSztBQUM5QixJQUFJRywyQkFBMkJDLCtKQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDJJQUEyQjtBQUNyRCxJQUFJSSxtQkFBbUJKLG1CQUFPQSxDQUFDLHlKQUFrQztBQUNqRSxNQUFNRixpQkFBaUIsU0FBU0EsZUFBZSxFQUFFTyxNQUFLLEVBQUcsRUFBRTtJQUN2RCxJQUFJQztJQUNKLDBDQUEwQztJQUMxQywyQ0FBMkM7SUFDM0MsTUFBTUMsSUFBSSxDQUFDRCxzQkFBc0JELE1BQU1HLGtCQUFrQixLQUFLLElBQUksR0FBR0Ysc0JBQXNCRCxNQUFNSSxnQkFBZ0I7SUFDakgsTUFBTUMsWUFBWUMsUUFBUU4sTUFBTU8saUJBQWlCO0lBQ2pELE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCxnQkFBZ0IsRUFBRVUsZUFBZSxDQUFDSixZQUFZO1FBQzNESyxNQUFNUixFQUFFUSxJQUFJO1FBQ1pDLFlBQVlULEVBQUVTLFVBQVU7UUFDeEJDLFFBQVFWLEVBQUVVLE1BQU07SUFDcEIsSUFBSUMsU0FBUztJQUNiLE9BQU8sV0FBVyxHQUFHaEIsT0FBT0QsT0FBTyxDQUFDa0IsYUFBYSxDQUFDLE9BQU87UUFDckQsZ0NBQWdDLElBQUk7SUFDeEMsR0FBRyxXQUFXLEdBQUdqQixPQUFPRCxPQUFPLENBQUNrQixhQUFhLENBQUMsTUFBTTtRQUNoRCw4QkFBOEJSLFFBQVFOLE1BQU1lLFFBQVE7SUFDeEQsR0FBR2IsRUFBRWMsVUFBVSxHQUFHLFdBQVcsR0FBR25CLE9BQU9ELE9BQU8sQ0FBQ2tCLGFBQWEsQ0FBQyxPQUFPO1FBQ2hFLG1CQUFtQlQsWUFBWSxTQUFTUSxTQUFTO1FBQ2pESSxVQUFVWixZQUFZLEtBQUtRLFNBQVM7UUFDcENLLE1BQU1iLFlBQVksU0FBU1EsU0FBUztRQUNwQ00sU0FBU1g7UUFDVFksT0FBT2YsWUFBWSxpQ0FBaUNRLFNBQVM7SUFDakUsR0FBRyxXQUFXLEdBQUdoQixPQUFPRCxPQUFPLENBQUNrQixhQUFhLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxHQUFHaEIsV0FBVyxFQUFFdUIsY0FBYyxDQUFDbkIsS0FBSyxXQUFXLEdBQUdMLE9BQU9ELE9BQU8sQ0FBQ2tCLGFBQWEsQ0FBQyxPQUFPO1FBQy9JUSxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsZUFBZTtRQUNmQyxnQkFBZ0I7SUFDcEIsR0FBRyxXQUFXLEdBQUcvQixPQUFPRCxPQUFPLENBQUNrQixhQUFhLENBQUMsUUFBUTtRQUNsRGUsR0FBRztJQUNQLElBQUksV0FBVyxHQUFHaEMsT0FBT0QsT0FBTyxDQUFDa0IsYUFBYSxDQUFDLFlBQVk7UUFDdkRnQixRQUFRO0lBQ1osSUFBSSxXQUFXLEdBQUdqQyxPQUFPRCxPQUFPLENBQUNrQixhQUFhLENBQUMsUUFBUTtRQUNuRGlCLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7SUFDUjtBQUNKO0FBQ0EzQyxzQkFBc0IsR0FBR0U7QUFFekIsSUFBSSxDQUFDLE9BQU9GLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ3VDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytDLE1BQU0sQ0FBQzdDLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0I4QyxPQUFPOUMsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb250YWluZXIvUnVudGltZUVycm9yL0NhbGxTdGFja0ZyYW1lLmpzPzcxYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNhbGxTdGFja0ZyYW1lID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9zdGFja0ZyYW1lID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgX3VzZU9wZW5JbkVkaXRvciA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3VzZS1vcGVuLWluLWVkaXRvclwiKTtcbmNvbnN0IENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoeyBmcmFtZSAgfSkge1xuICAgIHZhciBfb3JpZ2luYWxTdGFja0ZyYW1lO1xuICAgIC8vIFRPRE86IGFiaWxpdHkgdG8gZXhwYW5kIHJlc29sdmVkIGZyYW1lc1xuICAgIC8vIFRPRE86IHJlbmRlciBlcnJvciBvciBleHRlcm5hbCBpbmRpY2F0b3JcbiAgICBjb25zdCBmID0gKF9vcmlnaW5hbFN0YWNrRnJhbWUgPSBmcmFtZS5vcmlnaW5hbFN0YWNrRnJhbWUpICE9IG51bGwgPyBfb3JpZ2luYWxTdGFja0ZyYW1lIDogZnJhbWUuc291cmNlU3RhY2tGcmFtZTtcbiAgICBjb25zdCBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICBjb25zdCBvcGVuID0gKDAsIF91c2VPcGVuSW5FZGl0b3IpLnVzZU9wZW5JbkVkaXRvcihoYXNTb3VyY2UgPyB7XG4gICAgICAgIGZpbGU6IGYuZmlsZSxcbiAgICAgICAgbGluZU51bWJlcjogZi5saW5lTnVtYmVyLFxuICAgICAgICBjb2x1bW46IGYuY29sdW1uXG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZVwiOiB0cnVlXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6IEJvb2xlYW4oZnJhbWUuZXhwYW5kZWQpXG4gICAgfSwgZi5tZXRob2ROYW1lKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgXCJkYXRhLWhhcy1zb3VyY2VcIjogaGFzU291cmNlID8gJ3RydWUnIDogdW5kZWZpbmVkLFxuICAgICAgICB0YWJJbmRleDogaGFzU291cmNlID8gMTAgOiB1bmRlZmluZWQsXG4gICAgICAgIHJvbGU6IGhhc1NvdXJjZSA/ICdsaW5rJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgb25DbGljazogb3BlbixcbiAgICAgICAgdGl0bGU6IGhhc1NvdXJjZSA/ICdDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yJyA6IHVuZGVmaW5lZFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgKDAsIF9zdGFja0ZyYW1lKS5nZXRGcmFtZVNvdXJjZShmKSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIlxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7XG4gICAgICAgIHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgICAgICB4MTogXCIxMFwiLFxuICAgICAgICB5MTogXCIxNFwiLFxuICAgICAgICB4MjogXCIyMVwiLFxuICAgICAgICB5MjogXCIzXCJcbiAgICB9KSkpKTtcbn07XG5leHBvcnRzLkNhbGxTdGFja0ZyYW1lID0gQ2FsbFN0YWNrRnJhbWU7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGxTdGFja0ZyYW1lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhbGxTdGFja0ZyYW1lIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfc3RhY2tGcmFtZSIsIl91c2VPcGVuSW5FZGl0b3IiLCJmcmFtZSIsIl9vcmlnaW5hbFN0YWNrRnJhbWUiLCJmIiwib3JpZ2luYWxTdGFja0ZyYW1lIiwic291cmNlU3RhY2tGcmFtZSIsImhhc1NvdXJjZSIsIkJvb2xlYW4iLCJvcmlnaW5hbENvZGVGcmFtZSIsIm9wZW4iLCJ1c2VPcGVuSW5FZGl0b3IiLCJmaWxlIiwibGluZU51bWJlciIsImNvbHVtbiIsInVuZGVmaW5lZCIsImNyZWF0ZUVsZW1lbnQiLCJleHBhbmRlZCIsIm1ldGhvZE5hbWUiLCJ0YWJJbmRleCIsInJvbGUiLCJvbkNsaWNrIiwidGl0bGUiLCJnZXRGcmFtZVNvdXJjZSIsInhtbG5zIiwidmlld0JveCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsImQiLCJwb2ludHMiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/CallStackFrame.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/ComponentStackFrameRow.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/ComponentStackFrameRow.js ***!
  \******************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ComponentStackFrameRow = ComponentStackFrameRow;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _useOpenInEditor = __webpack_require__(/*! ../../helpers/use-open-in-editor */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\");\nfunction ComponentStackFrameRow({ componentStackFrame: { component , file , lineNumber , column  }  }) {\n    const open = (0, _useOpenInEditor).useOpenInEditor({\n        file,\n        column,\n        lineNumber\n    });\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        \"data-nextjs-component-stack-frame\": true\n    }, /*#__PURE__*/ _react.default.createElement(\"h6\", null, component), file ? /*#__PURE__*/ _react.default.createElement(\"div\", {\n        tabIndex: 10,\n        role: \"link\",\n        onClick: open,\n        title: \"Click to open in your editor\"\n    }, /*#__PURE__*/ _react.default.createElement(\"span\", null, file, \" (\", lineNumber, \":\", column, \")\"), /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }, /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"\n    }), /*#__PURE__*/ _react.default.createElement(\"polyline\", {\n        points: \"15 3 21 3 21 9\"\n    }), /*#__PURE__*/ _react.default.createElement(\"line\", {\n        x1: \"10\",\n        y1: \"14\",\n        x2: \"21\",\n        y2: \"3\"\n    }))) : null);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ComponentStackFrameRow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvQ29tcG9uZW50U3RhY2tGcmFtZVJvdy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw4QkFBOEIsR0FBR0U7QUFDakMsSUFBSUMsMkJBQTJCQywrSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJRyxtQkFBbUJILG1CQUFPQSxDQUFDLHlKQUFrQztBQUNqRSxTQUFTRix1QkFBdUIsRUFBRU0scUJBQXFCLEVBQUVDLFVBQVMsRUFBR0MsS0FBSSxFQUFHQyxXQUFVLEVBQUdDLE9BQU0sRUFBRyxHQUFHLEVBQUU7SUFDbkcsTUFBTUMsT0FBTyxDQUFDLEdBQUdOLGdCQUFnQixFQUFFTyxlQUFlLENBQUM7UUFDL0NKO1FBQ0FFO1FBQ0FEO0lBQ0o7SUFDQSxPQUFPLFdBQVcsR0FBR0wsT0FBT0QsT0FBTyxDQUFDVSxhQUFhLENBQUMsT0FBTztRQUNyRCxxQ0FBcUMsSUFBSTtJQUM3QyxHQUFHLFdBQVcsR0FBR1QsT0FBT0QsT0FBTyxDQUFDVSxhQUFhLENBQUMsTUFBTSxJQUFJLEVBQUVOLFlBQVlDLE9BQU8sV0FBVyxHQUFHSixPQUFPRCxPQUFPLENBQUNVLGFBQWEsQ0FBQyxPQUFPO1FBQzNIQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsU0FBU0w7UUFDVE0sT0FBTztJQUNYLEdBQUcsV0FBVyxHQUFHYixPQUFPRCxPQUFPLENBQUNVLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRUwsTUFBTSxNQUFNQyxZQUFZLEtBQUtDLFFBQVEsTUFBTSxXQUFXLEdBQUdOLE9BQU9ELE9BQU8sQ0FBQ1UsYUFBYSxDQUFDLE9BQU87UUFDckpLLE9BQU87UUFDUEMsU0FBUztRQUNUQyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtJQUNwQixHQUFHLFdBQVcsR0FBR3BCLE9BQU9ELE9BQU8sQ0FBQ1UsYUFBYSxDQUFDLFFBQVE7UUFDbERZLEdBQUc7SUFDUCxJQUFJLFdBQVcsR0FBR3JCLE9BQU9ELE9BQU8sQ0FBQ1UsYUFBYSxDQUFDLFlBQVk7UUFDdkRhLFFBQVE7SUFDWixJQUFJLFdBQVcsR0FBR3RCLE9BQU9ELE9BQU8sQ0FBQ1UsYUFBYSxDQUFDLFFBQVE7UUFDbkRjLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7SUFDUixPQUFPLElBQUk7QUFDZjtBQUVBLElBQUksQ0FBQyxPQUFPaEMsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDNEIsVUFBVSxLQUFLLGFBQWE7SUFDcktuQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPb0MsTUFBTSxDQUFDbEMsUUFBUUssT0FBTyxFQUFFTDtJQUMvQm1DLE9BQU9uQyxPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvQ29tcG9uZW50U3RhY2tGcmFtZVJvdy5qcz82ODg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db21wb25lbnRTdGFja0ZyYW1lUm93ID0gQ29tcG9uZW50U3RhY2tGcmFtZVJvdztcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfdXNlT3BlbkluRWRpdG9yID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvdXNlLW9wZW4taW4tZWRpdG9yXCIpO1xuZnVuY3Rpb24gQ29tcG9uZW50U3RhY2tGcmFtZVJvdyh7IGNvbXBvbmVudFN0YWNrRnJhbWU6IHsgY29tcG9uZW50ICwgZmlsZSAsIGxpbmVOdW1iZXIgLCBjb2x1bW4gIH0gIH0pIHtcbiAgICBjb25zdCBvcGVuID0gKDAsIF91c2VPcGVuSW5FZGl0b3IpLnVzZU9wZW5JbkVkaXRvcih7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgbGluZU51bWJlclxuICAgIH0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLWNvbXBvbmVudC1zdGFjay1mcmFtZVwiOiB0cnVlXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgbnVsbCwgY29tcG9uZW50KSwgZmlsZSA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHRhYkluZGV4OiAxMCxcbiAgICAgICAgcm9sZTogJ2xpbmsnLFxuICAgICAgICBvbkNsaWNrOiBvcGVuLFxuICAgICAgICB0aXRsZTogJ0NsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3InXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBmaWxlLCBcIiAoXCIsIGxpbmVOdW1iZXIsIFwiOlwiLCBjb2x1bW4sIFwiKVwiKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHtcbiAgICAgICAgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCJcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgIHgxOiBcIjEwXCIsXG4gICAgICAgIHkxOiBcIjE0XCIsXG4gICAgICAgIHgyOiBcIjIxXCIsXG4gICAgICAgIHkyOiBcIjNcIlxuICAgIH0pKSkgOiBudWxsKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG9uZW50U3RhY2tGcmFtZVJvdy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wb25lbnRTdGFja0ZyYW1lUm93IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfdXNlT3BlbkluRWRpdG9yIiwiY29tcG9uZW50U3RhY2tGcmFtZSIsImNvbXBvbmVudCIsImZpbGUiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwib3BlbiIsInVzZU9wZW5JbkVkaXRvciIsImNyZWF0ZUVsZW1lbnQiLCJ0YWJJbmRleCIsInJvbGUiLCJvbkNsaWNrIiwidGl0bGUiLCJ4bWxucyIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJkIiwicG9pbnRzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/ComponentStackFrameRow.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/FrameworkIcon.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/FrameworkIcon.js ***!
  \*********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FrameworkIcon = FrameworkIcon;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nfunction FrameworkIcon({ framework  }) {\n    if (framework === \"react\") {\n        return /*#__PURE__*/ _react.default.createElement(\"svg\", {\n            \"data-nextjs-call-stack-framework-icon\": \"react\",\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"20\",\n            height: \"20\",\n            viewBox: \"0 0 410 369\",\n            fill: \"none\",\n            shapeRendering: \"geometricPrecision\",\n            stroke: \"currentColor\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\",\n            strokeWidth: \"5\"\n        }, /*#__PURE__*/ _react.default.createElement(\"path\", {\n            d: \"M204.995 224.552C226.56 224.552 244.042 207.07 244.042 185.506C244.042 163.941 226.56 146.459 204.995 146.459C183.43 146.459 165.948 163.941 165.948 185.506C165.948 207.07 183.43 224.552 204.995 224.552Z\",\n            fill: \"currentColor\"\n        }), /*#__PURE__*/ _react.default.createElement(\"path\", {\n            d: \"M409.99 184.505C409.99 153.707 381.437 126.667 335.996 108.925C343.342 60.6535 334.19 22.3878 307.492 6.98883C283.649 -6.77511 250.631 -0.0395641 214.512 25.9753C211.316 28.2692 208.143 30.7097 204.97 33.2477C201.822 30.7097 198.65 28.2692 195.477 25.9753C159.359 -0.0395641 126.34 -6.79951 102.497 6.98883C75.8237 22.3878 66.6721 60.6291 74.0422 108.852C28.5529 126.618 0 153.682 0 184.505C0 215.303 28.5528 242.342 73.9934 260.084C66.6477 308.356 75.7993 346.621 102.497 362.02C110.575 366.682 119.727 369 129.684 369C149.085 369 171.61 360.215 195.477 343.034C198.674 340.74 201.847 338.3 205.019 335.762C208.167 338.3 211.34 340.74 214.512 343.034C238.38 360.239 260.905 369 280.306 369C290.263 369 299.415 366.682 307.492 362.02C331.335 348.256 342 316.287 337.534 271.993C337.143 268.089 336.631 264.135 335.996 260.109C381.461 242.367 409.99 215.327 409.99 184.505ZM225.934 41.8136C246.238 27.1955 265.127 19.5814 280.306 19.5814C286.871 19.5814 292.728 20.9968 297.731 23.8765C315.204 33.9798 322.672 62.9475 317.327 102.433C299.756 97.0401 280.306 92.9158 259.392 90.2802C246.872 73.8074 233.597 58.9453 220.003 46.2551C221.98 44.7421 223.957 43.229 225.934 41.8136ZM112.259 23.8765C117.262 20.9968 123.119 19.5814 129.684 19.5814C144.863 19.5814 163.752 27.1711 184.056 41.8136C186.033 43.229 188.01 44.7176 189.986 46.2551C176.393 58.9453 163.142 73.783 150.622 90.2558C129.732 92.8914 110.258 97.0401 92.687 102.409C87.3424 62.9475 94.7857 33.9798 112.259 23.8765ZM19.5233 184.505C19.5233 164.322 40.9014 143.359 77.776 128.253C81.9003 146.141 88.0502 165.054 96.1768 184.456C88.0014 203.881 81.8515 222.819 77.7272 240.732C40.9014 225.626 19.5233 204.687 19.5233 184.505ZM184.056 327.196C154.966 348.134 128.805 354.675 112.259 345.133C94.7857 335.029 87.3181 306.062 92.6626 266.576C110.234 271.969 129.684 276.093 150.598 278.729C163.117 295.202 176.393 310.064 189.986 322.754C188.01 324.292 186.033 325.78 184.056 327.196ZM204.995 310.04C180.591 287.685 157.138 257.815 137.347 223.551C132.051 214.4 121.344 191.396 117 182.489C113.535 190.786 110.112 198.398 107.427 206.5C109.623 210.575 118.092 229.213 120.434 233.288C125.071 241.317 129.928 249.127 134.931 256.692C120.898 254.227 107.915 251.055 96.1035 247.321C102.815 217.011 116.213 182.064 137.347 145.458C142.545 136.453 153.838 116.346 159.5 108C150.568 109.147 143.395 108.767 135 110.5C132.56 114.453 122.777 131.645 120.434 135.721C115.749 143.823 111.454 151.925 107.427 159.978C102.546 146.581 98.8124 133.744 96.1524 121.64C125.755 112.293 162.727 106.411 204.995 106.411C215.562 106.411 237.63 106.197 247.49 106.905C242.048 99.7544 237.38 93.2819 231.694 86.888C227.082 86.7416 209.705 86.888 204.995 86.888C195.672 86.888 186.545 87.2053 177.589 87.7422C186.472 77.1752 195.672 67.5111 204.995 58.9697C229.375 81.3239 252.851 111.195 272.643 145.458C277.841 154.463 289.073 175.426 293.49 184.505C296.98 176.207 300.281 168.64 302.99 160.489C300.793 156.389 291.898 139.747 289.555 135.696C284.918 127.667 280.062 119.858 275.059 112.317C289.092 114.782 302.075 117.954 313.886 121.688C307.175 151.998 293.777 186.945 272.643 223.551C267.445 232.556 252.651 253.178 246.99 261.524C255.922 260.377 265.595 258.663 273.99 256.93C276.43 252.976 287.212 237.364 289.555 233.288C294.216 225.235 298.512 217.182 302.489 209.153C307.224 222.185 310.982 234.997 313.715 247.394C284.138 256.741 247.214 262.598 204.995 262.598C194.428 262.598 169.859 261.208 160 260.5C165.442 267.65 171.304 275.095 176.99 281.489C181.602 281.635 200.285 282.121 204.995 282.121C214.317 282.121 223.444 281.804 232.401 281.267C223.493 291.834 214.317 301.498 204.995 310.04ZM297.731 345.133C281.185 354.699 254.999 348.159 225.934 327.196C223.957 325.78 221.98 324.292 220.003 322.754C233.597 310.064 246.848 295.226 259.367 278.753C280.233 276.118 299.659 271.993 317.205 266.625C317.547 269.089 317.888 271.554 318.132 273.97C321.72 309.649 314.277 335.566 297.731 345.133ZM332.262 240.756C328.065 222.599 321.842 203.686 313.813 184.578C321.988 165.152 328.138 146.215 332.262 128.302C369.088 143.408 390.466 164.322 390.466 184.505C390.466 204.687 369.113 225.626 332.262 240.756Z\",\n            fill: \"currentColor\"\n        }));\n    }\n    return /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        \"data-nextjs-call-stack-framework-icon\": \"next\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"20\",\n        height: \"20\",\n        viewBox: \"0 0 180 180\",\n        fill: \"none\"\n    }, /*#__PURE__*/ _react.default.createElement(\"mask\", {\n        id: \"mask0_408_139\",\n        maskUnits: \"userSpaceOnUse\",\n        x: \"0\",\n        y: \"0\",\n        width: \"180\",\n        height: \"180\"\n    }, /*#__PURE__*/ _react.default.createElement(\"circle\", {\n        cx: \"90\",\n        cy: \"90\",\n        r: \"90\",\n        fill: \"black\"\n    })), /*#__PURE__*/ _react.default.createElement(\"g\", {\n        mask: \"url(#mask0_408_139)\"\n    }, /*#__PURE__*/ _react.default.createElement(\"circle\", {\n        cx: \"90\",\n        cy: \"90\",\n        r: \"87\",\n        fill: \"black\",\n        stroke: \"white\",\n        strokeWidth: \"6\"\n    }), /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M149.508 157.52L69.142 54H54V125.97H66.1136V69.3836L139.999 164.845C143.333 162.614 146.509 160.165 149.508 157.52Z\",\n        fill: \"url(#paint0_linear_408_139)\"\n    }), /*#__PURE__*/ _react.default.createElement(\"rect\", {\n        x: \"115\",\n        y: \"54\",\n        width: \"12\",\n        height: \"72\",\n        fill: \"url(#paint1_linear_408_139)\"\n    })), /*#__PURE__*/ _react.default.createElement(\"defs\", null, /*#__PURE__*/ _react.default.createElement(\"linearGradient\", {\n        id: \"paint0_linear_408_139\",\n        x1: \"109\",\n        y1: \"116.5\",\n        x2: \"144.5\",\n        y2: \"160.5\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        stopColor: \"white\"\n    }), /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"white\",\n        stopOpacity: \"0\"\n    })), /*#__PURE__*/ _react.default.createElement(\"linearGradient\", {\n        id: \"paint1_linear_408_139\",\n        x1: \"121\",\n        y1: \"54\",\n        x2: \"120.799\",\n        y2: \"106.875\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        stopColor: \"white\"\n    }), /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"white\",\n        stopOpacity: \"0\"\n    }))));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=FrameworkIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvRnJhbWV3b3JrSWNvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsMkJBQTJCQywrSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxTQUFTRixjQUFjLEVBQUVLLFVBQVMsRUFBRyxFQUFFO0lBQ25DLElBQUlBLGNBQWMsU0FBUztRQUN2QixPQUFPLFdBQVcsR0FBR0QsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsT0FBTztZQUNyRCx5Q0FBeUM7WUFDekNDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsTUFBTTtZQUNOQyxnQkFBZ0I7WUFDaEJDLFFBQVE7WUFDUkMsZUFBZTtZQUNmQyxnQkFBZ0I7WUFDaEJDLGFBQWE7UUFDakIsR0FBRyxXQUFXLEdBQUdaLE9BQU9ELE9BQU8sQ0FBQ0csYUFBYSxDQUFDLFFBQVE7WUFDbERXLEdBQUc7WUFDSE4sTUFBTTtRQUNWLElBQUksV0FBVyxHQUFHUCxPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxRQUFRO1lBQ25EVyxHQUFHO1lBQ0hOLE1BQU07UUFDVjtJQUNKLENBQUM7SUFDRCxPQUFPLFdBQVcsR0FBR1AsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsT0FBTztRQUNyRCx5Q0FBeUM7UUFDekNDLE9BQU87UUFDUEMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsTUFBTTtJQUNWLEdBQUcsV0FBVyxHQUFHUCxPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxRQUFRO1FBQ2xEWSxJQUFJO1FBQ0pDLFdBQVc7UUFDWEMsR0FBRztRQUNIQyxHQUFHO1FBQ0hiLE9BQU87UUFDUEMsUUFBUTtJQUNaLEdBQUcsV0FBVyxHQUFHTCxPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxVQUFVO1FBQ3BEZ0IsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLEdBQUc7UUFDSGIsTUFBTTtJQUNWLEtBQUssV0FBVyxHQUFHUCxPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxLQUFLO1FBQ2pEbUIsTUFBTTtJQUNWLEdBQUcsV0FBVyxHQUFHckIsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsVUFBVTtRQUNwRGdCLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxHQUFHO1FBQ0hiLE1BQU07UUFDTkUsUUFBUTtRQUNSRyxhQUFhO0lBQ2pCLElBQUksV0FBVyxHQUFHWixPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxRQUFRO1FBQ25EVyxHQUFHO1FBQ0hOLE1BQU07SUFDVixJQUFJLFdBQVcsR0FBR1AsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsUUFBUTtRQUNuRGMsR0FBRztRQUNIQyxHQUFHO1FBQ0hiLE9BQU87UUFDUEMsUUFBUTtRQUNSRSxNQUFNO0lBQ1YsS0FBSyxXQUFXLEdBQUdQLE9BQU9ELE9BQU8sQ0FBQ0csYUFBYSxDQUFDLFFBQVEsSUFBSSxFQUFFLFdBQVcsR0FBR0YsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsa0JBQWtCO1FBQ3ZIWSxJQUFJO1FBQ0pRLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsZUFBZTtJQUNuQixHQUFHLFdBQVcsR0FBRzFCLE9BQU9ELE9BQU8sQ0FBQ0csYUFBYSxDQUFDLFFBQVE7UUFDbER5QixXQUFXO0lBQ2YsSUFBSSxXQUFXLEdBQUczQixPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxRQUFRO1FBQ25EMEIsUUFBUTtRQUNSRCxXQUFXO1FBQ1hFLGFBQWE7SUFDakIsS0FBSyxXQUFXLEdBQUc3QixPQUFPRCxPQUFPLENBQUNHLGFBQWEsQ0FBQyxrQkFBa0I7UUFDOURZLElBQUk7UUFDSlEsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxlQUFlO0lBQ25CLEdBQUcsV0FBVyxHQUFHMUIsT0FBT0QsT0FBTyxDQUFDRyxhQUFhLENBQUMsUUFBUTtRQUNsRHlCLFdBQVc7SUFDZixJQUFJLFdBQVcsR0FBRzNCLE9BQU9ELE9BQU8sQ0FBQ0csYUFBYSxDQUFDLFFBQVE7UUFDbkQwQixRQUFRO1FBQ1JELFdBQVc7UUFDWEUsYUFBYTtJQUNqQjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9uQyxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUMrQixVQUFVLEtBQUssYUFBYTtJQUNyS3RDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU91QyxNQUFNLENBQUNyQyxRQUFRSyxPQUFPLEVBQUVMO0lBQy9Cc0MsT0FBT3RDLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29udGFpbmVyL1J1bnRpbWVFcnJvci9GcmFtZXdvcmtJY29uLmpzP2I4M2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZyYW1ld29ya0ljb24gPSBGcmFtZXdvcmtJY29uO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gRnJhbWV3b3JrSWNvbih7IGZyYW1ld29yayAgfSkge1xuICAgIGlmIChmcmFtZXdvcmsgPT09ICdyZWFjdCcpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgICAgICBcImRhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWV3b3JrLWljb25cIjogXCJyZWFjdFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjIwXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjBcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDQxMCAzNjlcIixcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXG4gICAgICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiNVwiXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgICAgZDogXCJNMjA0Ljk5NSAyMjQuNTUyQzIyNi41NiAyMjQuNTUyIDI0NC4wNDIgMjA3LjA3IDI0NC4wNDIgMTg1LjUwNkMyNDQuMDQyIDE2My45NDEgMjI2LjU2IDE0Ni40NTkgMjA0Ljk5NSAxNDYuNDU5QzE4My40MyAxNDYuNDU5IDE2NS45NDggMTYzLjk0MSAxNjUuOTQ4IDE4NS41MDZDMTY1Ljk0OCAyMDcuMDcgMTgzLjQzIDIyNC41NTIgMjA0Ljk5NSAyMjQuNTUyWlwiLFxuICAgICAgICAgICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICAgICAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgICBkOiBcIk00MDkuOTkgMTg0LjUwNUM0MDkuOTkgMTUzLjcwNyAzODEuNDM3IDEyNi42NjcgMzM1Ljk5NiAxMDguOTI1QzM0My4zNDIgNjAuNjUzNSAzMzQuMTkgMjIuMzg3OCAzMDcuNDkyIDYuOTg4ODNDMjgzLjY0OSAtNi43NzUxMSAyNTAuNjMxIC0wLjAzOTU2NDEgMjE0LjUxMiAyNS45NzUzQzIxMS4zMTYgMjguMjY5MiAyMDguMTQzIDMwLjcwOTcgMjA0Ljk3IDMzLjI0NzdDMjAxLjgyMiAzMC43MDk3IDE5OC42NSAyOC4yNjkyIDE5NS40NzcgMjUuOTc1M0MxNTkuMzU5IC0wLjAzOTU2NDEgMTI2LjM0IC02Ljc5OTUxIDEwMi40OTcgNi45ODg4M0M3NS44MjM3IDIyLjM4NzggNjYuNjcyMSA2MC42MjkxIDc0LjA0MjIgMTA4Ljg1MkMyOC41NTI5IDEyNi42MTggMCAxNTMuNjgyIDAgMTg0LjUwNUMwIDIxNS4zMDMgMjguNTUyOCAyNDIuMzQyIDczLjk5MzQgMjYwLjA4NEM2Ni42NDc3IDMwOC4zNTYgNzUuNzk5MyAzNDYuNjIxIDEwMi40OTcgMzYyLjAyQzExMC41NzUgMzY2LjY4MiAxMTkuNzI3IDM2OSAxMjkuNjg0IDM2OUMxNDkuMDg1IDM2OSAxNzEuNjEgMzYwLjIxNSAxOTUuNDc3IDM0My4wMzRDMTk4LjY3NCAzNDAuNzQgMjAxLjg0NyAzMzguMyAyMDUuMDE5IDMzNS43NjJDMjA4LjE2NyAzMzguMyAyMTEuMzQgMzQwLjc0IDIxNC41MTIgMzQzLjAzNEMyMzguMzggMzYwLjIzOSAyNjAuOTA1IDM2OSAyODAuMzA2IDM2OUMyOTAuMjYzIDM2OSAyOTkuNDE1IDM2Ni42ODIgMzA3LjQ5MiAzNjIuMDJDMzMxLjMzNSAzNDguMjU2IDM0MiAzMTYuMjg3IDMzNy41MzQgMjcxLjk5M0MzMzcuMTQzIDI2OC4wODkgMzM2LjYzMSAyNjQuMTM1IDMzNS45OTYgMjYwLjEwOUMzODEuNDYxIDI0Mi4zNjcgNDA5Ljk5IDIxNS4zMjcgNDA5Ljk5IDE4NC41MDVaTTIyNS45MzQgNDEuODEzNkMyNDYuMjM4IDI3LjE5NTUgMjY1LjEyNyAxOS41ODE0IDI4MC4zMDYgMTkuNTgxNEMyODYuODcxIDE5LjU4MTQgMjkyLjcyOCAyMC45OTY4IDI5Ny43MzEgMjMuODc2NUMzMTUuMjA0IDMzLjk3OTggMzIyLjY3MiA2Mi45NDc1IDMxNy4zMjcgMTAyLjQzM0MyOTkuNzU2IDk3LjA0MDEgMjgwLjMwNiA5Mi45MTU4IDI1OS4zOTIgOTAuMjgwMkMyNDYuODcyIDczLjgwNzQgMjMzLjU5NyA1OC45NDUzIDIyMC4wMDMgNDYuMjU1MUMyMjEuOTggNDQuNzQyMSAyMjMuOTU3IDQzLjIyOSAyMjUuOTM0IDQxLjgxMzZaTTExMi4yNTkgMjMuODc2NUMxMTcuMjYyIDIwLjk5NjggMTIzLjExOSAxOS41ODE0IDEyOS42ODQgMTkuNTgxNEMxNDQuODYzIDE5LjU4MTQgMTYzLjc1MiAyNy4xNzExIDE4NC4wNTYgNDEuODEzNkMxODYuMDMzIDQzLjIyOSAxODguMDEgNDQuNzE3NiAxODkuOTg2IDQ2LjI1NTFDMTc2LjM5MyA1OC45NDUzIDE2My4xNDIgNzMuNzgzIDE1MC42MjIgOTAuMjU1OEMxMjkuNzMyIDkyLjg5MTQgMTEwLjI1OCA5Ny4wNDAxIDkyLjY4NyAxMDIuNDA5Qzg3LjM0MjQgNjIuOTQ3NSA5NC43ODU3IDMzLjk3OTggMTEyLjI1OSAyMy44NzY1Wk0xOS41MjMzIDE4NC41MDVDMTkuNTIzMyAxNjQuMzIyIDQwLjkwMTQgMTQzLjM1OSA3Ny43NzYgMTI4LjI1M0M4MS45MDAzIDE0Ni4xNDEgODguMDUwMiAxNjUuMDU0IDk2LjE3NjggMTg0LjQ1NkM4OC4wMDE0IDIwMy44ODEgODEuODUxNSAyMjIuODE5IDc3LjcyNzIgMjQwLjczMkM0MC45MDE0IDIyNS42MjYgMTkuNTIzMyAyMDQuNjg3IDE5LjUyMzMgMTg0LjUwNVpNMTg0LjA1NiAzMjcuMTk2QzE1NC45NjYgMzQ4LjEzNCAxMjguODA1IDM1NC42NzUgMTEyLjI1OSAzNDUuMTMzQzk0Ljc4NTcgMzM1LjAyOSA4Ny4zMTgxIDMwNi4wNjIgOTIuNjYyNiAyNjYuNTc2QzExMC4yMzQgMjcxLjk2OSAxMjkuNjg0IDI3Ni4wOTMgMTUwLjU5OCAyNzguNzI5QzE2My4xMTcgMjk1LjIwMiAxNzYuMzkzIDMxMC4wNjQgMTg5Ljk4NiAzMjIuNzU0QzE4OC4wMSAzMjQuMjkyIDE4Ni4wMzMgMzI1Ljc4IDE4NC4wNTYgMzI3LjE5NlpNMjA0Ljk5NSAzMTAuMDRDMTgwLjU5MSAyODcuNjg1IDE1Ny4xMzggMjU3LjgxNSAxMzcuMzQ3IDIyMy41NTFDMTMyLjA1MSAyMTQuNCAxMjEuMzQ0IDE5MS4zOTYgMTE3IDE4Mi40ODlDMTEzLjUzNSAxOTAuNzg2IDExMC4xMTIgMTk4LjM5OCAxMDcuNDI3IDIwNi41QzEwOS42MjMgMjEwLjU3NSAxMTguMDkyIDIyOS4yMTMgMTIwLjQzNCAyMzMuMjg4QzEyNS4wNzEgMjQxLjMxNyAxMjkuOTI4IDI0OS4xMjcgMTM0LjkzMSAyNTYuNjkyQzEyMC44OTggMjU0LjIyNyAxMDcuOTE1IDI1MS4wNTUgOTYuMTAzNSAyNDcuMzIxQzEwMi44MTUgMjE3LjAxMSAxMTYuMjEzIDE4Mi4wNjQgMTM3LjM0NyAxNDUuNDU4QzE0Mi41NDUgMTM2LjQ1MyAxNTMuODM4IDExNi4zNDYgMTU5LjUgMTA4QzE1MC41NjggMTA5LjE0NyAxNDMuMzk1IDEwOC43NjcgMTM1IDExMC41QzEzMi41NiAxMTQuNDUzIDEyMi43NzcgMTMxLjY0NSAxMjAuNDM0IDEzNS43MjFDMTE1Ljc0OSAxNDMuODIzIDExMS40NTQgMTUxLjkyNSAxMDcuNDI3IDE1OS45NzhDMTAyLjU0NiAxNDYuNTgxIDk4LjgxMjQgMTMzLjc0NCA5Ni4xNTI0IDEyMS42NEMxMjUuNzU1IDExMi4yOTMgMTYyLjcyNyAxMDYuNDExIDIwNC45OTUgMTA2LjQxMUMyMTUuNTYyIDEwNi40MTEgMjM3LjYzIDEwNi4xOTcgMjQ3LjQ5IDEwNi45MDVDMjQyLjA0OCA5OS43NTQ0IDIzNy4zOCA5My4yODE5IDIzMS42OTQgODYuODg4QzIyNy4wODIgODYuNzQxNiAyMDkuNzA1IDg2Ljg4OCAyMDQuOTk1IDg2Ljg4OEMxOTUuNjcyIDg2Ljg4OCAxODYuNTQ1IDg3LjIwNTMgMTc3LjU4OSA4Ny43NDIyQzE4Ni40NzIgNzcuMTc1MiAxOTUuNjcyIDY3LjUxMTEgMjA0Ljk5NSA1OC45Njk3QzIyOS4zNzUgODEuMzIzOSAyNTIuODUxIDExMS4xOTUgMjcyLjY0MyAxNDUuNDU4QzI3Ny44NDEgMTU0LjQ2MyAyODkuMDczIDE3NS40MjYgMjkzLjQ5IDE4NC41MDVDMjk2Ljk4IDE3Ni4yMDcgMzAwLjI4MSAxNjguNjQgMzAyLjk5IDE2MC40ODlDMzAwLjc5MyAxNTYuMzg5IDI5MS44OTggMTM5Ljc0NyAyODkuNTU1IDEzNS42OTZDMjg0LjkxOCAxMjcuNjY3IDI4MC4wNjIgMTE5Ljg1OCAyNzUuMDU5IDExMi4zMTdDMjg5LjA5MiAxMTQuNzgyIDMwMi4wNzUgMTE3Ljk1NCAzMTMuODg2IDEyMS42ODhDMzA3LjE3NSAxNTEuOTk4IDI5My43NzcgMTg2Ljk0NSAyNzIuNjQzIDIyMy41NTFDMjY3LjQ0NSAyMzIuNTU2IDI1Mi42NTEgMjUzLjE3OCAyNDYuOTkgMjYxLjUyNEMyNTUuOTIyIDI2MC4zNzcgMjY1LjU5NSAyNTguNjYzIDI3My45OSAyNTYuOTNDMjc2LjQzIDI1Mi45NzYgMjg3LjIxMiAyMzcuMzY0IDI4OS41NTUgMjMzLjI4OEMyOTQuMjE2IDIyNS4yMzUgMjk4LjUxMiAyMTcuMTgyIDMwMi40ODkgMjA5LjE1M0MzMDcuMjI0IDIyMi4xODUgMzEwLjk4MiAyMzQuOTk3IDMxMy43MTUgMjQ3LjM5NEMyODQuMTM4IDI1Ni43NDEgMjQ3LjIxNCAyNjIuNTk4IDIwNC45OTUgMjYyLjU5OEMxOTQuNDI4IDI2Mi41OTggMTY5Ljg1OSAyNjEuMjA4IDE2MCAyNjAuNUMxNjUuNDQyIDI2Ny42NSAxNzEuMzA0IDI3NS4wOTUgMTc2Ljk5IDI4MS40ODlDMTgxLjYwMiAyODEuNjM1IDIwMC4yODUgMjgyLjEyMSAyMDQuOTk1IDI4Mi4xMjFDMjE0LjMxNyAyODIuMTIxIDIyMy40NDQgMjgxLjgwNCAyMzIuNDAxIDI4MS4yNjdDMjIzLjQ5MyAyOTEuODM0IDIxNC4zMTcgMzAxLjQ5OCAyMDQuOTk1IDMxMC4wNFpNMjk3LjczMSAzNDUuMTMzQzI4MS4xODUgMzU0LjY5OSAyNTQuOTk5IDM0OC4xNTkgMjI1LjkzNCAzMjcuMTk2QzIyMy45NTcgMzI1Ljc4IDIyMS45OCAzMjQuMjkyIDIyMC4wMDMgMzIyLjc1NEMyMzMuNTk3IDMxMC4wNjQgMjQ2Ljg0OCAyOTUuMjI2IDI1OS4zNjcgMjc4Ljc1M0MyODAuMjMzIDI3Ni4xMTggMjk5LjY1OSAyNzEuOTkzIDMxNy4yMDUgMjY2LjYyNUMzMTcuNTQ3IDI2OS4wODkgMzE3Ljg4OCAyNzEuNTU0IDMxOC4xMzIgMjczLjk3QzMyMS43MiAzMDkuNjQ5IDMxNC4yNzcgMzM1LjU2NiAyOTcuNzMxIDM0NS4xMzNaTTMzMi4yNjIgMjQwLjc1NkMzMjguMDY1IDIyMi41OTkgMzIxLjg0MiAyMDMuNjg2IDMxMy44MTMgMTg0LjU3OEMzMjEuOTg4IDE2NS4xNTIgMzI4LjEzOCAxNDYuMjE1IDMzMi4yNjIgMTI4LjMwMkMzNjkuMDg4IDE0My40MDggMzkwLjQ2NiAxNjQuMzIyIDM5MC40NjYgMTg0LjUwNUMzOTAuNDY2IDIwNC42ODcgMzY5LjExMyAyMjUuNjI2IDMzMi4yNjIgMjQwLjc1NlpcIixcbiAgICAgICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgXCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1ld29yay1pY29uXCI6IFwibmV4dFwiLFxuICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICB3aWR0aDogXCIyMFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMjBcIixcbiAgICAgICAgdmlld0JveDogXCIwIDAgMTgwIDE4MFwiLFxuICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1hc2tcIiwge1xuICAgICAgICBpZDogXCJtYXNrMF80MDhfMTM5XCIsXG4gICAgICAgIG1hc2tVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgICAgICB4OiBcIjBcIixcbiAgICAgICAgeTogXCIwXCIsXG4gICAgICAgIHdpZHRoOiBcIjE4MFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTgwXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgICAgICBjeDogXCI5MFwiLFxuICAgICAgICBjeTogXCI5MFwiLFxuICAgICAgICByOiBcIjkwXCIsXG4gICAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgIG1hc2s6IFwidXJsKCNtYXNrMF80MDhfMTM5KVwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICAgICAgY3g6IFwiOTBcIixcbiAgICAgICAgY3k6IFwiOTBcIixcbiAgICAgICAgcjogXCI4N1wiLFxuICAgICAgICBmaWxsOiBcImJsYWNrXCIsXG4gICAgICAgIHN0cm9rZTogXCJ3aGl0ZVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogXCI2XCJcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE0OS41MDggMTU3LjUyTDY5LjE0MiA1NEg1NFYxMjUuOTdINjYuMTEzNlY2OS4zODM2TDEzOS45OTkgMTY0Ljg0NUMxNDMuMzMzIDE2Mi42MTQgMTQ2LjUwOSAxNjAuMTY1IDE0OS41MDggMTU3LjUyWlwiLFxuICAgICAgICBmaWxsOiBcInVybCgjcGFpbnQwX2xpbmVhcl80MDhfMTM5KVwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICB4OiBcIjExNVwiLFxuICAgICAgICB5OiBcIjU0XCIsXG4gICAgICAgIHdpZHRoOiBcIjEyXCIsXG4gICAgICAgIGhlaWdodDogXCI3MlwiLFxuICAgICAgICBmaWxsOiBcInVybCgjcGFpbnQxX2xpbmVhcl80MDhfMTM5KVwiXG4gICAgfSkpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHtcbiAgICAgICAgaWQ6IFwicGFpbnQwX2xpbmVhcl80MDhfMTM5XCIsXG4gICAgICAgIHgxOiBcIjEwOVwiLFxuICAgICAgICB5MTogXCIxMTYuNVwiLFxuICAgICAgICB4MjogXCIxNDQuNVwiLFxuICAgICAgICB5MjogXCIxNjAuNVwiLFxuICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHtcbiAgICAgICAgc3RvcENvbG9yOiBcIndoaXRlXCJcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7XG4gICAgICAgIG9mZnNldDogXCIxXCIsXG4gICAgICAgIHN0b3BDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBzdG9wT3BhY2l0eTogXCIwXCJcbiAgICB9KSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHtcbiAgICAgICAgaWQ6IFwicGFpbnQxX2xpbmVhcl80MDhfMTM5XCIsXG4gICAgICAgIHgxOiBcIjEyMVwiLFxuICAgICAgICB5MTogXCI1NFwiLFxuICAgICAgICB4MjogXCIxMjAuNzk5XCIsXG4gICAgICAgIHkyOiBcIjEwNi44NzVcIixcbiAgICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7XG4gICAgICAgIHN0b3BDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN0b3BcIiwge1xuICAgICAgICBvZmZzZXQ6IFwiMVwiLFxuICAgICAgICBzdG9wQ29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgc3RvcE9wYWNpdHk6IFwiMFwiXG4gICAgfSkpKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyYW1ld29ya0ljb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRnJhbWV3b3JrSWNvbiIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiZnJhbWV3b3JrIiwiY3JlYXRlRWxlbWVudCIsInhtbG5zIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsInNoYXBlUmVuZGVyaW5nIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3Ryb2tlV2lkdGgiLCJkIiwiaWQiLCJtYXNrVW5pdHMiLCJ4IiwieSIsImN4IiwiY3kiLCJyIiwibWFzayIsIngxIiwieTEiLCJ4MiIsInkyIiwiZ3JhZGllbnRVbml0cyIsInN0b3BDb2xvciIsIm9mZnNldCIsInN0b3BPcGFjaXR5IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/FrameworkIcon.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/GroupedStackFrames.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/GroupedStackFrames.js ***!
  \**************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GroupedStackFrames = GroupedStackFrames;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _callStackFrame = __webpack_require__(/*! ./CallStackFrame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/CallStackFrame.js\");\nvar _frameworkIcon = __webpack_require__(/*! ./FrameworkIcon */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/FrameworkIcon.js\");\nfunction FrameworkGroup({ framework , stackFrames , all  }) {\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"details\", {\n        \"data-nextjs-collapsed-call-stack-details\": true\n    }, /*#__PURE__*/ _react.default.createElement(\"summary\", {\n        tabIndex: 10\n    }, /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        \"data-nextjs-call-stack-chevron-icon\": true,\n        fill: \"none\",\n        height: \"20\",\n        width: \"20\",\n        shapeRendering: \"geometricPrecision\",\n        stroke: \"currentColor\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        strokeWidth: \"2\",\n        viewBox: \"0 0 24 24\"\n    }, /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M9 18l6-6-6-6\"\n    })), /*#__PURE__*/ _react.default.createElement(_frameworkIcon.FrameworkIcon, {\n        framework: framework\n    }), framework === \"react\" ? \"React\" : \"Next.js\"), stackFrames.map((frame, index)=>/*#__PURE__*/ _react.default.createElement(_callStackFrame.CallStackFrame, {\n            key: `call-stack-${index}-${all}`,\n            frame: frame\n        }))));\n}\nfunction GroupedStackFrames({ groupedStackFrames , all  }) {\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, groupedStackFrames.map((stackFramesGroup, groupIndex)=>{\n        // Collapse React and Next.js frames\n        if (stackFramesGroup.framework) {\n            return /*#__PURE__*/ _react.default.createElement(FrameworkGroup, {\n                key: `call-stack-framework-group-${groupIndex}-${all}`,\n                framework: stackFramesGroup.framework,\n                stackFrames: stackFramesGroup.stackFrames,\n                all: all\n            });\n        }\n        return stackFramesGroup.stackFrames.map((frame, frameIndex)=>/*#__PURE__*/ _react.default.createElement(_callStackFrame.CallStackFrame, {\n                key: `call-stack-${groupIndex}-${frameIndex}-${all}`,\n                frame: frame\n            }));\n    }));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=GroupedStackFrames.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvR3JvdXBlZFN0YWNrRnJhbWVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QixJQUFJQywyQkFBMkJDLCtKQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUMsb0pBQWtCO0FBQ2hELElBQUlJLGlCQUFpQkosbUJBQU9BLENBQUMsa0pBQWlCO0FBQzlDLFNBQVNLLGVBQWUsRUFBRUMsVUFBUyxFQUFHQyxZQUFXLEVBQUdDLElBQUcsRUFBRyxFQUFFO0lBQ3hELE9BQU8sV0FBVyxHQUFHTixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQ1AsT0FBT0QsT0FBTyxDQUFDUyxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsR0FBR1IsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsV0FBVztRQUNuSSw0Q0FBNEMsSUFBSTtJQUNwRCxHQUFHLFdBQVcsR0FBR1AsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsV0FBVztRQUNyREUsVUFBVTtJQUNkLEdBQUcsV0FBVyxHQUFHVCxPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQyxPQUFPO1FBQ2pELHVDQUF1QyxJQUFJO1FBQzNDRyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsT0FBTztRQUNQQyxnQkFBZ0I7UUFDaEJDLFFBQVE7UUFDUkMsZUFBZTtRQUNmQyxnQkFBZ0I7UUFDaEJDLGFBQWE7UUFDYkMsU0FBUztJQUNiLEdBQUcsV0FBVyxHQUFHbEIsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUMsUUFBUTtRQUNsRFksR0FBRztJQUNQLEtBQUssV0FBVyxHQUFHbkIsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNMLGVBQWVrQixhQUFhLEVBQUU7UUFDMUVoQixXQUFXQTtJQUNmLElBQUlBLGNBQWMsVUFBVSxVQUFVLFNBQVMsR0FBR0MsWUFBWWdCLEdBQUcsQ0FBQyxDQUFDQyxPQUFPQyxRQUFRLFdBQVcsR0FBR3ZCLE9BQU9ELE9BQU8sQ0FBQ1EsYUFBYSxDQUFDTixnQkFBZ0J1QixjQUFjLEVBQUU7WUFDckpDLEtBQUssQ0FBQyxXQUFXLEVBQUVGLE1BQU0sQ0FBQyxFQUFFakIsSUFBSSxDQUFDO1lBQ2pDZ0IsT0FBT0E7UUFDWDtBQUNSO0FBQ0EsU0FBUzFCLG1CQUFtQixFQUFFOEIsbUJBQWtCLEVBQUdwQixJQUFHLEVBQUcsRUFBRTtJQUN2RCxPQUFPLFdBQVcsR0FBR04sT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNQLE9BQU9ELE9BQU8sQ0FBQ1MsUUFBUSxFQUFFLElBQUksRUFBRWtCLG1CQUFtQkwsR0FBRyxDQUFDLENBQUNNLGtCQUFrQkMsYUFBYTtRQUNwSSxvQ0FBb0M7UUFDcEMsSUFBSUQsaUJBQWlCdkIsU0FBUyxFQUFFO1lBQzVCLE9BQU8sV0FBVyxHQUFHSixPQUFPRCxPQUFPLENBQUNRLGFBQWEsQ0FBQ0osZ0JBQWdCO2dCQUM5RHNCLEtBQUssQ0FBQywyQkFBMkIsRUFBRUcsV0FBVyxDQUFDLEVBQUV0QixJQUFJLENBQUM7Z0JBQ3RERixXQUFXdUIsaUJBQWlCdkIsU0FBUztnQkFDckNDLGFBQWFzQixpQkFBaUJ0QixXQUFXO2dCQUN6Q0MsS0FBS0E7WUFDVDtRQUNKLENBQUM7UUFDRCxPQUNBcUIsaUJBQWlCdEIsV0FBVyxDQUFDZ0IsR0FBRyxDQUFDLENBQUNDLE9BQU9PLGFBQWEsV0FBVyxHQUFHN0IsT0FBT0QsT0FBTyxDQUFDUSxhQUFhLENBQUNOLGdCQUFnQnVCLGNBQWMsRUFBRTtnQkFDekhDLEtBQUssQ0FBQyxXQUFXLEVBQUVHLFdBQVcsQ0FBQyxFQUFFQyxXQUFXLENBQUMsRUFBRXZCLElBQUksQ0FBQztnQkFDcERnQixPQUFPQTtZQUNYO0lBQ1I7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPNUIsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDK0IsVUFBVSxLQUFLLGFBQWE7SUFDckt0QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPdUMsTUFBTSxDQUFDckMsUUFBUUssT0FBTyxFQUFFTDtJQUMvQnNDLE9BQU90QyxPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvR3JvdXBlZFN0YWNrRnJhbWVzLmpzPzlhOTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdyb3VwZWRTdGFja0ZyYW1lcyA9IEdyb3VwZWRTdGFja0ZyYW1lcztcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2FsbFN0YWNrRnJhbWUgPSByZXF1aXJlKFwiLi9DYWxsU3RhY2tGcmFtZVwiKTtcbnZhciBfZnJhbWV3b3JrSWNvbiA9IHJlcXVpcmUoXCIuL0ZyYW1ld29ya0ljb25cIik7XG5mdW5jdGlvbiBGcmFtZXdvcmtHcm91cCh7IGZyYW1ld29yayAsIHN0YWNrRnJhbWVzICwgYWxsICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGV0YWlsc1wiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtY29sbGFwc2VkLWNhbGwtc3RhY2stZGV0YWlsc1wiOiB0cnVlXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3VtbWFyeVwiLCB7XG4gICAgICAgIHRhYkluZGV4OiAxMFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtY2FsbC1zdGFjay1jaGV2cm9uLWljb25cIjogdHJ1ZSxcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIGhlaWdodDogXCIyMFwiLFxuICAgICAgICB3aWR0aDogXCIyMFwiLFxuICAgICAgICBzaGFwZVJlbmRlcmluZzogXCJnZW9tZXRyaWNQcmVjaXNpb25cIixcbiAgICAgICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk05IDE4bDYtNi02LTZcIlxuICAgIH0pKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9mcmFtZXdvcmtJY29uLkZyYW1ld29ya0ljb24sIHtcbiAgICAgICAgZnJhbWV3b3JrOiBmcmFtZXdvcmtcbiAgICB9KSwgZnJhbWV3b3JrID09PSAncmVhY3QnID8gJ1JlYWN0JyA6ICdOZXh0LmpzJyksIHN0YWNrRnJhbWVzLm1hcCgoZnJhbWUsIGluZGV4KT0+LyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9jYWxsU3RhY2tGcmFtZS5DYWxsU3RhY2tGcmFtZSwge1xuICAgICAgICAgICAga2V5OiBgY2FsbC1zdGFjay0ke2luZGV4fS0ke2FsbH1gLFxuICAgICAgICAgICAgZnJhbWU6IGZyYW1lXG4gICAgICAgIH0pKSkpO1xufVxuZnVuY3Rpb24gR3JvdXBlZFN0YWNrRnJhbWVzKHsgZ3JvdXBlZFN0YWNrRnJhbWVzICwgYWxsICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgZ3JvdXBlZFN0YWNrRnJhbWVzLm1hcCgoc3RhY2tGcmFtZXNHcm91cCwgZ3JvdXBJbmRleCk9PntcbiAgICAgICAgLy8gQ29sbGFwc2UgUmVhY3QgYW5kIE5leHQuanMgZnJhbWVzXG4gICAgICAgIGlmIChzdGFja0ZyYW1lc0dyb3VwLmZyYW1ld29yaykge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChGcmFtZXdvcmtHcm91cCwge1xuICAgICAgICAgICAgICAgIGtleTogYGNhbGwtc3RhY2stZnJhbWV3b3JrLWdyb3VwLSR7Z3JvdXBJbmRleH0tJHthbGx9YCxcbiAgICAgICAgICAgICAgICBmcmFtZXdvcms6IHN0YWNrRnJhbWVzR3JvdXAuZnJhbWV3b3JrLFxuICAgICAgICAgICAgICAgIHN0YWNrRnJhbWVzOiBzdGFja0ZyYW1lc0dyb3VwLnN0YWNrRnJhbWVzLFxuICAgICAgICAgICAgICAgIGFsbDogYWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4oLy8gRG9uJ3QgZ3JvdXAgbm9uIFJlYWN0IGFuZCBOZXh0LmpzIGZyYW1lc1xuICAgICAgICBzdGFja0ZyYW1lc0dyb3VwLnN0YWNrRnJhbWVzLm1hcCgoZnJhbWUsIGZyYW1lSW5kZXgpPT4vKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2NhbGxTdGFja0ZyYW1lLkNhbGxTdGFja0ZyYW1lLCB7XG4gICAgICAgICAgICAgICAga2V5OiBgY2FsbC1zdGFjay0ke2dyb3VwSW5kZXh9LSR7ZnJhbWVJbmRleH0tJHthbGx9YCxcbiAgICAgICAgICAgICAgICBmcmFtZTogZnJhbWVcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hcm91cGVkU3RhY2tGcmFtZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR3JvdXBlZFN0YWNrRnJhbWVzIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfY2FsbFN0YWNrRnJhbWUiLCJfZnJhbWV3b3JrSWNvbiIsIkZyYW1ld29ya0dyb3VwIiwiZnJhbWV3b3JrIiwic3RhY2tGcmFtZXMiLCJhbGwiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ0YWJJbmRleCIsImZpbGwiLCJoZWlnaHQiLCJ3aWR0aCIsInNoYXBlUmVuZGVyaW5nIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3Ryb2tlV2lkdGgiLCJ2aWV3Qm94IiwiZCIsIkZyYW1ld29ya0ljb24iLCJtYXAiLCJmcmFtZSIsImluZGV4IiwiQ2FsbFN0YWNrRnJhbWUiLCJrZXkiLCJncm91cGVkU3RhY2tGcmFtZXMiLCJzdGFja0ZyYW1lc0dyb3VwIiwiZ3JvdXBJbmRleCIsImZyYW1lSW5kZXgiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/GroupedStackFrames.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/index.js ***!
  \*************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.styles = exports.RuntimeError = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _codeFrame = __webpack_require__(/*! ../../components/CodeFrame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/index.js\");\nvar _noopTemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nvar _groupStackFramesByFramework = __webpack_require__(/*! ../../helpers/group-stack-frames-by-framework */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/group-stack-frames-by-framework.js\");\nvar _callStackFrame = __webpack_require__(/*! ./CallStackFrame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/CallStackFrame.js\");\nvar _groupedStackFrames = __webpack_require__(/*! ./GroupedStackFrames */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/GroupedStackFrames.js\");\nvar _componentStackFrameRow = __webpack_require__(/*! ./ComponentStackFrameRow */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/ComponentStackFrameRow.js\");\nconst RuntimeError = function RuntimeError({ error  }) {\n    const firstFirstPartyFrameIndex = React.useMemo(()=>{\n        return error.frames.findIndex((entry)=>entry.expanded && Boolean(entry.originalCodeFrame) && Boolean(entry.originalStackFrame));\n    }, [\n        error.frames\n    ]);\n    const firstFrame = React.useMemo(()=>{\n        var _firstFirstPartyFrameIndex;\n        return (_firstFirstPartyFrameIndex = error.frames[firstFirstPartyFrameIndex]) != null ? _firstFirstPartyFrameIndex : null;\n    }, [\n        error.frames,\n        firstFirstPartyFrameIndex\n    ]);\n    const allLeadingFrames = React.useMemo(()=>firstFirstPartyFrameIndex < 0 ? [] : error.frames.slice(0, firstFirstPartyFrameIndex), [\n        error.frames,\n        firstFirstPartyFrameIndex\n    ]);\n    const [all, setAll] = React.useState(firstFrame == null);\n    const toggleAll = React.useCallback(()=>{\n        setAll((v)=>!v);\n    }, []);\n    const leadingFrames = React.useMemo(()=>allLeadingFrames.filter((f)=>f.expanded || all), [\n        all,\n        allLeadingFrames\n    ]);\n    const allCallStackFrames = React.useMemo(()=>error.frames.slice(firstFirstPartyFrameIndex + 1), [\n        error.frames,\n        firstFirstPartyFrameIndex\n    ]);\n    const visibleCallStackFrames = React.useMemo(()=>allCallStackFrames.filter((f)=>f.expanded || all), [\n        all,\n        allCallStackFrames\n    ]);\n    const canShowMore = React.useMemo(()=>{\n        return allCallStackFrames.length !== visibleCallStackFrames.length || all && firstFrame != null;\n    }, [\n        all,\n        allCallStackFrames.length,\n        firstFrame,\n        visibleCallStackFrames.length\n    ]);\n    const stackFramesGroupedByFramework = React.useMemo(()=>(0, _groupStackFramesByFramework).groupStackFramesByFramework(visibleCallStackFrames), [\n        visibleCallStackFrames\n    ]);\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, firstFrame ? /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"h5\", null, \"Source\"), leadingFrames.map((frame, index)=>/*#__PURE__*/ React.createElement(_callStackFrame.CallStackFrame, {\n            key: `leading-frame-${index}-${all}`,\n            frame: frame\n        })), /*#__PURE__*/ React.createElement(_codeFrame.CodeFrame, {\n        stackFrame: firstFrame.originalStackFrame,\n        codeFrame: firstFrame.originalCodeFrame\n    })) : undefined, error.componentStackFrames ? /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"h5\", null, \"Component Stack\"), error.componentStackFrames.map((componentStackFrame, index)=>/*#__PURE__*/ React.createElement(_componentStackFrameRow.ComponentStackFrameRow, {\n            key: index,\n            componentStackFrame: componentStackFrame\n        }))) : null, stackFramesGroupedByFramework.length ? /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"h5\", null, \"Call Stack\"), /*#__PURE__*/ React.createElement(_groupedStackFrames.GroupedStackFrames, {\n        groupedStackFrames: stackFramesGroupedByFramework,\n        all: all\n    })) : undefined, canShowMore ? /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"button\", {\n        tabIndex: 10,\n        \"data-nextjs-data-runtime-error-collapsed-action\": true,\n        type: \"button\",\n        onClick: toggleAll\n    }, all ? \"Hide\" : \"Show\", \" collapsed frames\")) : undefined);\n};\nconst styles = _noopTemplate.noop`\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child),\n  [data-nextjs-component-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6,\n  [data-nextjs-component-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div,\n  [data-nextjs-component-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg,\n  [data-nextjs-component-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source],\n  [data-nextjs-component-stack-frame] > div {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover,\n  [data-nextjs-component-stack-frame] > div:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg,\n  [data-nextjs-component-stack-frame] > div > svg {\n    display: unset;\n  }\n\n  [data-nextjs-call-stack-framework-icon] {\n    margin-right: var(--size-gap);\n  }\n  [data-nextjs-call-stack-framework-icon='next'] > mask {\n    mask-type: alpha;\n  }\n  [data-nextjs-call-stack-framework-icon='react'] {\n    color: rgb(20, 158, 202);\n  }\n  [data-nextjs-collapsed-call-stack-details][open]\n    [data-nextjs-call-stack-chevron-icon] {\n    transform: rotate(90deg);\n  }\n  [data-nextjs-collapsed-call-stack-details] summary {\n    display: flex;\n    align-items: center;\n    margin: var(--size-gap-double) 0;\n    list-style: none;\n  }\n  [data-nextjs-collapsed-call-stack-details] summary::-webkit-details-marker {\n    display: none;\n  }\n\n  [data-nextjs-collapsed-call-stack-details] h6 {\n    color: #666;\n  }\n  [data-nextjs-collapsed-call-stack-details] [data-nextjs-call-stack-frame] {\n    margin-bottom: var(--size-gap-double);\n  }\n`;\nexports.styles = styles;\nexports.RuntimeError = RuntimeError;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsY0FBYyxHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQzdDLElBQUlJLDRCQUE0QkMsaUtBQWdFO0FBQ2hHLElBQUlFLFFBQVFILDBCQUEwQkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUMsbUpBQTRCO0FBQ3JELElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUMsK0lBQTZCO0FBQ3pELElBQUlLLCtCQUErQkwsbUJBQU9BLENBQUMsbUxBQStDO0FBQzFGLElBQUlNLGtCQUFrQk4sbUJBQU9BLENBQUMsb0pBQWtCO0FBQ2hELElBQUlPLHNCQUFzQlAsbUJBQU9BLENBQUMsNEpBQXNCO0FBQ3hELElBQUlRLDBCQUEwQlIsbUJBQU9BLENBQUMsb0tBQTBCO0FBQ2hFLE1BQU1GLGVBQWUsU0FBU0EsYUFBYSxFQUFFVyxNQUFLLEVBQUssRUFBRTtJQUNyRCxNQUFNQyw0QkFBNEJSLE1BQU1TLE9BQU8sQ0FBQyxJQUFJO1FBQ2hELE9BQU9GLE1BQU1HLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDLENBQUNDLFFBQVFBLE1BQU1DLFFBQVEsSUFBSUMsUUFBUUYsTUFBTUcsaUJBQWlCLEtBQUtELFFBQVFGLE1BQU1JLGtCQUFrQjtJQUNqSSxHQUFHO1FBQ0NULE1BQU1HLE1BQU07S0FDZjtJQUNELE1BQU1PLGFBQWFqQixNQUFNUyxPQUFPLENBQUMsSUFBSTtRQUNqQyxJQUFJUztRQUNKLE9BQU8sQ0FBQ0EsNkJBQTZCWCxNQUFNRyxNQUFNLENBQUNGLDBCQUEwQixLQUFLLElBQUksR0FBR1UsNkJBQTZCLElBQUk7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LElBQUksRUFBRSxlQUFlLFdBQVcsR0FBR3BDLE1BQU1vQyxhQUFhLENBQUMvQixvQkFBb0I2QyxrQkFBa0IsRUFBRTtRQUNuUEMsb0JBQW9CakI7UUFDcEJiLEtBQUtBO0lBQ1QsTUFBTXlCLFNBQVMsRUFBRWQsY0FBYyxXQUFXLEdBQUdoQyxNQUFNb0MsYUFBYSxDQUFDcEMsTUFBTXFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxHQUFHckMsTUFBTW9DLGFBQWEsQ0FBQyxVQUFVO1FBQy9IZ0IsVUFBVTtRQUNWLG1EQUFtRCxJQUFJO1FBQ3ZEQyxNQUFNO1FBQ05DLFNBQVM5QjtJQUNiLEdBQUdILE1BQU0sU0FBUyxNQUFNLEVBQUUsd0JBQXdCeUIsU0FBUztBQUMvRDtBQUNBLE1BQU1uRCxTQUFTTyxjQUFjcUQsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvRmxDLENBQUM7QUFDRDlELGNBQWMsR0FBR0U7QUFDakJGLG9CQUFvQixHQUFHRztBQUV2QixJQUFJLENBQUMsT0FBT0gsUUFBUU0sT0FBTyxLQUFLLGNBQWUsT0FBT04sUUFBUU0sT0FBTyxLQUFLLFlBQVlOLFFBQVFNLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT04sUUFBUU0sT0FBTyxDQUFDeUQsVUFBVSxLQUFLLGFBQWE7SUFDcktqRSxPQUFPQyxjQUFjLENBQUNDLFFBQVFNLE9BQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPa0UsTUFBTSxDQUFDaEUsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVFNLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IvaW5kZXguanM/ZmNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVzID0gZXhwb3J0cy5SdW50aW1lRXJyb3IgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY29kZUZyYW1lID0gcmVxdWlyZShcIi4uLy4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIF9ncm91cFN0YWNrRnJhbWVzQnlGcmFtZXdvcmsgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ncm91cC1zdGFjay1mcmFtZXMtYnktZnJhbWV3b3JrXCIpO1xudmFyIF9jYWxsU3RhY2tGcmFtZSA9IHJlcXVpcmUoXCIuL0NhbGxTdGFja0ZyYW1lXCIpO1xudmFyIF9ncm91cGVkU3RhY2tGcmFtZXMgPSByZXF1aXJlKFwiLi9Hcm91cGVkU3RhY2tGcmFtZXNcIik7XG52YXIgX2NvbXBvbmVudFN0YWNrRnJhbWVSb3cgPSByZXF1aXJlKFwiLi9Db21wb25lbnRTdGFja0ZyYW1lUm93XCIpO1xuY29uc3QgUnVudGltZUVycm9yID0gZnVuY3Rpb24gUnVudGltZUVycm9yKHsgZXJyb3IgLCAgfSkge1xuICAgIGNvbnN0IGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPSBSZWFjdC51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiBlcnJvci5mcmFtZXMuZmluZEluZGV4KChlbnRyeSk9PmVudHJ5LmV4cGFuZGVkICYmIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmIEJvb2xlYW4oZW50cnkub3JpZ2luYWxTdGFja0ZyYW1lKSk7XG4gICAgfSwgW1xuICAgICAgICBlcnJvci5mcmFtZXNcbiAgICBdKTtcbiAgICBjb25zdCBmaXJzdEZyYW1lID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICB2YXIgX2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXg7XG4gICAgICAgIHJldHVybiAoX2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPSBlcnJvci5mcmFtZXNbZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleF0pICE9IG51bGwgPyBfZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA6IG51bGw7XG4gICAgfSwgW1xuICAgICAgICBlcnJvci5mcmFtZXMsXG4gICAgICAgIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhcbiAgICBdKTtcbiAgICBjb25zdCBhbGxMZWFkaW5nRnJhbWVzID0gUmVhY3QudXNlTWVtbygoKT0+Zmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDAgPyBbXSA6IGVycm9yLmZyYW1lcy5zbGljZSgwLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4KSwgW1xuICAgICAgICBlcnJvci5mcmFtZXMsXG4gICAgICAgIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhcbiAgICBdKTtcbiAgICBjb25zdCBbYWxsLCBzZXRBbGxdID0gUmVhY3QudXNlU3RhdGUoZmlyc3RGcmFtZSA9PSBudWxsKTtcbiAgICBjb25zdCB0b2dnbGVBbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBzZXRBbGwoKHYpPT4hdik7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGxlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKCgpPT5hbGxMZWFkaW5nRnJhbWVzLmZpbHRlcigoZik9PmYuZXhwYW5kZWQgfHwgYWxsKSwgW1xuICAgICAgICBhbGwsXG4gICAgICAgIGFsbExlYWRpbmdGcmFtZXNcbiAgICBdKTtcbiAgICBjb25zdCBhbGxDYWxsU3RhY2tGcmFtZXMgPSBSZWFjdC51c2VNZW1vKCgpPT5lcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpLCBbXG4gICAgICAgIGVycm9yLmZyYW1lcyxcbiAgICAgICAgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleFxuICAgIF0pO1xuICAgIGNvbnN0IHZpc2libGVDYWxsU3RhY2tGcmFtZXMgPSBSZWFjdC51c2VNZW1vKCgpPT5hbGxDYWxsU3RhY2tGcmFtZXMuZmlsdGVyKChmKT0+Zi5leHBhbmRlZCB8fCBhbGwpLCBbXG4gICAgICAgIGFsbCxcbiAgICAgICAgYWxsQ2FsbFN0YWNrRnJhbWVzXG4gICAgXSk7XG4gICAgY29uc3QgY2FuU2hvd01vcmUgPSBSZWFjdC51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiBhbGxDYWxsU3RhY2tGcmFtZXMubGVuZ3RoICE9PSB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCB8fCBhbGwgJiYgZmlyc3RGcmFtZSAhPSBudWxsO1xuICAgIH0sIFtcbiAgICAgICAgYWxsLFxuICAgICAgICBhbGxDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdEZyYW1lLFxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCwgXG4gICAgXSk7XG4gICAgY29uc3Qgc3RhY2tGcmFtZXNHcm91cGVkQnlGcmFtZXdvcmsgPSBSZWFjdC51c2VNZW1vKCgpPT4oMCwgX2dyb3VwU3RhY2tGcmFtZXNCeUZyYW1ld29yaykuZ3JvdXBTdGFja0ZyYW1lc0J5RnJhbWV3b3JrKHZpc2libGVDYWxsU3RhY2tGcmFtZXMpLCBbXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXNcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBmaXJzdEZyYW1lID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNVwiLCBudWxsLCBcIlNvdXJjZVwiKSwgbGVhZGluZ0ZyYW1lcy5tYXAoKGZyYW1lLCBpbmRleCk9Pi8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfY2FsbFN0YWNrRnJhbWUuQ2FsbFN0YWNrRnJhbWUsIHtcbiAgICAgICAgICAgIGtleTogYGxlYWRpbmctZnJhbWUtJHtpbmRleH0tJHthbGx9YCxcbiAgICAgICAgICAgIGZyYW1lOiBmcmFtZVxuICAgICAgICB9KSksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChfY29kZUZyYW1lLkNvZGVGcmFtZSwge1xuICAgICAgICBzdGFja0ZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICAgICAgY29kZUZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lXG4gICAgfSkpIDogdW5kZWZpbmVkLCBlcnJvci5jb21wb25lbnRTdGFja0ZyYW1lcyA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDb21wb25lbnQgU3RhY2tcIiksIGVycm9yLmNvbXBvbmVudFN0YWNrRnJhbWVzLm1hcCgoY29tcG9uZW50U3RhY2tGcmFtZSwgaW5kZXgpPT4vKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2NvbXBvbmVudFN0YWNrRnJhbWVSb3cuQ29tcG9uZW50U3RhY2tGcmFtZVJvdywge1xuICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrRnJhbWU6IGNvbXBvbmVudFN0YWNrRnJhbWVcbiAgICAgICAgfSkpKSA6IG51bGwsIHN0YWNrRnJhbWVzR3JvdXBlZEJ5RnJhbWV3b3JrLmxlbmd0aCA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDYWxsIFN0YWNrXCIpLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX2dyb3VwZWRTdGFja0ZyYW1lcy5Hcm91cGVkU3RhY2tGcmFtZXMsIHtcbiAgICAgICAgZ3JvdXBlZFN0YWNrRnJhbWVzOiBzdGFja0ZyYW1lc0dyb3VwZWRCeUZyYW1ld29yayxcbiAgICAgICAgYWxsOiBhbGxcbiAgICB9KSkgOiB1bmRlZmluZWQsIGNhblNob3dNb3JlID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICB0YWJJbmRleDogMTAsXG4gICAgICAgIFwiZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25cIjogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgb25DbGljazogdG9nZ2xlQWxsXG4gICAgfSwgYWxsID8gJ0hpZGUnIDogJ1Nob3cnLCBcIiBjb2xsYXBzZWQgZnJhbWVzXCIpKSA6IHVuZGVmaW5lZCk7XG59O1xuY29uc3Qgc3R5bGVzID0gX25vb3BUZW1wbGF0ZS5ub29wYFxuICBidXR0b25bZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25dIHtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBwYWRkaW5nOiAwO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMyk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSxcbiAgW2RhdGEtbmV4dGpzLWNvbXBvbmVudC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2LFxuICBbZGF0YS1uZXh0anMtY29tcG9uZW50LXN0YWNrLWZyYW1lXSA+IGg2IHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xuICAgIGNvbG9yOiAjMjIyO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2W2RhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkPSdmYWxzZSddIHtcbiAgICBjb2xvcjogIzY2NjtcbiAgfVxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYsXG4gIFtkYXRhLW5leHRqcy1jb21wb25lbnQtc3RhY2stZnJhbWVdID4gZGl2IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XG4gICAgY29sb3I6ICM5OTk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnLFxuICBbZGF0YS1uZXh0anMtY29tcG9uZW50LXN0YWNrLWZyYW1lXSA+IGRpdiA+IHN2ZyB7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XG5cbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0sXG4gIFtkYXRhLW5leHRqcy1jb21wb25lbnQtc3RhY2stZnJhbWVdID4gZGl2IHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV06aG92ZXIsXG4gIFtkYXRhLW5leHRqcy1jb21wb25lbnQtc3RhY2stZnJhbWVdID4gZGl2OmhvdmVyIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcsXG4gIFtkYXRhLW5leHRqcy1jb21wb25lbnQtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcbiAgICBkaXNwbGF5OiB1bnNldDtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1ld29yay1pY29uXSB7XG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWV3b3JrLWljb249J25leHQnXSA+IG1hc2sge1xuICAgIG1hc2stdHlwZTogYWxwaGE7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWV3b3JrLWljb249J3JlYWN0J10ge1xuICAgIGNvbG9yOiByZ2IoMjAsIDE1OCwgMjAyKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtY29sbGFwc2VkLWNhbGwtc3RhY2stZGV0YWlsc11bb3Blbl1cbiAgICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1jaGV2cm9uLWljb25dIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvbGxhcHNlZC1jYWxsLXN0YWNrLWRldGFpbHNdIHN1bW1hcnkge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBtYXJnaW46IHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgMDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2xsYXBzZWQtY2FsbC1zdGFjay1kZXRhaWxzXSBzdW1tYXJ5Ojotd2Via2l0LWRldGFpbHMtbWFya2VyIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWNvbGxhcHNlZC1jYWxsLXN0YWNrLWRldGFpbHNdIGg2IHtcbiAgICBjb2xvcjogIzY2NjtcbiAgfVxuICBbZGF0YS1uZXh0anMtY29sbGFwc2VkLWNhbGwtc3RhY2stZGV0YWlsc10gW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdIHtcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xuICB9XG5gO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3R5bGVzIiwiUnVudGltZUVycm9yIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfY29kZUZyYW1lIiwiX25vb3BUZW1wbGF0ZSIsIl9ncm91cFN0YWNrRnJhbWVzQnlGcmFtZXdvcmsiLCJfY2FsbFN0YWNrRnJhbWUiLCJfZ3JvdXBlZFN0YWNrRnJhbWVzIiwiX2NvbXBvbmVudFN0YWNrRnJhbWVSb3ciLCJlcnJvciIsImZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXgiLCJ1c2VNZW1vIiwiZnJhbWVzIiwiZmluZEluZGV4IiwiZW50cnkiLCJleHBhbmRlZCIsIkJvb2xlYW4iLCJvcmlnaW5hbENvZGVGcmFtZSIsIm9yaWdpbmFsU3RhY2tGcmFtZSIsImZpcnN0RnJhbWUiLCJfZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCIsImFsbExlYWRpbmdGcmFtZXMiLCJzbGljZSIsImFsbCIsInNldEFsbCIsInVzZVN0YXRlIiwidG9nZ2xlQWxsIiwidXNlQ2FsbGJhY2siLCJ2IiwibGVhZGluZ0ZyYW1lcyIsImZpbHRlciIsImYiLCJhbGxDYWxsU3RhY2tGcmFtZXMiLCJ2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzIiwiY2FuU2hvd01vcmUiLCJsZW5ndGgiLCJzdGFja0ZyYW1lc0dyb3VwZWRCeUZyYW1ld29yayIsImdyb3VwU3RhY2tGcmFtZXNCeUZyYW1ld29yayIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIm1hcCIsImZyYW1lIiwiaW5kZXgiLCJDYWxsU3RhY2tGcmFtZSIsImtleSIsIkNvZGVGcmFtZSIsInN0YWNrRnJhbWUiLCJjb2RlRnJhbWUiLCJ1bmRlZmluZWQiLCJjb21wb25lbnRTdGFja0ZyYW1lcyIsImNvbXBvbmVudFN0YWNrRnJhbWUiLCJDb21wb25lbnRTdGFja0ZyYW1lUm93IiwiR3JvdXBlZFN0YWNrRnJhbWVzIiwiZ3JvdXBlZFN0YWNrRnJhbWVzIiwidGFiSW5kZXgiLCJ0eXBlIiwib25DbGljayIsIm5vb3AiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/index.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js ***!
  \******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.errorOverlayReducer = exports.ACTION_VERSION_INFO = exports.ACTION_UNHANDLED_REJECTION = exports.ACTION_UNHANDLED_ERROR = exports.ACTION_REFRESH = exports.ACTION_BEFORE_REFRESH = exports.ACTION_BUILD_ERROR = exports.ACTION_BUILD_OK = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nconst ACTION_BUILD_OK = \"build-ok\";\nexports.ACTION_BUILD_OK = ACTION_BUILD_OK;\nconst ACTION_BUILD_ERROR = \"build-error\";\nexports.ACTION_BUILD_ERROR = ACTION_BUILD_ERROR;\nconst ACTION_BEFORE_REFRESH = \"before-fast-refresh\";\nexports.ACTION_BEFORE_REFRESH = ACTION_BEFORE_REFRESH;\nconst ACTION_REFRESH = \"fast-refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nconst ACTION_UNHANDLED_ERROR = \"unhandled-error\";\nexports.ACTION_UNHANDLED_ERROR = ACTION_UNHANDLED_ERROR;\nconst ACTION_UNHANDLED_REJECTION = \"unhandled-rejection\";\nexports.ACTION_UNHANDLED_REJECTION = ACTION_UNHANDLED_REJECTION;\nconst ACTION_VERSION_INFO = \"version-info\";\nexports.ACTION_VERSION_INFO = ACTION_VERSION_INFO;\nfunction pushErrorFilterDuplicates(errors, err) {\n    return [\n        ...errors.filter((e)=>{\n            // Filter out duplicate errors\n            return e.event.reason !== err.event.reason;\n        }),\n        err\n    ];\n}\nconst errorOverlayReducer = (state, action)=>{\n    switch(action.type){\n        case ACTION_BUILD_OK:\n            {\n                return _extends({}, state, {\n                    buildError: null\n                });\n            }\n        case ACTION_BUILD_ERROR:\n            {\n                return _extends({}, state, {\n                    buildError: action.message\n                });\n            }\n        case ACTION_BEFORE_REFRESH:\n            {\n                return _extends({}, state, {\n                    refreshState: {\n                        type: \"pending\",\n                        errors: []\n                    }\n                });\n            }\n        case ACTION_REFRESH:\n            {\n                return _extends({}, state, {\n                    buildError: null,\n                    errors: // and UNHANDLED_REJECTION events might be dispatched between the\n                    // BEFORE_REFRESH and the REFRESH event. We want to keep those errors\n                    // around until the next refresh. Otherwise we run into a race\n                    // condition where those errors would be cleared on refresh completion\n                    // before they can be displayed.\n                    state.refreshState.type === \"pending\" ? state.refreshState.errors : [],\n                    refreshState: {\n                        type: \"idle\"\n                    }\n                });\n            }\n        case ACTION_UNHANDLED_ERROR:\n        case ACTION_UNHANDLED_REJECTION:\n            {\n                switch(state.refreshState.type){\n                    case \"idle\":\n                        {\n                            return _extends({}, state, {\n                                nextId: state.nextId + 1,\n                                errors: pushErrorFilterDuplicates(state.errors, {\n                                    id: state.nextId,\n                                    event: action\n                                })\n                            });\n                        }\n                    case \"pending\":\n                        {\n                            return _extends({}, state, {\n                                nextId: state.nextId + 1,\n                                refreshState: _extends({}, state.refreshState, {\n                                    errors: pushErrorFilterDuplicates(state.refreshState.errors, {\n                                        id: state.nextId,\n                                        event: action\n                                    })\n                                })\n                            });\n                        }\n                    default:\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        const _ = state.refreshState;\n                        return state;\n                }\n            }\n        case ACTION_VERSION_INFO:\n            {\n                return _extends({}, state, {\n                    versionInfo: action.versionInfo\n                });\n            }\n        default:\n            {\n                return state;\n            }\n    }\n};\nexports.errorOverlayReducer = errorOverlayReducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-overlay-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2Vycm9yLW92ZXJsYXktcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBR0EsMkJBQTJCLEdBQUdBLGtDQUFrQyxHQUFHQSw4QkFBOEIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN2UCxJQUFJVSxXQUFXQywrSEFBK0M7QUFDOUQsTUFBTUYsa0JBQWtCO0FBQ3hCVCx1QkFBdUIsR0FBR1M7QUFDMUIsTUFBTUQscUJBQXFCO0FBQzNCUiwwQkFBMEIsR0FBR1E7QUFDN0IsTUFBTUQsd0JBQXdCO0FBQzlCUCw2QkFBNkIsR0FBR087QUFDaEMsTUFBTUQsaUJBQWlCO0FBQ3ZCTixzQkFBc0IsR0FBR007QUFDekIsTUFBTUQseUJBQXlCO0FBQy9CTCw4QkFBOEIsR0FBR0s7QUFDakMsTUFBTUQsNkJBQTZCO0FBQ25DSixrQ0FBa0MsR0FBR0k7QUFDckMsTUFBTUQsc0JBQXNCO0FBQzVCSCwyQkFBMkIsR0FBR0c7QUFDOUIsU0FBU1UsMEJBQTBCQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtJQUM1QyxPQUFPO1dBQ0FELE9BQU9FLE1BQU0sQ0FBQyxDQUFDQyxJQUFJO1lBQ2xCLDhCQUE4QjtZQUM5QixPQUFPQSxFQUFFQyxLQUFLLENBQUNDLE1BQU0sS0FBS0osSUFBSUcsS0FBSyxDQUFDQyxNQUFNO1FBQzlDO1FBQ0FKO0tBQ0g7QUFDTDtBQUNBLE1BQU1iLHNCQUFzQixDQUFDa0IsT0FBT0MsU0FBUztJQUN6QyxPQUFPQSxPQUFPQyxJQUFJO1FBQ2QsS0FBS2I7WUFDRDtnQkFDSSxPQUFPQyxTQUFTLENBQUMsR0FBR1UsT0FBTztvQkFDdkJHLFlBQVksSUFBSTtnQkFDcEI7WUFDSjtRQUNKLEtBQUtmO1lBQ0Q7Z0JBQ0ksT0FBT0UsU0FBUyxDQUFDLEdBQUdVLE9BQU87b0JBQ3ZCRyxZQUFZRixPQUFPRyxPQUFPO2dCQUM5QjtZQUNKO1FBQ0osS0FBS2pCO1lBQ0Q7Z0JBQ0ksT0FBT0csU0FBUyxDQUFDLEdBQUdVLE9BQU87b0JBQ3ZCSyxjQUFjO3dCQUNWSCxNQUFNO3dCQUNOUixRQUFRLEVBQUU7b0JBQ2Q7Z0JBQ0o7WUFDSjtRQUNKLEtBQUtSO1lBQ0Q7Z0JBQ0ksT0FBT0ksU0FBUyxDQUFDLEdBQUdVLE9BQU87b0JBQ3ZCRyxZQUFZLElBQUk7b0JBQ2hCVCxRQUNBLGlFQUFpRTtvQkFDakUscUVBQXFFO29CQUNyRSw4REFBOEQ7b0JBQzlELHNFQUFzRTtvQkFDdEUsZ0NBQWdDO29CQUNoQ00sTUFBTUssWUFBWSxDQUFDSCxJQUFJLEtBQUssWUFBWUYsTUFBTUssWUFBWSxDQUFDWCxNQUFNLEdBQUcsRUFBRTtvQkFDdEVXLGNBQWM7d0JBQ1ZILE1BQU07b0JBQ1Y7Z0JBQ0o7WUFDSjtRQUNKLEtBQUtqQjtRQUNMLEtBQUtEO1lBQ0Q7Z0JBQ0ksT0FBT2dCLE1BQU1LLFlBQVksQ0FBQ0gsSUFBSTtvQkFDMUIsS0FBSzt3QkFDRDs0QkFDSSxPQUFPWixTQUFTLENBQUMsR0FBR1UsT0FBTztnQ0FDdkJNLFFBQVFOLE1BQU1NLE1BQU0sR0FBRztnQ0FDdkJaLFFBQVFELDBCQUEwQk8sTUFBTU4sTUFBTSxFQUFFO29DQUM1Q2EsSUFBSVAsTUFBTU0sTUFBTTtvQ0FDaEJSLE9BQU9HO2dDQUNYOzRCQUNKO3dCQUNKO29CQUNKLEtBQUs7d0JBQ0Q7NEJBQ0ksT0FBT1gsU0FBUyxDQUFDLEdBQUdVLE9BQU87Z0NBQ3ZCTSxRQUFRTixNQUFNTSxNQUFNLEdBQUc7Z0NBQ3ZCRCxjQUFjZixTQUFTLENBQUMsR0FBR1UsTUFBTUssWUFBWSxFQUFFO29DQUMzQ1gsUUFBUUQsMEJBQTBCTyxNQUFNSyxZQUFZLENBQUNYLE1BQU0sRUFBRTt3Q0FDekRhLElBQUlQLE1BQU1NLE1BQU07d0NBQ2hCUixPQUFPRztvQ0FDWDtnQ0FDSjs0QkFDSjt3QkFDSjtvQkFDSjt3QkFDSSw2REFBNkQ7d0JBQzdELE1BQU1PLElBQUlSLE1BQU1LLFlBQVk7d0JBQzVCLE9BQU9MO2dCQUNmO1lBQ0o7UUFDSixLQUFLakI7WUFDRDtnQkFDSSxPQUFPTyxTQUFTLENBQUMsR0FBR1UsT0FBTztvQkFDdkJTLGFBQWFSLE9BQU9RLFdBQVc7Z0JBQ25DO1lBQ0o7UUFDSjtZQUNJO2dCQUNJLE9BQU9UO1lBQ1g7SUFDUjtBQUNKO0FBQ0FwQiwyQkFBMkIsR0FBR0U7QUFFOUIsSUFBSSxDQUFDLE9BQU9GLFFBQVFZLE9BQU8sS0FBSyxjQUFlLE9BQU9aLFFBQVFZLE9BQU8sS0FBSyxZQUFZWixRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9aLFFBQVFZLE9BQU8sQ0FBQ2tCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLaEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRWSxPQUFPLEVBQUUsY0FBYztRQUFFWCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lDLE1BQU0sQ0FBQy9CLFFBQVFZLE9BQU8sRUFBRVo7SUFDL0JnQyxPQUFPaEMsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9lcnJvci1vdmVybGF5LXJlZHVjZXIuanM/MjVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXJyb3JPdmVybGF5UmVkdWNlciA9IGV4cG9ydHMuQUNUSU9OX1ZFUlNJT05fSU5GTyA9IGV4cG9ydHMuQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04gPSBleHBvcnRzLkFDVElPTl9VTkhBTkRMRURfRVJST1IgPSBleHBvcnRzLkFDVElPTl9SRUZSRVNIID0gZXhwb3J0cy5BQ1RJT05fQkVGT1JFX1JFRlJFU0ggPSBleHBvcnRzLkFDVElPTl9CVUlMRF9FUlJPUiA9IGV4cG9ydHMuQUNUSU9OX0JVSUxEX09LID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbmNvbnN0IEFDVElPTl9CVUlMRF9PSyA9ICdidWlsZC1vayc7XG5leHBvcnRzLkFDVElPTl9CVUlMRF9PSyA9IEFDVElPTl9CVUlMRF9PSztcbmNvbnN0IEFDVElPTl9CVUlMRF9FUlJPUiA9ICdidWlsZC1lcnJvcic7XG5leHBvcnRzLkFDVElPTl9CVUlMRF9FUlJPUiA9IEFDVElPTl9CVUlMRF9FUlJPUjtcbmNvbnN0IEFDVElPTl9CRUZPUkVfUkVGUkVTSCA9ICdiZWZvcmUtZmFzdC1yZWZyZXNoJztcbmV4cG9ydHMuQUNUSU9OX0JFRk9SRV9SRUZSRVNIID0gQUNUSU9OX0JFRk9SRV9SRUZSRVNIO1xuY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAnZmFzdC1yZWZyZXNoJztcbmV4cG9ydHMuQUNUSU9OX1JFRlJFU0ggPSBBQ1RJT05fUkVGUkVTSDtcbmNvbnN0IEFDVElPTl9VTkhBTkRMRURfRVJST1IgPSAndW5oYW5kbGVkLWVycm9yJztcbmV4cG9ydHMuQUNUSU9OX1VOSEFORExFRF9FUlJPUiA9IEFDVElPTl9VTkhBTkRMRURfRVJST1I7XG5jb25zdCBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWQtcmVqZWN0aW9uJztcbmV4cG9ydHMuQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04gPSBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTjtcbmNvbnN0IEFDVElPTl9WRVJTSU9OX0lORk8gPSAndmVyc2lvbi1pbmZvJztcbmV4cG9ydHMuQUNUSU9OX1ZFUlNJT05fSU5GTyA9IEFDVElPTl9WRVJTSU9OX0lORk87XG5mdW5jdGlvbiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKGVycm9ycywgZXJyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uZXJyb3JzLmZpbHRlcigoZSk9PntcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlIGVycm9yc1xuICAgICAgICAgICAgcmV0dXJuIGUuZXZlbnQucmVhc29uICE9PSBlcnIuZXZlbnQucmVhc29uO1xuICAgICAgICB9KSxcbiAgICAgICAgZXJyLCBcbiAgICBdO1xufVxuY29uc3QgZXJyb3JPdmVybGF5UmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKT0+e1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUNUSU9OX0JVSUxEX09LOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRFcnJvcjogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9CVUlMRF9FUlJPUjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRXJyb3I6IGFjdGlvbi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX0JFRk9SRV9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBQ1RJT05fUkVGUkVTSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogLy8gRXJyb3JzIGNhbiBjb21lIGluIGR1cmluZyB1cGRhdGVzLiBJbiB0aGlzIGNhc2UsIFVOSEFORExFRF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgVU5IQU5ETEVEX1JFSkVDVElPTiBldmVudHMgbWlnaHQgYmUgZGlzcGF0Y2hlZCBiZXR3ZWVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBCRUZPUkVfUkVGUkVTSCBhbmQgdGhlIFJFRlJFU0ggZXZlbnQuIFdlIHdhbnQgdG8ga2VlcCB0aG9zZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJvdW5kIHVudGlsIHRoZSBuZXh0IHJlZnJlc2guIE90aGVyd2lzZSB3ZSBydW4gaW50byBhIHJhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uZGl0aW9uIHdoZXJlIHRob3NlIGVycm9ycyB3b3VsZCBiZSBjbGVhcmVkIG9uIHJlZnJlc2ggY29tcGxldGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhleSBjYW4gYmUgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZWZyZXNoU3RhdGUudHlwZSA9PT0gJ3BlbmRpbmcnID8gc3RhdGUucmVmcmVzaFN0YXRlLmVycm9ycyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpZGxlJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1VOSEFORExFRF9FUlJPUjpcbiAgICAgICAgY2FzZSBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goc3RhdGUucmVmcmVzaFN0YXRlLnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogc3RhdGUubmV4dElkICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKHN0YXRlLmVycm9ycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHN0YXRlLm5leHRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IHN0YXRlLm5leHRJZCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTdGF0ZTogX2V4dGVuZHMoe30sIHN0YXRlLnJlZnJlc2hTdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKHN0YXRlLnJlZnJlc2hTdGF0ZS5lcnJvcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc3RhdGUubmV4dElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfID0gc3RhdGUucmVmcmVzaFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBQ1RJT05fVkVSU0lPTl9JTkZPOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkluZm86IGFjdGlvbi52ZXJzaW9uSW5mb1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5lcnJvck92ZXJsYXlSZWR1Y2VyID0gZXJyb3JPdmVybGF5UmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3Itb3ZlcmxheS1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVycm9yT3ZlcmxheVJlZHVjZXIiLCJBQ1RJT05fVkVSU0lPTl9JTkZPIiwiQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04iLCJBQ1RJT05fVU5IQU5ETEVEX0VSUk9SIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fQkVGT1JFX1JFRlJFU0giLCJBQ1RJT05fQlVJTERfRVJST1IiLCJBQ1RJT05fQlVJTERfT0siLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJkZWZhdWx0IiwicHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyIsImVycm9ycyIsImVyciIsImZpbHRlciIsImUiLCJldmVudCIsInJlYXNvbiIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsImJ1aWxkRXJyb3IiLCJtZXNzYWdlIiwicmVmcmVzaFN0YXRlIiwibmV4dElkIiwiaWQiLCJfIiwidmVyc2lvbkluZm8iLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-protocol.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-protocol.js ***!
  \************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSocketProtocol = getSocketProtocol;\nfunction getSocketProtocol(assetPrefix) {\n    let protocol = window.location.protocol;\n    try {\n        // assetPrefix is a url\n        protocol = new URL(assetPrefix).protocol;\n    } catch (_) {}\n    return protocol === \"http:\" ? \"ws\" : \"wss\";\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-socket-protocol.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvZ2V0LXNvY2tldC1wcm90b2NvbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUIsU0FBU0Esa0JBQWtCQyxXQUFXLEVBQUU7SUFDcEMsSUFBSUMsV0FBV0MsT0FBT0MsUUFBUSxDQUFDRixRQUFRO0lBQ3ZDLElBQUk7UUFDQSx1QkFBdUI7UUFDdkJBLFdBQVcsSUFBSUcsSUFBSUosYUFBYUMsUUFBUTtJQUM1QyxFQUFFLE9BQU9JLEdBQUcsQ0FBQztJQUNiLE9BQU9KLGFBQWEsVUFBVSxPQUFPLEtBQUs7QUFDOUM7QUFFQSxJQUFJLENBQUMsT0FBT0osUUFBUVMsT0FBTyxLQUFLLGNBQWUsT0FBT1QsUUFBUVMsT0FBTyxLQUFLLFlBQVlULFFBQVFTLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1QsUUFBUVMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1osT0FBT0MsY0FBYyxDQUFDQyxRQUFRUyxPQUFPLEVBQUUsY0FBYztRQUFFUixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2EsTUFBTSxDQUFDWCxRQUFRUyxPQUFPLEVBQUVUO0lBQy9CWSxPQUFPWixPQUFPLEdBQUdBLFFBQVFTLE9BQU87QUFDbEMsQ0FBQyxDQUVELCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvZ2V0LXNvY2tldC1wcm90b2NvbC5qcz9hYjY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRTb2NrZXRQcm90b2NvbCA9IGdldFNvY2tldFByb3RvY29sO1xuZnVuY3Rpb24gZ2V0U29ja2V0UHJvdG9jb2woYXNzZXRQcmVmaXgpIHtcbiAgICBsZXQgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gYXNzZXRQcmVmaXggaXMgYSB1cmxcbiAgICAgICAgcHJvdG9jb2wgPSBuZXcgVVJMKGFzc2V0UHJlZml4KS5wcm90b2NvbDtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNvY2tldC1wcm90b2NvbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRTb2NrZXRQcm90b2NvbCIsImFzc2V0UHJlZml4IiwicHJvdG9jb2wiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIlVSTCIsIl8iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-protocol.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/getErrorByType.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/getErrorByType.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorByType = getErrorByType;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _errorOverlayReducer = __webpack_require__(/*! ../error-overlay-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/error-overlay-reducer.js\");\nvar _nodeStackFrames = __webpack_require__(/*! ./nodeStackFrames */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js\");\nvar _stackFrame = __webpack_require__(/*! ./stack-frame */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js\");\nfunction getErrorByType(ev) {\n    return _getErrorByType.apply(this, arguments);\n}\nfunction _getErrorByType() {\n    _getErrorByType = _async_to_generator(function*(ev) {\n        const { id , event  } = ev;\n        switch(event.type){\n            case _errorOverlayReducer.ACTION_UNHANDLED_ERROR:\n            case _errorOverlayReducer.ACTION_UNHANDLED_REJECTION:\n                {\n                    const readyRuntimeError = {\n                        id,\n                        runtime: true,\n                        error: event.reason,\n                        frames: yield (0, _stackFrame).getOriginalStackFrames(event.frames, (0, _nodeStackFrames).getErrorSource(event.reason), event.reason.toString())\n                    };\n                    if (event.type === _errorOverlayReducer.ACTION_UNHANDLED_ERROR) {\n                        readyRuntimeError.componentStackFrames = event.componentStackFrames;\n                    }\n                    return readyRuntimeError;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = event;\n        throw new Error(\"type system invariant violation\");\n    });\n    return _getErrorByType.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=getErrorByType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvZ2V0RXJyb3JCeVR5cGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCLElBQUlDLHNCQUFzQkMscUpBQTBEO0FBQ3BGLElBQUlFLHVCQUF1QkYsbUJBQU9BLENBQUMsNElBQTBCO0FBQzdELElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUMsdUlBQW1CO0FBQ2xELElBQUlJLGNBQWNKLG1CQUFPQSxDQUFDLCtIQUFlO0FBQ3pDLFNBQVNGLGVBQWVPLEVBQUUsRUFBRTtJQUN4QixPQUFPQyxnQkFBZ0JDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQ3ZDO0FBQ0EsU0FBU0Ysa0JBQWtCO0lBQ3ZCQSxrQkFBa0JQLG9CQUFvQixVQUFVTSxFQUFFLEVBQUU7UUFDaEQsTUFBTSxFQUFFSSxHQUFFLEVBQUdDLE1BQUssRUFBRyxHQUFHTDtRQUN4QixPQUFPSyxNQUFNQyxJQUFJO1lBQ2IsS0FBS1QscUJBQXFCVSxzQkFBc0I7WUFDaEQsS0FBS1YscUJBQXFCVywwQkFBMEI7Z0JBQ2hEO29CQUNJLE1BQU1DLG9CQUFvQjt3QkFDdEJMO3dCQUNBTSxTQUFTLElBQUk7d0JBQ2JDLE9BQU9OLE1BQU1PLE1BQU07d0JBQ25CQyxRQUFRLE1BQU0sQ0FBQyxHQUFHZCxXQUFXLEVBQUVlLHNCQUFzQixDQUFDVCxNQUFNUSxNQUFNLEVBQUUsQ0FBQyxHQUFHZixnQkFBZ0IsRUFBRWlCLGNBQWMsQ0FBQ1YsTUFBTU8sTUFBTSxHQUFHUCxNQUFNTyxNQUFNLENBQUNJLFFBQVE7b0JBQ2pKO29CQUNBLElBQUlYLE1BQU1DLElBQUksS0FBS1QscUJBQXFCVSxzQkFBc0IsRUFBRTt3QkFDNURFLGtCQUFrQlEsb0JBQW9CLEdBQUdaLE1BQU1ZLG9CQUFvQjtvQkFDdkUsQ0FBQztvQkFDRCxPQUFPUjtnQkFDWDtZQUNKO2dCQUNJO29CQUNJLEtBQU07Z0JBQ1Y7UUFDUjtRQUNBLDZEQUE2RDtRQUM3RCxNQUFNUyxJQUFJYjtRQUNWLE1BQU0sSUFBSWMsTUFBTSxtQ0FBbUM7SUFDdkQ7SUFDQSxPQUFPbEIsZ0JBQWdCQyxLQUFLLENBQUMsSUFBSSxFQUFFQztBQUN2QztBQUVBLElBQUksQ0FBQyxPQUFPWixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUN3QixVQUFVLEtBQUssYUFBYTtJQUNySy9CLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQyxNQUFNLENBQUM5QixRQUFRSyxPQUFPLEVBQUVMO0lBQy9CK0IsT0FBTy9CLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy9nZXRFcnJvckJ5VHlwZS5qcz81YWNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRFcnJvckJ5VHlwZSA9IGdldEVycm9yQnlUeXBlO1xudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2Vycm9yT3ZlcmxheVJlZHVjZXIgPSByZXF1aXJlKFwiLi4vZXJyb3Itb3ZlcmxheS1yZWR1Y2VyXCIpO1xudmFyIF9ub2RlU3RhY2tGcmFtZXMgPSByZXF1aXJlKFwiLi9ub2RlU3RhY2tGcmFtZXNcIik7XG52YXIgX3N0YWNrRnJhbWUgPSByZXF1aXJlKFwiLi9zdGFjay1mcmFtZVwiKTtcbmZ1bmN0aW9uIGdldEVycm9yQnlUeXBlKGV2KSB7XG4gICAgcmV0dXJuIF9nZXRFcnJvckJ5VHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2dldEVycm9yQnlUeXBlKCkge1xuICAgIF9nZXRFcnJvckJ5VHlwZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKGV2KSB7XG4gICAgICAgIGNvbnN0IHsgaWQgLCBldmVudCAgfSA9IGV2O1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSl7XG4gICAgICAgICAgICBjYXNlIF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9VTkhBTkRMRURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIF9lcnJvck92ZXJsYXlSZWR1Y2VyLkFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZHlSdW50aW1lRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXZlbnQucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzOiB5aWVsZCAoMCwgX3N0YWNrRnJhbWUpLmdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZXZlbnQuZnJhbWVzLCAoMCwgX25vZGVTdGFja0ZyYW1lcykuZ2V0RXJyb3JTb3VyY2UoZXZlbnQucmVhc29uKSwgZXZlbnQucmVhc29uLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBfZXJyb3JPdmVybGF5UmVkdWNlci5BQ1RJT05fVU5IQU5ETEVEX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeVJ1bnRpbWVFcnJvci5jb21wb25lbnRTdGFja0ZyYW1lcyA9IGV2ZW50LmNvbXBvbmVudFN0YWNrRnJhbWVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkeVJ1bnRpbWVFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXyA9IGV2ZW50O1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgc3lzdGVtIGludmFyaWFudCB2aW9sYXRpb24nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2dldEVycm9yQnlUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEVycm9yQnlUeXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEVycm9yQnlUeXBlIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX2Vycm9yT3ZlcmxheVJlZHVjZXIiLCJfbm9kZVN0YWNrRnJhbWVzIiwiX3N0YWNrRnJhbWUiLCJldiIsIl9nZXRFcnJvckJ5VHlwZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiaWQiLCJldmVudCIsInR5cGUiLCJBQ1RJT05fVU5IQU5ETEVEX0VSUk9SIiwiQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04iLCJyZWFkeVJ1bnRpbWVFcnJvciIsInJ1bnRpbWUiLCJlcnJvciIsInJlYXNvbiIsImZyYW1lcyIsImdldE9yaWdpbmFsU3RhY2tGcmFtZXMiLCJnZXRFcnJvclNvdXJjZSIsInRvU3RyaW5nIiwiY29tcG9uZW50U3RhY2tGcmFtZXMiLCJfIiwiRXJyb3IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/getErrorByType.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/group-stack-frames-by-framework.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/group-stack-frames-by-framework.js ***!
  \************************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.groupStackFramesByFramework = groupStackFramesByFramework;\n/**\n * Get the origin framework of the stack frame by package name.\n */ function getFramework(sourcePackage) {\n    if (!sourcePackage) return undefined;\n    if (/^(react|react-dom|react-is|react-refresh|react-server-dom-webpack|scheduler)$/.test(sourcePackage)) {\n        return \"react\";\n    } else if (sourcePackage === \"next\") {\n        return \"next\";\n    }\n    return undefined;\n}\nfunction groupStackFramesByFramework(stackFrames) {\n    const stackFramesGroupedByFramework = [];\n    for (const stackFrame of stackFrames){\n        const currentGroup = stackFramesGroupedByFramework[stackFramesGroupedByFramework.length - 1];\n        const framework = getFramework(stackFrame.sourcePackage);\n        if (currentGroup && currentGroup.framework === framework) {\n            currentGroup.stackFrames.push(stackFrame);\n        } else {\n            stackFramesGroupedByFramework.push({\n                framework: framework,\n                stackFrames: [\n                    stackFrame\n                ]\n            });\n        }\n    }\n    return stackFramesGroupedByFramework;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=group-stack-frames-by-framework.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvZ3JvdXAtc3RhY2stZnJhbWVzLWJ5LWZyYW1ld29yay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQ0FBbUMsR0FBR0U7QUFDdEM7O0NBRUMsR0FBRyxTQUFTQyxhQUFhQyxhQUFhLEVBQUU7SUFDckMsSUFBSSxDQUFDQSxlQUFlLE9BQU9DO0lBQzNCLElBQUksZ0ZBQWdGQyxJQUFJLENBQUNGLGdCQUFnQjtRQUNyRyxPQUFPO0lBQ1gsT0FBTyxJQUFJQSxrQkFBa0IsUUFBUTtRQUNqQyxPQUFPO0lBQ1gsQ0FBQztJQUNELE9BQU9DO0FBQ1g7QUFDQSxTQUFTSCw0QkFBNEJLLFdBQVcsRUFBRTtJQUM5QyxNQUFNQyxnQ0FBZ0MsRUFBRTtJQUN4QyxLQUFLLE1BQU1DLGNBQWNGLFlBQVk7UUFDakMsTUFBTUcsZUFBZUYsNkJBQTZCLENBQUNBLDhCQUE4QkcsTUFBTSxHQUFHLEVBQUU7UUFDNUYsTUFBTUMsWUFBWVQsYUFBYU0sV0FBV0wsYUFBYTtRQUN2RCxJQUFJTSxnQkFBZ0JBLGFBQWFFLFNBQVMsS0FBS0EsV0FBVztZQUN0REYsYUFBYUgsV0FBVyxDQUFDTSxJQUFJLENBQUNKO1FBQ2xDLE9BQU87WUFDSEQsOEJBQThCSyxJQUFJLENBQUM7Z0JBQy9CRCxXQUFXQTtnQkFDWEwsYUFBYTtvQkFDVEU7aUJBQ0g7WUFDTDtRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU9EO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rQixNQUFNLENBQUNoQixRQUFRYyxPQUFPLEVBQUVkO0lBQy9CaUIsT0FBT2pCLE9BQU8sR0FBR0EsUUFBUWMsT0FBTztBQUNsQyxDQUFDLENBRUQsMkRBQTJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy9ncm91cC1zdGFjay1mcmFtZXMtYnktZnJhbWV3b3JrLmpzP2I4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdyb3VwU3RhY2tGcmFtZXNCeUZyYW1ld29yayA9IGdyb3VwU3RhY2tGcmFtZXNCeUZyYW1ld29yaztcbi8qKlxuICogR2V0IHRoZSBvcmlnaW4gZnJhbWV3b3JrIG9mIHRoZSBzdGFjayBmcmFtZSBieSBwYWNrYWdlIG5hbWUuXG4gKi8gZnVuY3Rpb24gZ2V0RnJhbWV3b3JrKHNvdXJjZVBhY2thZ2UpIHtcbiAgICBpZiAoIXNvdXJjZVBhY2thZ2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKC9eKHJlYWN0fHJlYWN0LWRvbXxyZWFjdC1pc3xyZWFjdC1yZWZyZXNofHJlYWN0LXNlcnZlci1kb20td2VicGFja3xzY2hlZHVsZXIpJC8udGVzdChzb3VyY2VQYWNrYWdlKSkge1xuICAgICAgICByZXR1cm4gJ3JlYWN0JztcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVBhY2thZ2UgPT09ICduZXh0Jykge1xuICAgICAgICByZXR1cm4gJ25leHQnO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ3JvdXBTdGFja0ZyYW1lc0J5RnJhbWV3b3JrKHN0YWNrRnJhbWVzKSB7XG4gICAgY29uc3Qgc3RhY2tGcmFtZXNHcm91cGVkQnlGcmFtZXdvcmsgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN0YWNrRnJhbWUgb2Ygc3RhY2tGcmFtZXMpe1xuICAgICAgICBjb25zdCBjdXJyZW50R3JvdXAgPSBzdGFja0ZyYW1lc0dyb3VwZWRCeUZyYW1ld29ya1tzdGFja0ZyYW1lc0dyb3VwZWRCeUZyYW1ld29yay5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgZnJhbWV3b3JrID0gZ2V0RnJhbWV3b3JrKHN0YWNrRnJhbWUuc291cmNlUGFja2FnZSk7XG4gICAgICAgIGlmIChjdXJyZW50R3JvdXAgJiYgY3VycmVudEdyb3VwLmZyYW1ld29yayA9PT0gZnJhbWV3b3JrKSB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuc3RhY2tGcmFtZXMucHVzaChzdGFja0ZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrRnJhbWVzR3JvdXBlZEJ5RnJhbWV3b3JrLnB1c2goe1xuICAgICAgICAgICAgICAgIGZyYW1ld29yazogZnJhbWV3b3JrLFxuICAgICAgICAgICAgICAgIHN0YWNrRnJhbWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrRnJhbWVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhY2tGcmFtZXNHcm91cGVkQnlGcmFtZXdvcms7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwLXN0YWNrLWZyYW1lcy1ieS1mcmFtZXdvcmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ3JvdXBTdGFja0ZyYW1lc0J5RnJhbWV3b3JrIiwiZ2V0RnJhbWV3b3JrIiwic291cmNlUGFja2FnZSIsInVuZGVmaW5lZCIsInRlc3QiLCJzdGFja0ZyYW1lcyIsInN0YWNrRnJhbWVzR3JvdXBlZEJ5RnJhbWV3b3JrIiwic3RhY2tGcmFtZSIsImN1cnJlbnRHcm91cCIsImxlbmd0aCIsImZyYW1ld29yayIsInB1c2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/group-stack-frames-by-framework.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js ***!
  \*************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.patchConsoleError = patchConsoleError;\nexports.hydrationErrorComponentStack = exports.hydrationErrorWarning = void 0;\nlet hydrationErrorWarning;\nexports.hydrationErrorWarning = hydrationErrorWarning;\nlet hydrationErrorComponentStack;\nexports.hydrationErrorComponentStack = hydrationErrorComponentStack;\nconst knownHydrationWarnings = new Set([\n    'Warning: Text content did not match. Server: \"%s\" Client: \"%s\"%s',\n    \"Warning: Expected server HTML to contain a matching <%s> in <%s>.%s\",\n    'Warning: Expected server HTML to contain a matching text node for \"%s\" in <%s>.%s',\n    \"Warning: Did not expect server HTML to contain a <%s> in <%s>.%s\",\n    'Warning: Did not expect server HTML to contain the text node \"%s\" in <%s>.%s'\n]);\nfunction patchConsoleError() {\n    const prev = console.error;\n    console.error = function(msg, serverContent, clientContent, componentStack) {\n        if (knownHydrationWarnings.has(msg)) {\n            exports.hydrationErrorWarning = hydrationErrorWarning = msg.replace(\"%s\", serverContent).replace(\"%s\", clientContent).replace(\"%s\", \"\");\n            exports.hydrationErrorComponentStack = hydrationErrorComponentStack = componentStack;\n        }\n        // @ts-expect-error argument is defined\n        prev.apply(console, arguments);\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hydration-error-info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvaHlkcmF0aW9uLWVycm9yLWluZm8uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUdFO0FBQzVCRixvQ0FBb0MsR0FBR0EsNkJBQTZCLEdBQUcsS0FBSztBQUM1RSxJQUFJSTtBQUNKSiw2QkFBNkIsR0FBR0k7QUFDaEMsSUFBSUQ7QUFDSkgsb0NBQW9DLEdBQUdHO0FBQ3ZDLE1BQU1FLHlCQUF5QixJQUFJQyxJQUFJO0lBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNKLG9CQUFvQjtJQUN6QixNQUFNSyxPQUFPQyxRQUFRQyxLQUFLO0lBQzFCRCxRQUFRQyxLQUFLLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxhQUFhLEVBQUVDLGFBQWEsRUFBRUMsY0FBYyxFQUFFO1FBQ3hFLElBQUlSLHVCQUF1QlMsR0FBRyxDQUFDSixNQUFNO1lBQ2pDViw2QkFBNkIsR0FBR0ksd0JBQXdCTSxJQUFJSyxPQUFPLENBQUMsTUFBTUosZUFBZUksT0FBTyxDQUFDLE1BQU1ILGVBQWVHLE9BQU8sQ0FBQyxNQUFNO1lBQ3BJZixvQ0FBb0MsR0FBR0csK0JBQStCVTtRQUMxRSxDQUFDO1FBQ0QsdUNBQXVDO1FBQ3ZDTixLQUFLUyxLQUFLLENBQUNSLFNBQVNTO0lBQ3hCO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2pCLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUWtCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvaHlkcmF0aW9uLWVycm9yLWluZm8uanM/MzJhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGF0Y2hDb25zb2xlRXJyb3IgPSBwYXRjaENvbnNvbGVFcnJvcjtcbmV4cG9ydHMuaHlkcmF0aW9uRXJyb3JDb21wb25lbnRTdGFjayA9IGV4cG9ydHMuaHlkcmF0aW9uRXJyb3JXYXJuaW5nID0gdm9pZCAwO1xubGV0IGh5ZHJhdGlvbkVycm9yV2FybmluZztcbmV4cG9ydHMuaHlkcmF0aW9uRXJyb3JXYXJuaW5nID0gaHlkcmF0aW9uRXJyb3JXYXJuaW5nO1xubGV0IGh5ZHJhdGlvbkVycm9yQ29tcG9uZW50U3RhY2s7XG5leHBvcnRzLmh5ZHJhdGlvbkVycm9yQ29tcG9uZW50U3RhY2sgPSBoeWRyYXRpb25FcnJvckNvbXBvbmVudFN0YWNrO1xuY29uc3Qga25vd25IeWRyYXRpb25XYXJuaW5ncyA9IG5ldyBTZXQoW1xuICAgICdXYXJuaW5nOiBUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCIlcycsXG4gICAgJ1dhcm5pbmc6IEV4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJXMnLFxuICAgICdXYXJuaW5nOiBFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgdGV4dCBub2RlIGZvciBcIiVzXCIgaW4gPCVzPi4lcycsXG4gICAgJ1dhcm5pbmc6IERpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJXMnLFxuICAgICdXYXJuaW5nOiBEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJXMnLCBcbl0pO1xuZnVuY3Rpb24gcGF0Y2hDb25zb2xlRXJyb3IoKSB7XG4gICAgY29uc3QgcHJldiA9IGNvbnNvbGUuZXJyb3I7XG4gICAgY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uKG1zZywgc2VydmVyQ29udGVudCwgY2xpZW50Q29udGVudCwgY29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgaWYgKGtub3duSHlkcmF0aW9uV2FybmluZ3MuaGFzKG1zZykpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuaHlkcmF0aW9uRXJyb3JXYXJuaW5nID0gaHlkcmF0aW9uRXJyb3JXYXJuaW5nID0gbXNnLnJlcGxhY2UoJyVzJywgc2VydmVyQ29udGVudCkucmVwbGFjZSgnJXMnLCBjbGllbnRDb250ZW50KS5yZXBsYWNlKCclcycsICcnKTtcbiAgICAgICAgICAgIGV4cG9ydHMuaHlkcmF0aW9uRXJyb3JDb21wb25lbnRTdGFjayA9IGh5ZHJhdGlvbkVycm9yQ29tcG9uZW50U3RhY2sgPSBjb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFyZ3VtZW50IGlzIGRlZmluZWRcbiAgICAgICAgcHJldi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5ZHJhdGlvbi1lcnJvci1pbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhdGNoQ29uc29sZUVycm9yIiwiaHlkcmF0aW9uRXJyb3JDb21wb25lbnRTdGFjayIsImh5ZHJhdGlvbkVycm9yV2FybmluZyIsImtub3duSHlkcmF0aW9uV2FybmluZ3MiLCJTZXQiLCJwcmV2IiwiY29uc29sZSIsImVycm9yIiwibXNnIiwic2VydmVyQ29udGVudCIsImNsaWVudENvbnRlbnQiLCJjb21wb25lbnRTdGFjayIsImhhcyIsInJlcGxhY2UiLCJhcHBseSIsImFyZ3VtZW50cyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getFilesystemFrame = getFilesystemFrame;\nexports.getErrorSource = getErrorSource;\nexports.decorateServerError = decorateServerError;\nexports.getServerError = getServerError;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _stacktraceParser = __webpack_require__(/*! next/dist/compiled/stacktrace-parser */ \"next/dist/compiled/stacktrace-parser\");\nfunction getFilesystemFrame(frame) {\n    const f = _extends({}, frame);\n    if (typeof f.file === \"string\") {\n        if (f.file.startsWith(\"/\") || // Win32:\n        /^[a-z]:\\\\/i.test(f.file) || // Win32 UNC:\n        f.file.startsWith(\"\\\\\\\\\")) {\n            f.file = `file://${f.file}`;\n        }\n    }\n    return f;\n}\nconst symbolError = Symbol(\"NextjsError\");\nfunction getErrorSource(error) {\n    return error[symbolError] || null;\n}\nfunction decorateServerError(error, type) {\n    Object.defineProperty(error, symbolError, {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: type\n    });\n}\nfunction getServerError(error, type) {\n    let n;\n    try {\n        throw new Error(error.message);\n    } catch (e) {\n        n = e;\n    }\n    n.name = error.name;\n    try {\n        n.stack = `${n.toString()}\\n${(0, _stacktraceParser).parse(error.stack).map(getFilesystemFrame).map((f)=>{\n            let str = `    at ${f.methodName}`;\n            if (f.file) {\n                let loc = f.file;\n                if (f.lineNumber) {\n                    loc += `:${f.lineNumber}`;\n                    if (f.column) {\n                        loc += `:${f.column}`;\n                    }\n                }\n                str += ` (${loc})`;\n            }\n            return str;\n        }).join(\"\\n\")}`;\n    } catch (e1) {\n        n.stack = error.stack;\n    }\n    decorateServerError(n, type);\n    return n;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=nodeStackFrames.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QkYsc0JBQXNCLEdBQUdHO0FBQ3pCSCwyQkFBMkIsR0FBR0k7QUFDOUJKLHNCQUFzQixHQUFHSztBQUN6QixJQUFJQyxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUUsb0JBQW9CRixtQkFBT0EsQ0FBQyxrRkFBc0M7QUFDdEUsU0FBU0wsbUJBQW1CUSxLQUFLLEVBQUU7SUFDL0IsTUFBTUMsSUFBSUwsU0FBUyxDQUFDLEdBQUdJO0lBQ3ZCLElBQUksT0FBT0MsRUFBRUMsSUFBSSxLQUFLLFVBQVU7UUFDNUIsSUFDQUQsRUFBRUMsSUFBSSxDQUFDQyxVQUFVLENBQUMsUUFBUSxTQUFTO1FBQ25DLGFBQWFDLElBQUksQ0FBQ0gsRUFBRUMsSUFBSSxLQUFLLGFBQWE7UUFDMUNELEVBQUVDLElBQUksQ0FBQ0MsVUFBVSxDQUFDLFNBQVM7WUFDdkJGLEVBQUVDLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRUQsRUFBRUMsSUFBSSxDQUFDLENBQUM7UUFDL0IsQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBQ0EsTUFBTUksY0FBY0MsT0FBTztBQUMzQixTQUFTYixlQUFlYyxLQUFLLEVBQUU7SUFDM0IsT0FBT0EsS0FBSyxDQUFDRixZQUFZLElBQUksSUFBSTtBQUNyQztBQUNBLFNBQVNYLG9CQUFvQmEsS0FBSyxFQUFFQyxJQUFJLEVBQUU7SUFDdENwQixPQUFPQyxjQUFjLENBQUNrQixPQUFPRixhQUFhO1FBQ3RDSSxVQUFVLEtBQUs7UUFDZkMsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLEtBQUs7UUFDbkJwQixPQUFPaUI7SUFDWDtBQUNKO0FBQ0EsU0FBU2IsZUFBZVksS0FBSyxFQUFFQyxJQUFJLEVBQUU7SUFDakMsSUFBSUk7SUFDSixJQUFJO1FBQ0EsTUFBTSxJQUFJQyxNQUFNTixNQUFNTyxPQUFPLEVBQUU7SUFDbkMsRUFBRSxPQUFPQyxHQUFHO1FBQ1JILElBQUlHO0lBQ1I7SUFDQUgsRUFBRUksSUFBSSxHQUFHVCxNQUFNUyxJQUFJO0lBQ25CLElBQUk7UUFDQUosRUFBRUssS0FBSyxHQUFHLENBQUMsRUFBRUwsRUFBRU0sUUFBUSxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUduQixpQkFBaUIsRUFBRW9CLEtBQUssQ0FBQ1osTUFBTVUsS0FBSyxFQUFFRyxHQUFHLENBQUM1QixvQkFBb0I0QixHQUFHLENBQUMsQ0FBQ25CLElBQUk7WUFDckcsSUFBSW9CLE1BQU0sQ0FBQyxPQUFPLEVBQUVwQixFQUFFcUIsVUFBVSxDQUFDLENBQUM7WUFDbEMsSUFBSXJCLEVBQUVDLElBQUksRUFBRTtnQkFDUixJQUFJcUIsTUFBTXRCLEVBQUVDLElBQUk7Z0JBQ2hCLElBQUlELEVBQUV1QixVQUFVLEVBQUU7b0JBQ2RELE9BQU8sQ0FBQyxDQUFDLEVBQUV0QixFQUFFdUIsVUFBVSxDQUFDLENBQUM7b0JBQ3pCLElBQUl2QixFQUFFd0IsTUFBTSxFQUFFO3dCQUNWRixPQUFPLENBQUMsQ0FBQyxFQUFFdEIsRUFBRXdCLE1BQU0sQ0FBQyxDQUFDO29CQUN6QixDQUFDO2dCQUNMLENBQUM7Z0JBQ0RKLE9BQU8sQ0FBQyxFQUFFLEVBQUVFLElBQUksQ0FBQyxDQUFDO1lBQ3RCLENBQUM7WUFDRCxPQUFPRjtRQUNYLEdBQUdLLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDbkIsRUFBRSxPQUFPQyxJQUFJO1FBQ1RmLEVBQUVLLEtBQUssR0FBR1YsTUFBTVUsS0FBSztJQUN6QjtJQUNBdkIsb0JBQW9Ca0IsR0FBR0o7SUFDdkIsT0FBT0k7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPdEIsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDOEIsVUFBVSxLQUFLLGFBQWE7SUFDckt4QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFRLE9BQU8sRUFBRSxjQUFjO1FBQUVQLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPeUMsTUFBTSxDQUFDdkMsUUFBUVEsT0FBTyxFQUFFUjtJQUMvQndDLE9BQU94QyxPQUFPLEdBQUdBLFFBQVFRLE9BQU87QUFDbEMsQ0FBQyxDQUVELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzLmpzPzljM2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEZpbGVzeXN0ZW1GcmFtZSA9IGdldEZpbGVzeXN0ZW1GcmFtZTtcbmV4cG9ydHMuZ2V0RXJyb3JTb3VyY2UgPSBnZXRFcnJvclNvdXJjZTtcbmV4cG9ydHMuZGVjb3JhdGVTZXJ2ZXJFcnJvciA9IGRlY29yYXRlU2VydmVyRXJyb3I7XG5leHBvcnRzLmdldFNlcnZlckVycm9yID0gZ2V0U2VydmVyRXJyb3I7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9zdGFja3RyYWNlUGFyc2VyID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zdGFja3RyYWNlLXBhcnNlclwiKTtcbmZ1bmN0aW9uIGdldEZpbGVzeXN0ZW1GcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IGYgPSBfZXh0ZW5kcyh7fSwgZnJhbWUpO1xuICAgIGlmICh0eXBlb2YgZi5maWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoLy8gUG9zaXg6XG4gICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCcvJykgfHwgLy8gV2luMzI6XG4gICAgICAgIC9eW2Etel06XFxcXC9pLnRlc3QoZi5maWxlKSB8fCAvLyBXaW4zMiBVTkM6XG4gICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCdcXFxcXFxcXCcpKSB7XG4gICAgICAgICAgICBmLmZpbGUgPSBgZmlsZTovLyR7Zi5maWxlfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGY7XG59XG5jb25zdCBzeW1ib2xFcnJvciA9IFN5bWJvbCgnTmV4dGpzRXJyb3InKTtcbmZ1bmN0aW9uIGdldEVycm9yU291cmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yW3N5bWJvbEVycm9yXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVTZXJ2ZXJFcnJvcihlcnJvciwgdHlwZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgc3ltYm9sRXJyb3IsIHtcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHR5cGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlckVycm9yKGVycm9yLCB0eXBlKSB7XG4gICAgbGV0IG47XG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbiA9IGU7XG4gICAgfVxuICAgIG4ubmFtZSA9IGVycm9yLm5hbWU7XG4gICAgdHJ5IHtcbiAgICAgICAgbi5zdGFjayA9IGAke24udG9TdHJpbmcoKX1cXG4keygwLCBfc3RhY2t0cmFjZVBhcnNlcikucGFyc2UoZXJyb3Iuc3RhY2spLm1hcChnZXRGaWxlc3lzdGVtRnJhbWUpLm1hcCgoZik9PntcbiAgICAgICAgICAgIGxldCBzdHIgPSBgICAgIGF0ICR7Zi5tZXRob2ROYW1lfWA7XG4gICAgICAgICAgICBpZiAoZi5maWxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvYyA9IGYuZmlsZTtcbiAgICAgICAgICAgICAgICBpZiAoZi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYyArPSBgOiR7Zi5saW5lTnVtYmVyfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jICs9IGA6JHtmLmNvbHVtbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBgICgke2xvY30pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpfWA7XG4gICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgICAgbi5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH1cbiAgICBkZWNvcmF0ZVNlcnZlckVycm9yKG4sIHR5cGUpO1xuICAgIHJldHVybiBuO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlU3RhY2tGcmFtZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RmlsZXN5c3RlbUZyYW1lIiwiZ2V0RXJyb3JTb3VyY2UiLCJkZWNvcmF0ZVNlcnZlckVycm9yIiwiZ2V0U2VydmVyRXJyb3IiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3N0YWNrdHJhY2VQYXJzZXIiLCJmcmFtZSIsImYiLCJmaWxlIiwic3RhcnRzV2l0aCIsInRlc3QiLCJzeW1ib2xFcnJvciIsIlN5bWJvbCIsImVycm9yIiwidHlwZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm4iLCJFcnJvciIsIm1lc3NhZ2UiLCJlIiwibmFtZSIsInN0YWNrIiwidG9TdHJpbmciLCJwYXJzZSIsIm1hcCIsInN0ciIsIm1ldGhvZE5hbWUiLCJsb2MiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiam9pbiIsImUxIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js ***!
  \******************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.noop = noop;\nfunction noop(strings, ...keys) {\n    const lastIndex = strings.length - 1;\n    return strings.slice(0, lastIndex).reduce((p, s, i)=>p + s + keys[i], \"\") + strings[lastIndex];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=noop-template.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUdFO0FBQ2YsU0FBU0EsS0FBS0MsT0FBTyxFQUFFLEdBQUdDLElBQUksRUFBRTtJQUM1QixNQUFNQyxZQUFZRixRQUFRRyxNQUFNLEdBQUc7SUFDbkMsT0FBT0gsUUFBUUksS0FBSyxDQUFDLEdBQUdGLFdBQVdHLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxHQUFHQyxJQUFJRixJQUFJQyxJQUFJTixJQUFJLENBQUNPLEVBQUUsRUFBRSxNQUFNUixPQUFPLENBQUNFLFVBQVU7QUFDbEc7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUVksT0FBTyxLQUFLLGNBQWUsT0FBT1osUUFBUVksT0FBTyxLQUFLLFlBQVlaLFFBQVFZLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1osUUFBUVksT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRWSxPQUFPLEVBQUUsY0FBYztRQUFFWCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2dCLE1BQU0sQ0FBQ2QsUUFBUVksT0FBTyxFQUFFWjtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9oZWxwZXJzL25vb3AtdGVtcGxhdGUuanM/ZTY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5mdW5jdGlvbiBub29wKHN0cmluZ3MsIC4uLmtleXMpIHtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHN0cmluZ3Muc2xpY2UoMCwgbGFzdEluZGV4KS5yZWR1Y2UoKHAsIHMsIGkpPT5wICsgcyArIGtleXNbaV0sICcnKSArIHN0cmluZ3NbbGFzdEluZGV4XTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC10ZW1wbGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub29wIiwic3RyaW5ncyIsImtleXMiLCJsYXN0SW5kZXgiLCJsZW5ndGgiLCJzbGljZSIsInJlZHVjZSIsInAiLCJzIiwiaSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js ***!
  \**************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseComponentStack = parseComponentStack;\nfunction parseComponentStack(componentStack) {\n    const componentStackFrames = [];\n    for (const line of componentStack.trim().split(\"\\n\")){\n        // Get component and file from the component stack line\n        const match = /at ([^ ]+)( \\((.*)\\))?/.exec(line);\n        if (match == null ? void 0 : match[1]) {\n            const component = match[1];\n            const webpackFile = match[3];\n            // Stop parsing the component stack if we reach a Next.js component\n            if (webpackFile == null ? void 0 : webpackFile.includes(\"next/dist/client/components/\")) {\n                break;\n            }\n            const modulePath = webpackFile == null ? void 0 : webpackFile.replace(/^(webpack-internal:\\/\\/\\/|file:\\/\\/)(\\(.*\\)\\/)?/, \"\");\n            var ref;\n            const [file, lineNumber, column] = (ref = modulePath == null ? void 0 : modulePath.split(\":\")) != null ? ref : [];\n            componentStackFrames.push({\n                component,\n                file,\n                lineNumber: lineNumber ? Number(lineNumber) : undefined,\n                column: column ? Number(column) : undefined\n            });\n        }\n    }\n    return componentStackFrames;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=parse-component-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvcGFyc2UtY29tcG9uZW50LXN0YWNrLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHRTtBQUM5QixTQUFTQSxvQkFBb0JDLGNBQWMsRUFBRTtJQUN6QyxNQUFNQyx1QkFBdUIsRUFBRTtJQUMvQixLQUFLLE1BQU1DLFFBQVFGLGVBQWVHLElBQUksR0FBR0MsS0FBSyxDQUFDLE1BQU07UUFDakQsdURBQXVEO1FBQ3ZELE1BQU1DLFFBQVEseUJBQXlCQyxJQUFJLENBQUNKO1FBQzVDLElBQUlHLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSUEsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUNuQyxNQUFNRSxZQUFZRixLQUFLLENBQUMsRUFBRTtZQUMxQixNQUFNRyxjQUFjSCxLQUFLLENBQUMsRUFBRTtZQUM1QixtRUFBbUU7WUFDbkUsSUFBSUcsZUFBZSxJQUFJLEdBQUcsS0FBSyxJQUFJQSxZQUFZQyxRQUFRLENBQUMsK0JBQStCLEVBQUU7Z0JBQ3JGLEtBQU07WUFDVixDQUFDO1lBQ0QsTUFBTUMsYUFBYUYsZUFBZSxJQUFJLEdBQUcsS0FBSyxJQUFJQSxZQUFZRyxPQUFPLENBQUMsbURBQW1ELEdBQUc7WUFDNUgsSUFBSUM7WUFDSixNQUFNLENBQUNDLE1BQU1DLFlBQVlDLE9BQU8sR0FBRyxDQUFDSCxNQUFNRixjQUFjLElBQUksR0FBRyxLQUFLLElBQUlBLFdBQVdOLEtBQUssQ0FBQyxJQUFJLEtBQUssSUFBSSxHQUFHUSxNQUFNLEVBQUU7WUFDakhYLHFCQUFxQmUsSUFBSSxDQUFDO2dCQUN0QlQ7Z0JBQ0FNO2dCQUNBQyxZQUFZQSxhQUFhRyxPQUFPSCxjQUFjSSxTQUFTO2dCQUN2REgsUUFBUUEsU0FBU0UsT0FBT0YsVUFBVUcsU0FBUztZQUMvQztRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU9qQjtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9KLFFBQVFzQixPQUFPLEtBQUssY0FBZSxPQUFPdEIsUUFBUXNCLE9BQU8sS0FBSyxZQUFZdEIsUUFBUXNCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3RCLFFBQVFzQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0IsT0FBTyxFQUFFLGNBQWM7UUFBRXJCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPMEIsTUFBTSxDQUFDeEIsUUFBUXNCLE9BQU8sRUFBRXRCO0lBQy9CeUIsT0FBT3pCLE9BQU8sR0FBR0EsUUFBUXNCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvcGFyc2UtY29tcG9uZW50LXN0YWNrLmpzPzBjZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlQ29tcG9uZW50U3RhY2sgPSBwYXJzZUNvbXBvbmVudFN0YWNrO1xuZnVuY3Rpb24gcGFyc2VDb21wb25lbnRTdGFjayhjb21wb25lbnRTdGFjaykge1xuICAgIGNvbnN0IGNvbXBvbmVudFN0YWNrRnJhbWVzID0gW107XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbXBvbmVudFN0YWNrLnRyaW0oKS5zcGxpdCgnXFxuJykpe1xuICAgICAgICAvLyBHZXQgY29tcG9uZW50IGFuZCBmaWxlIGZyb20gdGhlIGNvbXBvbmVudCBzdGFjayBsaW5lXG4gICAgICAgIGNvbnN0IG1hdGNoID0gL2F0IChbXiBdKykoIFxcKCguKilcXCkpPy8uZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFsxXSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCB3ZWJwYWNrRmlsZSA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgLy8gU3RvcCBwYXJzaW5nIHRoZSBjb21wb25lbnQgc3RhY2sgaWYgd2UgcmVhY2ggYSBOZXh0LmpzIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKHdlYnBhY2tGaWxlID09IG51bGwgPyB2b2lkIDAgOiB3ZWJwYWNrRmlsZS5pbmNsdWRlcygnbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzLycpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVQYXRoID0gd2VicGFja0ZpbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHdlYnBhY2tGaWxlLnJlcGxhY2UoL14od2VicGFjay1pbnRlcm5hbDpcXC9cXC9cXC98ZmlsZTpcXC9cXC8pKFxcKC4qXFwpXFwvKT8vLCAnJyk7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgY29uc3QgW2ZpbGUsIGxpbmVOdW1iZXIsIGNvbHVtbl0gPSAocmVmID0gbW9kdWxlUGF0aCA9PSBudWxsID8gdm9pZCAwIDogbW9kdWxlUGF0aC5zcGxpdCgnOicpKSAhPSBudWxsID8gcmVmIDogW107XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0ZyYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyID8gTnVtYmVyKGxpbmVOdW1iZXIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uID8gTnVtYmVyKGNvbHVtbikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRTdGFja0ZyYW1lcztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtY29tcG9uZW50LXN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlQ29tcG9uZW50U3RhY2siLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudFN0YWNrRnJhbWVzIiwibGluZSIsInRyaW0iLCJzcGxpdCIsIm1hdGNoIiwiZXhlYyIsImNvbXBvbmVudCIsIndlYnBhY2tGaWxlIiwiaW5jbHVkZXMiLCJtb2R1bGVQYXRoIiwicmVwbGFjZSIsInJlZiIsImZpbGUiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwicHVzaCIsIk51bWJlciIsInVuZGVmaW5lZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseStack = parseStack;\nvar _stacktraceParser = __webpack_require__(/*! next/dist/compiled/stacktrace-parser */ \"next/dist/compiled/stacktrace-parser\");\nconst regexNextStatic = /\\/_next(\\/static\\/.+)/g;\nfunction parseStack(stack) {\n    const frames = (0, _stacktraceParser).parse(stack);\n    return frames.map((frame)=>{\n        try {\n            const url = new URL(frame.file);\n            const res = regexNextStatic.exec(url.pathname);\n            if (res) {\n                var ref, ref1;\n                const distDir = (ref1 = (ref = process.env.__NEXT_DIST_DIR) == null ? void 0 : ref.replace(/\\\\/g, \"/\")) == null ? void 0 : ref1.replace(/\\/$/, \"\");\n                if (distDir) {\n                    frame.file = \"file://\" + distDir.concat(res.pop());\n                }\n            }\n        } catch (e) {}\n        return frame;\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=parseStack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBR0U7QUFDckIsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQyxrRkFBc0M7QUFDdEUsTUFBTUMsa0JBQWtCO0FBQ3hCLFNBQVNILFdBQVdJLEtBQUssRUFBRTtJQUN2QixNQUFNQyxTQUFTLENBQUMsR0FBR0osaUJBQWlCLEVBQUVLLEtBQUssQ0FBQ0Y7SUFDNUMsT0FBT0MsT0FBT0UsR0FBRyxDQUFDLENBQUNDLFFBQVE7UUFDdkIsSUFBSTtZQUNBLE1BQU1DLE1BQU0sSUFBSUMsSUFBSUYsTUFBTUcsSUFBSTtZQUM5QixNQUFNQyxNQUFNVCxnQkFBZ0JVLElBQUksQ0FBQ0osSUFBSUssUUFBUTtZQUM3QyxJQUFJRixLQUFLO2dCQUNMLElBQUlHLEtBQUtDO2dCQUNULE1BQU1DLFVBQVUsQ0FBQ0QsT0FBTyxDQUFDRCxNQUFNRyxRQUFRQyxHQUFHLENBQUNDLGVBQWUsS0FBSyxJQUFJLEdBQUcsS0FBSyxJQUFJTCxJQUFJTSxPQUFPLENBQUMsT0FBTyxJQUFJLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSUwsS0FBS0ssT0FBTyxDQUFDLE9BQU8sR0FBRztnQkFDbEosSUFBSUosU0FBUztvQkFDVFQsTUFBTUcsSUFBSSxHQUFHLFlBQVlNLFFBQVFLLE1BQU0sQ0FBQ1YsSUFBSVcsR0FBRztnQkFDbkQsQ0FBQztZQUNMLENBQUM7UUFDTCxFQUFFLE9BQU9DLEdBQUcsQ0FBQztRQUNiLE9BQU9oQjtJQUNYO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1YsUUFBUTJCLE9BQU8sS0FBSyxjQUFlLE9BQU8zQixRQUFRMkIsT0FBTyxLQUFLLFlBQVkzQixRQUFRMkIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0IsUUFBUTJCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks5QixPQUFPQyxjQUFjLENBQUNDLFFBQVEyQixPQUFPLEVBQUUsY0FBYztRQUFFMUIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxDQUFDLENBRUQsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrLmpzPzM1NDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlU3RhY2sgPSBwYXJzZVN0YWNrO1xudmFyIF9zdGFja3RyYWNlUGFyc2VyID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zdGFja3RyYWNlLXBhcnNlclwiKTtcbmNvbnN0IHJlZ2V4TmV4dFN0YXRpYyA9IC9cXC9fbmV4dChcXC9zdGF0aWNcXC8uKykvZztcbmZ1bmN0aW9uIHBhcnNlU3RhY2soc3RhY2spIHtcbiAgICBjb25zdCBmcmFtZXMgPSAoMCwgX3N0YWNrdHJhY2VQYXJzZXIpLnBhcnNlKHN0YWNrKTtcbiAgICByZXR1cm4gZnJhbWVzLm1hcCgoZnJhbWUpPT57XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gcmVnZXhOZXh0U3RhdGljLmV4ZWModXJsLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3REaXIgPSAocmVmMSA9IChyZWYgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTVF9ESVIpID09IG51bGwgPyB2b2lkIDAgOiByZWYucmVwbGFjZSgvXFxcXC9nLCAnLycpKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0RGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmZpbGUgPSAnZmlsZTovLycgKyBkaXN0RGlyLmNvbmNhdChyZXMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlU3RhY2siLCJfc3RhY2t0cmFjZVBhcnNlciIsInJlcXVpcmUiLCJyZWdleE5leHRTdGF0aWMiLCJzdGFjayIsImZyYW1lcyIsInBhcnNlIiwibWFwIiwiZnJhbWUiLCJ1cmwiLCJVUkwiLCJmaWxlIiwicmVzIiwiZXhlYyIsInBhdGhuYW1lIiwicmVmIiwicmVmMSIsImRpc3REaXIiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0RJU1RfRElSIiwicmVwbGFjZSIsImNvbmNhdCIsInBvcCIsImUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js ***!
  \****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getOriginalStackFrame = getOriginalStackFrame;\nexports.getOriginalStackFrames = getOriginalStackFrames;\nexports.getFrameSource = getFrameSource;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nfunction getOriginalStackFrame(source, type, errorMessage) {\n    var ref7, ref1;\n    function _getOriginalStackFrame() {\n        return __getOriginalStackFrame.apply(this, arguments);\n    }\n    function __getOriginalStackFrame() {\n        __getOriginalStackFrame = _async_to_generator(function*() {\n            var ref, ref4, ref5;\n            const params = new URLSearchParams();\n            params.append(\"isServer\", String(type === \"server\"));\n            params.append(\"isEdgeServer\", String(type === \"edge-server\"));\n            params.append(\"isAppDirectory\", \"true\");\n            params.append(\"errorMessage\", errorMessage);\n            for(const key in source){\n                var _key;\n                params.append(key, ((_key = source[key]) != null ? _key : \"\").toString());\n            }\n            const controller = new AbortController();\n            const tm = setTimeout(()=>controller.abort(), 3000);\n            const res = yield self.fetch(`${ false || \"\"}/__nextjs_original-stack-frame?${params.toString()}`, {\n                signal: controller.signal\n            }).finally(()=>{\n                clearTimeout(tm);\n            });\n            if (!res.ok || res.status === 204) {\n                return Promise.reject(new Error((yield res.text())));\n            }\n            const body = yield res.json();\n            var /* collapsed */ ref6;\n            return {\n                error: false,\n                reason: null,\n                external: false,\n                expanded: !Boolean((ref6 = ((ref = source.file) == null ? void 0 : ref.includes(\"node_modules\")) || ((ref4 = body.originalStackFrame) == null ? void 0 : (ref5 = ref4.file) == null ? void 0 : ref5.includes(\"node_modules\"))) != null ? ref6 : true),\n                sourceStackFrame: source,\n                originalStackFrame: body.originalStackFrame,\n                originalCodeFrame: body.originalCodeFrame || null,\n                sourcePackage: body.sourcePackage\n            };\n        });\n        return __getOriginalStackFrame.apply(this, arguments);\n    }\n    if (!(((ref7 = source.file) == null ? void 0 : ref7.startsWith(\"webpack-internal:\")) || ((ref1 = source.file) == null ? void 0 : ref1.startsWith(\"file:\")))) {\n        return Promise.resolve({\n            error: false,\n            reason: null,\n            external: true,\n            expanded: false,\n            sourceStackFrame: source,\n            originalStackFrame: null,\n            originalCodeFrame: null\n        });\n    }\n    var ref2, ref3;\n    return _getOriginalStackFrame().catch((err)=>{\n        return {\n            error: true,\n            reason: (ref3 = (ref2 = err == null ? void 0 : err.message) != null ? ref2 : err == null ? void 0 : err.toString()) != null ? ref3 : \"Unknown Error\",\n            external: false,\n            expanded: false,\n            sourceStackFrame: source,\n            originalStackFrame: null,\n            originalCodeFrame: null\n        };\n    });\n}\nfunction getOriginalStackFrames(frames, type, errorMessage) {\n    return Promise.all(frames.map((frame)=>getOriginalStackFrame(frame, type, errorMessage)));\n}\nfunction getFrameSource(frame) {\n    let str = \"\";\n    try {\n        var ref;\n        const u = new URL(frame.file);\n        // Strip the origin for same-origin scripts.\n        if (typeof globalThis !== \"undefined\" && ((ref = globalThis.location) == null ? void 0 : ref.origin) !== u.origin) {\n            // URLs can be valid without an `origin`, so long as they have a\n            // `protocol`. However, `origin` is preferred.\n            if (u.origin === \"null\") {\n                str += u.protocol;\n            } else {\n                str += u.origin;\n            }\n        }\n        // Strip query string information as it's typically too verbose to be\n        // meaningful.\n        str += u.pathname;\n        str += \" \";\n    } catch (e) {\n        str += (frame.file || \"(unknown)\") + \" \";\n    }\n    if (frame.lineNumber != null) {\n        if (frame.column != null) {\n            str += `(${frame.lineNumber}:${frame.column}) `;\n        } else {\n            str += `(${frame.lineNumber}) `;\n        }\n    }\n    return str.slice(0, -1);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=stack-frame.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvc3RhY2stZnJhbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsNkJBQTZCLEdBQUdFO0FBQ2hDRiw4QkFBOEIsR0FBR0c7QUFDakNILHNCQUFzQixHQUFHSTtBQUN6QixJQUFJQyxzQkFBc0JDLHFKQUEwRDtBQUNwRixTQUFTSixzQkFBc0JNLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxZQUFZLEVBQUU7SUFDdkQsSUFBSUMsTUFBTUM7SUFDVixTQUFTQyx5QkFBeUI7UUFDOUIsT0FBT0Msd0JBQXdCQyxLQUFLLENBQUMsSUFBSSxFQUFFQztJQUMvQztJQUNBLFNBQVNGLDBCQUEwQjtRQUMvQkEsMEJBQTBCVCxvQkFBb0IsWUFBWTtZQUN0RCxJQUFJWSxLQUFLQyxNQUFNQztZQUNmLE1BQU1DLFNBQVMsSUFBSUM7WUFDbkJELE9BQU9FLE1BQU0sQ0FBQyxZQUFZQyxPQUFPZCxTQUFTO1lBQzFDVyxPQUFPRSxNQUFNLENBQUMsZ0JBQWdCQyxPQUFPZCxTQUFTO1lBQzlDVyxPQUFPRSxNQUFNLENBQUMsa0JBQWtCO1lBQ2hDRixPQUFPRSxNQUFNLENBQUMsZ0JBQWdCWjtZQUM5QixJQUFJLE1BQU1jLE9BQU9oQixPQUFPO2dCQUNwQixJQUFJaUI7Z0JBQ0pMLE9BQU9FLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDLENBQUNDLE9BQU9qQixNQUFNLENBQUNnQixJQUFJLEtBQUssSUFBSSxHQUFHQyxPQUFPLEVBQUUsRUFBRUMsUUFBUTtZQUMxRTtZQUNBLE1BQU1DLGFBQWEsSUFBSUM7WUFDdkIsTUFBTUMsS0FBS0MsV0FBVyxJQUFJSCxXQUFXSSxLQUFLLElBQUk7WUFDOUMsTUFBTUMsTUFBTSxNQUFNQyxLQUFLQyxLQUFLLENB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TyxFQUFFUDtJQUMvQnNGLE9BQU90RixPQUFPLEdBQUdBLFFBQVFPLE9BQU87QUFDbEMsQ0FBQyxDQUVELHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvc3RhY2stZnJhbWUuanM/MzlhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lO1xuZXhwb3J0cy5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcztcbmV4cG9ydHMuZ2V0RnJhbWVTb3VyY2UgPSBnZXRGcmFtZVNvdXJjZTtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKHNvdXJjZSwgdHlwZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgdmFyIHJlZjcsIHJlZjE7XG4gICAgZnVuY3Rpb24gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2V0T3JpZ2luYWxTdGFja0ZyYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKCkge1xuICAgICAgICBfX2dldE9yaWdpbmFsU3RhY2tGcmFtZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgdmFyIHJlZiwgcmVmNCwgcmVmNTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2lzU2VydmVyJywgU3RyaW5nKHR5cGUgPT09ICdzZXJ2ZXInKSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKCdpc0VkZ2VTZXJ2ZXInLCBTdHJpbmcodHlwZSA9PT0gJ2VkZ2Utc2VydmVyJykpO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZCgnaXNBcHBEaXJlY3RvcnknLCAndHJ1ZScpO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZCgnZXJyb3JNZXNzYWdlJywgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIGZvcihjb25zdCBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICB2YXIgX2tleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfa2V5ID0gc291cmNlW2tleV0pICE9IG51bGwgPyBfa2V5IDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHRtID0gc2V0VGltZW91dCgoKT0+Y29udHJvbGxlci5hYm9ydCgpLCAzMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHNlbGYuZmV0Y2goYCR7cHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJ30vX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0bSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzLm9rIHx8IHJlcy5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoKHlpZWxkIHJlcy50ZXh0KCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5ID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIHZhciAvKiBjb2xsYXBzZWQgKi8gcmVmNjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICFCb29sZWFuKChyZWY2ID0gKCgocmVmID0gc291cmNlLmZpbGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpKSB8fCAoKHJlZjQgPSBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY1ID0gcmVmNC5maWxlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmNS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpKSkgIT0gbnVsbCA/IHJlZjYgOiB0cnVlKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VTdGFja0ZyYW1lOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFja0ZyYW1lOiBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogYm9keS5vcmlnaW5hbENvZGVGcmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHNvdXJjZVBhY2thZ2U6IGJvZHkuc291cmNlUGFja2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2dldE9yaWdpbmFsU3RhY2tGcmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoISgoKHJlZjcgPSBzb3VyY2UuZmlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZjcuc3RhcnRzV2l0aCgnd2VicGFjay1pbnRlcm5hbDonKSkgfHwgKChyZWYxID0gc291cmNlLmZpbGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYxLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWxTdGFja0ZyYW1lOiBudWxsLFxuICAgICAgICAgICAgb3JpZ2luYWxDb2RlRnJhbWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZWYyLCByZWYzO1xuICAgIHJldHVybiBfZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKCkuY2F0Y2goKGVycik9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiB0cnVlLFxuICAgICAgICAgICAgcmVhc29uOiAocmVmMyA9IChyZWYyID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIubWVzc2FnZSkgIT0gbnVsbCA/IHJlZjIgOiBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci50b1N0cmluZygpKSAhPSBudWxsID8gcmVmMyA6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhY2tGcmFtZTogbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5hbFN0YWNrRnJhbWVzKGZyYW1lcywgdHlwZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZyYW1lcy5tYXAoKGZyYW1lKT0+Z2V0T3JpZ2luYWxTdGFja0ZyYW1lKGZyYW1lLCB0eXBlLCBlcnJvck1lc3NhZ2UpKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZVNvdXJjZShmcmFtZSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBjb25zdCB1ID0gbmV3IFVSTChmcmFtZS5maWxlKTtcbiAgICAgICAgLy8gU3RyaXAgdGhlIG9yaWdpbiBmb3Igc2FtZS1vcmlnaW4gc2NyaXB0cy5cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiAoKHJlZiA9IGdsb2JhbFRoaXMubG9jYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiByZWYub3JpZ2luKSAhPT0gdS5vcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFVSTHMgY2FuIGJlIHZhbGlkIHdpdGhvdXQgYW4gYG9yaWdpbmAsIHNvIGxvbmcgYXMgdGhleSBoYXZlIGFcbiAgICAgICAgICAgIC8vIGBwcm90b2NvbGAuIEhvd2V2ZXIsIGBvcmlnaW5gIGlzIHByZWZlcnJlZC5cbiAgICAgICAgICAgIGlmICh1Lm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHUucHJvdG9jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSB1Lm9yaWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpcCBxdWVyeSBzdHJpbmcgaW5mb3JtYXRpb24gYXMgaXQncyB0eXBpY2FsbHkgdG9vIHZlcmJvc2UgdG8gYmVcbiAgICAgICAgLy8gbWVhbmluZ2Z1bC5cbiAgICAgICAgc3RyICs9IHUucGF0aG5hbWU7XG4gICAgICAgIHN0ciArPSAnICc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdHIgKz0gKGZyYW1lLmZpbGUgfHwgJyh1bmtub3duKScpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoZnJhbWUubGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAoJHtmcmFtZS5saW5lTnVtYmVyfToke2ZyYW1lLmNvbHVtbn0pIGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gYCgke2ZyYW1lLmxpbmVOdW1iZXJ9KSBgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgLTEpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay1mcmFtZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRPcmlnaW5hbFN0YWNrRnJhbWUiLCJnZXRPcmlnaW5hbFN0YWNrRnJhbWVzIiwiZ2V0RnJhbWVTb3VyY2UiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsImRlZmF1bHQiLCJzb3VyY2UiLCJ0eXBlIiwiZXJyb3JNZXNzYWdlIiwicmVmNyIsInJlZjEiLCJfZ2V0T3JpZ2luYWxTdGFja0ZyYW1lIiwiX19nZXRPcmlnaW5hbFN0YWNrRnJhbWUiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlZiIsInJlZjQiLCJyZWY1IiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwiU3RyaW5nIiwia2V5IiwiX2tleSIsInRvU3RyaW5nIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRtIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzIiwic2VsZiIsImZldGNoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJzaWduYWwiLCJmaW5hbGx5IiwiY2xlYXJUaW1lb3V0Iiwib2siLCJzdGF0dXMiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJ0ZXh0IiwiYm9keSIsImpzb24iLCJyZWY2IiwiZXJyb3IiLCJyZWFzb24iLCJleHRlcm5hbCIsImV4cGFuZGVkIiwiQm9vbGVhbiIsImZpbGUiLCJpbmNsdWRlcyIsIm9yaWdpbmFsU3RhY2tGcmFtZSIsInNvdXJjZVN0YWNrRnJhbWUiLCJvcmlnaW5hbENvZGVGcmFtZSIsInNvdXJjZVBhY2thZ2UiLCJzdGFydHNXaXRoIiwicmVzb2x2ZSIsInJlZjIiLCJyZWYzIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwiZnJhbWVzIiwiYWxsIiwibWFwIiwiZnJhbWUiLCJzdHIiLCJ1IiwiVVJMIiwiZ2xvYmFsVGhpcyIsImxvY2F0aW9uIiwib3JpZ2luIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImUiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwic2xpY2UiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stack-frame.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js ***!
  \**********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useErrorHandler = useErrorHandler;\nexports.RuntimeErrorHandler = void 0;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _notFound = __webpack_require__(/*! ../../../not-found */ \"(sc_client)/./node_modules/next/dist/client/components/not-found.js\");\nvar _redirect = __webpack_require__(/*! ../../../redirect */ \"(sc_client)/./node_modules/next/dist/client/components/redirect.js\");\nvar _hydrationErrorInfo = __webpack_require__(/*! ./hydration-error-info */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js\");\nconst RuntimeErrorHandler = {\n    hadRuntimeError: false\n};\nexports.RuntimeErrorHandler = RuntimeErrorHandler;\nfunction isNextRouterError(error) {\n    return error && error.digest && ((0, _redirect).isRedirectError(error) || (0, _notFound).isNotFoundError(error));\n}\nfunction isHydrationError(error) {\n    return error.message.match(/(hydration|content does not match|did not match)/i) != null;\n}\nif (false) {}\nconst errorQueue = [];\nconst rejectionQueue = [];\nconst errorHandlers = [];\nconst rejectionHandlers = [];\nif (false) {}\nfunction useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {\n    (0, _react).useEffect(()=>{\n        // Handle queued errors.\n        errorQueue.forEach(handleOnUnhandledError);\n        rejectionQueue.forEach(handleOnUnhandledRejection);\n        // Listen to new errors.\n        errorHandlers.push(handleOnUnhandledError);\n        rejectionHandlers.push(handleOnUnhandledRejection);\n        return ()=>{\n            // Remove listeners.\n            errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);\n            rejectionHandlers.splice(rejectionHandlers.indexOf(handleOnUnhandledRejection), 1);\n        };\n    }, [\n        handleOnUnhandledError,\n        handleOnUnhandledRejection\n    ]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-error-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvdXNlLWVycm9yLWhhbmRsZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCRiwyQkFBMkIsR0FBRyxLQUFLO0FBQ25DLElBQUlJLFNBQVNDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzVCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLCtGQUFvQjtBQUM1QyxJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQyw2RkFBbUI7QUFDM0MsSUFBSUcsc0JBQXNCSCxtQkFBT0EsQ0FBQyxpSkFBd0I7QUFDMUQsTUFBTUYsc0JBQXNCO0lBQ3hCTSxpQkFBaUIsS0FBSztBQUMxQjtBQUNBVCwyQkFBMkIsR0FBR0c7QUFDOUIsU0FBU08sa0JBQWtCQyxLQUFLLEVBQUU7SUFDOUIsT0FBT0EsU0FBU0EsTUFBTUMsTUFBTSxJQUFLLEVBQUMsR0FBR0wsU0FBUyxFQUFFTSxlQUFlLENBQUNGLFVBQVUsQ0FBQyxHQUFHTCxTQUFTLEVBQUVRLGVBQWUsQ0FBQ0gsTUFBSztBQUNsSDtBQUNBLFNBQVNJLGlCQUFpQkosS0FBSyxFQUFFO0lBQzdCLE9BQU9BLE1BQU1LLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLHdEQUF3RCxJQUFJO0FBQzNGO0FBQ0EsSUFBSSxLQUFrQixFQUFhLEVBS2xDO0FBQ0QsTUFBTUksYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLE1BQU1DLGdCQUFnQixFQUFFO0FBQ3hCLE1BQU1DLG9CQUFvQixFQUFFO0FBQzVCLElBQUksS0FBa0IsRUFBYSxFQXlDbEM7QUFDRCxTQUFTdEIsZ0JBQWdCbUMsc0JBQXNCLEVBQUVDLDBCQUEwQixFQUFFO0lBQ3hFLElBQUdsQyxNQUFNLEVBQUVtQyxTQUFTLENBQUMsSUFBSTtRQUN0Qix3QkFBd0I7UUFDeEJsQixXQUFXbUIsT0FBTyxDQUFDSDtRQUNuQmYsZUFBZWtCLE9BQU8sQ0FBQ0Y7UUFDdkIsd0JBQXdCO1FBQ3hCZixjQUFjVyxJQUFJLENBQUNHO1FBQ25CYixrQkFBa0JVLElBQUksQ0FBQ0k7UUFDdkIsT0FBTyxJQUFJO1lBQ1Asb0JBQW9CO1lBQ3BCZixjQUFja0IsTUFBTSxDQUFDbEIsY0FBY21CLE9BQU8sQ0FBQ0wseUJBQXlCO1lBQ3BFYixrQkFBa0JpQixNQUFNLENBQUNqQixrQkFBa0JrQixPQUFPLENBQUNKLDZCQUE2QjtRQUNwRjtJQUNKLEdBQUc7UUFDQ0Q7UUFDQUM7S0FDSDtBQUNMO0FBRUEsSUFBSSxDQUFDLE9BQU90QyxRQUFRMkMsT0FBTyxLQUFLLGNBQWUsT0FBTzNDLFFBQVEyQyxPQUFPLEtBQUssWUFBWTNDLFFBQVEyQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQyxRQUFRMkMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJDLE9BQU8sRUFBRSxjQUFjO1FBQUUxQyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytDLE1BQU0sQ0FBQzdDLFFBQVEyQyxPQUFPLEVBQUUzQztJQUMvQjhDLE9BQU85QyxPQUFPLEdBQUdBLFFBQVEyQyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9oZWxwZXJzL3VzZS1lcnJvci1oYW5kbGVyLmpzP2E2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZUVycm9ySGFuZGxlciA9IHVzZUVycm9ySGFuZGxlcjtcbmV4cG9ydHMuUnVudGltZUVycm9ySGFuZGxlciA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX25vdEZvdW5kID0gcmVxdWlyZShcIi4uLy4uLy4uL25vdC1mb3VuZFwiKTtcbnZhciBfcmVkaXJlY3QgPSByZXF1aXJlKFwiLi4vLi4vLi4vcmVkaXJlY3RcIik7XG52YXIgX2h5ZHJhdGlvbkVycm9ySW5mbyA9IHJlcXVpcmUoXCIuL2h5ZHJhdGlvbi1lcnJvci1pbmZvXCIpO1xuY29uc3QgUnVudGltZUVycm9ySGFuZGxlciA9IHtcbiAgICBoYWRSdW50aW1lRXJyb3I6IGZhbHNlXG59O1xuZXhwb3J0cy5SdW50aW1lRXJyb3JIYW5kbGVyID0gUnVudGltZUVycm9ySGFuZGxlcjtcbmZ1bmN0aW9uIGlzTmV4dFJvdXRlckVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIGVycm9yLmRpZ2VzdCAmJiAoKDAsIF9yZWRpcmVjdCkuaXNSZWRpcmVjdEVycm9yKGVycm9yKSB8fCAoMCwgX25vdEZvdW5kKS5pc05vdEZvdW5kRXJyb3IoZXJyb3IpKTtcbn1cbmZ1bmN0aW9uIGlzSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZS5tYXRjaCgvKGh5ZHJhdGlvbnxjb250ZW50IGRvZXMgbm90IG1hdGNofGRpZCBub3QgbWF0Y2gpL2kpICE9IG51bGw7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBJbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcyBvbiB0aGUgY2xpZW50XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDUwO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG59XG5jb25zdCBlcnJvclF1ZXVlID0gW107XG5jb25zdCByZWplY3Rpb25RdWV1ZSA9IFtdO1xuY29uc3QgZXJyb3JIYW5kbGVycyA9IFtdO1xuY29uc3QgcmVqZWN0aW9uSGFuZGxlcnMgPSBbXTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRoZXNlIGV2ZW50IGhhbmRsZXJzIG11c3QgYmUgYWRkZWQgb3V0c2lkZSBvZiB0aGUgaG9vayBiZWNhdXNlIHRoZXJlIGlzIG5vXG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGhvb2sgd2lsbCBiZSBhbGl2ZSBpbiBhIG1vdW50ZWQgY29tcG9uZW50IGluIHRpbWUgdG9cbiAgICAvLyB3aGVuIHRoZSBlcnJvcnMgb2NjdXIuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2KT0+e1xuICAgICAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoZXYuZXJyb3IpKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXYgPT0gbnVsbCA/IHZvaWQgMCA6IGV2LmVycm9yO1xuICAgICAgICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIGVycm9yLnN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNIeWRyYXRpb25FcnJvcihlcnJvcikgJiYgIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2h0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3JlYWN0LWh5ZHJhdGlvbi1lcnJvcicpKSB7XG4gICAgICAgICAgICBpZiAoX2h5ZHJhdGlvbkVycm9ySW5mby5oeWRyYXRpb25FcnJvcldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9ICdcXG5cXG4nICsgX2h5ZHJhdGlvbkVycm9ySW5mby5oeWRyYXRpb25FcnJvcldhcm5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2h5ZHJhdGlvbkVycm9ySW5mby5oeWRyYXRpb25FcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuX2NvbXBvbmVudFN0YWNrID0gX2h5ZHJhdGlvbkVycm9ySW5mby5oeWRyYXRpb25FcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSAnXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlcnJvcjtcbiAgICAgICAgZXJyb3JRdWV1ZS5wdXNoKGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgZXJyb3JIYW5kbGVycyl7XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIChldik9PntcbiAgICAgICAgY29uc3QgcmVhc29uID0gZXYgPT0gbnVsbCA/IHZvaWQgMCA6IGV2LnJlYXNvbjtcbiAgICAgICAgaWYgKCFyZWFzb24gfHwgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHJlYXNvbjtcbiAgICAgICAgcmVqZWN0aW9uUXVldWUucHVzaChlKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHJlamVjdGlvbkhhbmRsZXJzKXtcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUVycm9ySGFuZGxlcihoYW5kbGVPblVuaGFuZGxlZEVycm9yLCBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbikge1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBIYW5kbGUgcXVldWVkIGVycm9ycy5cbiAgICAgICAgZXJyb3JRdWV1ZS5mb3JFYWNoKGhhbmRsZU9uVW5oYW5kbGVkRXJyb3IpO1xuICAgICAgICByZWplY3Rpb25RdWV1ZS5mb3JFYWNoKGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKTtcbiAgICAgICAgLy8gTGlzdGVuIHRvIG5ldyBlcnJvcnMuXG4gICAgICAgIGVycm9ySGFuZGxlcnMucHVzaChoYW5kbGVPblVuaGFuZGxlZEVycm9yKTtcbiAgICAgICAgcmVqZWN0aW9uSGFuZGxlcnMucHVzaChoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgICAgICAgIGVycm9ySGFuZGxlcnMuc3BsaWNlKGVycm9ySGFuZGxlcnMuaW5kZXhPZihoYW5kbGVPblVuaGFuZGxlZEVycm9yKSwgMSk7XG4gICAgICAgICAgICByZWplY3Rpb25IYW5kbGVycy5zcGxpY2UocmVqZWN0aW9uSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbiksIDEpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaGFuZGxlT25VbmhhbmRsZWRFcnJvcixcbiAgICAgICAgaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb25cbiAgICBdKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWVycm9yLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlRXJyb3JIYW5kbGVyIiwiUnVudGltZUVycm9ySGFuZGxlciIsIl9yZWFjdCIsInJlcXVpcmUiLCJfbm90Rm91bmQiLCJfcmVkaXJlY3QiLCJfaHlkcmF0aW9uRXJyb3JJbmZvIiwiaGFkUnVudGltZUVycm9yIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJlcnJvciIsImRpZ2VzdCIsImlzUmVkaXJlY3RFcnJvciIsImlzTm90Rm91bmRFcnJvciIsImlzSHlkcmF0aW9uRXJyb3IiLCJtZXNzYWdlIiwibWF0Y2giLCJFcnJvciIsInN0YWNrVHJhY2VMaW1pdCIsImUiLCJlcnJvclF1ZXVlIiwicmVqZWN0aW9uUXVldWUiLCJlcnJvckhhbmRsZXJzIiwicmVqZWN0aW9uSGFuZGxlcnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZXYiLCJwcmV2ZW50RGVmYXVsdCIsInN0YWNrIiwiaW5jbHVkZXMiLCJoeWRyYXRpb25FcnJvcldhcm5pbmciLCJoeWRyYXRpb25FcnJvckNvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudFN0YWNrIiwicHVzaCIsImhhbmRsZXIiLCJyZWFzb24iLCJoYW5kbGVPblVuaGFuZGxlZEVycm9yIiwiaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24iLCJ1c2VFZmZlY3QiLCJmb3JFYWNoIiwic3BsaWNlIiwiaW5kZXhPZiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-error-handler.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useOpenInEditor = useOpenInEditor;\nvar _react = __webpack_require__(/*! react */ \"react\");\nfunction useOpenInEditor({ file , lineNumber , column  } = {}) {\n    const openInEditor = (0, _react).useCallback(()=>{\n        if (file == null || lineNumber == null || column == null) return;\n        const params = new URLSearchParams();\n        params.append(\"file\", file);\n        params.append(\"lineNumber\", String(lineNumber));\n        params.append(\"column\", String(column));\n        self.fetch(`${ false || \"\"}/__nextjs_launch-editor?${params.toString()}`).then(()=>{}, ()=>{\n            console.error(\"There was an issue opening this code in your editor.\");\n        });\n    }, [\n        file,\n        lineNumber,\n        column\n    ]);\n    return openInEditor;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-open-in-editor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvdXNlLW9wZW4taW4tZWRpdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRTtBQUMxQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixTQUFTRixnQkFBZ0IsRUFBRUcsS0FBSSxFQUFHQyxXQUFVLEVBQUdDLE9BQU0sRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQzNELE1BQU1DLGVBQWUsQ0FBQyxHQUFHTCxNQUFNLEVBQUVNLFdBQVcsQ0FBQyxJQUFJO1FBQzdDLElBQUlKLFFBQVEsSUFBSSxJQUFJQyxjQUFjLElBQUksSUFBSUMsVUFBVSxJQUFJLEVBQUU7UUFDMUQsTUFBTUcsU0FBUyxJQUFJQztRQUNuQkQsT0FBT0UsTUFBTSxDQUFDLFFBQVFQO1FBQ3RCSyxPQUFPRSxNQUFNLENBQUMsY0FBY0MsT0FBT1A7UUFDbkNJLE9BQU9FLE1BQU0sQ0FBQyxVQUFVQyxPQUFPTjtRQUMvQk8sS0FBS0MsS0FBSyxDQUFDLENBQUMsRUFBRUMsTUFBa0MsSUFBSSxHQUFHLHdCQUF3QixFQUFFTixPQUFPUyxRQUFRLEdBQUcsQ0FBQyxFQUFFQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSTtZQUNuSEMsUUFBUUMsS0FBSyxDQUFDO1FBQ2xCO0lBQ0osR0FBRztRQUNDakI7UUFDQUM7UUFDQUM7S0FDSDtJQUNELE9BQU9DO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUXVCLE9BQU8sS0FBSyxjQUFlLE9BQU92QixRQUFRdUIsT0FBTyxLQUFLLFlBQVl2QixRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdkIsUUFBUXVCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksxQixPQUFPQyxjQUFjLENBQUNDLFFBQVF1QixPQUFPLEVBQUUsY0FBYztRQUFFdEIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8yQixNQUFNLENBQUN6QixRQUFRdUIsT0FBTyxFQUFFdkI7SUFDL0IwQixPQUFPMUIsT0FBTyxHQUFHQSxRQUFRdUIsT0FBTztBQUNsQyxDQUFDLENBRUQsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy91c2Utb3Blbi1pbi1lZGl0b3IuanM/MTQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlT3BlbkluRWRpdG9yID0gdXNlT3BlbkluRWRpdG9yO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIHVzZU9wZW5JbkVkaXRvcih7IGZpbGUgLCBsaW5lTnVtYmVyICwgY29sdW1uICB9ID0ge30pIHtcbiAgICBjb25zdCBvcGVuSW5FZGl0b3IgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBpZiAoZmlsZSA9PSBudWxsIHx8IGxpbmVOdW1iZXIgPT0gbnVsbCB8fCBjb2x1bW4gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZCgnbGluZU51bWJlcicsIFN0cmluZyhsaW5lTnVtYmVyKSk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoJ2NvbHVtbicsIFN0cmluZyhjb2x1bW4pKTtcbiAgICAgICAgc2VsZi5mZXRjaChgJHtwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnfS9fX25leHRqc19sYXVuY2gtZWRpdG9yPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCkudGhlbigoKT0+e30sICgpPT57XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGVyZSB3YXMgYW4gaXNzdWUgb3BlbmluZyB0aGlzIGNvZGUgaW4geW91ciBlZGl0b3IuJyk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgY29sdW1uXG4gICAgXSk7XG4gICAgcmV0dXJuIG9wZW5JbkVkaXRvcjtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW9wZW4taW4tZWRpdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZU9wZW5JbkVkaXRvciIsIl9yZWFjdCIsInJlcXVpcmUiLCJmaWxlIiwibGluZU51bWJlciIsImNvbHVtbiIsIm9wZW5JbkVkaXRvciIsInVzZUNhbGxiYWNrIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwiU3RyaW5nIiwic2VsZiIsImZldGNoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJ0b1N0cmluZyIsInRoZW4iLCJjb25zb2xlIiwiZXJyb3IiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-websocket.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-websocket.js ***!
  \******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useWebsocket = useWebsocket;\nexports.useSendMessage = useSendMessage;\nexports.useWebsocketPing = useWebsocketPing;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _appRouterContext = __webpack_require__(/*! ../../../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _getSocketProtocol = __webpack_require__(/*! ./get-socket-protocol */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-protocol.js\");\nfunction useWebsocket(assetPrefix) {\n    const webSocketRef = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        if (webSocketRef.current) {\n            return;\n        }\n        const { hostname , port  } = window.location;\n        const protocol = (0, _getSocketProtocol).getSocketProtocol(assetPrefix);\n        const normalizedAssetPrefix = assetPrefix.replace(/^\\/+/, \"\");\n        let url = `${protocol}://${hostname}:${port}${normalizedAssetPrefix ? `/${normalizedAssetPrefix}` : \"\"}`;\n        if (normalizedAssetPrefix.startsWith(\"http\")) {\n            url = `${protocol}://${normalizedAssetPrefix.split(\"://\")[1]}`;\n        }\n        webSocketRef.current = new window.WebSocket(`${url}/_next/webpack-hmr`);\n    }, [\n        assetPrefix\n    ]);\n    return webSocketRef;\n}\nfunction useSendMessage(webSocketRef) {\n    const sendMessage = (0, _react).useCallback((data)=>{\n        const socket = webSocketRef.current;\n        if (!socket || socket.readyState !== socket.OPEN) {\n            return;\n        }\n        return socket.send(data);\n    }, [\n        webSocketRef\n    ]);\n    return sendMessage;\n}\nfunction useWebsocketPing(websocketRef) {\n    const sendMessage = useSendMessage(websocketRef);\n    const { tree  } = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    (0, _react).useEffect(()=>{\n        // Taken from on-demand-entries-client.js\n        // TODO-APP: check 404 case\n        const interval = setInterval(()=>{\n            sendMessage(JSON.stringify({\n                event: \"ping\",\n                tree,\n                appDirRoute: true\n            }));\n        }, 2500);\n        return ()=>clearInterval(interval);\n    }, [\n        tree,\n        sendMessage\n    ]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-websocket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvdXNlLXdlYnNvY2tldC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxvQkFBb0IsR0FBR0U7QUFDdkJGLHNCQUFzQixHQUFHRztBQUN6Qkgsd0JBQXdCLEdBQUdJO0FBQzNCLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzVCLElBQUlDLG9CQUFvQkQsbUJBQU9BLENBQUMseUZBQThDO0FBQzlFLElBQUlFLHFCQUFxQkYsbUJBQU9BLENBQUMsK0lBQXVCO0FBQ3hELFNBQVNKLGFBQWFPLFdBQVcsRUFBRTtJQUMvQixNQUFNQyxlQUFlLENBQUMsR0FBR0wsTUFBTSxFQUFFTSxNQUFNO0lBQ3RDLElBQUdOLE1BQU0sRUFBRU8sU0FBUyxDQUFDLElBQUk7UUFDdEIsSUFBSUYsYUFBYUcsT0FBTyxFQUFFO1lBQ3RCO1FBQ0osQ0FBQztRQUNELE1BQU0sRUFBRUMsU0FBUSxFQUFHQyxLQUFJLEVBQUcsR0FBR0MsT0FBT0MsUUFBUTtRQUM1QyxNQUFNQyxXQUFXLENBQUMsR0FBR1Ysa0JBQWtCLEVBQUVXLGlCQUFpQixDQUFDVjtRQUMzRCxNQUFNVyx3QkFBd0JYLFlBQVlZLE9BQU8sQ0FBQyxRQUFRO1FBQzFELElBQUlDLE1BQU0sQ0FBQyxFQUFFSixTQUFTLEdBQUcsRUFBRUosU0FBUyxDQUFDLEVBQUVDLEtBQUssRUFBRUssd0JBQXdCLENBQUMsQ0FBQyxFQUFFQSxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3hHLElBQUlBLHNCQUFzQkcsVUFBVSxDQUFDLFNBQVM7WUFDMUNELE1BQU0sQ0FBQyxFQUFFSixTQUFTLEdBQUcsRUFBRUUsc0JBQXNCSSxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xFLENBQUM7UUFDRGQsYUFBYUcsT0FBTyxHQUFHLElBQUlHLE9BQU9TLFNBQVMsQ0FBQyxDQUFDLEVBQUVILElBQUksa0JBQWtCLENBQUM7SUFDMUUsR0FBRztRQUNDYjtLQUNIO0lBQ0QsT0FBT0M7QUFDWDtBQUNBLFNBQVNQLGVBQWVPLFlBQVksRUFBRTtJQUNsQyxNQUFNZ0IsY0FBYyxDQUFDLEdBQUdyQixNQUFNLEVBQUVzQixXQUFXLENBQUMsQ0FBQ0MsT0FBTztRQUNoRCxNQUFNQyxTQUFTbkIsYUFBYUcsT0FBTztRQUNuQyxJQUFJLENBQUNnQixVQUFVQSxPQUFPQyxVQUFVLEtBQUtELE9BQU9FLElBQUksRUFBRTtZQUM5QztRQUNKLENBQUM7UUFDRCxPQUFPRixPQUFPRyxJQUFJLENBQUNKO0lBQ3ZCLEdBQUc7UUFDQ2xCO0tBQ0g7SUFDRCxPQUFPZ0I7QUFDWDtBQUNBLFNBQVN0QixpQkFBaUI2QixZQUFZLEVBQUU7SUFDcEMsTUFBTVAsY0FBY3ZCLGVBQWU4QjtJQUNuQyxNQUFNLEVBQUVDLEtBQUksRUFBRyxHQUFHLENBQUMsR0FBRzdCLE1BQU0sRUFBRThCLFVBQVUsQ0FBQzVCLGtCQUFrQjZCLHlCQUF5QjtJQUNuRixJQUFHL0IsTUFBTSxFQUFFTyxTQUFTLENBQUMsSUFBSTtRQUN0Qix5Q0FBeUM7UUFDekMsMkJBQTJCO1FBQzNCLE1BQU15QixXQUFXQyxZQUFZLElBQUk7WUFDN0JaLFlBQVlhLEtBQUtDLFNBQVMsQ0FBQztnQkFDdkJDLE9BQU87Z0JBQ1BQO2dCQUNBUSxhQUFhLElBQUk7WUFDckI7UUFDSixHQUFHO1FBQ0gsT0FBTyxJQUFJQyxjQUFjTjtJQUM3QixHQUFHO1FBQ0NIO1FBQ0FSO0tBQ0g7QUFDTDtBQUVBLElBQUksQ0FBQyxPQUFPMUIsUUFBUTRDLE9BQU8sS0FBSyxjQUFlLE9BQU81QyxRQUFRNEMsT0FBTyxLQUFLLFlBQVk1QyxRQUFRNEMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPNUMsUUFBUTRDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksvQyxPQUFPQyxjQUFjLENBQUNDLFFBQVE0QyxPQUFPLEVBQUUsY0FBYztRQUFFM0MsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nRCxNQUFNLENBQUM5QyxRQUFRNEMsT0FBTyxFQUFFNUM7SUFDL0IrQyxPQUFPL0MsT0FBTyxHQUFHQSxRQUFRNEMsT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaGVscGVycy91c2Utd2Vic29ja2V0LmpzPzdiODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZVdlYnNvY2tldCA9IHVzZVdlYnNvY2tldDtcbmV4cG9ydHMudXNlU2VuZE1lc3NhZ2UgPSB1c2VTZW5kTWVzc2FnZTtcbmV4cG9ydHMudXNlV2Vic29ja2V0UGluZyA9IHVzZVdlYnNvY2tldFBpbmc7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9nZXRTb2NrZXRQcm90b2NvbCA9IHJlcXVpcmUoXCIuL2dldC1zb2NrZXQtcHJvdG9jb2xcIik7XG5mdW5jdGlvbiB1c2VXZWJzb2NrZXQoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHdlYlNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3N0bmFtZSAsIHBvcnQgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gKDAsIF9nZXRTb2NrZXRQcm90b2NvbCkuZ2V0U29ja2V0UHJvdG9jb2woYXNzZXRQcmVmaXgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQXNzZXRQcmVmaXggPSBhc3NldFByZWZpeC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgbGV0IHVybCA9IGAke3Byb3RvY29sfTovLyR7aG9zdG5hbWV9OiR7cG9ydH0ke25vcm1hbGl6ZWRBc3NldFByZWZpeCA/IGAvJHtub3JtYWxpemVkQXNzZXRQcmVmaXh9YCA6ICcnfWA7XG4gICAgICAgIGlmIChub3JtYWxpemVkQXNzZXRQcmVmaXguc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHtwcm90b2NvbH06Ly8ke25vcm1hbGl6ZWRBc3NldFByZWZpeC5zcGxpdCgnOi8vJylbMV19YDtcbiAgICAgICAgfVxuICAgICAgICB3ZWJTb2NrZXRSZWYuY3VycmVudCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGAke3VybH0vX25leHQvd2VicGFjay1obXJgKTtcbiAgICB9LCBbXG4gICAgICAgIGFzc2V0UHJlZml4XG4gICAgXSk7XG4gICAgcmV0dXJuIHdlYlNvY2tldFJlZjtcbn1cbmZ1bmN0aW9uIHVzZVNlbmRNZXNzYWdlKHdlYlNvY2tldFJlZikge1xuICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGRhdGEpPT57XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHdlYlNvY2tldFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXNvY2tldCB8fCBzb2NrZXQucmVhZHlTdGF0ZSAhPT0gc29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfSwgW1xuICAgICAgICB3ZWJTb2NrZXRSZWZcbiAgICBdKTtcbiAgICByZXR1cm4gc2VuZE1lc3NhZ2U7XG59XG5mdW5jdGlvbiB1c2VXZWJzb2NrZXRQaW5nKHdlYnNvY2tldFJlZikge1xuICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlU2VuZE1lc3NhZ2Uod2Vic29ja2V0UmVmKTtcbiAgICBjb25zdCB7IHRyZWUgIH0gPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBUYWtlbiBmcm9tIG9uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qc1xuICAgICAgICAvLyBUT0RPLUFQUDogY2hlY2sgNDA0IGNhc2VcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAncGluZycsXG4gICAgICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgICAgICBhcHBEaXJSb3V0ZTogdHJ1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCAyNTAwKTtcbiAgICAgICAgcmV0dXJuICgpPT5jbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHNlbmRNZXNzYWdlXG4gICAgXSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS13ZWJzb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlV2Vic29ja2V0IiwidXNlU2VuZE1lc3NhZ2UiLCJ1c2VXZWJzb2NrZXRQaW5nIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2dldFNvY2tldFByb3RvY29sIiwiYXNzZXRQcmVmaXgiLCJ3ZWJTb2NrZXRSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImdldFNvY2tldFByb3RvY29sIiwibm9ybWFsaXplZEFzc2V0UHJlZml4IiwicmVwbGFjZSIsInVybCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsIldlYlNvY2tldCIsInNlbmRNZXNzYWdlIiwidXNlQ2FsbGJhY2siLCJkYXRhIiwic29ja2V0IiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzZW5kIiwid2Vic29ja2V0UmVmIiwidHJlZSIsInVzZUNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsImFwcERpclJvdXRlIiwiY2xlYXJJbnRlcnZhbCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-websocket.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/hooks/use-on-click-outside.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/hooks/use-on-click-outside.js ***!
  \***********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useOnClickOutside = useOnClickOutside;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nfunction useOnClickOutside(el, handler) {\n    React.useEffect(()=>{\n        if (el == null || handler == null) {\n            return;\n        }\n        const listener = (e)=>{\n            // Do nothing if clicking ref's element or descendent elements\n            if (!el || el.contains(e.target)) {\n                return;\n            }\n            handler(e);\n        };\n        const root = el.getRootNode();\n        root.addEventListener(\"mousedown\", listener);\n        root.addEventListener(\"touchstart\", listener);\n        return function() {\n            root.removeEventListener(\"mousedown\", listener);\n            root.removeEventListener(\"touchstart\", listener);\n        };\n    }, [\n        handler,\n        el\n    ]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-on-click-outside.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hvb2tzL3VzZS1vbi1jbGljay1vdXRzaWRlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHlCQUF5QixHQUFHRTtBQUM1QixJQUFJQyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELFNBQVNGLGtCQUFrQkssRUFBRSxFQUFFQyxPQUFPLEVBQUU7SUFDcENGLE1BQU1HLFNBQVMsQ0FBQyxJQUFJO1FBQ2hCLElBQUlGLE1BQU0sSUFBSSxJQUFJQyxXQUFXLElBQUksRUFBRTtZQUMvQjtRQUNKLENBQUM7UUFDRCxNQUFNRSxXQUFXLENBQUNDLElBQUk7WUFDbEIsOERBQThEO1lBQzlELElBQUksQ0FBQ0osTUFBTUEsR0FBR0ssUUFBUSxDQUFDRCxFQUFFRSxNQUFNLEdBQUc7Z0JBQzlCO1lBQ0osQ0FBQztZQUNETCxRQUFRRztRQUNaO1FBQ0EsTUFBTUcsT0FBT1AsR0FBR1EsV0FBVztRQUMzQkQsS0FBS0UsZ0JBQWdCLENBQUMsYUFBYU47UUFDbkNJLEtBQUtFLGdCQUFnQixDQUFDLGNBQWNOO1FBQ3BDLE9BQU8sV0FBVztZQUNkSSxLQUFLRyxtQkFBbUIsQ0FBQyxhQUFhUDtZQUN0Q0ksS0FBS0csbUJBQW1CLENBQUMsY0FBY1A7UUFDM0M7SUFDSixHQUFHO1FBQ0NGO1FBQ0FEO0tBQ0g7QUFDTDtBQUVBLElBQUksQ0FBQyxPQUFPUCxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNhLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3FCLE1BQU0sQ0FBQ25CLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JvQixPQUFPcEIsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZS5qcz9jNjkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VPbkNsaWNrT3V0c2lkZSA9IHVzZU9uQ2xpY2tPdXRzaWRlO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgUmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiB1c2VPbkNsaWNrT3V0c2lkZShlbCwgaGFuZGxlcikge1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoZWwgPT0gbnVsbCB8fCBoYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChlKT0+e1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjbGlja2luZyByZWYncyBlbGVtZW50IG9yIGRlc2NlbmRlbnQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghZWwgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgZWxcbiAgICBdKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW9uLWNsaWNrLW91dHNpZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlT25DbGlja091dHNpZGUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsImRlZmF1bHQiLCJSZWFjdCIsImVsIiwiaGFuZGxlciIsInVzZUVmZmVjdCIsImxpc3RlbmVyIiwiZSIsImNvbnRhaW5zIiwidGFyZ2V0Iiwicm9vdCIsImdldFJvb3ROb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/hooks/use-on-click-outside.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/icons/CloseIcon.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/icons/CloseIcon.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CloseIcon = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nconst CloseIcon = ()=>{\n    return /*#__PURE__*/ React.createElement(\"svg\", {\n        width: \"24\",\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /*#__PURE__*/ React.createElement(\"path\", {\n        d: \"M18 6L6 18\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }), /*#__PURE__*/ React.createElement(\"path\", {\n        d: \"M6 6L18 18\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n    }));\n};\nexports.CloseIcon = CloseIcon;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=CloseIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2ljb25zL0Nsb3NlSWNvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLElBQUlHLDRCQUE0QkMsaUtBQWdFO0FBQ2hHLElBQUlFLFFBQVFILDBCQUEwQkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsTUFBTUYsWUFBWSxJQUFJO0lBQ2xCLE9BQU8sV0FBVyxHQUFHSSxNQUFNQyxhQUFhLENBQUMsT0FBTztRQUM1Q0MsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsTUFBTTtRQUNOQyxPQUFPO0lBQ1gsR0FBRyxXQUFXLEdBQUdOLE1BQU1DLGFBQWEsQ0FBQyxRQUFRO1FBQ3pDTSxHQUFHO1FBQ0hDLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtJQUNwQixJQUFJLFdBQVcsR0FBR1gsTUFBTUMsYUFBYSxDQUFDLFFBQVE7UUFDMUNNLEdBQUc7UUFDSEMsUUFBUTtRQUNSQyxhQUFhO1FBQ2JDLGVBQWU7UUFDZkMsZ0JBQWdCO0lBQ3BCO0FBQ0o7QUFDQWpCLGlCQUFpQixHQUFHRTtBQUVwQixJQUFJLENBQUMsT0FBT0YsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDYSxVQUFVLEtBQUssYUFBYTtJQUNyS3BCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9xQixNQUFNLENBQUNuQixRQUFRSyxPQUFPLEVBQUVMO0lBQy9Cb0IsT0FBT3BCLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvaWNvbnMvQ2xvc2VJY29uLmpzPzY4YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNsb3NlSWNvbiA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgQ2xvc2VJY29uID0gKCk9PntcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE4IDZMNiAxOFwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSksIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk02IDZMMTggMThcIixcbiAgICAgICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pKTtcbn07XG5leHBvcnRzLkNsb3NlSWNvbiA9IENsb3NlSWNvbjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xvc2VJY29uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsb3NlSWNvbiIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlJlYWN0IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsImZpbGwiLCJ4bWxucyIsImQiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/icons/CloseIcon.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/Base.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/Base.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Base = Base;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction Base() {\n    return /*#__PURE__*/ React.createElement(\"style\", null, _noopTemplate.noop`\n        :host {\n          --size-gap-half: 4px;\n          --size-gap: 8px;\n          --size-gap-double: 16px;\n          --size-gap-triple: 24px;\n          --size-gap-quad: 32px;\n\n          --size-font-small: 14px;\n          --size-font: 16px;\n          --size-font-big: 20px;\n          --size-font-bigger: 24px;\n\n          --color-accents-1: #808080;\n          --color-accents-2: #222222;\n          --color-accents-3: #404040;\n\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\n            Menlo, Courier, monospace;\n\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\n          --color-ansi-bg: #111111;\n          --color-ansi-fg: #cccccc;\n\n          --color-ansi-white: #777777;\n          --color-ansi-black: #141414;\n          --color-ansi-blue: #00aaff;\n          --color-ansi-cyan: #88ddff;\n          --color-ansi-green: #98ec65;\n          --color-ansi-magenta: #aa88ff;\n          --color-ansi-red: #ff5555;\n          --color-ansi-yellow: #ffcc33;\n          --color-ansi-bright-white: #ffffff;\n          --color-ansi-bright-black: #777777;\n          --color-ansi-bright-blue: #33bbff;\n          --color-ansi-bright-cyan: #bbecff;\n          --color-ansi-bright-green: #b6f292;\n          --color-ansi-bright-magenta: #cebbff;\n          --color-ansi-bright-red: #ff8888;\n          --color-ansi-bright-yellow: #ffd966;\n        }\n\n        .mono {\n          font-family: var(--font-stack-monospace);\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-bottom: var(--size-gap);\n          font-weight: 500;\n          line-height: 1.5;\n        }\n\n        h1 {\n          font-size: 40px;\n        }\n        h2 {\n          font-size: 32px;\n        }\n        h3 {\n          font-size: 28px;\n        }\n        h4 {\n          font-size: 24px;\n        }\n        h5 {\n          font-size: 20px;\n        }\n        h6 {\n          font-size: 16px;\n        }\n      `);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL3N0eWxlcy9CYXNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELFlBQVksR0FBR0U7QUFDZixJQUFJQyw0QkFBNEJDLGlLQUFnRTtBQUNoRyxJQUFJRSxRQUFRSCwwQkFBMEJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLGdCQUFnQkgsbUJBQU9BLENBQUMsNElBQTBCO0FBQ3RELFNBQVNGLE9BQU87SUFDWixPQUFPLFdBQVcsR0FBR0ksTUFBTUUsYUFBYSxDQUFDLFNBQVMsSUFBSSxFQUFFRCxjQUFjRSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTJFekUsQ0FBQztBQUNQO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ0ssVUFBVSxLQUFLLGFBQWE7SUFDcktaLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9hLE1BQU0sQ0FBQ1gsUUFBUUssT0FBTyxFQUFFTDtJQUMvQlksT0FBT1osT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9zdHlsZXMvQmFzZS5qcz9lMTIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CYXNlID0gQmFzZTtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQmFzZSgpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgbnVsbCwgX25vb3BUZW1wbGF0ZS5ub29wYFxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiA0cHg7XG4gICAgICAgICAgLS1zaXplLWdhcDogOHB4O1xuICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxNnB4O1xuICAgICAgICAgIC0tc2l6ZS1nYXAtdHJpcGxlOiAyNHB4O1xuICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMzJweDtcblxuICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAxNHB4O1xuICAgICAgICAgIC0tc2l6ZS1mb250OiAxNnB4O1xuICAgICAgICAgIC0tc2l6ZS1mb250LWJpZzogMjBweDtcbiAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDI0cHg7XG5cbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcblxuICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLCAnTGliZXJhdGlvbiBNb25vJyxcbiAgICAgICAgICAgIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XG5cbiAgICAgICAgICAtLWNvbG9yLWFuc2ktc2VsZWN0aW9uOiByZ2JhKDk1LCAxMjYsIDE1MSwgMC40OCk7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJnOiAjMTExMTExO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1mZzogI2NjY2NjYztcblxuICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5tb25vIHtcbiAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEsXG4gICAgICAgIGgyLFxuICAgICAgICBoMyxcbiAgICAgICAgaDQsXG4gICAgICAgIGg1LFxuICAgICAgICBoNiB7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHtcbiAgICAgICAgICBmb250LXNpemU6IDQwcHg7XG4gICAgICAgIH1cbiAgICAgICAgaDIge1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgfVxuICAgICAgICBoMyB7XG4gICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xuICAgICAgICB9XG4gICAgICAgIGg0IHtcbiAgICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgIH1cbiAgICAgICAgaDUge1xuICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgfVxuICAgICAgICBoNiB7XG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICB9XG4gICAgICBgKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfbm9vcFRlbXBsYXRlIiwiY3JlYXRlRWxlbWVudCIsIm5vb3AiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/Base.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/ComponentStyles.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/ComponentStyles.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ComponentStyles = ComponentStyles;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _styles = __webpack_require__(/*! ../components/CodeFrame/styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/CodeFrame/styles.js\");\nvar _dialog = __webpack_require__(/*! ../components/Dialog */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Dialog/index.js\");\nvar _styles1 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/LeftRightDialogHeader/styles.js\");\nvar _styles2 = __webpack_require__(/*! ../components/Overlay/styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js\");\nvar _styles3 = __webpack_require__(/*! ../components/Terminal/styles */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js\");\nvar _toast = __webpack_require__(/*! ../components/Toast */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js\");\nvar _versionStalenessInfo = __webpack_require__(/*! ../components/VersionStalenessInfo */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js\");\nvar _buildError = __webpack_require__(/*! ../container/BuildError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/BuildError.js\");\nvar _rootLayoutError = __webpack_require__(/*! ../container/RootLayoutError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RootLayoutError.js\");\nvar _errors = __webpack_require__(/*! ../container/Errors */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/Errors.js\");\nvar _runtimeError = __webpack_require__(/*! ../container/RuntimeError */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/container/RuntimeError/index.js\");\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction ComponentStyles() {\n    return /*#__PURE__*/ React.createElement(\"style\", null, _noopTemplate.noop`\n        ${_styles2.styles}\n        ${_toast.styles}\n        ${_dialog.styles}\n        ${_styles1.styles}\n        ${_styles.styles}\n        ${_styles3.styles}\n        \n        ${_buildError.styles}\n        ${_rootLayoutError.styles}\n        ${_errors.styles}\n        ${_runtimeError.styles}\n        ${_versionStalenessInfo.styles}\n      `);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ComponentStyles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL3N0eWxlcy9Db21wb25lbnRTdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLElBQUlDLDRCQUE0QkMsaUtBQWdFO0FBQ2hHLElBQUlFLFFBQVFILDBCQUEwQkMsbUJBQU9BLENBQUMsb0JBQU87QUFDckQsSUFBSUcsVUFBVUgsbUJBQU9BLENBQUMsd0pBQWdDO0FBQ3RELElBQUlJLFVBQVVKLG1CQUFPQSxDQUFDLDBJQUFzQjtBQUM1QyxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQyxnTEFBNEM7QUFDbkUsSUFBSU0sV0FBV04sbUJBQU9BLENBQUMsb0pBQThCO0FBQ3JELElBQUlPLFdBQVdQLG1CQUFPQSxDQUFDLHNKQUErQjtBQUN0RCxJQUFJUSxTQUFTUixtQkFBT0EsQ0FBQyx3SUFBcUI7QUFDMUMsSUFBSVMsd0JBQXdCVCxtQkFBT0EsQ0FBQyxzS0FBb0M7QUFDeEUsSUFBSVUsY0FBY1YsbUJBQU9BLENBQUMsMElBQXlCO0FBQ25ELElBQUlXLG1CQUFtQlgsbUJBQU9BLENBQUMsb0pBQThCO0FBQzdELElBQUlZLFVBQVVaLG1CQUFPQSxDQUFDLGtJQUFxQjtBQUMzQyxJQUFJYSxnQkFBZ0JiLG1CQUFPQSxDQUFDLG9KQUEyQjtBQUN2RCxJQUFJYyxnQkFBZ0JkLG1CQUFPQSxDQUFDLDRJQUEwQjtBQUN0RCxTQUFTRixrQkFBa0I7SUFDdkIsT0FBTyxXQUFXLEdBQUdJLE1BQU1hLGFBQWEsQ0FBQyxTQUFTLElBQUksRUFBRUQsY0FBY0UsSUFBSSxDQUFDO1FBQ3ZFLEVBQUVWLFNBQVNXLE1BQU0sQ0FBQztRQUNsQixFQUFFVCxPQUFPUyxNQUFNLENBQUM7UUFDaEIsRUFBRWIsUUFBUWEsTUFBTSxDQUFDO1FBQ2pCLEVBQUVaLFNBQVNZLE1BQU0sQ0FBQztRQUNsQixFQUFFZCxRQUFRYyxNQUFNLENBQUM7UUFDakIsRUFBRVYsU0FBU1UsTUFBTSxDQUFDOztRQUVsQixFQUFFUCxZQUFZTyxNQUFNLENBQUM7UUFDckIsRUFBRU4saUJBQWlCTSxNQUFNLENBQUM7UUFDMUIsRUFBRUwsUUFBUUssTUFBTSxDQUFDO1FBQ2pCLEVBQUVKLGNBQWNJLE1BQU0sQ0FBQztRQUN2QixFQUFFUixzQkFBc0JRLE1BQU0sQ0FBQztNQUNqQyxDQUFDO0FBQ1A7QUFFQSxJQUFJLENBQUMsT0FBT3JCLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ2lCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLeEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3lCLE1BQU0sQ0FBQ3ZCLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0J3QixPQUFPeEIsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9zdHlsZXMvQ29tcG9uZW50U3R5bGVzLmpzPzc4MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbXBvbmVudFN0eWxlcyA9IENvbXBvbmVudFN0eWxlcztcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9zdHlsZXMgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9Db2RlRnJhbWUvc3R5bGVzXCIpO1xudmFyIF9kaWFsb2cgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9EaWFsb2dcIik7XG52YXIgX3N0eWxlczEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvc3R5bGVzXCIpO1xudmFyIF9zdHlsZXMyID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXNcIik7XG52YXIgX3N0eWxlczMgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXNcIik7XG52YXIgX3RvYXN0ID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgX3ZlcnNpb25TdGFsZW5lc3NJbmZvID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm9cIik7XG52YXIgX2J1aWxkRXJyb3IgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0J1aWxkRXJyb3JcIik7XG52YXIgX3Jvb3RMYXlvdXRFcnJvciA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvUm9vdExheW91dEVycm9yXCIpO1xudmFyIF9lcnJvcnMgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL0Vycm9yc1wiKTtcbnZhciBfcnVudGltZUVycm9yID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9SdW50aW1lRXJyb3JcIik7XG52YXIgX25vb3BUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG5mdW5jdGlvbiBDb21wb25lbnRTdHlsZXMoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIG51bGwsIF9ub29wVGVtcGxhdGUubm9vcGBcbiAgICAgICAgJHtfc3R5bGVzMi5zdHlsZXN9XG4gICAgICAgICR7X3RvYXN0LnN0eWxlc31cbiAgICAgICAgJHtfZGlhbG9nLnN0eWxlc31cbiAgICAgICAgJHtfc3R5bGVzMS5zdHlsZXN9XG4gICAgICAgICR7X3N0eWxlcy5zdHlsZXN9XG4gICAgICAgICR7X3N0eWxlczMuc3R5bGVzfVxuICAgICAgICBcbiAgICAgICAgJHtfYnVpbGRFcnJvci5zdHlsZXN9XG4gICAgICAgICR7X3Jvb3RMYXlvdXRFcnJvci5zdHlsZXN9XG4gICAgICAgICR7X2Vycm9ycy5zdHlsZXN9XG4gICAgICAgICR7X3J1bnRpbWVFcnJvci5zdHlsZXN9XG4gICAgICAgICR7X3ZlcnNpb25TdGFsZW5lc3NJbmZvLnN0eWxlc31cbiAgICAgIGApO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb25lbnRTdHlsZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcG9uZW50U3R5bGVzIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfc3R5bGVzIiwiX2RpYWxvZyIsIl9zdHlsZXMxIiwiX3N0eWxlczIiLCJfc3R5bGVzMyIsIl90b2FzdCIsIl92ZXJzaW9uU3RhbGVuZXNzSW5mbyIsIl9idWlsZEVycm9yIiwiX3Jvb3RMYXlvdXRFcnJvciIsIl9lcnJvcnMiLCJfcnVudGltZUVycm9yIiwiX25vb3BUZW1wbGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJub29wIiwic3R5bGVzIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/ComponentStyles.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/CssReset.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/CssReset.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CssReset = CssReset;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar React = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _noopTemplate = __webpack_require__(/*! ../helpers/noop-template */ \"(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction CssReset() {\n    return /*#__PURE__*/ React.createElement(\"style\", null, _noopTemplate.noop`\n        :host {\n          all: initial;\n\n          /* the direction property is not reset by 'all' */\n          direction: ltr;\n        }\n\n        /*!\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n         * Copyright 2011-2019 The Bootstrap Authors\n         * Copyright 2011-2019 Twitter, Inc.\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n         */\n        *,\n        *::before,\n        *::after {\n          box-sizing: border-box;\n        }\n\n        :host {\n          font-family: sans-serif;\n          line-height: 1.15;\n          -webkit-text-size-adjust: 100%;\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        }\n\n        article,\n        aside,\n        figcaption,\n        figure,\n        footer,\n        header,\n        hgroup,\n        main,\n        nav,\n        section {\n          display: block;\n        }\n\n        :host {\n          margin: 0;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n            'Noto Color Emoji';\n          font-size: 16px;\n          font-weight: 400;\n          line-height: 1.5;\n          color: #212529;\n          text-align: left;\n          background-color: #fff;\n        }\n\n        [tabindex='-1']:focus:not(:focus-visible) {\n          outline: 0 !important;\n        }\n\n        hr {\n          box-sizing: content-box;\n          height: 0;\n          overflow: visible;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-top: 0;\n          margin-bottom: 8px;\n        }\n\n        p {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        abbr[title],\n        abbr[data-original-title] {\n          text-decoration: underline;\n          -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n          cursor: help;\n          border-bottom: 0;\n          -webkit-text-decoration-skip-ink: none;\n          text-decoration-skip-ink: none;\n        }\n\n        address {\n          margin-bottom: 16px;\n          font-style: normal;\n          line-height: inherit;\n        }\n\n        ol,\n        ul,\n        dl {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        ol ol,\n        ul ul,\n        ol ul,\n        ul ol {\n          margin-bottom: 0;\n        }\n\n        dt {\n          font-weight: 700;\n        }\n\n        dd {\n          margin-bottom: 8px;\n          margin-left: 0;\n        }\n\n        blockquote {\n          margin: 0 0 16px;\n        }\n\n        b,\n        strong {\n          font-weight: bolder;\n        }\n\n        small {\n          font-size: 80%;\n        }\n\n        sub,\n        sup {\n          position: relative;\n          font-size: 75%;\n          line-height: 0;\n          vertical-align: baseline;\n        }\n\n        sub {\n          bottom: -0.25em;\n        }\n\n        sup {\n          top: -0.5em;\n        }\n\n        a {\n          color: #007bff;\n          text-decoration: none;\n          background-color: transparent;\n        }\n\n        a:hover {\n          color: #0056b3;\n          text-decoration: underline;\n        }\n\n        a:not([href]) {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        a:not([href]):hover {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        pre,\n        code,\n        kbd,\n        samp {\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n            'Liberation Mono', 'Courier New', monospace;\n          font-size: 1em;\n        }\n\n        pre {\n          margin-top: 0;\n          margin-bottom: 16px;\n          overflow: auto;\n        }\n\n        figure {\n          margin: 0 0 16px;\n        }\n\n        img {\n          vertical-align: middle;\n          border-style: none;\n        }\n\n        svg {\n          overflow: hidden;\n          vertical-align: middle;\n        }\n\n        table {\n          border-collapse: collapse;\n        }\n\n        caption {\n          padding-top: 12px;\n          padding-bottom: 12px;\n          color: #6c757d;\n          text-align: left;\n          caption-side: bottom;\n        }\n\n        th {\n          text-align: inherit;\n        }\n\n        label {\n          display: inline-block;\n          margin-bottom: 8px;\n        }\n\n        button {\n          border-radius: 0;\n        }\n\n        button:focus {\n          outline: 1px dotted;\n          outline: 5px auto -webkit-focus-ring-color;\n        }\n\n        input,\n        button,\n        select,\n        optgroup,\n        textarea {\n          margin: 0;\n          font-family: inherit;\n          font-size: inherit;\n          line-height: inherit;\n        }\n\n        button,\n        input {\n          overflow: visible;\n        }\n\n        button,\n        select {\n          text-transform: none;\n        }\n\n        select {\n          word-wrap: normal;\n        }\n\n        button,\n        [type='button'],\n        [type='reset'],\n        [type='submit'] {\n          -webkit-appearance: button;\n        }\n\n        button:not(:disabled),\n        [type='button']:not(:disabled),\n        [type='reset']:not(:disabled),\n        [type='submit']:not(:disabled) {\n          cursor: pointer;\n        }\n\n        button::-moz-focus-inner,\n        [type='button']::-moz-focus-inner,\n        [type='reset']::-moz-focus-inner,\n        [type='submit']::-moz-focus-inner {\n          padding: 0;\n          border-style: none;\n        }\n\n        input[type='radio'],\n        input[type='checkbox'] {\n          box-sizing: border-box;\n          padding: 0;\n        }\n\n        input[type='date'],\n        input[type='time'],\n        input[type='datetime-local'],\n        input[type='month'] {\n          -webkit-appearance: listbox;\n        }\n\n        textarea {\n          overflow: auto;\n          resize: vertical;\n        }\n\n        fieldset {\n          min-width: 0;\n          padding: 0;\n          margin: 0;\n          border: 0;\n        }\n\n        legend {\n          display: block;\n          width: 100%;\n          max-width: 100%;\n          padding: 0;\n          margin-bottom: 8px;\n          font-size: 24px;\n          line-height: inherit;\n          color: inherit;\n          white-space: normal;\n        }\n\n        progress {\n          vertical-align: baseline;\n        }\n\n        [type='number']::-webkit-inner-spin-button,\n        [type='number']::-webkit-outer-spin-button {\n          height: auto;\n        }\n\n        [type='search'] {\n          outline-offset: -2px;\n          -webkit-appearance: none;\n        }\n\n        [type='search']::-webkit-search-decoration {\n          -webkit-appearance: none;\n        }\n\n        ::-webkit-file-upload-button {\n          font: inherit;\n          -webkit-appearance: button;\n        }\n\n        output {\n          display: inline-block;\n        }\n\n        summary {\n          display: list-item;\n          cursor: pointer;\n        }\n\n        template {\n          display: none;\n        }\n\n        [hidden] {\n          display: none !important;\n        }\n      `);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=CssReset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL3N0eWxlcy9Dc3NSZXNldC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0U7QUFDbkIsSUFBSUMsNEJBQTRCQyxpS0FBZ0U7QUFDaEcsSUFBSUUsUUFBUUgsMEJBQTBCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUNyRCxJQUFJRyxnQkFBZ0JILG1CQUFPQSxDQUFDLDRJQUEwQjtBQUN0RCxTQUFTRixXQUFXO0lBQ2hCLE9BQU8sV0FBVyxHQUFHSSxNQUFNRSxhQUFhLENBQUMsU0FBUyxJQUFJLEVBQUVELGNBQWNFLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWdXekUsQ0FBQztBQUNQO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ0ssVUFBVSxLQUFLLGFBQWE7SUFDcktaLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9hLE1BQU0sQ0FBQ1gsUUFBUUssT0FBTyxFQUFFTDtJQUMvQlksT0FBT1osT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9zdHlsZXMvQ3NzUmVzZXQuanM/MWEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ3NzUmVzZXQgPSBDc3NSZXNldDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIFJlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9ub29wVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQ3NzUmVzZXQoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIG51bGwsIF9ub29wVGVtcGxhdGUubm9vcGBcbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGFsbDogaW5pdGlhbDtcblxuICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXG4gICAgICAgICAgZGlyZWN0aW9uOiBsdHI7XG4gICAgICAgIH1cblxuICAgICAgICAvKiFcbiAgICAgICAgICogQm9vdHN0cmFwIFJlYm9vdCB2NC40LjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICAgICAgICAqIENvcHlyaWdodCAyMDExLTIwMTkgVGhlIEJvb3RzdHJhcCBBdXRob3JzXG4gICAgICAgICAqIENvcHlyaWdodCAyMDExLTIwMTkgVHdpdHRlciwgSW5jLlxuICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAgICAgICAgKiBGb3JrZWQgZnJvbSBOb3JtYWxpemUuY3NzLCBsaWNlbnNlZCBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZClcbiAgICAgICAgICovXG4gICAgICAgICosXG4gICAgICAgICo6OmJlZm9yZSxcbiAgICAgICAgKjo6YWZ0ZXIge1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XG4gICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFydGljbGUsXG4gICAgICAgIGFzaWRlLFxuICAgICAgICBmaWdjYXB0aW9uLFxuICAgICAgICBmaWd1cmUsXG4gICAgICAgIGZvb3RlcixcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBoZ3JvdXAsXG4gICAgICAgIG1haW4sXG4gICAgICAgIG5hdixcbiAgICAgICAgc2VjdGlvbiB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90byxcbiAgICAgICAgICAgICdIZWx2ZXRpY2EgTmV1ZScsIEFyaWFsLCAnTm90byBTYW5zJywgc2Fucy1zZXJpZixcbiAgICAgICAgICAgICdBcHBsZSBDb2xvciBFbW9qaScsICdTZWdvZSBVSSBFbW9qaScsICdTZWdvZSBVSSBTeW1ib2wnLFxuICAgICAgICAgICAgJ05vdG8gQ29sb3IgRW1vamknO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG4gICAgICAgICAgY29sb3I6ICMyMTI1Mjk7XG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICAgICAgICB9XG5cbiAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xuICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhyIHtcbiAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XG4gICAgICAgIH1cblxuICAgICAgICBoMSxcbiAgICAgICAgaDIsXG4gICAgICAgIGgzLFxuICAgICAgICBoNCxcbiAgICAgICAgaDUsXG4gICAgICAgIGg2IHtcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHAge1xuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFiYnJbdGl0bGVdLFxuICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gICAgICAgICAgY3Vyc29yOiBoZWxwO1xuICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XG4gICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkcmVzcyB7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvbCxcbiAgICAgICAgdWwsXG4gICAgICAgIGRsIHtcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgICAgIH1cblxuICAgICAgICBvbCBvbCxcbiAgICAgICAgdWwgdWwsXG4gICAgICAgIG9sIHVsLFxuICAgICAgICB1bCBvbCB7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGR0IHtcbiAgICAgICAgICBmb250LXdlaWdodDogNzAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGQge1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrcXVvdGUge1xuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XG4gICAgICAgIH1cblxuICAgICAgICBiLFxuICAgICAgICBzdHJvbmcge1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBzbWFsbCB7XG4gICAgICAgICAgZm9udC1zaXplOiA4MCU7XG4gICAgICAgIH1cblxuICAgICAgICBzdWIsXG4gICAgICAgIHN1cCB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YiB7XG4gICAgICAgICAgYm90dG9tOiAtMC4yNWVtO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwIHtcbiAgICAgICAgICB0b3A6IC0wLjVlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEge1xuICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGE6aG92ZXIge1xuICAgICAgICAgIGNvbG9yOiAjMDA1NmIzO1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpub3QoW2hyZWZdKSB7XG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlLFxuICAgICAgICBjb2RlLFxuICAgICAgICBrYmQsXG4gICAgICAgIHNhbXAge1xuICAgICAgICAgIGZvbnQtZmFtaWx5OiBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsXG4gICAgICAgICAgICAnTGliZXJhdGlvbiBNb25vJywgJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMWVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlIHtcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgIH1cblxuICAgICAgICBmaWd1cmUge1xuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XG4gICAgICAgIH1cblxuICAgICAgICBpbWcge1xuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICAgICAgYm9yZGVyLXN0eWxlOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnIHtcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZSB7XG4gICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcHRpb24ge1xuICAgICAgICAgIHBhZGRpbmctdG9wOiAxMnB4O1xuICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAxMnB4O1xuICAgICAgICAgIGNvbG9yOiAjNmM3NTdkO1xuICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgICAgICAgY2FwdGlvbi1zaWRlOiBib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICB0aCB7XG4gICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsIHtcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uIHtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uOmZvY3VzIHtcbiAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xuICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0LFxuICAgICAgICBidXR0b24sXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgb3B0Z3JvdXAsXG4gICAgICAgIHRleHRhcmVhIHtcbiAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XG4gICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBpbnB1dCB7XG4gICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24sXG4gICAgICAgIHNlbGVjdCB7XG4gICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3Qge1xuICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ10sXG4gICAgICAgIFt0eXBlPSdyZXNldCddLFxuICAgICAgICBbdHlwZT0nc3VibWl0J10ge1xuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXG4gICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxuICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcbiAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxuICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcbiAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0W3R5cGU9J3JhZGlvJ10sXG4gICAgICAgIGlucHV0W3R5cGU9J2NoZWNrYm94J10ge1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcbiAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxuICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxuICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0YXJlYSB7XG4gICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkc2V0IHtcbiAgICAgICAgICBtaW4td2lkdGg6IDA7XG4gICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVnZW5kIHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzcyB7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xuICAgICAgICAgIGhlaWdodDogYXV0bztcbiAgICAgICAgfVxuXG4gICAgICAgIFt0eXBlPSdzZWFyY2gnXSB7XG4gICAgICAgICAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcbiAgICAgICAgICBmb250OiBpbmhlcml0O1xuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0IHtcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBzdW1tYXJ5IHtcbiAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBbaGlkZGVuXSB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICBgKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3NzUmVzZXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ3NzUmVzZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsImRlZmF1bHQiLCJSZWFjdCIsIl9ub29wVGVtcGxhdGUiLCJjcmVhdGVFbGVtZW50Iiwibm9vcCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/react-dev-overlay/internal/styles/CssReset.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/redirect.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/components/redirect.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.redirect = redirect;\nexports.isRedirectError = isRedirectError;\nexports.getURLFromRedirectError = getURLFromRedirectError;\nconst REDIRECT_ERROR_CODE = \"NEXT_REDIRECT\";\nfunction redirect(url) {\n    // eslint-disable-next-line no-throw-literal\n    const error = new Error(REDIRECT_ERROR_CODE);\n    error.digest = `${REDIRECT_ERROR_CODE};${url}`;\n    throw error;\n}\nfunction isRedirectError(error) {\n    return typeof (error == null ? void 0 : error.digest) === \"string\" && error.digest.startsWith(REDIRECT_ERROR_CODE + \";\") && error.digest.length > REDIRECT_ERROR_CODE.length + 1;\n}\nfunction getURLFromRedirectError(error) {\n    if (!isRedirectError(error)) return null;\n    // Slices off the beginning of the digest that contains the code and the\n    // separating ';'.\n    return error.digest.slice(REDIRECT_ERROR_CODE.length + 1);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=redirect.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlZGlyZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHRTtBQUNuQkYsdUJBQXVCLEdBQUdHO0FBQzFCSCwrQkFBK0IsR0FBR0k7QUFDbEMsTUFBTUMsc0JBQXNCO0FBQzVCLFNBQVNILFNBQVNJLEdBQUcsRUFBRTtJQUNuQiw0Q0FBNEM7SUFDNUMsTUFBTUMsUUFBUSxJQUFJQyxNQUFNSDtJQUN4QkUsTUFBTUUsTUFBTSxHQUFHLENBQUMsRUFBRUosb0JBQW9CLENBQUMsRUFBRUMsSUFBSSxDQUFDO0lBQzlDLE1BQU1DLE1BQU07QUFDaEI7QUFDQSxTQUFTSixnQkFBZ0JJLEtBQUssRUFBRTtJQUM1QixPQUFPLE9BQVFBLENBQUFBLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSUEsTUFBTUUsTUFBTSxNQUFNLFlBQVlGLE1BQU1FLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDTCxzQkFBc0IsUUFBUUUsTUFBTUUsTUFBTSxDQUFDRSxNQUFNLEdBQUdOLG9CQUFvQk0sTUFBTSxHQUFHO0FBQ25MO0FBQ0EsU0FBU1Asd0JBQXdCRyxLQUFLLEVBQUU7SUFDcEMsSUFBSSxDQUFDSixnQkFBZ0JJLFFBQVEsT0FBTyxJQUFJO0lBQ3hDLHdFQUF3RTtJQUN4RSxrQkFBa0I7SUFDbEIsT0FBT0EsTUFBTUUsTUFBTSxDQUFDRyxLQUFLLENBQUNQLG9CQUFvQk0sTUFBTSxHQUFHO0FBQzNEO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFhLE9BQU8sS0FBSyxjQUFlLE9BQU9iLFFBQVFhLE9BQU8sS0FBSyxZQUFZYixRQUFRYSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9iLFFBQVFhLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktoQixPQUFPQyxjQUFjLENBQUNDLFFBQVFhLE9BQU8sRUFBRSxjQUFjO1FBQUVaLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPaUIsTUFBTSxDQUFDZixRQUFRYSxPQUFPLEVBQUViO0lBQy9CZ0IsT0FBT2hCLE9BQU8sR0FBR0EsUUFBUWEsT0FBTztBQUNsQyxDQUFDLENBRUQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVkaXJlY3QuanM/YjI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVkaXJlY3QgPSByZWRpcmVjdDtcbmV4cG9ydHMuaXNSZWRpcmVjdEVycm9yID0gaXNSZWRpcmVjdEVycm9yO1xuZXhwb3J0cy5nZXRVUkxGcm9tUmVkaXJlY3RFcnJvciA9IGdldFVSTEZyb21SZWRpcmVjdEVycm9yO1xuY29uc3QgUkVESVJFQ1RfRVJST1JfQ09ERSA9ICdORVhUX1JFRElSRUNUJztcbmZ1bmN0aW9uIHJlZGlyZWN0KHVybCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoUkVESVJFQ1RfRVJST1JfQ09ERSk7XG4gICAgZXJyb3IuZGlnZXN0ID0gYCR7UkVESVJFQ1RfRVJST1JfQ09ERX07JHt1cmx9YDtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5kaWdlc3QpID09PSAnc3RyaW5nJyAmJiBlcnJvci5kaWdlc3Quc3RhcnRzV2l0aChSRURJUkVDVF9FUlJPUl9DT0RFICsgJzsnKSAmJiBlcnJvci5kaWdlc3QubGVuZ3RoID4gUkVESVJFQ1RfRVJST1JfQ09ERS5sZW5ndGggKyAxO1xufVxuZnVuY3Rpb24gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIWlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHJldHVybiBudWxsO1xuICAgIC8vIFNsaWNlcyBvZmYgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGlnZXN0IHRoYXQgY29udGFpbnMgdGhlIGNvZGUgYW5kIHRoZVxuICAgIC8vIHNlcGFyYXRpbmcgJzsnLlxuICAgIHJldHVybiBlcnJvci5kaWdlc3Quc2xpY2UoUkVESVJFQ1RfRVJST1JfQ09ERS5sZW5ndGggKyAxKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkaXJlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVkaXJlY3QiLCJpc1JlZGlyZWN0RXJyb3IiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsIlJFRElSRUNUX0VSUk9SX0NPREUiLCJ1cmwiLCJlcnJvciIsIkVycm9yIiwiZGlnZXN0Iiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/redirect.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react).useContext(_appRouterContext.TemplateContext);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsSUFBSUMsNEJBQTRCQyxpS0FBZ0U7QUFDaEcsSUFBSUMsU0FBU0YsMEJBQTBCQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUN0RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGdGQUFxQztBQUNyRSxTQUFTRiw0QkFBNEI7SUFDakMsTUFBTUssV0FBVyxDQUFDLEdBQUdGLE1BQU0sRUFBRUcsVUFBVSxDQUFDRixrQkFBa0JHLGVBQWU7SUFDekUsT0FBTyxXQUFXLEdBQUdKLE9BQU9KLE9BQU8sQ0FBQ1MsYUFBYSxDQUFDTCxPQUFPSixPQUFPLENBQUNVLFFBQVEsRUFBRSxJQUFJLEVBQUVKO0FBQ3JGO0FBR0EsSUFBSSxDQUFDLE9BQU9SLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ1csVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcz84ZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuVGVtcGxhdGVDb250ZXh0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/render-from-template-context.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.applyRouterStatePatchToTree = applyRouterStatePatchToTree;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(sc_client)/./node_modules/next/dist/client/components/match-segments.js\");\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree) {\n    const [segment, parallelRoutes] = initialTree;\n    if ((0, _matchSegments).matchSegment(segment, patchTree[0])) {\n        const newParallelRoutes = {};\n        for(const key in parallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchTree[1][key] !== \"undefined\";\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(parallelRoutes[key], patchTree[1][key]);\n            } else {\n                newParallelRoutes[key] = parallelRoutes[key];\n            }\n        }\n        for(const key1 in patchTree[1]){\n            if (newParallelRoutes[key1]) {\n                continue;\n            }\n            newParallelRoutes[key1] = patchTree[1][key1];\n        }\n        const tree = [\n            segment,\n            newParallelRoutes\n        ];\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = treePatch;\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        _extends({}, parallelRoutes, {\n            [parallelRouteKey]: parallelRoutePatch\n        })\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    return tree;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1DQUFtQyxHQUFHRTtBQUN0QyxJQUFJQyxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUUsaUJBQWlCRixtQkFBT0EsQ0FBQyxtR0FBbUI7QUFDaEQ7O0NBRUMsR0FBRyxTQUFTRyxXQUFXQyxXQUFXLEVBQUVDLFNBQVMsRUFBRTtJQUM1QyxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0g7SUFDbEMsSUFBSSxDQUFDLEdBQUdGLGNBQWMsRUFBRU0sWUFBWSxDQUFDRixTQUFTRCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pELE1BQU1JLG9CQUFvQixDQUFDO1FBQzNCLElBQUksTUFBTUMsT0FBT0gsZUFBZTtZQUM1QixNQUFNSSw4QkFBOEIsT0FBT04sU0FBUyxDQUFDLEVBQUUsQ0FBQ0ssSUFBSSxLQUFLO1lBQ2pFLElBQUlDLDZCQUE2QjtnQkFDN0JGLGlCQUFpQixDQUFDQyxJQUFJLEdBQUdQLFdBQVdJLGNBQWMsQ0FBQ0csSUFBSSxFQUFFTCxTQUFTLENBQUMsRUFBRSxDQUFDSyxJQUFJO1lBQzlFLE9BQU87Z0JBQ0hELGlCQUFpQixDQUFDQyxJQUFJLEdBQUdILGNBQWMsQ0FBQ0csSUFBSTtZQUNoRCxDQUFDO1FBQ0w7UUFDQSxJQUFJLE1BQU1FLFFBQVFQLFNBQVMsQ0FBQyxFQUFFLENBQUM7WUFDM0IsSUFBSUksaUJBQWlCLENBQUNHLEtBQUssRUFBRTtnQkFDekIsUUFBUztZQUNiLENBQUM7WUFDREgsaUJBQWlCLENBQUNHLEtBQUssR0FBR1AsU0FBUyxDQUFDLEVBQUUsQ0FBQ08sS0FBSztRQUNoRDtRQUNBLE1BQU1DLE9BQU87WUFDVFA7WUFDQUc7U0FDSDtRQUNELElBQUlMLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDaEJTLElBQUksQ0FBQyxFQUFFLEdBQUdULFdBQVcsQ0FBQyxFQUFFO1FBQzVCLENBQUM7UUFDRCxJQUFJQSxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ2hCUyxJQUFJLENBQUMsRUFBRSxHQUFHVCxXQUFXLENBQUMsRUFBRTtRQUM1QixDQUFDO1FBQ0QsSUFBSUEsV0FBVyxDQUFDLEVBQUUsRUFBRTtZQUNoQlMsSUFBSSxDQUFDLEVBQUUsR0FBR1QsV0FBVyxDQUFDLEVBQUU7UUFDNUIsQ0FBQztRQUNELE9BQU9TO0lBQ1gsQ0FBQztJQUNELE9BQU9SO0FBQ1g7QUFDQSxTQUFTUCw0QkFBNEJnQixpQkFBaUIsRUFBRUMsaUJBQWlCLEVBQUVDLFNBQVMsRUFBRTtJQUNsRixNQUFNLENBQUNWLFNBQVNDLG9CQUFvQlUsYUFBYSxHQUFHRjtJQUNwRCxlQUFlO0lBQ2YsSUFBSUQsa0JBQWtCSSxNQUFNLEtBQUssR0FBRztRQUNoQyxNQUFNTCxPQUFPVixXQUFXWSxtQkFBbUJDO1FBQzNDLE9BQU9IO0lBQ1gsQ0FBQztJQUNELE1BQU0sQ0FBQ00sZ0JBQWdCQyxpQkFBaUIsR0FBR047SUFDM0MsaUdBQWlHO0lBQ2pHLElBQUksQ0FBQyxDQUFDLEdBQUdaLGNBQWMsRUFBRU0sWUFBWSxDQUFDVyxnQkFBZ0JiLFVBQVU7UUFDNUQsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELE1BQU1lLGNBQWNQLGtCQUFrQkksTUFBTSxLQUFLO0lBQ2pELElBQUlJO0lBQ0osSUFBSUQsYUFBYTtRQUNiQyxxQkFBcUJOO0lBQ3pCLE9BQU87UUFDSE0scUJBQXFCeEIsNEJBQTRCZ0Isa0JBQWtCUyxLQUFLLENBQUMsSUFBSWhCLGNBQWMsQ0FBQ2EsaUJBQWlCLEVBQUVKO1FBQy9HLElBQUlNLHVCQUF1QixJQUFJLEVBQUU7WUFDN0IsT0FBTyxJQUFJO1FBQ2YsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNVCxPQUFPO1FBQ1RDLGlCQUFpQixDQUFDLEVBQUU7UUFDcEJmLFNBQVMsQ0FBQyxHQUFHUSxnQkFBZ0I7WUFDekIsQ0FBQ2EsaUJBQWlCLEVBQUVFO1FBQ3hCO0tBQ0g7SUFDRCxxQ0FBcUM7SUFDckMsSUFBSUwsY0FBYztRQUNkSixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUk7SUFDbEIsQ0FBQztJQUNELE9BQU9BO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT2pCLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ3VCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytCLE1BQU0sQ0FBQzdCLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS5qcz9mN2MzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWU7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4uL21hdGNoLXNlZ21lbnRzXCIpO1xuLyoqXG4gKiBEZWVwIG1lcmdlIG9mIHRoZSB0d28gcm91dGVyIHN0YXRlcy4gUGFyYWxsZWwgcm91dGUga2V5cyBhcmUgcHJlc2VydmVkIGlmIHRoZSBwYXRjaCBkb2Vzbid0IGhhdmUgdGhlbS5cbiAqLyBmdW5jdGlvbiBhcHBseVBhdGNoKGluaXRpYWxUcmVlLCBwYXRjaFRyZWUpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gaW5pdGlhbFRyZWU7XG4gICAgaWYgKCgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KHNlZ21lbnQsIHBhdGNoVHJlZVswXSkpIHtcbiAgICAgICAgY29uc3QgbmV3UGFyYWxsZWxSb3V0ZXMgPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgICAgICBjb25zdCBpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMgPSB0eXBlb2YgcGF0Y2hUcmVlWzFdW2tleV0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKGlzSW5QYXRjaFRyZWVQYXJhbGxlbFJvdXRlcykge1xuICAgICAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBhcHBseVBhdGNoKHBhcmFsbGVsUm91dGVzW2tleV0sIHBhdGNoVHJlZVsxXVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5XSA9IHBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGNvbnN0IGtleTEgaW4gcGF0Y2hUcmVlWzFdKXtcbiAgICAgICAgICAgIGlmIChuZXdQYXJhbGxlbFJvdXRlc1trZXkxXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNba2V5MV0gPSBwYXRjaFRyZWVbMV1ba2V5MV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJlZSA9IFtcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICBuZXdQYXJhbGxlbFJvdXRlc1xuICAgICAgICBdO1xuICAgICAgICBpZiAoaW5pdGlhbFRyZWVbMl0pIHtcbiAgICAgICAgICAgIHRyZWVbMl0gPSBpbml0aWFsVHJlZVsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFRyZWVbM10pIHtcbiAgICAgICAgICAgIHRyZWVbM10gPSBpbml0aWFsVHJlZVszXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFRyZWVbNF0pIHtcbiAgICAgICAgICAgIHRyZWVbNF0gPSBpbml0aWFsVHJlZVs0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoVHJlZTtcbn1cbmZ1bmN0aW9uIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgLCAsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBSb290IHJlZnJlc2hcbiAgICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBhcHBseVBhdGNoKGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9tYXRjaFNlZ21lbnRzIiwiYXBwbHlQYXRjaCIsImluaXRpYWxUcmVlIiwicGF0Y2hUcmVlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwibWF0Y2hTZWdtZW50IiwibmV3UGFyYWxsZWxSb3V0ZXMiLCJrZXkiLCJpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMiLCJrZXkxIiwidHJlZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RMYXlvdXQiLCJsZW5ndGgiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJsYXN0U2VnbWVudCIsInBhcmFsbGVsUm91dGVQYXRjaCIsInNsaWNlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nfunction createHrefFromUrl(url) {\n    return url.pathname + url.search + url.hash;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHlCQUF5QixHQUFHRTtBQUM1QixTQUFTQSxrQkFBa0JDLEdBQUcsRUFBRTtJQUM1QixPQUFPQSxJQUFJQyxRQUFRLEdBQUdELElBQUlFLE1BQU0sR0FBR0YsSUFBSUcsSUFBSTtBQUMvQztBQUVBLElBQUksQ0FBQyxPQUFPTixRQUFRTyxPQUFPLEtBQUssY0FBZSxPQUFPUCxRQUFRTyxPQUFPLEtBQUssWUFBWVAsUUFBUU8sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUCxRQUFRTyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVixPQUFPQyxjQUFjLENBQUNDLFFBQVFPLE9BQU8sRUFBRSxjQUFjO1FBQUVOLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxDQUFDLENBRUQsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwuanM/YTc3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlSHJlZkZyb21VcmwgPSBjcmVhdGVIcmVmRnJvbVVybDtcbmZ1bmN0aW9uIGNyZWF0ZUhyZWZGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1ocmVmLWZyb20tdXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInitialRouterState = createInitialRouterState;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _createHrefFromUrl = __webpack_require__(/*! ./create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nfunction createInitialRouterState({ initialTree , children , initialCanonicalUrl , initialParallelRoutes , isServer , location , initialHead  }) {\n    const cache = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: children,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes\n    };\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialHead);\n    }\n    return {\n        tree: initialTree,\n        cache,\n        prefetchCache: new Map(),\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false\n        },\n        focusAndScrollRef: {\n            apply: false\n        },\n        canonicalUrl: // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n        location ? (0, _createHrefFromUrl).createHrefFromUrl(location) : initialCanonicalUrl\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBR0U7QUFDbkMsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQyxtRkFBd0M7QUFDeEUsSUFBSUMscUJBQXFCRCxtQkFBT0EsQ0FBQyw2SEFBd0I7QUFDekQsSUFBSUUsaUNBQWlDRixtQkFBT0EsQ0FBQywySkFBdUM7QUFDcEYsU0FBU0YseUJBQXlCLEVBQUVLLFlBQVcsRUFBR0MsU0FBUSxFQUFHQyxvQkFBbUIsRUFBR0Msc0JBQXFCLEVBQUdDLFNBQVEsRUFBR0MsU0FBUSxFQUFHQyxZQUFXLEVBQUcsRUFBRTtJQUM3SSxNQUFNQyxRQUFRO1FBQ1ZDLFFBQVFaLGtCQUFrQmEsV0FBVyxDQUFDQyxLQUFLO1FBQzNDQyxNQUFNLElBQUk7UUFDVkMsYUFBYVg7UUFDYixvSkFBb0o7UUFDcEpZLGdCQUFnQlQsV0FBVyxJQUFJVSxRQUFRWCxxQkFBcUI7SUFDaEU7SUFDQSx5RUFBeUU7SUFDekUsSUFBSUEsMEJBQTBCLElBQUksSUFBSUEsc0JBQXNCWSxJQUFJLEtBQUssR0FBRztRQUNuRSxJQUFHaEIsOEJBQThCLEVBQUVpQiw2QkFBNkIsQ0FBQ1QsT0FBT1UsV0FBV2pCLGFBQWFNO0lBQ3JHLENBQUM7SUFDRCxPQUFPO1FBQ0hZLE1BQU1sQjtRQUNOTztRQUNBWSxlQUFlLElBQUlMO1FBQ25CTSxTQUFTO1lBQ0xDLGFBQWEsS0FBSztZQUNsQkMsZUFBZSxLQUFLO1FBQ3hCO1FBQ0FDLG1CQUFtQjtZQUNmQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUMsY0FDQSxrSkFBa0o7UUFDbEpwQixXQUFXLENBQUMsR0FBR1Asa0JBQWtCLEVBQUU0QixpQkFBaUIsQ0FBQ3JCLFlBQVlILG1CQUFtQjtJQUN4RjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFrQyxPQUFPLEtBQUssY0FBZSxPQUFPbEMsUUFBUWtDLE9BQU8sS0FBSyxZQUFZbEMsUUFBUWtDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xDLFFBQVFrQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0MsT0FBTyxFQUFFLGNBQWM7UUFBRWpDLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0MsTUFBTSxDQUFDcEMsUUFBUWtDLE9BQU8sRUFBRWxDO0lBQy9CcUMsT0FBT3JDLE9BQU8sR0FBR0EsUUFBUWtDLE9BQU87QUFDbEMsQ0FBQyxDQUVELHVEQUF1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS5qcz9kY2I0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVJbml0aWFsUm91dGVyU3RhdGUgPSBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGU7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG52YXIgX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkID0gcmVxdWlyZShcIi4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWRcIik7XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoeyBpbml0aWFsVHJlZSAsIGNoaWxkcmVuICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGluaXRpYWxQYXJhbGxlbFJvdXRlcyAsIGlzU2VydmVyICwgbG9jYXRpb24gLCBpbml0aWFsSGVhZCAgfSkge1xuICAgIGNvbnN0IGNhY2hlID0ge1xuICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRyZW4sXG4gICAgICAgIC8vIFRoZSBjYWNoZSBnZXRzIHNlZWRlZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gYGluaXRpYWxQYXJhbGxlbFJvdXRlc2AgZW5zdXJlcyB0aGUgY2FjaGUgZnJvbSB0aGUgZmlyc3QgcmVuZGVyIGlzIHRoZXJlIGR1cmluZyB0aGUgc2Vjb25kIHJlbmRlci5cbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IGlzU2VydmVyID8gbmV3IE1hcCgpIDogaW5pdGlhbFBhcmFsbGVsUm91dGVzXG4gICAgfTtcbiAgICAvLyBXaGVuIHRoZSBjYWNoZSBoYXNuJ3QgYmVlbiBzZWVkZWQgeWV0IHdlIGZpbGwgdGhlIGNhY2hlIHdpdGggdGhlIGhlYWQuXG4gICAgaWYgKGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9PT0gbnVsbCB8fCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAoMCwgX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKS5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgdW5kZWZpbmVkLCBpbml0aWFsVHJlZSwgaW5pdGlhbEhlYWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IG5ldyBNYXAoKSxcbiAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBjYW5vbmljYWxVcmw6IC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgICAgIC8vIFRoaXMgaXMgc2FmZSB0byBkbyBhcyBjYW5vbmljYWxVcmwgY2FuJ3QgYmUgcmVuZGVyZWQsIGl0J3Mgb25seSB1c2VkIHRvIGNvbnRyb2wgdGhlIGhpc3RvcnkgdXBkYXRlcyBpbiB0aGUgdXNlRWZmZWN0IGZ1cnRoZXIgZG93biBpbiB0aGlzIGZpbGUuXG4gICAgICAgIGxvY2F0aW9uID8gKDAsIF9jcmVhdGVIcmVmRnJvbVVybCkuY3JlYXRlSHJlZkZyb21VcmwobG9jYXRpb24pIDogaW5pdGlhbENhbm9uaWNhbFVybFxuICAgIH07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUiLCJfYXBwUm91dGVyQ29udGV4dCIsInJlcXVpcmUiLCJfY3JlYXRlSHJlZkZyb21VcmwiLCJfZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJpbml0aWFsVHJlZSIsImNoaWxkcmVuIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsImlzU2VydmVyIiwibG9jYXRpb24iLCJpbml0aWFsSGVhZCIsImNhY2hlIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJSRUFEWSIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwic2l6ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwidW5kZWZpbmVkIiwidHJlZSIsInByZWZldGNoQ2FjaGUiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsImNhbm9uaWNhbFVybCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js ***!
  \*******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createOptimisticTree = createOptimisticTree;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(sc_client)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction createOptimisticTree(segments, flightRouterState, parentRefetch) {\n    const [existingSegment, existingParallelRoutes, url, refresh, isRootLayout] = flightRouterState || [\n        null,\n        {}\n    ];\n    const segment = segments[0];\n    const isLastSegment = segments.length === 1;\n    const segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n    let parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    let childTree;\n    if (!isLastSegment) {\n        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    const result = [\n        segment,\n        _extends({}, parallelRoutes, childTree ? {\n            children: childTree\n        } : {})\n    ];\n    if (url) {\n        result[2] = url;\n    }\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    } else if (segmentMatches && refresh) {\n        result[3] = refresh;\n    }\n    if (segmentMatches && isRootLayout) {\n        result[4] = isRootLayout;\n    }\n    return result;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-optimistic-tree.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1vcHRpbWlzdGljLXRyZWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsNEJBQTRCLEdBQUdFO0FBQy9CLElBQUlDLFdBQVdDLCtIQUErQztBQUM5RCxJQUFJRSxpQkFBaUJGLG1CQUFPQSxDQUFDLG1HQUFtQjtBQUNoRCxTQUFTRixxQkFBcUJLLFFBQVEsRUFBRUMsaUJBQWlCLEVBQUVDLGFBQWEsRUFBRTtJQUN0RSxNQUFNLENBQUNDLGlCQUFpQkMsd0JBQXdCQyxLQUFLQyxTQUFTQyxhQUFhLEdBQUdOLHFCQUFxQjtRQUMvRixJQUFJO1FBQ0osQ0FBQztLQUNKO0lBQ0QsTUFBTU8sVUFBVVIsUUFBUSxDQUFDLEVBQUU7SUFDM0IsTUFBTVMsZ0JBQWdCVCxTQUFTVSxNQUFNLEtBQUs7SUFDMUMsTUFBTUMsaUJBQWlCUixvQkFBb0IsSUFBSSxJQUFJLENBQUMsR0FBR0osY0FBYyxFQUFFYSxZQUFZLENBQUNULGlCQUFpQks7SUFDckcsTUFBTUsseUJBQXlCLENBQUNaLHFCQUFxQixDQUFDVTtJQUN0RCxJQUFJRyxpQkFBaUIsQ0FBQztJQUN0QixJQUFJWCxvQkFBb0IsSUFBSSxJQUFJUSxnQkFBZ0I7UUFDNUNHLGlCQUFpQlY7SUFDckIsQ0FBQztJQUNELElBQUlXO0lBQ0osSUFBSSxDQUFDTixlQUFlO1FBQ2hCLE1BQU1PLFlBQVlyQixxQkFBcUJLLFNBQVNpQixLQUFLLENBQUMsSUFBSUgsaUJBQWlCQSxlQUFlSSxRQUFRLEdBQUcsSUFBSSxFQUFFaEIsaUJBQWlCVztRQUM1SEUsWUFBWUM7SUFDaEIsQ0FBQztJQUNELE1BQU1HLFNBQVM7UUFDWFg7UUFDQVosU0FBUyxDQUFDLEdBQUdrQixnQkFBZ0JDLFlBQVk7WUFDckNHLFVBQVVIO1FBQ2QsSUFBSSxDQUFDLENBQUM7S0FDVDtJQUNELElBQUlWLEtBQUs7UUFDTGMsTUFBTSxDQUFDLEVBQUUsR0FBR2Q7SUFDaEIsQ0FBQztJQUNELElBQUksQ0FBQ0gsaUJBQWlCVyx3QkFBd0I7UUFDMUNNLE1BQU0sQ0FBQyxFQUFFLEdBQUc7SUFDaEIsT0FBTyxJQUFJUixrQkFBa0JMLFNBQVM7UUFDbENhLE1BQU0sQ0FBQyxFQUFFLEdBQUdiO0lBQ2hCLENBQUM7SUFDRCxJQUFJSyxrQkFBa0JKLGNBQWM7UUFDaENZLE1BQU0sQ0FBQyxFQUFFLEdBQUdaO0lBQ2hCLENBQUM7SUFDRCxPQUFPWTtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU8xQixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNzQixVQUFVLEtBQUssYUFBYTtJQUNySzdCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU84QixNQUFNLENBQUM1QixRQUFRSyxPQUFPLEVBQUVMO0lBQy9CNkIsT0FBTzdCLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLW9wdGltaXN0aWMtdHJlZS5qcz9kZDA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVPcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfbWF0Y2hTZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRjaC1zZWdtZW50c1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcGFyZW50UmVmZXRjaCkge1xuICAgIGNvbnN0IFtleGlzdGluZ1NlZ21lbnQsIGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMsIHVybCwgcmVmcmVzaCwgaXNSb290TGF5b3V0XSA9IGZsaWdodFJvdXRlclN0YXRlIHx8IFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAge31cbiAgICBdO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gc2VnbWVudHMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHNlZ21lbnRNYXRjaGVzID0gZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmICgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk7XG4gICAgY29uc3Qgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCA9ICFmbGlnaHRSb3V0ZXJTdGF0ZSB8fCAhc2VnbWVudE1hdGNoZXM7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVzID0ge307XG4gICAgaWYgKGV4aXN0aW5nU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50TWF0Y2hlcykge1xuICAgICAgICBwYXJhbGxlbFJvdXRlcyA9IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXM7XG4gICAgfVxuICAgIGxldCBjaGlsZFRyZWU7XG4gICAgaWYgKCFpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLnNsaWNlKDEpLCBwYXJhbGxlbFJvdXRlcyA/IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuIDogbnVsbCwgcGFyZW50UmVmZXRjaCB8fCBzaG91bGRSZWZldGNoVGhpc0xldmVsKTtcbiAgICAgICAgY2hpbGRUcmVlID0gY2hpbGRJdGVtO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIF9leHRlbmRzKHt9LCBwYXJhbGxlbFJvdXRlcywgY2hpbGRUcmVlID8ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkVHJlZVxuICAgICAgICB9IDoge30pLCBcbiAgICBdO1xuICAgIGlmICh1cmwpIHtcbiAgICAgICAgcmVzdWx0WzJdID0gdXJsO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFJlZmV0Y2ggJiYgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCkge1xuICAgICAgICByZXN1bHRbM10gPSAncmVmZXRjaCc7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50TWF0Y2hlcyAmJiByZWZyZXNoKSB7XG4gICAgICAgIHJlc3VsdFszXSA9IHJlZnJlc2g7XG4gICAgfVxuICAgIGlmIChzZWdtZW50TWF0Y2hlcyAmJiBpc1Jvb3RMYXlvdXQpIHtcbiAgICAgICAgcmVzdWx0WzRdID0gaXNSb290TGF5b3V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtb3B0aW1pc3RpYy10cmVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZU9wdGltaXN0aWNUcmVlIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9tYXRjaFNlZ21lbnRzIiwic2VnbWVudHMiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInBhcmVudFJlZmV0Y2giLCJleGlzdGluZ1NlZ21lbnQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIiwidXJsIiwicmVmcmVzaCIsImlzUm9vdExheW91dCIsInNlZ21lbnQiLCJpc0xhc3RTZWdtZW50IiwibGVuZ3RoIiwic2VnbWVudE1hdGNoZXMiLCJtYXRjaFNlZ21lbnQiLCJzaG91bGRSZWZldGNoVGhpc0xldmVsIiwicGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFRyZWUiLCJjaGlsZEl0ZW0iLCJzbGljZSIsImNoaWxkcmVuIiwicmVzdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js ***!
  \************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createRecordFromThenable = createRecordFromThenable;\nfunction createRecordFromThenable(thenable) {\n    thenable.status = \"pending\";\n    thenable.then((value)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, (err)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.value = err;\n        }\n    });\n    return thenable;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-record-from-thenable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yZWNvcmQtZnJvbS10aGVuYWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBR0U7QUFDbkMsU0FBU0EseUJBQXlCQyxRQUFRLEVBQUU7SUFDeENBLFNBQVNDLE1BQU0sR0FBRztJQUNsQkQsU0FBU0UsSUFBSSxDQUFDLENBQUNKLFFBQVE7UUFDbkIsSUFBSUUsU0FBU0MsTUFBTSxLQUFLLFdBQVc7WUFDL0JELFNBQVNDLE1BQU0sR0FBRztZQUNsQkQsU0FBU0YsS0FBSyxHQUFHQTtRQUNyQixDQUFDO0lBQ0wsR0FBRyxDQUFDSyxNQUFNO1FBQ04sSUFBSUgsU0FBU0MsTUFBTSxLQUFLLFdBQVc7WUFDL0JELFNBQVNDLE1BQU0sR0FBRztZQUNsQkQsU0FBU0YsS0FBSyxHQUFHSztRQUNyQixDQUFDO0lBQ0w7SUFDQSxPQUFPSDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFPLE9BQU8sS0FBSyxjQUFlLE9BQU9QLFFBQVFPLE9BQU8sS0FBSyxZQUFZUCxRQUFRTyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLFFBQVFPLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU8sT0FBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsUUFBUU8sT0FBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxRQUFRTyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx1REFBdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcmVjb3JkLWZyb20tdGhlbmFibGUuanM/M2EzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlO1xuZnVuY3Rpb24gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgdGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgIHRoZW5hYmxlLnRoZW4oKHZhbHVlKT0+e1xuICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgdGhlbmFibGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHRoZW5hYmxlLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZW5hYmxlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtcmVjb3JkLWZyb20tdGhlbmFibGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwidGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwiZXJyIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fetchServerResponse = fetchServerResponse;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"next/dist/compiled/react-server-dom-webpack/client\");\nvar _appRouterHeaders = __webpack_require__(/*! ../app-router-headers */ \"(sc_client)/./node_modules/next/dist/client/components/app-router-headers.js\");\nvar _appRouter = __webpack_require__(/*! ../app-router */ \"(sc_client)/./node_modules/next/dist/client/components/app-router.js\");\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n    return _fetchServerResponse.apply(this, arguments);\n}\nfunction _fetchServerResponse() {\n    _fetchServerResponse = _async_to_generator(function*(url, flightRouterState, prefetch) {\n        const headers = {\n            // Enable flight response\n            [_appRouterHeaders.RSC]: \"1\",\n            // Provide the current router state\n            [_appRouterHeaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(flightRouterState)\n        };\n        if (prefetch) {\n            // Enable prefetch response\n            headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = \"1\";\n        }\n        const res = yield fetch(url.toString(), {\n            // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n            credentials: \"same-origin\",\n            headers\n        });\n        const canonicalUrl = res.redirected ? (0, _appRouter).urlToUrlWithoutFlightMarker(res.url) : undefined;\n        const isFlightResponse = res.headers.get(\"content-type\") === _appRouterHeaders.RSC_CONTENT_TYPE_HEADER;\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        if (!isFlightResponse) {\n            return [\n                res.url,\n                undefined\n            ];\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightData = yield (0, _client).createFromFetch(Promise.resolve(res));\n        return [\n            flightData,\n            canonicalUrl\n        ];\n    });\n    return _fetchServerResponse.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBR0U7QUFDOUIsSUFBSUMsc0JBQXNCQyxxSkFBMEQ7QUFDcEYsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUMsOEdBQW9EO0FBQzFFLElBQUlHLG9CQUFvQkgsbUJBQU9BLENBQUMsMkdBQXVCO0FBQ3ZELElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLDJGQUFlO0FBRXhDLFNBQVNGLG9CQUFvQk8sR0FBRyxFQUFFQyxpQkFBaUIsRUFBRUMsUUFBUSxFQUFFO0lBQzNELE9BQU9DLHFCQUFxQkMsS0FBSyxDQUFDLElBQUksRUFBRUM7QUFDNUM7QUFDQSxTQUFTRix1QkFBdUI7SUFDNUJBLHVCQUF1QlQsb0JBQW9CLFVBQVVNLEdBQUcsRUFBRUMsaUJBQWlCLEVBQUVDLFFBQVEsRUFBRTtRQUNuRixNQUFNSSxVQUFVO1lBQ1oseUJBQXlCO1lBQ3pCLENBQUNSLGtCQUFrQlMsR0FBRyxDQUFDLEVBQUU7WUFDekIsbUNBQW1DO1lBQ25DLENBQUNULGtCQUFrQlUsc0JBQXNCLENBQUMsRUFBRUMsS0FBS0MsU0FBUyxDQUFDVDtRQUMvRDtRQUNBLElBQUlDLFVBQVU7WUFDViwyQkFBMkI7WUFDM0JJLE9BQU8sQ0FBQ1Isa0JBQWtCYSxvQkFBb0IsQ0FBQyxHQUFHO1FBQ3RELENBQUM7UUFDRCxNQUFNQyxNQUFNLE1BQU1DLE1BQU1iLElBQUljLFFBQVEsSUFBSTtZQUNwQyx3RkFBd0Y7WUFDeEZDLGFBQWE7WUFDYlQ7UUFDSjtRQUNBLE1BQU1VLGVBQWVKLElBQUlLLFVBQVUsR0FBRyxDQUFDLEdBQUdsQixVQUFVLEVBQUVtQiwyQkFBMkIsQ0FBQ04sSUFBSVosR0FBRyxJQUFJbUIsU0FBUztRQUN0RyxNQUFNQyxtQkFBbUJSLElBQUlOLE9BQU8sQ0FBQ2UsR0FBRyxDQUFDLG9CQUFvQnZCLGtCQUFrQndCLHVCQUF1QjtRQUN0Ryw0RkFBNEY7UUFDNUYsSUFBSSxDQUFDRixrQkFBa0I7WUFDbkIsT0FBTztnQkFDSFIsSUFBSVosR0FBRztnQkFDUG1CO2FBQ0g7UUFDTCxDQUFDO1FBQ0QsMkVBQTJFO1FBQzNFLE1BQU1JLGFBQWEsTUFBTSxDQUFDLEdBQUcxQixPQUFPLEVBQUUyQixlQUFlLENBQUNDLFFBQVFDLE9BQU8sQ0FBQ2Q7UUFDdEUsT0FBTztZQUNIVztZQUNBUDtTQUNIO0lBQ0w7SUFDQSxPQUFPYixxQkFBcUJDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQzVDO0FBRUEsSUFBSSxDQUFDLE9BQU9kLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQytCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3VDLE1BQU0sQ0FBQ3JDLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JzQyxPQUFPdEMsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UuanM/ZmE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mZXRjaFNlcnZlclJlc3BvbnNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZTtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9jbGllbnQgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnRcIik7XG52YXIgX2FwcFJvdXRlckhlYWRlcnMgPSByZXF1aXJlKFwiLi4vYXBwLXJvdXRlci1oZWFkZXJzXCIpO1xudmFyIF9hcHBSb3V0ZXIgPSByZXF1aXJlKFwiLi4vYXBwLXJvdXRlclwiKTtcblxuZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIGZsaWdodFJvdXRlclN0YXRlLCBwcmVmZXRjaCkge1xuICAgIHJldHVybiBfZmV0Y2hTZXJ2ZXJSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2ZldGNoU2VydmVyUmVzcG9uc2UoKSB7XG4gICAgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKih1cmwsIGZsaWdodFJvdXRlclN0YXRlLCBwcmVmZXRjaCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgICAgICAgICAgW19hcHBSb3V0ZXJIZWFkZXJzLlJTQ106ICcxJyxcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgICAgICAgICBbX2FwcFJvdXRlckhlYWRlcnMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRV06IEpTT04uc3RyaW5naWZ5KGZsaWdodFJvdXRlclN0YXRlKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBwcmVmZXRjaCByZXNwb25zZVxuICAgICAgICAgICAgaGVhZGVyc1tfYXBwUm91dGVySGVhZGVycy5ORVhUX1JPVVRFUl9QUkVGRVRDSF0gPSAnMSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIG9sZGVyIGJyb3dzZXJzLiBgc2FtZS1vcmlnaW5gIGlzIHRoZSBkZWZhdWx0IGluIG1vZGVybiBicm93c2Vycy5cbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyAoMCwgX2FwcFJvdXRlcikudXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHJlcy51cmwpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpc0ZsaWdodFJlc3BvbnNlID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSA9PT0gX2FwcFJvdXRlckhlYWRlcnMuUlNDX0NPTlRFTlRfVFlQRV9IRUFERVI7XG4gICAgICAgIC8vIElmIGZldGNoIHJldHVybnMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGZsaWdodCByZXNwb25zZSBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByZXMudXJsLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGBmZXRjaGAgcmVhZGFibGUgc3RyZWFtIHRoYXQgY2FuIGJlIHVud3JhcHBlZCBieSBgUmVhY3QudXNlYC5cbiAgICAgICAgY29uc3QgZmxpZ2h0RGF0YSA9IHlpZWxkICgwLCBfY2xpZW50KS5jcmVhdGVGcm9tRmV0Y2goUHJvbWlzZS5yZXNvbHZlKHJlcykpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVybFxuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBfZmV0Y2hTZXJ2ZXJSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1zZXJ2ZXItcmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIl9hc3luY190b19nZW5lcmF0b3IiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9jbGllbnQiLCJfYXBwUm91dGVySGVhZGVycyIsIl9hcHBSb3V0ZXIiLCJ1cmwiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJhcHBseSIsImFyZ3VtZW50cyIsImhlYWRlcnMiLCJSU0MiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFIiwiSlNPTiIsInN0cmluZ2lmeSIsIk5FWFRfUk9VVEVSX1BSRUZFVENIIiwicmVzIiwiZmV0Y2giLCJ0b1N0cmluZyIsImNyZWRlbnRpYWxzIiwiY2Fub25pY2FsVXJsIiwicmVkaXJlY3RlZCIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInVuZGVmaW5lZCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJnZXQiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsImZsaWdodERhdGEiLCJjcmVhdGVGcm9tRmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillCacheWithDataProperty = fillCacheWithDataProperty;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nfunction fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n    const isLastEntry = segments.length === 1;\n    const parallelRouteKey = \"children\";\n    const [segment] = segments;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segment);\n    let childCacheNode = childSegmentMap.get(segment);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segment, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-data-property.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1kYXRhLXByb3BlcnR5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlDQUFpQyxHQUFHRTtBQUNwQyxJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDLG1GQUF3QztBQUN4RSxTQUFTRiwwQkFBMEJHLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRTtJQUNqRixNQUFNQyxjQUFjRixTQUFTRyxNQUFNLEtBQUs7SUFDeEMsTUFBTUMsbUJBQW1CO0lBQ3pCLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHTDtJQUNsQixNQUFNTSwwQkFBMEJQLGNBQWNRLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDSjtJQUNqRSxJQUFJLENBQUNFLHlCQUF5QjtRQUMxQiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFLE9BQU87WUFDSEcsZ0JBQWdCLElBQUk7UUFDeEI7SUFDSixDQUFDO0lBQ0QsSUFBSUMsa0JBQWtCWixTQUFTUyxjQUFjLENBQUNDLEdBQUcsQ0FBQ0o7SUFDbEQsSUFBSSxDQUFDTSxtQkFBbUJBLG9CQUFvQkoseUJBQXlCO1FBQ2pFSSxrQkFBa0IsSUFBSUMsSUFBSUw7UUFDMUJSLFNBQVNTLGNBQWMsQ0FBQ0ssR0FBRyxDQUFDUixrQkFBa0JNO0lBQ2xELENBQUM7SUFDRCxNQUFNRyx5QkFBeUJQLHdCQUF3QkUsR0FBRyxDQUFDSDtJQUMzRCxJQUFJUyxpQkFBaUJKLGdCQUFnQkYsR0FBRyxDQUFDSDtJQUN6Qyx5RkFBeUY7SUFDekYsSUFBSUgsYUFBYTtRQUNiLElBQUksQ0FBQ1ksa0JBQWtCLENBQUNBLGVBQWVDLElBQUksSUFBSUQsbUJBQW1CRCx3QkFBd0I7WUFDdEZILGdCQUFnQkUsR0FBRyxDQUFDUCxTQUFTO2dCQUN6QlcsUUFBUXBCLGtCQUFrQnFCLFdBQVcsQ0FBQ0MsVUFBVTtnQkFDaERILE1BQU1kO2dCQUNOa0IsYUFBYSxJQUFJO2dCQUNqQlosZ0JBQWdCLElBQUlJO1lBQ3hCO1FBQ0osQ0FBQztRQUNEO0lBQ0osQ0FBQztJQUNELElBQUksQ0FBQ0csa0JBQWtCLENBQUNELHdCQUF3QjtRQUM1QywrRUFBK0U7UUFDL0UsSUFBSSxDQUFDQyxnQkFBZ0I7WUFDakJKLGdCQUFnQkUsR0FBRyxDQUFDUCxTQUFTO2dCQUN6QlcsUUFBUXBCLGtCQUFrQnFCLFdBQVcsQ0FBQ0MsVUFBVTtnQkFDaERILE1BQU1kO2dCQUNOa0IsYUFBYSxJQUFJO2dCQUNqQlosZ0JBQWdCLElBQUlJO1lBQ3hCO1FBQ0osQ0FBQztRQUNEO0lBQ0osQ0FBQztJQUNELElBQUlHLG1CQUFtQkQsd0JBQXdCO1FBQzNDQyxpQkFBaUI7WUFDYkUsUUFBUUYsZUFBZUUsTUFBTTtZQUM3QkQsTUFBTUQsZUFBZUMsSUFBSTtZQUN6QkksYUFBYUwsZUFBZUssV0FBVztZQUN2Q1osZ0JBQWdCLElBQUlJLElBQUlHLGVBQWVQLGNBQWM7UUFDekQ7UUFDQUcsZ0JBQWdCRSxHQUFHLENBQUNQLFNBQVNTO0lBQ2pDLENBQUM7SUFDRCxPQUFPbkIsMEJBQTBCbUIsZ0JBQWdCRCx3QkFBd0JiLFNBQVNvQixLQUFLLENBQUMsSUFBSW5CO0FBQ2hHO0FBRUEsSUFBSSxDQUFDLE9BQU9SLFFBQVE0QixPQUFPLEtBQUssY0FBZSxPQUFPNUIsUUFBUTRCLE9BQU8sS0FBSyxZQUFZNUIsUUFBUTRCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzVCLFFBQVE0QixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLL0IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNEIsT0FBTyxFQUFFLGNBQWM7UUFBRTNCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPZ0MsTUFBTSxDQUFDOUIsUUFBUTRCLE9BQU8sRUFBRTVCO0lBQy9CK0IsT0FBTy9CLE9BQU8sR0FBR0EsUUFBUTRCLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1kYXRhLXByb3BlcnR5LmpzP2Y1NTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkgPSBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5O1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuZnVuY3Rpb24gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgc2VnbWVudHMsIGZldGNoUmVzcG9uc2UpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IHNlZ21lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlS2V5ID0gJ2NoaWxkcmVuJztcbiAgICBjb25zdCBbc2VnbWVudF0gPSBzZWdtZW50cztcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFpbE9wdGltaXN0aWM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnQpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoIGluIHRoZSBwbGFjZSB3aGVyZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lc24ndCBoYXZlIHRoZSBkYXRhIHlldC5cbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoUmVzcG9uc2UoKSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIHNlZ21lbnRzLnNsaWNlKDEpLCBmZXRjaFJlc3BvbnNlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsbC1jYWNoZS13aXRoLWRhdGEtcHJvcGVydHkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwicmVxdWlyZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInNlZ21lbnRzIiwiZmV0Y2hSZXNwb25zZSIsImlzTGFzdEVudHJ5IiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInNlZ21lbnQiLCJleGlzdGluZ0NoaWxkU2VnbWVudE1hcCIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwiYmFpbE9wdGltaXN0aWMiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJkYXRhIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJEQVRBX0ZFVENIIiwic3ViVHJlZURhdGEiLCJzbGljZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillCacheWithNewSubTreeData = fillCacheWithNewSubTreeData;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _invalidateCacheByRouterState = __webpack_require__(/*! ./invalidate-cache-by-router-state */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                (0, _invalidateCacheByRouterState).invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n            childSegmentMap.set(segmentForCache, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1DQUFtQyxHQUFHRTtBQUN0QyxJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDLG1GQUF3QztBQUN4RSxJQUFJQyxnQ0FBZ0NELG1CQUFPQSxDQUFDLHFKQUFvQztBQUNoRixJQUFJRSxpQ0FBaUNGLG1CQUFPQSxDQUFDLDJKQUF1QztBQUNwRixTQUFTRiw0QkFBNEJLLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxjQUFjLEVBQUU7SUFDMUUsTUFBTUMsY0FBY0QsZUFBZUUsTUFBTSxJQUFJO0lBQzdDLE1BQU0sQ0FBQ0Msa0JBQWtCQyxRQUFRLEdBQUdKO0lBQ3BDLE1BQU1LLGtCQUFrQkMsTUFBTUMsT0FBTyxDQUFDSCxXQUFXQSxPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPO0lBQ3JFLE1BQU1JLDBCQUEwQlQsY0FBY1UsY0FBYyxDQUFDQyxHQUFHLENBQUNQO0lBQ2pFLElBQUksQ0FBQ0sseUJBQXlCO1FBQzFCLDZFQUE2RTtRQUM3RSxzRUFBc0U7UUFDdEU7SUFDSixDQUFDO0lBQ0QsSUFBSUcsa0JBQWtCYixTQUFTVyxjQUFjLENBQUNDLEdBQUcsQ0FBQ1A7SUFDbEQsSUFBSSxDQUFDUSxtQkFBbUJBLG9CQUFvQkgseUJBQXlCO1FBQ2pFRyxrQkFBa0IsSUFBSUMsSUFBSUo7UUFDMUJWLFNBQVNXLGNBQWMsQ0FBQ0ksR0FBRyxDQUFDVixrQkFBa0JRO0lBQ2xELENBQUM7SUFDRCxNQUFNRyx5QkFBeUJOLHdCQUF3QkUsR0FBRyxDQUFDTDtJQUMzRCxJQUFJVSxpQkFBaUJKLGdCQUFnQkQsR0FBRyxDQUFDTDtJQUN6QyxJQUFJSixhQUFhO1FBQ2IsSUFBSSxDQUFDYyxrQkFBa0IsQ0FBQ0EsZUFBZUMsSUFBSSxJQUFJRCxtQkFBbUJELHdCQUF3QjtZQUN0RkMsaUJBQWlCO2dCQUNiRSxRQUFRdkIsa0JBQWtCd0IsV0FBVyxDQUFDQyxLQUFLO2dCQUMzQ0gsTUFBTSxJQUFJO2dCQUNWSSxhQUFhcEIsY0FBYyxDQUFDLEVBQUU7Z0JBQzlCLG9FQUFvRTtnQkFDcEVTLGdCQUFnQksseUJBQXlCLElBQUlGLElBQUlFLHVCQUF1QkwsY0FBYyxJQUFJLElBQUlHLEtBQUs7WUFDdkc7WUFDQSxJQUFJRSx3QkFBd0I7Z0JBQ3ZCLElBQUdsQiw2QkFBNkIsRUFBRXlCLDRCQUE0QixDQUFDTixnQkFBZ0JELHdCQUF3QmQsY0FBYyxDQUFDLEVBQUU7WUFDN0gsQ0FBQztZQUNBLElBQUdILDhCQUE4QixFQUFFeUIsNkJBQTZCLENBQUNQLGdCQUFnQkQsd0JBQXdCZCxjQUFjLENBQUMsRUFBRSxFQUFFQSxjQUFjLENBQUMsRUFBRTtZQUM5SVcsZ0JBQWdCRSxHQUFHLENBQUNSLGlCQUFpQlU7UUFDekMsQ0FBQztRQUNEO0lBQ0osQ0FBQztJQUNELElBQUksQ0FBQ0Esa0JBQWtCLENBQUNELHdCQUF3QjtRQUM1Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0osQ0FBQztJQUNELElBQUlDLG1CQUFtQkQsd0JBQXdCO1FBQzNDQyxpQkFBaUI7WUFDYkUsUUFBUUYsZUFBZUUsTUFBTTtZQUM3QkQsTUFBTUQsZUFBZUMsSUFBSTtZQUN6QkksYUFBYUwsZUFBZUssV0FBVztZQUN2Q1gsZ0JBQWdCLElBQUlHLElBQUlHLGVBQWVOLGNBQWM7UUFDekQ7UUFDQUUsZ0JBQWdCRSxHQUFHLENBQUNSLGlCQUFpQlU7SUFDekMsQ0FBQztJQUNEdEIsNEJBQTRCc0IsZ0JBQWdCRCx3QkFBd0JkLGVBQWV1QixLQUFLLENBQUM7QUFDN0Y7QUFFQSxJQUFJLENBQUMsT0FBT2hDLFFBQVFpQyxPQUFPLEtBQUssY0FBZSxPQUFPakMsUUFBUWlDLE9BQU8sS0FBSyxZQUFZakMsUUFBUWlDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pDLFFBQVFpQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUMsT0FBTyxFQUFFLGNBQWM7UUFBRWhDLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPcUMsTUFBTSxDQUFDbkMsUUFBUWlDLE9BQU8sRUFBRWpDO0lBQy9Cb0MsT0FBT3BDLE9BQU8sR0FBR0EsUUFBUWlDLE9BQU87QUFDbEMsQ0FBQyxDQUVELDREQUE0RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLmpzPzlmZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSA9IGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2ludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlXCIpO1xudmFyIF9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCA9IHJlcXVpcmUoXCIuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkXCIpO1xuZnVuY3Rpb24gZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIDw9IDU7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3Qgc2VnbWVudEZvckNhY2hlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhY2hpbGRDYWNoZU5vZGUuZGF0YSB8fCBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBmbGlnaHREYXRhUGF0aFszXSxcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2VnbWVudHMgb3RoZXIgdGhhbiB0aGUgb25lIHdlIGdvdCBkYXRhIGZvciBhcmUgcHJlc2VydmVkLlxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID8gbmV3IE1hcChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSA6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9pbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKS5pbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKS5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0sIGZsaWdodERhdGFQYXRoWzRdKTtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IGNoaWxkQ2FjaGVOb2RlLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICB9XG4gICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aC5zbGljZSgyKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwicmVxdWlyZSIsIl9pbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwiX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0RGF0YVBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50Iiwic2VnbWVudEZvckNhY2hlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsImNoaWxkU2VnbWVudE1hcCIsIk1hcCIsInNldCIsImV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUiLCJjaGlsZENhY2hlTm9kZSIsImRhdGEiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIlJFQURZIiwic3ViVHJlZURhdGEiLCJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJzbGljZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js ***!
  \********************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillLazyItemsTillLeafWithHead = fillLazyItemsTillLeafWithHead;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                parallelRouteCacheNode.delete(cacheKey);\n                const newCacheNode = {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes)\n                };\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        const newCacheNode = {\n            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n            data: null,\n            subTreeData: null,\n            parallelRoutes: new Map()\n        };\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHFDQUFxQyxHQUFHRTtBQUN4QyxJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDLG1GQUF3QztBQUN4RSxTQUFTRiw4QkFBOEJHLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxXQUFXLEVBQUVDLElBQUksRUFBRTtJQUMvRSxNQUFNQyxnQkFBZ0JYLE9BQU9ZLElBQUksQ0FBQ0gsV0FBVyxDQUFDLEVBQUUsRUFBRUksTUFBTSxLQUFLO0lBQzdELElBQUlGLGVBQWU7UUFDZkosU0FBU0csSUFBSSxHQUFHQTtRQUNoQjtJQUNKLENBQUM7SUFDRCwrRkFBK0Y7SUFDL0YsSUFBSSxNQUFNSSxPQUFPTCxXQUFXLENBQUMsRUFBRSxDQUFDO1FBQzVCLE1BQU1NLHFCQUFxQk4sV0FBVyxDQUFDLEVBQUUsQ0FBQ0ssSUFBSTtRQUM5QyxNQUFNRSwwQkFBMEJELGtCQUFrQixDQUFDLEVBQUU7UUFDckQsTUFBTUUsV0FBV0MsTUFBTUMsT0FBTyxDQUFDSCwyQkFBMkJBLHVCQUF1QixDQUFDLEVBQUUsR0FBR0EsdUJBQXVCO1FBQzlHLElBQUlSLGVBQWU7WUFDZixNQUFNWSxrQ0FBa0NaLGNBQWNhLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUjtZQUN6RSxJQUFJTSxpQ0FBaUM7Z0JBQ2pDLElBQUlHLHlCQUF5QixJQUFJQyxJQUFJSjtnQkFDckMsTUFBTUssb0JBQW9CRix1QkFBdUJELEdBQUcsQ0FBQ0w7Z0JBQ3JETSx1QkFBdUJHLE1BQU0sQ0FBQ1Q7Z0JBQzlCLE1BQU1VLGVBQWU7b0JBQ2pCQyxRQUFRdkIsa0JBQWtCd0IsV0FBVyxDQUFDQyxnQkFBZ0I7b0JBQ3REQyxNQUFNLElBQUk7b0JBQ1ZDLGFBQWEsSUFBSTtvQkFDakJYLGdCQUFnQixJQUFJRyxJQUFJQyxxQkFBcUIsSUFBSSxHQUFHLEtBQUssSUFBSUEsa0JBQWtCSixjQUFjO2dCQUNqRztnQkFDQUUsdUJBQXVCVSxHQUFHLENBQUNoQixVQUFVVTtnQkFDckN2Qiw4QkFBOEJ1QixjQUFjTyxXQUFXbkIsb0JBQW9CTDtnQkFDM0VILFNBQVNjLGNBQWMsQ0FBQ1ksR0FBRyxDQUFDbkIsS0FBS1M7Z0JBQ2pDLFFBQVM7WUFDYixDQUFDO1FBQ0wsQ0FBQztRQUNELE1BQU1JLGVBQWU7WUFDakJDLFFBQVF2QixrQkFBa0J3QixXQUFXLENBQUNDLGdCQUFnQjtZQUN0REMsTUFBTSxJQUFJO1lBQ1ZDLGFBQWEsSUFBSTtZQUNqQlgsZ0JBQWdCLElBQUlHO1FBQ3hCO1FBQ0EsTUFBTVcseUJBQXlCNUIsU0FBU2MsY0FBYyxDQUFDQyxHQUFHLENBQUNSO1FBQzNELElBQUlxQix3QkFBd0I7WUFDeEJBLHVCQUF1QkYsR0FBRyxDQUFDaEIsVUFBVVU7UUFDekMsT0FBTztZQUNIcEIsU0FBU2MsY0FBYyxDQUFDWSxHQUFHLENBQUNuQixLQUFLLElBQUlVLElBQUk7Z0JBQ3JDO29CQUNJUDtvQkFDQVU7aUJBQ0g7YUFDSjtRQUNMLENBQUM7UUFDRHZCLDhCQUE4QnVCLGNBQWNPLFdBQVduQixvQkFBb0JMO0lBQy9FO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUWtDLE9BQU8sS0FBSyxjQUFlLE9BQU9sQyxRQUFRa0MsT0FBTyxLQUFLLFlBQVlsQyxRQUFRa0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEMsUUFBUWtDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFrQyxPQUFPLEVBQUUsY0FBYztRQUFFakMsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQyxNQUFNLENBQUNwQyxRQUFRa0MsT0FBTyxFQUFFbEM7SUFDL0JxQyxPQUFPckMsT0FBTyxHQUFHQSxRQUFRa0MsT0FBTztBQUNsQyxDQUFDLENBRUQsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQuanM/NmM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgPSBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZDtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmZ1bmN0aW9uIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCByb3V0ZXJTdGF0ZSwgaGVhZCkge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIG5ld0NhY2hlLmhlYWQgPSBoZWFkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWdtZW50IHRoYXQgd2UgZ290IGRhdGEgZm9yIHNvIHRoYXQgaXQgaXMgZmlsbGVkIGluIGR1cmluZyByZW5kZXJpbmcgb2Ygc3ViVHJlZURhdGEuXG4gICAgZm9yKGNvbnN0IGtleSBpbiByb3V0ZXJTdGF0ZVsxXSl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVTdGF0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDYWNoZU5vZGUgPSBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoZXhpc3RpbmdDYWNoZU5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGV4aXN0aW5nQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGVOb2RlLCB1bmRlZmluZWQsIHBhcmFsbGVsUm91dGVTdGF0ZSwgaGVhZCk7XG4gICAgICAgICAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzKSB7XG4gICAgICAgICAgICBleGlzdGluZ1BhcmFsbGVsUm91dGVzLnNldChjYWNoZUtleSwgbmV3Q2FjaGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlTm9kZVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIHVuZGVmaW5lZCwgcGFyYWxsZWxSb3V0ZVN0YXRlLCBoZWFkKTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiX2FwcFJvdXRlckNvbnRleHQiLCJyZXF1aXJlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJoZWFkIiwiaXNMYXN0U2VnbWVudCIsImtleXMiLCJsZW5ndGgiLCJrZXkiLCJwYXJhbGxlbFJvdXRlU3RhdGUiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwicGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSIsIk1hcCIsImV4aXN0aW5nQ2FjaGVOb2RlIiwiZGVsZXRlIiwibmV3Q2FjaGVOb2RlIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJMQVpZX0lOSVRJQUxJWkVEIiwiZGF0YSIsInN1YlRyZWVEYXRhIiwic2V0IiwidW5kZWZpbmVkIiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js ***!
  \**************************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.invalidateCacheBelowFlightSegmentPath = invalidateCacheBelowFlightSegmentPath;\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(segmentForCache);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDZDQUE2QyxHQUFHRTtBQUNoRCxTQUFTQSxzQ0FBc0NDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUIsRUFBRTtJQUN2RixNQUFNQyxjQUFjRCxrQkFBa0JFLE1BQU0sSUFBSTtJQUNoRCxNQUFNLENBQUNDLGtCQUFrQkMsUUFBUSxHQUFHSjtJQUNwQyxNQUFNSyxrQkFBa0JDLE1BQU1DLE9BQU8sQ0FBQ0gsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTztJQUNyRSxNQUFNSSwwQkFBMEJULGNBQWNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtJQUNqRSxJQUFJLENBQUNLLHlCQUF5QjtRQUMxQiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0osQ0FBQztJQUNELElBQUlHLGtCQUFrQmIsU0FBU1csY0FBYyxDQUFDQyxHQUFHLENBQUNQO0lBQ2xELElBQUksQ0FBQ1EsbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNqRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVixTQUFTVyxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Ysa0JBQWtCUTtJQUNsRCxDQUFDO0lBQ0QsaURBQWlEO0lBQ2pELElBQUlWLGFBQWE7UUFDYlUsZ0JBQWdCRyxNQUFNLENBQUNUO1FBQ3ZCO0lBQ0osQ0FBQztJQUNELE1BQU1VLHlCQUF5QlAsd0JBQXdCRSxHQUFHLENBQUNMO0lBQzNELElBQUlXLGlCQUFpQkwsZ0JBQWdCRCxHQUFHLENBQUNMO0lBQ3pDLElBQUksQ0FBQ1csa0JBQWtCLENBQUNELHdCQUF3QjtRQUM1Qyw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0osQ0FBQztJQUNELElBQUlDLG1CQUFtQkQsd0JBQXdCO1FBQzNDQyxpQkFBaUI7WUFDYkMsUUFBUUQsZUFBZUMsTUFBTTtZQUM3QkMsTUFBTUYsZUFBZUUsSUFBSTtZQUN6QkMsYUFBYUgsZUFBZUcsV0FBVztZQUN2Q1YsZ0JBQWdCLElBQUlHLElBQUlJLGVBQWVQLGNBQWM7UUFDekQ7UUFDQUUsZ0JBQWdCRSxHQUFHLENBQUNSLGlCQUFpQlc7SUFDekMsQ0FBQztJQUNEbkIsc0NBQXNDbUIsZ0JBQWdCRCx3QkFBd0JmLGtCQUFrQm9CLEtBQUssQ0FBQztBQUMxRztBQUVBLElBQUksQ0FBQyxPQUFPekIsUUFBUTBCLE9BQU8sS0FBSyxjQUFlLE9BQU8xQixRQUFRMEIsT0FBTyxLQUFLLFlBQVkxQixRQUFRMEIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPMUIsUUFBUTBCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks3QixPQUFPQyxjQUFjLENBQUNDLFFBQVEwQixPQUFPLEVBQUUsY0FBYztRQUFFekIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU84QixNQUFNLENBQUM1QixRQUFRMEIsT0FBTyxFQUFFMUI7SUFDL0I2QixPQUFPN0IsT0FBTyxHQUFHQSxRQUFRMEIsT0FBTztBQUNsQyxDQUFDLENBRUQscUVBQXFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGguanM/OGZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCA9IGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGg7XG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDI7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0U2VnbWVudFBhdGg7XG4gICAgY29uc3Qgc2VnbWVudEZvckNhY2hlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgLy8gSW4gY2FzZSBvZiBsYXN0IGVudHJ5IGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuZGVsZXRlKHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IGNoaWxkQ2FjaGVOb2RlLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMikpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50Iiwic2VnbWVudEZvckNhY2hlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsImNoaWxkU2VnbWVudE1hcCIsIk1hcCIsInNldCIsImRlbGV0ZSIsImV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUiLCJjaGlsZENhY2hlTm9kZSIsInN0YXR1cyIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.invalidateCacheByRouterState = invalidateCacheByRouterState;\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-by-router-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG9DQUFvQyxHQUFHRTtBQUN2QyxTQUFTQSw2QkFBNkJDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxXQUFXLEVBQUU7SUFDeEUsK0ZBQStGO0lBQy9GLElBQUksTUFBTUMsT0FBT0QsV0FBVyxDQUFDLEVBQUUsQ0FBQztRQUM1QixNQUFNRSwwQkFBMEJGLFdBQVcsQ0FBQyxFQUFFLENBQUNDLElBQUksQ0FBQyxFQUFFO1FBQ3RELE1BQU1FLFdBQVdDLE1BQU1DLE9BQU8sQ0FBQ0gsMkJBQTJCQSx1QkFBdUIsQ0FBQyxFQUFFLEdBQUdBLHVCQUF1QjtRQUM5RyxNQUFNSSxrQ0FBa0NQLGNBQWNRLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtRQUN6RSxJQUFJSyxpQ0FBaUM7WUFDakMsSUFBSUcseUJBQXlCLElBQUlDLElBQUlKO1lBQ3JDRyx1QkFBdUJFLE1BQU0sQ0FBQ1I7WUFDOUJMLFNBQVNTLGNBQWMsQ0FBQ0ssR0FBRyxDQUFDWCxLQUFLUTtRQUNyQyxDQUFDO0lBQ0w7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPZCxRQUFRa0IsT0FBTyxLQUFLLGNBQWUsT0FBT2xCLFFBQVFrQixPQUFPLEtBQUssWUFBWWxCLFFBQVFrQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9sQixRQUFRa0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3JCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWtCLE9BQU8sRUFBRSxjQUFjO1FBQUVqQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS5qcz8wNjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlID0gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZTtcbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlKSB7XG4gICAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiBzdWJUcmVlRGF0YS5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwia2V5Iiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJkZWxldGUiLCJzZXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isNavigatingToNewRootLayout = isNavigatingToNewRootLayout;\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1DQUFtQyxHQUFHRTtBQUN0QyxTQUFTQSw0QkFBNEJDLFdBQVcsRUFBRUMsUUFBUSxFQUFFO0lBQ3hELG1CQUFtQjtJQUNuQixNQUFNQyxxQkFBcUJGLFdBQVcsQ0FBQyxFQUFFO0lBQ3pDLE1BQU1HLGtCQUFrQkYsUUFBUSxDQUFDLEVBQUU7SUFDbkMsMkZBQTJGO0lBQzNGLDREQUE0RDtJQUM1RCx1SUFBdUk7SUFDdkksSUFBSUcsTUFBTUMsT0FBTyxDQUFDSCx1QkFBdUJFLE1BQU1DLE9BQU8sQ0FBQ0Ysa0JBQWtCO1FBQ3JFLHNIQUFzSDtRQUN0SCx1R0FBdUc7UUFDdkcsSUFBSUQsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxJQUFJRCxrQkFBa0IsQ0FBQyxFQUFFLEtBQUtDLGVBQWUsQ0FBQyxFQUFFLEVBQUU7WUFDOUYsT0FBTyxJQUFJO1FBQ2YsQ0FBQztJQUNMLE9BQU8sSUFBSUQsdUJBQXVCQyxpQkFBaUI7UUFDL0MsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELGlDQUFpQztJQUNqQyxJQUFJSCxXQUFXLENBQUMsRUFBRSxFQUFFO1FBQ2hCLDRFQUE0RTtRQUM1RSxPQUFPLENBQUNDLFFBQVEsQ0FBQyxFQUFFO0lBQ3ZCLENBQUM7SUFDRCxxRUFBcUU7SUFDckUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsRUFBRTtRQUNiLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCw0R0FBNEc7SUFDNUcsMkZBQTJGO0lBQzNGLG1EQUFtRDtJQUNuRCxNQUFNSyxtQkFBbUJYLE9BQU9ZLE1BQU0sQ0FBQ1AsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDekQsTUFBTVEsZ0JBQWdCYixPQUFPWSxNQUFNLENBQUNOLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ25ELElBQUksQ0FBQ0ssb0JBQW9CLENBQUNFLGVBQWUsT0FBTyxJQUFJO0lBQ3BELE9BQU9ULDRCQUE0Qk8sa0JBQWtCRTtBQUN6RDtBQUVBLElBQUksQ0FBQyxPQUFPWCxRQUFRWSxPQUFPLEtBQUssY0FBZSxPQUFPWixRQUFRWSxPQUFPLEtBQUssWUFBWVosUUFBUVksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPWixRQUFRWSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLZixPQUFPQyxjQUFjLENBQUNDLFFBQVFZLE9BQU8sRUFBRSxjQUFjO1FBQUVYLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPZ0IsTUFBTSxDQUFDZCxRQUFRWSxPQUFPLEVBQUVaO0lBQy9CZSxPQUFPZixPQUFPLEdBQUdBLFFBQVFZLE9BQU87QUFDbEMsQ0FBQyxDQUVELDREQUE0RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0LmpzP2NjNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dDtcbmZ1bmN0aW9uIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV4dFRyZWUpIHtcbiAgICAvLyBDb21wYXJlIHNlZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyZWVTZWdtZW50ID0gY3VycmVudFRyZWVbMF07XG4gICAgY29uc3QgbmV4dFRyZWVTZWdtZW50ID0gbmV4dFRyZWVbMF07XG4gICAgLy8gSWYgYW55IHNlZ21lbnQgaXMgZGlmZmVyZW50IGJlZm9yZSB3ZSBmaW5kIHRoZSByb290IGxheW91dCwgdGhlIHJvb3QgbGF5b3V0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEUuZy4gL3NhbWUvKGdyb3VwMSkvbGF5b3V0LmpzIC0+IC9zYW1lLyhncm91cDIpL2xheW91dC5qc1xuICAgIC8vIEZpcnN0IHNlZ21lbnQgaXMgJ3NhbWUnIGZvciBib3RoLCBrZWVwIGxvb2tpbmcuIChncm91cDEpIGNoYW5nZWQgdG8gKGdyb3VwMikgYmVmb3JlIHRoZSByb290IGxheW91dCB3YXMgZm91bmQsIGl0IG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRUcmVlU2VnbWVudCkgJiYgQXJyYXkuaXNBcnJheShuZXh0VHJlZVNlZ21lbnQpKSB7XG4gICAgICAgIC8vIENvbXBhcmUgZHluYW1pYyBwYXJhbSBuYW1lIGFuZCB0eXBlIGJ1dCBpZ25vcmUgdGhlIHZhbHVlLCBkaWZmZXJlbnQgdmFsdWVzIHdvdWxkIG5vdCBhZmZlY3QgdGhlIGN1cnJlbnQgcm9vdCBsYXlvdXRcbiAgICAgICAgLy8gL1tuYW1lXSAtIC9zbHVnMSBhbmQgL3NsdWcyLCBib3RoIHZhbHVlcyAoc2x1ZzEgJiBzbHVnMikgc3RpbGwgaGFzIHRoZSBzYW1lIGxheW91dCAvW25hbWVdL2xheW91dC5qc1xuICAgICAgICBpZiAoY3VycmVudFRyZWVTZWdtZW50WzBdICE9PSBuZXh0VHJlZVNlZ21lbnRbMF0gfHwgY3VycmVudFRyZWVTZWdtZW50WzJdICE9PSBuZXh0VHJlZVNlZ21lbnRbMl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VHJlZVNlZ21lbnQgIT09IG5leHRUcmVlU2VnbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQ3VycmVudCB0cmVlIHJvb3QgbGF5b3V0IGZvdW5kXG4gICAgaWYgKGN1cnJlbnRUcmVlWzRdKSB7XG4gICAgICAgIC8vIElmIHRoZSBuZXh0IHRyZWUgZG9lc24ndCBoYXZlIHRoZSByb290IGxheW91dCBmbGFnLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgcmV0dXJuICFuZXh0VHJlZVs0XTtcbiAgICB9XG4gICAgLy8gQ3VycmVudCB0cmVlICBkaWRuJ3QgaGF2ZSBpdHMgcm9vdCBsYXlvdXQgaGVyZSwgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgaWYgKG5leHRUcmVlWzRdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBXZSBjYW4ndCBhc3N1bWUgaXQncyBgcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW5gIGhlcmUgaW4gY2FzZSB0aGUgcm9vdCBsYXlvdXQgaXMgYGFwcC9Ac29tZXRoaW5nL2xheW91dC5qc2BcbiAgICAvLyBCdXQgaXQncyBub3QgcG9zc2libGUgdG8gYmUgbW9yZSB0aGFuIG9uZSBwYXJhbGxlbFJvdXRlcyBiZWZvcmUgdGhlIHJvb3QgbGF5b3V0IGlzIGZvdW5kXG4gICAgLy8gVE9ETy1BUFA6IGNoYW5nZSB0byB0cmF2ZXJzZSBhbGwgcGFyYWxsZWwgcm91dGVzXG4gICAgY29uc3QgY3VycmVudFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMoY3VycmVudFRyZWVbMV0pWzBdO1xuICAgIGNvbnN0IG5leHRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKG5leHRUcmVlWzFdKVswXTtcbiAgICBpZiAoIWN1cnJlbnRUcmVlQ2hpbGQgfHwgIW5leHRUcmVlQ2hpbGQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWVDaGlsZCwgbmV4dFRyZWVDaGlsZCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImN1cnJlbnRUcmVlIiwibmV4dFRyZWUiLCJjdXJyZW50VHJlZVNlZ21lbnQiLCJuZXh0VHJlZVNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJjdXJyZW50VHJlZUNoaWxkIiwidmFsdWVzIiwibmV4dFRyZWVDaGlsZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/read-record-value.js ***!
  \**************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.readRecordValue = readRecordValue;\nfunction readRecordValue(thenable) {\n    // @ts-expect-error TODO: fix type\n    if (thenable.status === \"fulfilled\") {\n        // @ts-expect-error TODO: fix type\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=read-record-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlYWQtcmVjb3JkLXZhbHVlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRTtBQUMxQixTQUFTQSxnQkFBZ0JDLFFBQVEsRUFBRTtJQUMvQixrQ0FBa0M7SUFDbEMsSUFBSUEsU0FBU0MsTUFBTSxLQUFLLGFBQWE7UUFDakMsa0NBQWtDO1FBQ2xDLE9BQU9ELFNBQVNGLEtBQUs7SUFDekIsT0FBTztRQUNILE1BQU1FLFNBQVM7SUFDbkIsQ0FBQztBQUNMO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktSLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9TLE1BQU0sQ0FBQ1AsUUFBUUssT0FBTyxFQUFFTDtJQUMvQlEsT0FBT1IsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWFkLXJlY29yZC12YWx1ZS5qcz9lN2M2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkUmVjb3JkVmFsdWUgPSByZWFkUmVjb3JkVmFsdWU7XG5mdW5jdGlvbiByZWFkUmVjb3JkVmFsdWUodGhlbmFibGUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpeCB0eXBlXG4gICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkLXJlY29yZC12YWx1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWFkUmVjb3JkVmFsdWUiLCJ0aGVuYWJsZSIsInN0YXR1cyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.findHeadInCache = findHeadInCache;\nfunction findHeadInCache(childSegmentMap, parallelRoutes) {\n    if (!childSegmentMap) {\n        return undefined;\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const isLastItem = Object.keys(childParallelRoutes).length === 0;\n        const cacheKey = Array.isArray(segment) ? segment[1] : segment;\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        if (isLastItem && cacheNode.head) return cacheNode.head;\n        const segmentMap = cacheNode.parallelRoutes.get(key);\n        if (segmentMap) {\n            const item = findHeadInCache(segmentMap, childParallelRoutes);\n            if (item) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsU0FBU0EsZ0JBQWdCQyxlQUFlLEVBQUVDLGNBQWMsRUFBRTtJQUN0RCxJQUFJLENBQUNELGlCQUFpQjtRQUNsQixPQUFPRTtJQUNYLENBQUM7SUFDRCxJQUFJLE1BQU1DLE9BQU9GLGVBQWU7UUFDNUIsTUFBTSxDQUFDRyxTQUFTQyxvQkFBb0IsR0FBR0osY0FBYyxDQUFDRSxJQUFJO1FBQzFELE1BQU1HLGFBQWFYLE9BQU9ZLElBQUksQ0FBQ0YscUJBQXFCRyxNQUFNLEtBQUs7UUFDL0QsTUFBTUMsV0FBV0MsTUFBTUMsT0FBTyxDQUFDUCxXQUFXQSxPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPO1FBQzlELE1BQU1RLFlBQVlaLGdCQUFnQmEsR0FBRyxDQUFDSjtRQUN0QyxJQUFJLENBQUNHLFdBQVc7WUFDWixRQUFTO1FBQ2IsQ0FBQztRQUNELElBQUlOLGNBQWNNLFVBQVVFLElBQUksRUFBRSxPQUFPRixVQUFVRSxJQUFJO1FBQ3ZELE1BQU1DLGFBQWFILFVBQVVYLGNBQWMsQ0FBQ1ksR0FBRyxDQUFDVjtRQUNoRCxJQUFJWSxZQUFZO1lBQ1osTUFBTUMsT0FBT2pCLGdCQUFnQmdCLFlBQVlWO1lBQ3pDLElBQUlXLE1BQU07Z0JBQ04sT0FBT0E7WUFDWCxDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsT0FBT2Q7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPTCxRQUFRb0IsT0FBTyxLQUFLLGNBQWUsT0FBT3BCLFFBQVFvQixPQUFPLEtBQUssWUFBWXBCLFFBQVFvQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9wQixRQUFRb0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3ZCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW9CLE9BQU8sRUFBRSxjQUFjO1FBQUVuQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3dCLE1BQU0sQ0FBQ3RCLFFBQVFvQixPQUFPLEVBQUVwQjtJQUMvQnVCLE9BQU92QixPQUFPLEdBQUdBLFFBQVFvQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUuanM/NzVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmluZEhlYWRJbkNhY2hlID0gZmluZEhlYWRJbkNhY2hlO1xuZnVuY3Rpb24gZmluZEhlYWRJbkNhY2hlKGNoaWxkU2VnbWVudE1hcCwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IoY29uc3Qga2V5IGluIHBhcmFsbGVsUm91dGVzKXtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XTtcbiAgICAgICAgY29uc3QgaXNMYXN0SXRlbSA9IE9iamVjdC5rZXlzKGNoaWxkUGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEl0ZW0gJiYgY2FjaGVOb2RlLmhlYWQpIHJldHVybiBjYWNoZU5vZGUuaGVhZDtcbiAgICAgICAgY29uc3Qgc2VnbWVudE1hcCA9IGNhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHNlZ21lbnRNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGUoc2VnbWVudE1hcCwgY2hpbGRQYXJhbGxlbFJvdXRlcyk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmQtaGVhZC1pbi1jYWNoZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaW5kSGVhZEluQ2FjaGUiLCJjaGlsZFNlZ21lbnRNYXAiLCJwYXJhbGxlbFJvdXRlcyIsInVuZGVmaW5lZCIsImtleSIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiaXNMYXN0SXRlbSIsImtleXMiLCJsZW5ndGgiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImNhY2hlTm9kZSIsImdldCIsImhlYWQiLCJzZWdtZW50TWFwIiwiaXRlbSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleMutable = handleMutable;\nexports.applyFlightData = applyFlightData;\nexports.handleExternalUrl = handleExternalUrl;\nexports.navigateReducer = navigateReducer;\nvar _appRouterContext = __webpack_require__(/*! ../../../../shared/lib/app-router-context */ \"../../shared/lib/app-router-context\");\nvar _fetchServerResponse = __webpack_require__(/*! ../fetch-server-response */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _createRecordFromThenable = __webpack_require__(/*! ../create-record-from-thenable */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\");\nvar _readRecordValue = __webpack_require__(/*! ../read-record-value */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nvar _fillCacheWithNewSubtreeData = __webpack_require__(/*! ../fill-cache-with-new-subtree-data */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\");\nvar _invalidateCacheBelowFlightSegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nvar _fillCacheWithDataProperty = __webpack_require__(/*! ../fill-cache-with-data-property */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js\");\nvar _createOptimisticTree = __webpack_require__(/*! ../create-optimistic-tree */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _shouldHardNavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nfunction handleMutable(state, mutable) {\n    return {\n        // Set href.\n        canonicalUrl: typeof mutable.canonicalUrl !== \"undefined\" ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: typeof mutable.pendingPush !== \"undefined\" ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: typeof mutable.mpaNavigation !== \"undefined\" ? mutable.mpaNavigation : state.pushRef.mpaNavigation\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: typeof mutable.applyFocusAndScroll !== \"undefined\" ? mutable.applyFocusAndScroll : state.focusAndScrollRef.apply\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: state.prefetchCache,\n        // Apply patched router state.\n        tree: typeof mutable.patchedTree !== \"undefined\" ? mutable.patchedTree : state.tree\n    };\n}\nfunction applyFlightData(state, cache, flightDataPath) {\n    // The one before last item is the router state tree patch\n    const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (subTreeData === null) {\n        return false;\n    }\n    if (flightDataPath.length === 3) {\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = subTreeData;\n        (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n    } else {\n        // Copy subTreeData for the root node of the cache.\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = state.cache.subTreeData;\n        // Create a copy of the existing cache with the subTreeData applied.\n        (0, _fillCacheWithNewSubtreeData).fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n    }\n    return true;\n}\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.previousTree = state.tree;\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.applyFocusAndScroll = false;\n    return handleMutable(state, mutable);\n}\nfunction navigateReducer(state, action) {\n    const { url , isExternalUrl , locationSearch , navigateType , cache , mutable , forceOptimisticNavigation  } = action;\n    const { pathname , search  } = url;\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    const pendingPush = navigateType === \"push\";\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = state.prefetchCache.get(href);\n    if (prefetchValues) {\n        // The one before last item is the router state tree patch\n        const { flightData , tree: newTree , canonicalUrlOverride  } = prefetchValues;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        if (newTree !== null) {\n            if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n                return handleExternalUrl(state, mutable, href, pendingPush);\n            }\n            // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n            const flightDataPath = flightData[0];\n            const flightSegmentPath = flightDataPath.slice(0, -3);\n            const applied = applyFlightData(state, cache, flightDataPath);\n            const hardNavigate = search !== locationSearch || (0, _shouldHardNavigate).shouldHardNavigate([\n                \"\",\n                ...flightSegmentPath\n            ], state.tree);\n            if (hardNavigate) {\n                cache.status = _appRouterContext.CacheStates.READY;\n                // Copy subTreeData for the root node of the cache.\n                cache.subTreeData = state.cache.subTreeData;\n                (0, _invalidateCacheBelowFlightSegmentpath).invalidateCacheBelowFlightSegmentPath(cache, state.cache, flightSegmentPath);\n                // Ensure the existing cache value is used when the cache was not invalidated.\n                mutable.cache = cache;\n            } else if (applied) {\n                mutable.cache = cache;\n            }\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = newTree;\n            mutable.applyFocusAndScroll = true;\n            mutable.canonicalUrl = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : href;\n            mutable.pendingPush = pendingPush;\n            return handleMutable(state, mutable);\n        }\n    }\n    // When doing a hard push there can be two cases: with optimistic tree and without\n    // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n    // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n    // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n    if (forceOptimisticNavigation) {\n        const segments = pathname.split(\"/\");\n        // TODO-APP: figure out something better for index pages\n        segments.push(\"\");\n        // Optimistic tree case.\n        // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n        const optimisticTree = (0, _createOptimisticTree).createOptimisticTree(segments, state.tree, false);\n        // Copy subTreeData for the root node of the cache.\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = state.cache.subTreeData;\n        // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n        // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n        const res = (0, _fillCacheWithDataProperty).fillCacheWithDataProperty(cache, state.cache, segments.slice(1), ()=>(0, _fetchServerResponse).fetchServerResponse(url, optimisticTree));\n        // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n        if (!(res == null ? void 0 : res.bailOptimistic)) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = optimisticTree;\n            mutable.pendingPush = pendingPush;\n            mutable.applyFocusAndScroll = true;\n            mutable.cache = cache;\n            mutable.canonicalUrl = href;\n            return handleMutable(state, mutable);\n        }\n    }\n    // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n    // If no in-flight fetch at the top, start it.\n    if (!cache.data) {\n        cache.data = (0, _createRecordFromThenable).createRecordFromThenable((0, _fetchServerResponse).fetchServerResponse(url, state.tree));\n    }\n    // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n    const [flightData, canonicalUrlOverride] = (0, _readRecordValue).readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // The one before last item is the router state tree patch\n    const [treePatch] = flightDataPath.slice(-3, -2);\n    // Path without the last segment, router state, and the subTreeData\n    const flightSegmentPath = flightDataPath.slice(0, -4);\n    // Create new tree based on the flightSegmentPath and router state patch\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    mutable.canonicalUrl = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : href;\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.applyFocusAndScroll = true;\n    mutable.pendingPush = pendingPush;\n    const applied = applyFlightData(state, cache, flightDataPath);\n    if (applied) {\n        mutable.cache = cache;\n    }\n    return handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL25hdmlnYXRlLXJlZHVjZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdFO0FBQ3hCRix1QkFBdUIsR0FBR0c7QUFDMUJILHlCQUF5QixHQUFHSTtBQUM1QkosdUJBQXVCLEdBQUdLO0FBQzFCLElBQUlDLG9CQUFvQkMsbUJBQU9BLENBQUMsc0ZBQTJDO0FBQzNFLElBQUlDLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0lBQTBCO0FBQzdELElBQUlFLDRCQUE0QkYsbUJBQU9BLENBQUMsNElBQWdDO0FBQ3hFLElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUMsd0hBQXNCO0FBQ3JELElBQUlJLHFCQUFxQkosbUJBQU9BLENBQUMsOEhBQXlCO0FBQzFELElBQUlLLGlDQUFpQ0wsbUJBQU9BLENBQUMsNEpBQXdDO0FBQ3JGLElBQUlNLCtCQUErQk4sbUJBQU9BLENBQUMsc0pBQXFDO0FBQ2hGLElBQUlPLHlDQUF5Q1AsbUJBQU9BLENBQUMsd0tBQThDO0FBQ25HLElBQUlRLDZCQUE2QlIsbUJBQU9BLENBQUMsZ0pBQWtDO0FBQzNFLElBQUlTLHdCQUF3QlQsbUJBQU9BLENBQUMsa0lBQTJCO0FBQy9ELElBQUlVLCtCQUErQlYsbUJBQU9BLENBQUMsc0pBQXFDO0FBQ2hGLElBQUlXLHNCQUFzQlgsbUJBQU9BLENBQUMsOEhBQXlCO0FBQzNELElBQUlZLCtCQUErQlosbUJBQU9BLENBQUMsc0pBQXFDO0FBQ2hGLFNBQVNMLGNBQWNrQixLQUFLLEVBQUVDLE9BQU8sRUFBRTtJQUNuQyxPQUFPO1FBQ0gsWUFBWTtRQUNaQyxjQUFjLE9BQU9ELFFBQVFDLFlBQVksS0FBSyxjQUFjRCxRQUFRQyxZQUFZLEtBQUtGLE1BQU1FLFlBQVks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QUFRb0YsT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci5qcz9kODE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYW5kbGVNdXRhYmxlID0gaGFuZGxlTXV0YWJsZTtcbmV4cG9ydHMuYXBwbHlGbGlnaHREYXRhID0gYXBwbHlGbGlnaHREYXRhO1xuZXhwb3J0cy5oYW5kbGVFeHRlcm5hbFVybCA9IGhhbmRsZUV4dGVybmFsVXJsO1xuZXhwb3J0cy5uYXZpZ2F0ZVJlZHVjZXIgPSBuYXZpZ2F0ZVJlZHVjZXI7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xudmFyIF9jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUgPSByZXF1aXJlKFwiLi4vY3JlYXRlLXJlY29yZC1mcm9tLXRoZW5hYmxlXCIpO1xudmFyIF9yZWFkUmVjb3JkVmFsdWUgPSByZXF1aXJlKFwiLi4vcmVhZC1yZWNvcmQtdmFsdWVcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xudmFyIF9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCA9IHJlcXVpcmUoXCIuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbnZhciBfZmlsbENhY2hlV2l0aE5ld1N1YnRyZWVEYXRhID0gcmVxdWlyZShcIi4uL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhXCIpO1xudmFyIF9pbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRwYXRoID0gcmVxdWlyZShcIi4uL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoXCIpO1xudmFyIF9maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2ZpbGwtY2FjaGUtd2l0aC1kYXRhLXByb3BlcnR5XCIpO1xudmFyIF9jcmVhdGVPcHRpbWlzdGljVHJlZSA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtb3B0aW1pc3RpYy10cmVlXCIpO1xudmFyIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG52YXIgX3Nob3VsZEhhcmROYXZpZ2F0ZSA9IHJlcXVpcmUoXCIuLi9zaG91bGQtaGFyZC1uYXZpZ2F0ZVwiKTtcbnZhciBfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuZnVuY3Rpb24gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICBjYW5vbmljYWxVcmw6IHR5cGVvZiBtdXRhYmxlLmNhbm9uaWNhbFVybCAhPT0gJ3VuZGVmaW5lZCcgPyBtdXRhYmxlLmNhbm9uaWNhbFVybCA9PT0gc3RhdGUuY2Fub25pY2FsVXJsID8gc3RhdGUuY2Fub25pY2FsVXJsIDogbXV0YWJsZS5jYW5vbmljYWxVcmwgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0eXBlb2YgbXV0YWJsZS5wZW5kaW5nUHVzaCAhPT0gJ3VuZGVmaW5lZCcgPyBtdXRhYmxlLnBlbmRpbmdQdXNoIDogc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCxcbiAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHR5cGVvZiBtdXRhYmxlLm1wYU5hdmlnYXRpb24gIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5tcGFOYXZpZ2F0aW9uIDogc3RhdGUucHVzaFJlZi5tcGFOYXZpZ2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgYXBwbHk6IHR5cGVvZiBtdXRhYmxlLmFwcGx5Rm9jdXNBbmRTY3JvbGwgIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5hcHBseUZvY3VzQW5kU2Nyb2xsIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgIGNhY2hlOiBtdXRhYmxlLmNhY2hlID8gbXV0YWJsZS5jYWNoZSA6IHN0YXRlLmNhY2hlLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgdHJlZTogdHlwZW9mIG11dGFibGUucGF0Y2hlZFRyZWUgIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5wYXRjaGVkVHJlZSA6IHN0YXRlLnRyZWVcbiAgICB9O1xufVxuZnVuY3Rpb24gYXBwbHlGbGlnaHREYXRhKHN0YXRlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICBpZiAoc3ViVHJlZURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN1YlRyZWVEYXRhO1xuICAgICAgICAoMCwgX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKS5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgc3RhdGUuY2FjaGUsIHRyZWVQYXRjaCwgaGVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBleGlzdGluZyBjYWNoZSB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcHBsaWVkLlxuICAgICAgICAoMCwgX2ZpbGxDYWNoZVdpdGhOZXdTdWJ0cmVlRGF0YSkuZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwsIHBlbmRpbmdQdXNoKSB7XG4gICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cmw7XG4gICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgIG11dGFibGUuYXBwbHlGb2N1c0FuZFNjcm9sbCA9IGZhbHNlO1xuICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbn1cbmZ1bmN0aW9uIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwgLCBpc0V4dGVybmFsVXJsICwgbG9jYXRpb25TZWFyY2ggLCBuYXZpZ2F0ZVR5cGUgLCBjYWNoZSAsIG11dGFibGUgLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uICwgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgeyBwYXRobmFtZSAsIHNlYXJjaCAgfSA9IHVybDtcbiAgICBjb25zdCBocmVmID0gKDAsIF9jcmVhdGVIcmVmRnJvbVVybCkuY3JlYXRlSHJlZkZyb21VcmwodXJsKTtcbiAgICBjb25zdCBwZW5kaW5nUHVzaCA9IG5hdmlnYXRlVHlwZSA9PT0gJ3B1c2gnO1xuICAgIGNvbnN0IGlzRm9yQ3VycmVudFRyZWUgPSBKU09OLnN0cmluZ2lmeShtdXRhYmxlLnByZXZpb3VzVHJlZSkgPT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpO1xuICAgIGlmIChpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9XG4gICAgaWYgKGlzRXh0ZXJuYWxVcmwpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9IHN0YXRlLnByZWZldGNoQ2FjaGUuZ2V0KGhyZWYpO1xuICAgIGlmIChwcmVmZXRjaFZhbHVlcykge1xuICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgIGNvbnN0IHsgZmxpZ2h0RGF0YSAsIHRyZWU6IG5ld1RyZWUgLCBjYW5vbmljYWxVcmxPdmVycmlkZSAgfSA9IHByZWZldGNoVmFsdWVzO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKHN0YXRlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gLy8gVE9ETy1BUFA6IFJldmlzaXQgc2VhcmNoUGFyYW1zIHN1cHBvcnRcbiAgICAgICAgICAgIHNlYXJjaCAhPT0gbG9jYXRpb25TZWFyY2ggfHwgKDAsIF9zaG91bGRIYXJkTmF2aWdhdGUpLnNob3VsZEhhcmROYXZpZ2F0ZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUpO1xuICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgKDAsIF9pbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRwYXRoKS5pbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZXhpc3RpbmcgY2FjaGUgdmFsdWUgaXMgdXNlZCB3aGVuIHRoZSBjYWNoZSB3YXMgbm90IGludmFsaWRhdGVkLlxuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgbXV0YWJsZS5hcHBseUZvY3VzQW5kU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSkgOiBocmVmO1xuICAgICAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9ICgwLCBfY3JlYXRlT3B0aW1pc3RpY1RyZWUpLmNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCBmYWxzZSk7XG4gICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgLy8gQ29weSBleGlzdGluZyBjYWNoZSBub2RlcyBhcyBmYXIgYXMgcG9zc2libGUgYW5kIGZpbGwgaW4gYGRhdGFgIHByb3BlcnR5IHdpdGggdGhlIHN0YXJ0ZWQgZGF0YSBmZXRjaC5cbiAgICAgICAgLy8gVGhlIGBkYXRhYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIHN1c3BlbmQgaW4gbGF5b3V0LXJvdXRlciBkdXJpbmcgcmVuZGVyIGlmIGl0IGhhc24ndCByZXNvbHZlZCB5ZXQgYnkgdGhlIHRpbWUgaXQgcmVuZGVycy5cbiAgICAgICAgY29uc3QgcmVzID0gKDAsIF9maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KS5maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNhY2hlLCBzdGF0ZS5jYWNoZSwgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgc2VnbWVudHMuc2xpY2UoMSksICgpPT4oMCwgX2ZldGNoU2VydmVyUmVzcG9uc2UpLmZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBvcHRpbWlzdGljVHJlZSkpO1xuICAgICAgICAvLyBJZiBvcHRpbWlzdGljIGZldGNoIGNvdWxkbid0IGhhcHBlbiBpdCBmYWxscyBiYWNrIHRvIHRoZSBub24tb3B0aW1pc3RpYyBjYXNlLlxuICAgICAgICBpZiAoIShyZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcy5iYWlsT3B0aW1pc3RpYykpIHtcbiAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBvcHRpbWlzdGljVHJlZTtcbiAgICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaDtcbiAgICAgICAgICAgIG11dGFibGUuYXBwbHlGb2N1c0FuZFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWY7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmVsb3cgaXMgdGhlIG5vdC1vcHRpbWlzdGljIGNhc2UuIERhdGEgaXMgZmV0Y2hlZCBhdCB0aGUgcm9vdCBhbmQgc3VzcGVuZGVkIHRoZXJlIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAgICAvLyBJZiBubyBpbi1mbGlnaHQgZmV0Y2ggYXQgdGhlIHRvcCwgc3RhcnQgaXQuXG4gICAgaWYgKCFjYWNoZS5kYXRhKSB7XG4gICAgICAgIGNhY2hlLmRhdGEgPSAoMCwgX2NyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSkuY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSkuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHN0YXRlLnRyZWUpKTtcbiAgICB9XG4gICAgLy8gVW53cmFwIGNhY2hlIGRhdGEgd2l0aCBgdXNlYCB0byBzdXNwZW5kIGhlcmUgKGluIHRoZSByZWR1Y2VyKSB1bnRpbCB0aGUgZmV0Y2ggcmVzb2x2ZXMuXG4gICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9ICgwLCBfcmVhZFJlY29yZFZhbHVlKS5yZWFkUmVjb3JkVmFsdWUoY2FjaGUuZGF0YSk7XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgY29uc3QgW3RyZWVQYXRjaF0gPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMywgLTIpO1xuICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgW1xuICAgICAgICAnJyxcbiAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IGhyZWY7XG4gICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgIG11dGFibGUuYXBwbHlGb2N1c0FuZFNjcm9sbCA9IHRydWU7XG4gICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgIGNvbnN0IGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoc3RhdGUsIGNhY2hlLCBmbGlnaHREYXRhUGF0aCk7XG4gICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRlLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFuZGxlTXV0YWJsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhbmRsZUV4dGVybmFsVXJsIiwibmF2aWdhdGVSZWR1Y2VyIiwiX2FwcFJvdXRlckNvbnRleHQiLCJyZXF1aXJlIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJfY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwiX3JlYWRSZWNvcmRWYWx1ZSIsIl9jcmVhdGVIcmVmRnJvbVVybCIsIl9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIl9maWxsQ2FjaGVXaXRoTmV3U3VidHJlZURhdGEiLCJfaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50cGF0aCIsIl9maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5IiwiX2NyZWF0ZU9wdGltaXN0aWNUcmVlIiwiX2FwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsIl9zaG91bGRIYXJkTmF2aWdhdGUiLCJfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0Iiwic3RhdGUiLCJtdXRhYmxlIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiYXBwbHkiLCJhcHBseUZvY3VzQW5kU2Nyb2xsIiwiY2FjaGUiLCJwcmVmZXRjaENhY2hlIiwidHJlZSIsInBhdGNoZWRUcmVlIiwiZmxpZ2h0RGF0YVBhdGgiLCJ0cmVlUGF0Y2giLCJzdWJUcmVlRGF0YSIsImhlYWQiLCJzbGljZSIsImxlbmd0aCIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiUkVBRFkiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSIsInVybCIsInByZXZpb3VzVHJlZSIsImFjdGlvbiIsImlzRXh0ZXJuYWxVcmwiLCJsb2NhdGlvblNlYXJjaCIsIm5hdmlnYXRlVHlwZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImlzRm9yQ3VycmVudFRyZWUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJwcmVmZXRjaFZhbHVlcyIsImdldCIsImZsaWdodERhdGEiLCJuZXdUcmVlIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJmbGlnaHRTZWdtZW50UGF0aCIsImFwcGxpZWQiLCJoYXJkTmF2aWdhdGUiLCJzaG91bGRIYXJkTmF2aWdhdGUiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwic2VnbWVudHMiLCJzcGxpdCIsInB1c2giLCJvcHRpbWlzdGljVHJlZSIsImNyZWF0ZU9wdGltaXN0aWNUcmVlIiwicmVzIiwiZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJiYWlsT3B0aW1pc3RpYyIsImRhdGEiLCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJyZWFkUmVjb3JkVmFsdWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJFcnJvciIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.prefetchReducer = prefetchReducer;\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nfunction prefetchReducer(state, action) {\n    const { url , serverResponse  } = action;\n    const [flightData, canonicalUrlOverride] = serverResponse;\n    if (typeof flightData === \"string\") {\n        return state;\n    }\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // The one before last item is the router state tree patch\n    const [treePatch] = flightDataPath.slice(-3);\n    const flightSegmentPath = flightDataPath.slice(0, -3);\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    // Patch did not apply correctly\n    if (newTree === null) {\n        return state;\n    }\n    // Create new tree based on the flightSegmentPath and router state patch\n    state.prefetchCache.set(href, {\n        flightData,\n        // Create new tree based on the flightSegmentPath and router state patch\n        tree: newTree,\n        canonicalUrlOverride\n    });\n    return state;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLElBQUlDLCtCQUErQkMsbUJBQU9BLENBQUMsc0pBQXFDO0FBQ2hGLElBQUlDLHFCQUFxQkQsbUJBQU9BLENBQUMsOEhBQXlCO0FBQzFELFNBQVNGLGdCQUFnQkksS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDcEMsTUFBTSxFQUFFQyxJQUFHLEVBQUdDLGVBQWMsRUFBRyxHQUFHRjtJQUNsQyxNQUFNLENBQUNHLFlBQVlDLHFCQUFxQixHQUFHRjtJQUMzQyxJQUFJLE9BQU9DLGVBQWUsVUFBVTtRQUNoQyxPQUFPSjtJQUNYLENBQUM7SUFDRCxNQUFNTSxPQUFPLENBQUMsR0FBR1Asa0JBQWtCLEVBQUVRLGlCQUFpQixDQUFDTDtJQUN2RCwyR0FBMkc7SUFDM0csTUFBTU0saUJBQWlCSixVQUFVLENBQUMsRUFBRTtJQUNwQywwREFBMEQ7SUFDMUQsTUFBTSxDQUFDSyxVQUFVLEdBQUdELGVBQWVFLEtBQUssQ0FBQyxDQUFDO0lBQzFDLE1BQU1DLG9CQUFvQkgsZUFBZUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUNuRCxNQUFNRSxVQUFVLENBQUMsR0FBR2YsNEJBQTRCLEVBQUVnQiwyQkFBMkIsQ0FDN0U7UUFDSTtXQUNHRjtLQUNOLEVBQUVYLE1BQU1jLElBQUksRUFBRUw7SUFDZixnQ0FBZ0M7SUFDaEMsSUFBSUcsWUFBWSxJQUFJLEVBQUU7UUFDbEIsT0FBT1o7SUFDWCxDQUFDO0lBQ0Qsd0VBQXdFO0lBQ3hFQSxNQUFNZSxhQUFhLENBQUNDLEdBQUcsQ0FBQ1YsTUFBTTtRQUMxQkY7UUFDQSx3RUFBd0U7UUFDeEVVLE1BQU1GO1FBQ05QO0lBQ0o7SUFDQSxPQUFPTDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVF1QixPQUFPLEtBQUssY0FBZSxPQUFPdkIsUUFBUXVCLE9BQU8sS0FBSyxZQUFZdkIsUUFBUXVCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3ZCLFFBQVF1QixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLMUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRdUIsT0FBTyxFQUFFLGNBQWM7UUFBRXRCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPMkIsTUFBTSxDQUFDekIsUUFBUXVCLE9BQU8sRUFBRXZCO0lBQy9CMEIsT0FBTzFCLE9BQU8sR0FBR0EsUUFBUXVCLE9BQU87QUFDbEMsQ0FBQyxDQUVELDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3ByZWZldGNoLXJlZHVjZXIuanM/M2IzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJlZmV0Y2hSZWR1Y2VyID0gcHJlZmV0Y2hSZWR1Y2VyO1xudmFyIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHVybCAsIHNlcnZlclJlc3BvbnNlICB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTMpO1xuICAgIGNvbnN0IG5ld1RyZWUgPSAoMCwgX2FwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSkuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICBbXG4gICAgICAgICcnLFxuICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgLy8gUGF0Y2ggZGlkIG5vdCBhcHBseSBjb3JyZWN0bHlcbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgIHN0YXRlLnByZWZldGNoQ2FjaGUuc2V0KGhyZWYsIHtcbiAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgIHRyZWU6IG5ld1RyZWUsXG4gICAgICAgIGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmZXRjaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByZWZldGNoUmVkdWNlciIsIl9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJyZXF1aXJlIiwiX2NyZWF0ZUhyZWZGcm9tVXJsIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJzZXJ2ZXJSZXNwb25zZSIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImZsaWdodERhdGFQYXRoIiwidHJlZVBhdGNoIiwic2xpY2UiLCJmbGlnaHRTZWdtZW50UGF0aCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJ0cmVlIiwicHJlZmV0Y2hDYWNoZSIsInNldCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.refreshReducer = refreshReducer;\nvar _fetchServerResponse = __webpack_require__(/*! ../fetch-server-response */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _createRecordFromThenable = __webpack_require__(/*! ../create-record-from-thenable */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\");\nvar _readRecordValue = __webpack_require__(/*! ../read-record-value */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nvar _navigateReducer = __webpack_require__(/*! ./navigate-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction refreshReducer(state, action) {\n    const { cache , mutable , origin  } = action;\n    const href = state.canonicalUrl;\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return (0, _navigateReducer).handleMutable(state, mutable);\n    }\n    if (!cache.data) {\n        // TODO-APP: verify that `href` is not an external url.\n        // Fetch data from the root of the tree.\n        cache.data = (0, _createRecordFromThenable).createRecordFromThenable((0, _fetchServerResponse).fetchServerResponse(new URL(href, origin), [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            \"refetch\"\n        ]));\n    }\n    const [flightData, canonicalUrlOverride] = (0, _readRecordValue).readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // FlightDataPath with more than two items means unexpected Flight data was returned\n    if (flightDataPath.length !== 3) {\n        // TODO-APP: handle this case better\n        console.log(\"REFRESH FAILED\");\n        return state;\n    }\n    // Given the path can only have two items the items are only the router state and subTreeData for the root.\n    const [treePatch] = flightDataPath;\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\"\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n    }\n    const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : undefined;\n    if (canonicalUrlOverride) {\n        mutable.canonicalUrl = canonicalUrlOverrideHref;\n    }\n    const applied = (0, _navigateReducer).applyFlightData(state, cache, flightDataPath);\n    if (applied) {\n        mutable.cache = cache;\n    }\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.canonicalUrl = href;\n    return (0, _navigateReducer).handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0U7QUFDekIsSUFBSUMsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnSUFBMEI7QUFDN0QsSUFBSUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw0SUFBZ0M7QUFDeEUsSUFBSUUsbUJBQW1CRixtQkFBT0EsQ0FBQyx3SEFBc0I7QUFDckQsSUFBSUcscUJBQXFCSCxtQkFBT0EsQ0FBQyw4SEFBeUI7QUFDMUQsSUFBSUksK0JBQStCSixtQkFBT0EsQ0FBQyxzSkFBcUM7QUFDaEYsSUFBSUssK0JBQStCTCxtQkFBT0EsQ0FBQyxzSkFBcUM7QUFDaEYsSUFBSU0sbUJBQW1CTixtQkFBT0EsQ0FBQyw4SEFBb0I7QUFDbkQsU0FBU0YsZUFBZVMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDbkMsTUFBTSxFQUFFQyxNQUFLLEVBQUdDLFFBQU8sRUFBR0MsT0FBTSxFQUFHLEdBQUdIO0lBQ3RDLE1BQU1JLE9BQU9MLE1BQU1NLFlBQVk7SUFDL0IsTUFBTUMsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNOLFFBQVFPLFlBQVksTUFBTUYsS0FBS0MsU0FBUyxDQUFDVCxNQUFNVyxJQUFJO0lBQzNGLElBQUlKLGtCQUFrQjtRQUNsQixPQUFPLENBQUMsR0FBR1IsZ0JBQWdCLEVBQUVhLGFBQWEsQ0FBQ1osT0FBT0c7SUFDdEQsQ0FBQztJQUNELElBQUksQ0FBQ0QsTUFBTVcsSUFBSSxFQUFFO1FBQ2IsdURBQXVEO1FBQ3ZELHdDQUF3QztRQUN4Q1gsTUFBTVcsSUFBSSxHQUFHLENBQUMsR0FBR25CLHlCQUF5QixFQUFFb0Isd0JBQXdCLENBQUMsQ0FBQyxHQUFHdEIsb0JBQW9CLEVBQUV1QixtQkFBbUIsQ0FBQyxJQUFJQyxJQUFJWCxNQUFNRCxTQUFTO1lBQ3RJSixNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUNiWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUNiWCxNQUFNVyxJQUFJLENBQUMsRUFBRTtZQUNiO1NBQ0g7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDTSxZQUFZQyxxQkFBcUIsR0FBRyxDQUFDLEdBQUd2QixnQkFBZ0IsRUFBRXdCLGVBQWUsQ0FBQ2pCLE1BQU1XLElBQUk7SUFDM0YsNERBQTREO0lBQzVELElBQUksT0FBT0ksZUFBZSxVQUFVO1FBQ2hDLE9BQU8sQ0FBQyxHQUFHbEIsZ0JBQWdCLEVBQUVxQixpQkFBaUIsQ0FBQ3BCLE9BQU9HLFNBQVNjLFlBQVlqQixNQUFNcUIsT0FBTyxDQUFDQyxXQUFXO0lBQ3hHLENBQUM7SUFDRCwyREFBMkQ7SUFDM0RwQixNQUFNVyxJQUFJLEdBQUcsSUFBSTtJQUNqQiwyR0FBMkc7SUFDM0csTUFBTVUsaUJBQWlCTixVQUFVLENBQUMsRUFBRTtJQUNwQyxvRkFBb0Y7SUFDcEYsSUFBSU0sZUFBZUMsTUFBTSxLQUFLLEdBQUc7UUFDN0Isb0NBQW9DO1FBQ3BDQyxRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPMUI7SUFDWCxDQUFDO0lBQ0QsMkdBQTJHO0lBQzNHLE1BQU0sQ0FBQzJCLFVBQVUsR0FBR0o7SUFDcEIsTUFBTUssVUFBVSxDQUFDLEdBQUcvQiw0QkFBNEIsRUFBRWdDLDJCQUEyQixDQUM3RTtRQUNJO0tBQ0gsRUFBRTdCLE1BQU1XLElBQUksRUFBRWdCO0lBQ2YsSUFBSUMsWUFBWSxJQUFJLEVBQUU7UUFDbEIsTUFBTSxJQUFJRSxNQUFNLG9CQUFvQjtJQUN4QyxDQUFDO0lBQ0QsSUFBSSxDQUFDLEdBQUdoQyw0QkFBNEIsRUFBRWlDLDJCQUEyQixDQUFDL0IsTUFBTVcsSUFBSSxFQUFFaUIsVUFBVTtRQUNwRixPQUFPLENBQUMsR0FBRzdCLGdCQUFnQixFQUFFcUIsaUJBQWlCLENBQUNwQixPQUFPRyxTQUFTRSxNQUFNTCxNQUFNcUIsT0FBTyxDQUFDQyxXQUFXO0lBQ2xHLENBQUM7SUFDRCxNQUFNVSwyQkFBMkJkLHVCQUF1QixDQUFDLEdBQUd0QixrQkFBa0IsRUFBRXFDLGlCQUFpQixDQUFDZix3QkFBd0JnQixTQUFTO0lBQ25JLElBQUloQixzQkFBc0I7UUFDdEJmLFFBQVFHLFlBQVksR0FBRzBCO0lBQzNCLENBQUM7SUFDRCxNQUFNRyxVQUFVLENBQUMsR0FBR3BDLGdCQUFnQixFQUFFcUMsZUFBZSxDQUFDcEMsT0FBT0UsT0FBT3FCO0lBQ3BFLElBQUlZLFNBQVM7UUFDVGhDLFFBQVFELEtBQUssR0FBR0E7SUFDcEIsQ0FBQztJQUNEQyxRQUFRTyxZQUFZLEdBQUdWLE1BQU1XLElBQUk7SUFDakNSLFFBQVFrQyxXQUFXLEdBQUdUO0lBQ3RCekIsUUFBUUcsWUFBWSxHQUFHRDtJQUN2QixPQUFPLENBQUMsR0FBR04sZ0JBQWdCLEVBQUVhLGFBQWEsQ0FBQ1osT0FBT0c7QUFDdEQ7QUFFQSxJQUFJLENBQUMsT0FBT2QsUUFBUWlELE9BQU8sS0FBSyxjQUFlLE9BQU9qRCxRQUFRaUQsT0FBTyxLQUFLLFlBQVlqRCxRQUFRaUQsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakQsUUFBUWlELE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktwRCxPQUFPQyxjQUFjLENBQUNDLFFBQVFpRCxPQUFPLEVBQUUsY0FBYztRQUFFaEQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9xRCxNQUFNLENBQUNuRCxRQUFRaUQsT0FBTyxFQUFFakQ7SUFDL0JvRCxPQUFPcEQsT0FBTyxHQUFHQSxRQUFRaUQsT0FBTztBQUNsQyxDQUFDLENBRUQsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyLmpzPzI5M2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlZnJlc2hSZWR1Y2VyID0gcmVmcmVzaFJlZHVjZXI7XG52YXIgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xudmFyIF9jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUgPSByZXF1aXJlKFwiLi4vY3JlYXRlLXJlY29yZC1mcm9tLXRoZW5hYmxlXCIpO1xudmFyIF9yZWFkUmVjb3JkVmFsdWUgPSByZXF1aXJlKFwiLi4vcmVhZC1yZWNvcmQtdmFsdWVcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xudmFyIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG52YXIgX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbnZhciBfbmF2aWdhdGVSZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmZ1bmN0aW9uIHJlZnJlc2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IGNhY2hlICwgbXV0YWJsZSAsIG9yaWdpbiAgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgIGNvbnN0IGlzRm9yQ3VycmVudFRyZWUgPSBKU09OLnN0cmluZ2lmeShtdXRhYmxlLnByZXZpb3VzVHJlZSkgPT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpO1xuICAgIGlmIChpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikuaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfVxuICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICAgICAgY2FjaGUuZGF0YSA9ICgwLCBfY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKS5jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUoKDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgb3JpZ2luKSwgW1xuICAgICAgICAgICAgc3RhdGUudHJlZVswXSxcbiAgICAgICAgICAgIHN0YXRlLnRyZWVbMV0sXG4gICAgICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gKDAsIF9yZWFkUmVjb3JkVmFsdWUpLnJlYWRSZWNvcmRWYWx1ZShjYWNoZS5kYXRhKTtcbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikuaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGUuZGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgIGNhY2hlLmRhdGEgPSBudWxsO1xuICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgIGlmIChmbGlnaHREYXRhUGF0aC5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3QuXG4gICAgY29uc3QgW3RyZWVQYXRjaF0gPSBmbGlnaHREYXRhUGF0aDtcbiAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgW1xuICAgICAgICAnJ1xuICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgfVxuICAgIGlmICgoMCwgX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCkuaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikuaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgfVxuICAgIGNvbnN0IGFwcGxpZWQgPSAoMCwgX25hdmlnYXRlUmVkdWNlcikuYXBwbHlGbGlnaHREYXRhKHN0YXRlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgIGlmIChhcHBsaWVkKSB7XG4gICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gaHJlZjtcbiAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZyZXNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVmcmVzaFJlZHVjZXIiLCJfZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInJlcXVpcmUiLCJfY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwiX3JlYWRSZWNvcmRWYWx1ZSIsIl9jcmVhdGVIcmVmRnJvbVVybCIsIl9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiX25hdmlnYXRlUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwiY2FjaGUiLCJtdXRhYmxlIiwib3JpZ2luIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsImlzRm9yQ3VycmVudFRyZWUiLCJKU09OIiwic3RyaW5naWZ5IiwicHJldmlvdXNUcmVlIiwidHJlZSIsImhhbmRsZU11dGFibGUiLCJkYXRhIiwiY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInJlYWRSZWNvcmRWYWx1ZSIsImhhbmRsZUV4dGVybmFsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwiZmxpZ2h0RGF0YVBhdGgiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsIkVycm9yIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ1bmRlZmluZWQiLCJhcHBsaWVkIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.restoreReducer = restoreReducer;\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nfunction restoreReducer(state, action) {\n    const { url , tree  } = action;\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: state.pushRef,\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: state.cache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: tree\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxzQkFBc0IsR0FBR0U7QUFDekIsSUFBSUMscUJBQXFCQyxtQkFBT0EsQ0FBQyw4SEFBeUI7QUFDMUQsU0FBU0YsZUFBZUcsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDbkMsTUFBTSxFQUFFQyxJQUFHLEVBQUdDLEtBQUksRUFBRyxHQUFHRjtJQUN4QixNQUFNRyxPQUFPLENBQUMsR0FBR04sa0JBQWtCLEVBQUVPLGlCQUFpQixDQUFDSDtJQUN2RCxPQUFPO1FBQ0gsb0JBQW9CO1FBQ3BCSSxjQUFjRjtRQUNkRyxTQUFTUCxNQUFNTyxPQUFPO1FBQ3RCQyxtQkFBbUJSLE1BQU1RLGlCQUFpQjtRQUMxQ0MsT0FBT1QsTUFBTVMsS0FBSztRQUNsQkMsZUFBZVYsTUFBTVUsYUFBYTtRQUNsQyx3QkFBd0I7UUFDeEJQLE1BQU1BO0lBQ1Y7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRZ0IsT0FBTyxLQUFLLGNBQWUsT0FBT2hCLFFBQVFnQixPQUFPLEtBQUssWUFBWWhCLFFBQVFnQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9oQixRQUFRZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS25CLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWdCLE9BQU8sRUFBRSxjQUFjO1FBQUVmLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPb0IsTUFBTSxDQUFDbEIsUUFBUWdCLE9BQU8sRUFBRWhCO0lBQy9CbUIsT0FBT25CLE9BQU8sR0FBR0EsUUFBUWdCLE9BQU87QUFDbEMsQ0FBQyxDQUVELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci5qcz83OTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZXN0b3JlUmVkdWNlciA9IHJlc3RvcmVSZWR1Y2VyO1xudmFyIF9jcmVhdGVIcmVmRnJvbVVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmZ1bmN0aW9uIHJlc3RvcmVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IHVybCAsIHRyZWUgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2V0IGNhbm9uaWNhbCB1cmxcbiAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgLy8gUmVzdG9yZSBwcm92aWRlZCB0cmVlXG4gICAgICAgIHRyZWU6IHRyZWVcbiAgICB9O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXN0b3JlLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVzdG9yZVJlZHVjZXIiLCJfY3JlYXRlSHJlZkZyb21VcmwiLCJyZXF1aXJlIiwic3RhdGUiLCJhY3Rpb24iLCJ1cmwiLCJ0cmVlIiwiaHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiY2FjaGUiLCJwcmVmZXRjaENhY2hlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.serverPatchReducer = serverPatchReducer;\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nvar _navigateReducer = __webpack_require__(/*! ./navigate-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction serverPatchReducer(state, action) {\n    const { flightData , previousTree , overrideCanonicalUrl , cache , mutable  } = action;\n    const isForCurrentTree = JSON.stringify(previousTree) === JSON.stringify(state.tree);\n    // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n    // In that case opt-out of applying the patch given that the data could be stale.\n    if (!isForCurrentTree) {\n        // TODO-APP: Handle tree mismatch\n        console.log(\"TREE MISMATCH\");\n        // Keep everything as-is.\n        return state;\n    }\n    if (mutable.previousTree) {\n        return (0, _navigateReducer).handleMutable(state, mutable);\n    }\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n    const flightSegmentPath = flightDataPath.slice(0, -4);\n    const [treePatch] = flightDataPath.slice(-3, -2);\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n    }\n    const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createHrefFromUrl).createHrefFromUrl(overrideCanonicalUrl) : undefined;\n    if (canonicalUrlOverrideHref) {\n        mutable.canonicalUrl = canonicalUrlOverrideHref;\n    }\n    (0, _navigateReducer).applyFlightData(state, cache, flightDataPath);\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.cache = cache;\n    return (0, _navigateReducer).handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QixJQUFJQyxxQkFBcUJDLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUMxRCxJQUFJQywrQkFBK0JELG1CQUFPQSxDQUFDLHNKQUFxQztBQUNoRixJQUFJRSwrQkFBK0JGLG1CQUFPQSxDQUFDLHNKQUFxQztBQUNoRixJQUFJRyxtQkFBbUJILG1CQUFPQSxDQUFDLDhIQUFvQjtBQUNuRCxTQUFTRixtQkFBbUJNLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ3ZDLE1BQU0sRUFBRUMsV0FBVSxFQUFHQyxhQUFZLEVBQUdDLHFCQUFvQixFQUFHQyxNQUFLLEVBQUdDLFFBQU8sRUFBRyxHQUFHTDtJQUNoRixNQUFNTSxtQkFBbUJDLEtBQUtDLFNBQVMsQ0FBQ04sa0JBQWtCSyxLQUFLQyxTQUFTLENBQUNULE1BQU1VLElBQUk7SUFDbkYsa0lBQWtJO0lBQ2xJLGlGQUFpRjtJQUNqRixJQUFJLENBQUNILGtCQUFrQjtRQUNuQixpQ0FBaUM7UUFDakNJLFFBQVFDLEdBQUcsQ0FBQztRQUNaLHlCQUF5QjtRQUN6QixPQUFPWjtJQUNYLENBQUM7SUFDRCxJQUFJTSxRQUFRSCxZQUFZLEVBQUU7UUFDdEIsT0FBTyxDQUFDLEdBQUdKLGdCQUFnQixFQUFFYyxhQUFhLENBQUNiLE9BQU9NO0lBQ3RELENBQUM7SUFDRCw0REFBNEQ7SUFDNUQsSUFBSSxPQUFPSixlQUFlLFVBQVU7UUFDaEMsT0FBTyxDQUFDLEdBQUdILGdCQUFnQixFQUFFZSxpQkFBaUIsQ0FBQ2QsT0FBT00sU0FBU0osWUFBWUYsTUFBTWUsT0FBTyxDQUFDQyxXQUFXO0lBQ3hHLENBQUM7SUFDRCwyR0FBMkc7SUFDM0csTUFBTUMsaUJBQWlCZixVQUFVLENBQUMsRUFBRTtJQUNwQyxtRkFBbUY7SUFDbkYsTUFBTWdCLG9CQUFvQkQsZUFBZUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUNuRCxNQUFNLENBQUNDLFVBQVUsR0FBR0gsZUFBZUUsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQzlDLE1BQU1FLFVBQVUsQ0FBQyxHQUFHeEIsNEJBQTRCLEVBQUV5QiwyQkFBMkIsQ0FDN0U7UUFDSTtXQUNHSjtLQUNOLEVBQUVsQixNQUFNVSxJQUFJLEVBQUVVO0lBQ2YsSUFBSUMsWUFBWSxJQUFJLEVBQUU7UUFDbEIsTUFBTSxJQUFJRSxNQUFNLG9CQUFvQjtJQUN4QyxDQUFDO0lBQ0QsSUFBSSxDQUFDLEdBQUd6Qiw0QkFBNEIsRUFBRTBCLDJCQUEyQixDQUFDeEIsTUFBTVUsSUFBSSxFQUFFVyxVQUFVO1FBQ3BGLE9BQU8sQ0FBQyxHQUFHdEIsZ0JBQWdCLEVBQUVlLGlCQUFpQixDQUFDZCxPQUFPTSxTQUFTTixNQUFNeUIsWUFBWSxFQUFFekIsTUFBTWUsT0FBTyxDQUFDQyxXQUFXO0lBQ2hILENBQUM7SUFDRCxNQUFNVSwyQkFBMkJ0Qix1QkFBdUIsQ0FBQyxHQUFHVCxrQkFBa0IsRUFBRWdDLGlCQUFpQixDQUFDdkIsd0JBQXdCd0IsU0FBUztJQUNuSSxJQUFJRiwwQkFBMEI7UUFDMUJwQixRQUFRbUIsWUFBWSxHQUFHQztJQUMzQixDQUFDO0lBQ0EsSUFBRzNCLGdCQUFnQixFQUFFOEIsZUFBZSxDQUFDN0IsT0FBT0ssT0FBT1k7SUFDcERYLFFBQVFILFlBQVksR0FBR0gsTUFBTVUsSUFBSTtJQUNqQ0osUUFBUXdCLFdBQVcsR0FBR1Q7SUFDdEJmLFFBQVFELEtBQUssR0FBR0E7SUFDaEIsT0FBTyxDQUFDLEdBQUdOLGdCQUFnQixFQUFFYyxhQUFhLENBQUNiLE9BQU9NO0FBQ3REO0FBRUEsSUFBSSxDQUFDLE9BQU9kLFFBQVF1QyxPQUFPLEtBQUssY0FBZSxPQUFPdkMsUUFBUXVDLE9BQU8sS0FBSyxZQUFZdkMsUUFBUXVDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3ZDLFFBQVF1QyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLMUMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRdUMsT0FBTyxFQUFFLGNBQWM7UUFBRXRDLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPMkMsTUFBTSxDQUFDekMsUUFBUXVDLE9BQU8sRUFBRXZDO0lBQy9CMEMsT0FBTzFDLE9BQU8sR0FBR0EsUUFBUXVDLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLmpzP2RhZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNlcnZlclBhdGNoUmVkdWNlciA9IHNlcnZlclBhdGNoUmVkdWNlcjtcbnZhciBfY3JlYXRlSHJlZkZyb21VcmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG52YXIgX2FwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSA9IHJlcXVpcmUoXCIuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZVwiKTtcbnZhciBfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xudmFyIF9uYXZpZ2F0ZVJlZHVjZXIgPSByZXF1aXJlKFwiLi9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xuZnVuY3Rpb24gc2VydmVyUGF0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCB7IGZsaWdodERhdGEgLCBwcmV2aW91c1RyZWUgLCBvdmVycmlkZUNhbm9uaWNhbFVybCAsIGNhY2hlICwgbXV0YWJsZSAgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkocHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgLy8gV2hlbiBhIGZldGNoIGlzIHNsb3cgdG8gcmVzb2x2ZSBpdCBjb3VsZCBiZSB0aGF0IHlvdSBuYXZpZ2F0ZWQgYXdheSB3aGlsZSB0aGUgcmVxdWVzdCB3YXMgaGFwcGVuaW5nIG9yIGJlZm9yZSB0aGUgcmVkdWNlciBydW5zLlxuICAgIC8vIEluIHRoYXQgY2FzZSBvcHQtb3V0IG9mIGFwcGx5aW5nIHRoZSBwYXRjaCBnaXZlbiB0aGF0IHRoZSBkYXRhIGNvdWxkIGJlIHN0YWxlLlxuICAgIGlmICghaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogSGFuZGxlIHRyZWUgbWlzbWF0Y2hcbiAgICAgICAgY29uc29sZS5sb2coJ1RSRUUgTUlTTUFUQ0gnKTtcbiAgICAgICAgLy8gS2VlcCBldmVyeXRoaW5nIGFzLWlzLlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGlmIChtdXRhYmxlLnByZXZpb3VzVHJlZSkge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikuaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAvLyBTbGljZXMgb2ZmIHRoZSBsYXN0IHNlZ21lbnQgKHdoaWNoIGlzIGF0IC00KSBhcyBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlIHlldFxuICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTQpO1xuICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMsIC0yKTtcbiAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgW1xuICAgICAgICAnJyxcbiAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBzdGF0ZS5jYW5vbmljYWxVcmwsIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2gpO1xuICAgIH1cbiAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBvdmVycmlkZUNhbm9uaWNhbFVybCA/ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKG92ZXJyaWRlQ2Fub25pY2FsVXJsKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgIH1cbiAgICAoMCwgX25hdmlnYXRlUmVkdWNlcikuYXBwbHlGbGlnaHREYXRhKHN0YXRlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgcmV0dXJuICgwLCBfbmF2aWdhdGVSZWR1Y2VyKS5oYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLXBhdGNoLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiX2NyZWF0ZUhyZWZGcm9tVXJsIiwicmVxdWlyZSIsIl9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiX25hdmlnYXRlUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwiZmxpZ2h0RGF0YSIsInByZXZpb3VzVHJlZSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwiY2FjaGUiLCJtdXRhYmxlIiwiaXNGb3JDdXJyZW50VHJlZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmVlIiwiY29uc29sZSIsImxvZyIsImhhbmRsZU11dGFibGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImZsaWdodERhdGFQYXRoIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJzbGljZSIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJFcnJvciIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbHlGbGlnaHREYXRhIiwicGF0Y2hlZFRyZWUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\nconst ACTION_REFRESH = \"refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nconst ACTION_NAVIGATE = \"navigate\";\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nconst ACTION_RESTORE = \"restore\";\nexports.ACTION_RESTORE = ACTION_RESTORE;\nconst ACTION_SERVER_PATCH = \"server-patch\";\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nconst ACTION_PREFETCH = \"prefetch\";\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLHVCQUF1QixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ3pJLE1BQU1NLGlCQUFpQjtBQUN2Qk4sc0JBQXNCLEdBQUdNO0FBQ3pCLE1BQU1ELGtCQUFrQjtBQUN4QkwsdUJBQXVCLEdBQUdLO0FBQzFCLE1BQU1ELGlCQUFpQjtBQUN2Qkosc0JBQXNCLEdBQUdJO0FBQ3pCLE1BQU1ELHNCQUFzQjtBQUM1QkgsMkJBQTJCLEdBQUdHO0FBQzlCLE1BQU1ELGtCQUFrQjtBQUN4QkYsdUJBQXVCLEdBQUdFO0FBRTFCLElBQUksQ0FBQyxPQUFPRixRQUFRTyxPQUFPLEtBQUssY0FBZSxPQUFPUCxRQUFRTyxPQUFPLEtBQUssWUFBWVAsUUFBUU8sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUCxRQUFRTyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVixPQUFPQyxjQUFjLENBQUNDLFFBQVFPLE9BQU8sRUFBRSxjQUFjO1FBQUVOLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxDQUFDLENBRUQsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanM/NjU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gZXhwb3J0cy5BQ1RJT05fU0VSVkVSX1BBVENIID0gZXhwb3J0cy5BQ1RJT05fUkVTVE9SRSA9IGV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IHZvaWQgMDtcbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnO1xuZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IEFDVElPTl9SRUZSRVNIO1xuY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJztcbmV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gQUNUSU9OX05BVklHQVRFO1xuY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSc7XG5leHBvcnRzLkFDVElPTl9SRVNUT1JFID0gQUNUSU9OX1JFU1RPUkU7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCc7XG5leHBvcnRzLkFDVElPTl9TRVJWRVJfUEFUQ0ggPSBBQ1RJT05fU0VSVkVSX1BBVENIO1xuY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJztcbmV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gQUNUSU9OX1BSRUZFVENIO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItcmVkdWNlci10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVGUkVTSCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.reducer = void 0;\nvar _routerReducerTypes = __webpack_require__(/*! ./router-reducer-types */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar _navigateReducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nvar _serverPatchReducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\");\nvar _restoreReducer = __webpack_require__(/*! ./reducers/restore-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\");\nvar _refreshReducer = __webpack_require__(/*! ./reducers/refresh-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\");\nvar _prefetchReducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(sc_client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerReducerTypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigateReducer).navigateReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverPatchReducer).serverPatchReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_RESTORE:\n            {\n                return (0, _restoreReducer).restoreReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_REFRESH:\n            {\n                return (0, _refreshReducer).refreshReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchReducer).prefetchReducer(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  true ? serverReducer : 0;\nexports.reducer = reducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLHNCQUFzQkMsbUJBQU9BLENBQUMsNkhBQXdCO0FBQzFELElBQUlDLG1CQUFtQkQsbUJBQU9BLENBQUMsdUlBQTZCO0FBQzVELElBQUlFLHNCQUFzQkYsbUJBQU9BLENBQUMsK0lBQWlDO0FBQ25FLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUMscUlBQTRCO0FBQzFELElBQUlJLGtCQUFrQkosbUJBQU9BLENBQUMscUlBQTRCO0FBQzFELElBQUlLLG1CQUFtQkwsbUJBQU9BLENBQUMsdUlBQTZCO0FBQzVEOztDQUVDLEdBQUcsU0FBU00sY0FBY0MsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDdEMsT0FBT0EsT0FBT0MsSUFBSTtRQUNkLEtBQUtWLG9CQUFvQlcsZUFBZTtZQUNwQztnQkFDSSxPQUFPLENBQUMsR0FBR1QsZ0JBQWdCLEVBQUVVLGVBQWUsQ0FBQ0osT0FBT0M7WUFDeEQ7UUFDSixLQUFLVCxvQkFBb0JhLG1CQUFtQjtZQUN4QztnQkFDSSxPQUFPLENBQUMsR0FBR1YsbUJBQW1CLEVBQUVXLGtCQUFrQixDQUFDTixPQUFPQztZQUM5RDtRQUNKLEtBQUtULG9CQUFvQmUsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR1gsZUFBZSxFQUFFWSxjQUFjLENBQUNSLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1Qsb0JBQW9CaUIsY0FBYztZQUNuQztnQkFDSSxPQUFPLENBQUMsR0FBR1osZUFBZSxFQUFFYSxjQUFjLENBQUNWLE9BQU9DO1lBQ3REO1FBQ0osS0FBS1Qsb0JBQW9CbUIsZUFBZTtZQUNwQztnQkFDSSxPQUFPLENBQUMsR0FBR2IsZ0JBQWdCLEVBQUVjLGVBQWUsQ0FBQ1osT0FBT0M7WUFDeEQ7UUFDSiwrREFBK0Q7UUFDL0Q7WUFDSSxNQUFNLElBQUlZLE1BQU0sa0JBQWtCO0lBQzFDO0FBQ0o7QUFDQSxTQUFTQyxjQUFjZCxLQUFLLEVBQUVlLE9BQU8sRUFBRTtJQUNuQyxPQUFPZjtBQUNYO0FBQ0EsTUFBTVQsVUFBVSxLQUFrQixHQUFjdUIsZ0JBQWdCZixDQUFhO0FBQzdFVixlQUFlLEdBQUdFO0FBRWxCLElBQUksQ0FBQyxPQUFPRixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTytCLE1BQU0sQ0FBQzdCLFFBQVEyQixPQUFPLEVBQUUzQjtJQUMvQjhCLE9BQU85QixPQUFPLEdBQUdBLFFBQVEyQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci5qcz8xZGRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWR1Y2VyID0gdm9pZCAwO1xudmFyIF9yb3V0ZXJSZWR1Y2VyVHlwZXMgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcbnZhciBfbmF2aWdhdGVSZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlclwiKTtcbnZhciBfc2VydmVyUGF0Y2hSZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXJcIik7XG52YXIgX3Jlc3RvcmVSZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyXCIpO1xudmFyIF9yZWZyZXNoUmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlclwiKTtcbnZhciBfcHJlZmV0Y2hSZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlclwiKTtcbi8qKlxuICogUmVkdWNlciB0aGF0IGhhbmRsZXMgdGhlIGFwcC1yb3V0ZXIgc3RhdGUgdXBkYXRlcy5cbiAqLyBmdW5jdGlvbiBjbGllbnRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpe1xuICAgICAgICBjYXNlIF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikubmF2aWdhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zZXJ2ZXJQYXRjaFJlZHVjZXIpLnNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9SRVNUT1JFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3RvcmVSZWR1Y2VyKS5yZXN0b3JlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZnJlc2hSZWR1Y2VyKS5yZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9QUkVGRVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9wcmVmZXRjaFJlZHVjZXIpLnByZWZldGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VydmVyUmVkdWNlcihzdGF0ZSwgX2FjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IHJlZHVjZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyO1xuZXhwb3J0cy5yZWR1Y2VyID0gcmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVkdWNlciIsIl9yb3V0ZXJSZWR1Y2VyVHlwZXMiLCJyZXF1aXJlIiwiX25hdmlnYXRlUmVkdWNlciIsIl9zZXJ2ZXJQYXRjaFJlZHVjZXIiLCJfcmVzdG9yZVJlZHVjZXIiLCJfcmVmcmVzaFJlZHVjZXIiLCJfcHJlZmV0Y2hSZWR1Y2VyIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIkFDVElPTl9OQVZJR0FURSIsIm5hdmlnYXRlUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJzZXJ2ZXJQYXRjaFJlZHVjZXIiLCJBQ1RJT05fUkVTVE9SRSIsInJlc3RvcmVSZWR1Y2VyIiwiQUNUSU9OX1JFRlJFU0giLCJyZWZyZXNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInByZWZldGNoUmVkdWNlciIsIkVycm9yIiwic2VydmVyUmVkdWNlciIsIl9hY3Rpb24iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shouldHardNavigate = shouldHardNavigate;\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(sc_client)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRTtBQUM3QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLG1HQUFtQjtBQUNoRCxTQUFTRixtQkFBbUJHLGlCQUFpQixFQUFFQyxpQkFBaUIsRUFBRTtJQUM5RCxNQUFNLENBQUNDLFNBQVNDLGVBQWUsR0FBR0Y7SUFDbEMsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0csZ0JBQWdCQyxpQkFBaUIsR0FBR0w7SUFDM0MseURBQXlEO0lBQ3pELElBQUksQ0FBQyxDQUFDLEdBQUdGLGNBQWMsRUFBRVEsWUFBWSxDQUFDRixnQkFBZ0JGLFVBQVU7UUFDNUQsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQy9CLE9BQU8sSUFBSTtRQUNmLENBQUM7UUFDRCxzRUFBc0U7UUFDdEUsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUNoRCxJQUFJRCxhQUFhO1FBQ2IsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxPQUFPWixtQkFBbUJHLGtCQUFrQlcsS0FBSyxDQUFDLElBQUlSLGNBQWMsQ0FBQ0UsaUJBQWlCO0FBQzFGO0FBRUEsSUFBSSxDQUFDLE9BQU9WLFFBQVFpQixPQUFPLEtBQUssY0FBZSxPQUFPakIsUUFBUWlCLE9BQU8sS0FBSyxZQUFZakIsUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pCLFFBQVFpQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUIsT0FBTyxFQUFFLGNBQWM7UUFBRWhCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPcUIsTUFBTSxDQUFDbkIsUUFBUWlCLE9BQU8sRUFBRWpCO0lBQy9Cb0IsT0FBT3BCLE9BQU8sR0FBR0EsUUFBUWlCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Nob3VsZC1oYXJkLW5hdmlnYXRlLmpzPzY2MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNob3VsZEhhcmROYXZpZ2F0ZSA9IHNob3VsZEhhcmROYXZpZ2F0ZTtcbnZhciBfbWF0Y2hTZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRjaC1zZWdtZW50c1wiKTtcbmZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHNlZ21lbnQgbWF0Y2hlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudC5cbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGlmIChsYXN0U2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMiksIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvdWxkLWhhcmQtbmF2aWdhdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiX21hdGNoU2VnbWVudHMiLCJyZXF1aXJlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsImN1cnJlbnRTZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsIm1hdGNoU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImxhc3RTZWdtZW50IiwibGVuZ3RoIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n");

/***/ }),

/***/ "(sc_shared)/./node_modules/next/dist/client/components/static-generation-async-storage.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-async-storage.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.staticGenerationAsyncStorage = void 0;\nvar _asyncLocalStorage = __webpack_require__(/*! ./async-local-storage */ \"(sc_shared)/./node_modules/next/dist/client/components/async-local-storage.js\");\nconst staticGenerationAsyncStorage = (0, _asyncLocalStorage).createAsyncLocalStorage();\nexports.staticGenerationAsyncStorage = staticGenerationAsyncStorage;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-async-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NoYXJlZCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWFzeW5jLXN0b3JhZ2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsb0NBQW9DLEdBQUcsS0FBSztBQUM1QyxJQUFJRyxxQkFBcUJDLG1CQUFPQSxDQUFDLDRHQUF1QjtBQUN4RCxNQUFNRiwrQkFBK0IsQ0FBQyxHQUFHQyxrQkFBa0IsRUFBRUUsdUJBQXVCO0FBQ3BGTCxvQ0FBb0MsR0FBR0U7QUFFdkMsSUFBSSxDQUFDLE9BQU9GLFFBQVFNLE9BQU8sS0FBSyxjQUFlLE9BQU9OLFFBQVFNLE9BQU8sS0FBSyxZQUFZTixRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9OLFFBQVFNLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktULE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU0sT0FBTyxFQUFFLGNBQWM7UUFBRUwsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9VLE1BQU0sQ0FBQ1IsUUFBUU0sT0FBTyxFQUFFTjtJQUMvQlMsT0FBT1QsT0FBTyxHQUFHQSxRQUFRTSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwyREFBMkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1hc3luYy1zdG9yYWdlLmpzPzJiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UgPSB2b2lkIDA7XG52YXIgX2FzeW5jTG9jYWxTdG9yYWdlID0gcmVxdWlyZShcIi4vYXN5bmMtbG9jYWwtc3RvcmFnZVwiKTtcbmNvbnN0IHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UgPSAoMCwgX2FzeW5jTG9jYWxTdG9yYWdlKS5jcmVhdGVBc3luY0xvY2FsU3RvcmFnZSgpO1xuZXhwb3J0cy5zdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlID0gc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGljLWdlbmVyYXRpb24tYXN5bmMtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlIiwiX2FzeW5jTG9jYWxTdG9yYWdlIiwicmVxdWlyZSIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_shared)/./node_modules/next/dist/client/components/static-generation-async-storage.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\nvar _react = __webpack_require__(/*! react */ \"react\");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction devToolReducer(fn, ref) {\n    return (state, action)=>{\n        const res = fn(state, action);\n        if (ref.current) {\n            ref.current.send(action, normalizeRouterState(res));\n        }\n        return res;\n    };\n}\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n    const [state, dispatch] = (0, _react).useReducer(fn, initialState);\n    return [\n        state,\n        dispatch,\n        ()=>{}\n    ];\n}\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n    const devtoolsConnectionRef = (0, _react).useRef();\n    const enabledRef = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 8000,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState\n    ]);\n    const [state, dispatch] = (0, _react).useReducer(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState);\n    const sync = (0, _react).useCallback(()=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(state));\n        }\n    }, [\n        state\n    ]);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\nconst useReducerWithReduxDevtools =  false ? 0 : useReducerWithReduxDevtoolsNoop;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsbUNBQW1DLEdBQUcsS0FBSztBQUMzQyxJQUFJRyxTQUFTQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM1QixTQUFTQyxxQkFBcUJDLEdBQUcsRUFBRTtJQUMvQixJQUFJQSxlQUFlQyxLQUFLO1FBQ3BCLE1BQU1DLE1BQU0sQ0FBQztRQUNiLEtBQUssTUFBTSxDQUFDQyxLQUFLUixNQUFNLElBQUlLLElBQUlJLE9BQU8sR0FBRztZQUNyQyxJQUFJLE9BQU9ULFVBQVUsWUFBWTtnQkFDN0JPLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO2dCQUNYLFFBQVM7WUFDYixDQUFDO1lBQ0QsSUFBSSxPQUFPUixVQUFVLFlBQVlBLFVBQVUsSUFBSSxFQUFFO2dCQUM3QyxJQUFJQSxNQUFNVSxRQUFRLEVBQUU7b0JBQ2hCSCxHQUFHLENBQUNDLElBQUksR0FBR1IsTUFBTVUsUUFBUSxDQUFDQyxRQUFRO29CQUNsQyxRQUFTO2dCQUNiLENBQUM7Z0JBQ0QsSUFBSVgsTUFBTVksY0FBYyxFQUFFO29CQUN0QkwsR0FBRyxDQUFDQyxJQUFJLEdBQUc7b0JBQ1gsUUFBUztnQkFDYixDQUFDO1lBQ0wsQ0FBQztZQUNERCxHQUFHLENBQUNDLElBQUksR0FBR0oscUJBQXFCSjtRQUNwQztRQUNBLE9BQU9PO0lBQ1gsQ0FBQztJQUNELElBQUksT0FBT0YsUUFBUSxZQUFZQSxRQUFRLElBQUksRUFBRTtRQUN6QyxNQUFNRSxNQUFNLENBQUM7UUFDYixJQUFJLE1BQU1DLE9BQU9ILElBQUk7WUFDakIsTUFBTUwsUUFBUUssR0FBRyxDQUFDRyxJQUFJO1lBQ3RCLElBQUksT0FBT1IsVUFBVSxZQUFZO2dCQUM3Qk8sR0FBRyxD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LElBQUksQ0FBQyxPQUFPRixRQUFRNkMsT0FBTyxLQUFLLGNBQWUsT0FBTzdDLFFBQVE2QyxPQUFPLEtBQUssWUFBWTdDLFFBQVE2QyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU83QyxRQUFRNkMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTZDLE9BQU8sRUFBRSxjQUFjO1FBQUU1QyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lELE1BQU0sQ0FBQy9DLFFBQVE2QyxPQUFPLEVBQUU3QztJQUMvQmdELE9BQU9oRCxPQUFPLEdBQUdBLFFBQVE2QyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzPzQ1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwuZW50cmllcygpKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fYnVuZGxlckNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWwpe1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX2J1bmRsZXJDb25maWcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsLm1hcChub3JtYWxpemVSb3V0ZXJTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZXZUb29sUmVkdWNlcihmbiwgcmVmKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKT0+e1xuICAgICAgICBjb25zdCByZXMgPSBmbihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZWYuY3VycmVudC5zZW5kKGFjdGlvbiwgbm9ybWFsaXplUm91dGVyU3RhdGUocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGZuLCBpbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgKCk9Pnt9XG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwoZm4sIGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IGRldnRvb2xzQ29ubmVjdGlvblJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IGVuYWJsZWRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50IHx8IGVuYWJsZWRSZWYuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KHtcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IDgwMDAsXG4gICAgICAgICAgICBuYW1lOiAnbmV4dC1yb3V0ZXInXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50LmluaXQobm9ybWFsaXplUm91dGVyU3RhdGUoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGluaXRpYWxTdGF0ZVxuICAgIF0pO1xuICAgIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gKDAsIF9yZWFjdCkudXNlUmVkdWNlcihkZXZUb29sUmVkdWNlcigvKiBsb2dSZWR1Y2VyKCAqLyBmbiAvKikqLyAsIGRldnRvb2xzQ29ubmVjdGlvblJlZiksIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3Qgc3luYyA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTkRFUl9TWU5DJ1xuICAgICAgICAgICAgfSwgbm9ybWFsaXplUm91dGVyU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHN5bmNcbiAgICBdO1xufVxuY29uc3QgdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIDogdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcDtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsIl9yZWFjdCIsInJlcXVpcmUiLCJub3JtYWxpemVSb3V0ZXJTdGF0ZSIsInZhbCIsIk1hcCIsIm9iaiIsImtleSIsImVudHJpZXMiLCIkJHR5cGVvZiIsInRvU3RyaW5nIiwiX2J1bmRsZXJDb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImRldlRvb2xSZWR1Y2VyIiwiZm4iLCJyZWYiLCJzdGF0ZSIsImFjdGlvbiIsInJlcyIsImN1cnJlbnQiLCJzZW5kIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcCIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwidXNlUmVkdWNlciIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwiLCJkZXZ0b29sc0Nvbm5lY3Rpb25SZWYiLCJ1c2VSZWYiLCJlbmFibGVkUmVmIiwidXNlRWZmZWN0IiwidW5kZWZpbmVkIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwibmFtZSIsImluaXQiLCJzeW5jIiwidXNlQ2FsbGJhY2siLCJ0eXBlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = formatWebpackMessages;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _stripAnsi = _interop_require_default(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"next/dist/compiled/strip-ansi\"));\nfunction formatWebpackMessages(json, verbose) {\n    const formattedErrors = json.errors.map((message)=>{\n        const isUnknownNextFontError = message.message.includes(\"An error occured in `next/font`.\");\n        return formatMessage(message, isUnknownNextFontError || verbose);\n    });\n    const formattedWarnings = json.warnings.map((message)=>{\n        return formatMessage(message, verbose);\n    });\n    // Reorder errors to put the most relevant ones first.\n    let reactServerComponentsError = -1;\n    for(let i = 0; i < formattedErrors.length; i++){\n        const error = formattedErrors[i];\n        if (error.includes(\"ReactServerComponentsError\")) {\n            reactServerComponentsError = i;\n            break;\n        }\n    }\n    // Move the reactServerComponentsError to the top if it exists\n    if (reactServerComponentsError !== -1) {\n        const error = formattedErrors.splice(reactServerComponentsError, 1);\n        formattedErrors.unshift(error[0]);\n    }\n    const result = _extends({}, json, {\n        errors: formattedErrors,\n        warnings: formattedWarnings\n    });\n    if (!verbose && result.errors.some(isLikelyASyntaxError)) {\n        // If there are any syntax errors, show just them.\n        result.errors = result.errors.filter(isLikelyASyntaxError);\n        result.warnings = [];\n    }\n    return result;\n}\n// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js\n// It's been edited to remove chalk and CRA-specific logic\nconst friendlySyntaxErrorLabel = \"Syntax error:\";\nconst WEBPACK_BREAKING_CHANGE_POLYFILLS = \"\\n\\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\";\nfunction isLikelyASyntaxError(message) {\n    return (0, _stripAnsi).default(message).indexOf(friendlySyntaxErrorLabel) !== -1;\n}\nlet hadMissingSassError = false;\n// Cleans up webpack error messages.\nfunction formatMessage(message, verbose, importTraceNote) {\n    // TODO: Replace this once webpack 5 is stable\n    if (typeof message === \"object\" && message.message) {\n        const filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter((trace)=>!/next-(middleware|client-pages|edge-function)-loader\\.js/.test(trace.originName));\n        let body = message.message;\n        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);\n        if (breakingChangeIndex >= 0) {\n            body = body.slice(0, breakingChangeIndex);\n        }\n        message = (message.moduleName ? (0, _stripAnsi).default(message.moduleName) + \"\\n\" : \"\") + (message.file ? (0, _stripAnsi).default(message.file) + \"\\n\" : \"\") + body + (message.details && verbose ? \"\\n\" + message.details : \"\") + (filteredModuleTrace && filteredModuleTrace.length ? (importTraceNote || \"\\n\\nImport trace for requested module:\") + filteredModuleTrace.map((trace)=>`\\n${trace.moduleName}`).join(\"\") : \"\") + (message.stack && verbose ? \"\\n\" + message.stack : \"\");\n    }\n    let lines = message.split(\"\\n\");\n    // Strip Webpack-added headers off errors/warnings\n    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n    lines = lines.filter((line)=>!/Module [A-z ]+\\(from/.test(line));\n    // Transform parsing error into syntax error\n    // TODO: move this to our ESLint formatter?\n    lines = lines.map((line)=>{\n        const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(line);\n        if (!parsingError) {\n            return line;\n        }\n        const [, errorLine, errorColumn, errorMessage] = parsingError;\n        return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`;\n    });\n    message = lines.join(\"\\n\");\n    // Smoosh syntax errors (commonly found in CSS)\n    message = message.replace(/SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g, `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`);\n    // Clean up export errors\n    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, `Attempted import error: '$1' is not exported from '$2'.`);\n    message = message.replace(/^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm, `Attempted import error: '$2' does not contain a default export (imported as '$1').`);\n    message = message.replace(/^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm, `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`);\n    lines = message.split(\"\\n\");\n    // Remove leading newline\n    if (lines.length > 2 && lines[1].trim() === \"\") {\n        lines.splice(1, 1);\n    }\n    // Cleans up verbose \"module not found\" messages for files and packages.\n    if (lines[1] && lines[1].indexOf(\"Module not found: \") === 0) {\n        lines = [\n            lines[0],\n            lines[1].replace(\"Error: \", \"\").replace(\"Module not found: Cannot find file:\", \"Cannot find file:\"),\n            ...lines.slice(2)\n        ];\n    }\n    // Add helpful message for users trying to use Sass for the first time\n    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {\n        // ./file.module.scss (<<loader info>>) => ./file.module.scss\n        const firstLine = lines[0].split(\"!\");\n        lines[0] = firstLine[firstLine.length - 1];\n        lines[1] = \"To use Next.js' built-in Sass support, you first need to install `sass`.\\n\";\n        lines[1] += \"Run `npm i sass` or `yarn add sass` inside your workspace.\\n\";\n        lines[1] += \"\\nLearn more: https://nextjs.org/docs/messages/install-sass\";\n        // dispose of unhelpful stack trace\n        lines = lines.slice(0, 2);\n        hadMissingSassError = true;\n    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {\n        // dispose of unhelpful stack trace following missing sass module\n        lines = [];\n    }\n    if (!verbose) {\n        message = lines.join(\"\\n\");\n        // Internal stacks are generally useless so we strip them... with the\n        // exception of stacks containing `webpack:` because they're normally\n        // from user code generated by Webpack. For more information see\n        // https://github.com/facebook/create-react-app/pull/1050\n        message = message.replace(/^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm, \"\") // at ... ...:x:y\n        ;\n        message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, \"\") // at <anonymous>\n        ;\n        message = message.replace(/File was processed with these loaders:\\n(.+[\\\\/](next[\\\\/]dist[\\\\/].+|@next[\\\\/]react-refresh-utils[\\\\/]loader)\\.js\\n)*You may need an additional loader to handle the result of these loaders.\\n/g, \"\");\n        lines = message.split(\"\\n\");\n    }\n    // Remove duplicated newlines\n    lines = lines.filter((line, index, arr)=>index === 0 || line.trim() !== \"\" || line.trim() !== arr[index - 1].trim());\n    // Reassemble the message\n    message = lines.join(\"\\n\");\n    return message.trim();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=format-webpack-messages.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9mb3JtYXQtd2VicGFjay1tZXNzYWdlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQyxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCwrSkFBK0Q7QUFDOUYsSUFBSUUsYUFBYUQseUJBQXlCRCxtQkFBT0EsQ0FBQyxvRUFBK0I7QUFDakYsU0FBU0Ysc0JBQXNCSyxJQUFJLEVBQUVDLE9BQU8sRUFBRTtJQUMxQyxNQUFNQyxrQkFBa0JGLEtBQUtHLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLFVBQVU7UUFDL0MsTUFBTUMseUJBQXlCRCxRQUFRQSxPQUFPLENBQUNFLFFBQVEsQ0FBQztRQUN4RCxPQUFPQyxjQUFjSCxTQUFTQywwQkFBMEJMO0lBQzVEO0lBQ0EsTUFBTVEsb0JBQW9CVCxLQUFLVSxRQUFRLENBQUNOLEdBQUcsQ0FBQyxDQUFDQyxVQUFVO1FBQ25ELE9BQU9HLGNBQWNILFNBQVNKO0lBQ2xDO0lBQ0Esc0RBQXNEO0lBQ3RELElBQUlVLDZCQUE2QixDQUFDO0lBQ2xDLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJVixnQkFBZ0JXLE1BQU0sRUFBRUQsSUFBSTtRQUMzQyxNQUFNRSxRQUFRWixlQUFlLENBQUNVLEVBQUU7UUFDaEMsSUFBSUUsTUFBTVAsUUFBUSxDQUFDLCtCQUErQjtZQUM5Q0ksNkJBQTZCQztZQUM3QixLQUFNO1FBQ1YsQ0FBQztJQUNMO0lBQ0EsOERBQThEO0lBQzlELElBQUlELCtCQUErQixDQUFDLEdBQUc7UUFDbkMsTUFBTUcsUUFBUVosZ0JBQWdCYSxNQUFNLENBQUNKLDRCQUE0QjtRQUNqRVQsZ0JBQWdCYyxPQUFPLENBQUNGLEtBQUssQ0FBQyxFQUFFO0lBQ3BDLENB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QUFPL0QsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvZm9ybWF0LXdlYnBhY2stbWVzc2FnZXMuanM/NzVlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcztcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3N0cmlwQW5zaSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2lcIikpO1xuZnVuY3Rpb24gZm9ybWF0V2VicGFja01lc3NhZ2VzKGpzb24sIHZlcmJvc2UpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRFcnJvcnMgPSBqc29uLmVycm9ycy5tYXAoKG1lc3NhZ2UpPT57XG4gICAgICAgIGNvbnN0IGlzVW5rbm93bk5leHRGb250RXJyb3IgPSBtZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoJ0FuIGVycm9yIG9jY3VyZWQgaW4gYG5leHQvZm9udGAuJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIGlzVW5rbm93bk5leHRGb250RXJyb3IgfHwgdmVyYm9zZSk7XG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0dGVkV2FybmluZ3MgPSBqc29uLndhcm5pbmdzLm1hcCgobWVzc2FnZSk9PntcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgdmVyYm9zZSk7XG4gICAgfSk7XG4gICAgLy8gUmVvcmRlciBlcnJvcnMgdG8gcHV0IHRoZSBtb3N0IHJlbGV2YW50IG9uZXMgZmlyc3QuXG4gICAgbGV0IHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yID0gLTE7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZEVycm9ycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZm9ybWF0dGVkRXJyb3JzW2ldO1xuICAgICAgICBpZiAoZXJyb3IuaW5jbHVkZXMoJ1JlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yJykpIHtcbiAgICAgICAgICAgIHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yIHRvIHRoZSB0b3AgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yICE9PSAtMSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGZvcm1hdHRlZEVycm9ycy5zcGxpY2UocmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IsIDEpO1xuICAgICAgICBmb3JtYXR0ZWRFcnJvcnMudW5zaGlmdChlcnJvclswXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IF9leHRlbmRzKHt9LCBqc29uLCB7XG4gICAgICAgIGVycm9yczogZm9ybWF0dGVkRXJyb3JzLFxuICAgICAgICB3YXJuaW5nczogZm9ybWF0dGVkV2FybmluZ3NcbiAgICB9KTtcbiAgICBpZiAoIXZlcmJvc2UgJiYgcmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IHN5bnRheCBlcnJvcnMsIHNob3cganVzdCB0aGVtLlxuICAgICAgICByZXN1bHQuZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpO1xuICAgICAgICByZXN1bHQud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iLzdiMWEzMmJlNmVjOWY5OWE2YzlhM2M2NjgxM2YzYWMwOWM0NzM2YjkvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL2Zvcm1hdFdlYnBhY2tNZXNzYWdlcy5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCB0byByZW1vdmUgY2hhbGsgYW5kIENSQS1zcGVjaWZpYyBsb2dpY1xuY29uc3QgZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsID0gJ1N5bnRheCBlcnJvcjonO1xuY29uc3QgV0VCUEFDS19CUkVBS0lOR19DSEFOR0VfUE9MWUZJTExTID0gJ1xcblxcbkJSRUFLSU5HIENIQU5HRTogd2VicGFjayA8IDUgdXNlZCB0byBpbmNsdWRlIHBvbHlmaWxscyBmb3Igbm9kZS5qcyBjb3JlIG1vZHVsZXMgYnkgZGVmYXVsdC4nO1xuZnVuY3Rpb24gaXNMaWtlbHlBU3ludGF4RXJyb3IobWVzc2FnZSkge1xuICAgIHJldHVybiAoMCwgX3N0cmlwQW5zaSkuZGVmYXVsdChtZXNzYWdlKS5pbmRleE9mKGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCkgIT09IC0xO1xufVxubGV0IGhhZE1pc3NpbmdTYXNzRXJyb3IgPSBmYWxzZTtcbi8vIENsZWFucyB1cCB3ZWJwYWNrIGVycm9yIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCB2ZXJib3NlLCBpbXBvcnRUcmFjZU5vdGUpIHtcbiAgICAvLyBUT0RPOiBSZXBsYWNlIHRoaXMgb25jZSB3ZWJwYWNrIDUgaXMgc3RhYmxlXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiBtZXNzYWdlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNb2R1bGVUcmFjZSA9IG1lc3NhZ2UubW9kdWxlVHJhY2UgJiYgbWVzc2FnZS5tb2R1bGVUcmFjZS5maWx0ZXIoKHRyYWNlKT0+IS9uZXh0LShtaWRkbGV3YXJlfGNsaWVudC1wYWdlc3xlZGdlLWZ1bmN0aW9uKS1sb2FkZXJcXC5qcy8udGVzdCh0cmFjZS5vcmlnaW5OYW1lKSk7XG4gICAgICAgIGxldCBib2R5ID0gbWVzc2FnZS5tZXNzYWdlO1xuICAgICAgICBjb25zdCBicmVha2luZ0NoYW5nZUluZGV4ID0gYm9keS5pbmRleE9mKFdFQlBBQ0tfQlJFQUtJTkdfQ0hBTkdFX1BPTFlGSUxMUyk7XG4gICAgICAgIGlmIChicmVha2luZ0NoYW5nZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIGJyZWFraW5nQ2hhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgPSAobWVzc2FnZS5tb2R1bGVOYW1lID8gKDAsIF9zdHJpcEFuc2kpLmRlZmF1bHQobWVzc2FnZS5tb2R1bGVOYW1lKSArICdcXG4nIDogJycpICsgKG1lc3NhZ2UuZmlsZSA/ICgwLCBfc3RyaXBBbnNpKS5kZWZhdWx0KG1lc3NhZ2UuZmlsZSkgKyAnXFxuJyA6ICcnKSArIGJvZHkgKyAobWVzc2FnZS5kZXRhaWxzICYmIHZlcmJvc2UgPyAnXFxuJyArIG1lc3NhZ2UuZGV0YWlscyA6ICcnKSArIChmaWx0ZXJlZE1vZHVsZVRyYWNlICYmIGZpbHRlcmVkTW9kdWxlVHJhY2UubGVuZ3RoID8gKGltcG9ydFRyYWNlTm90ZSB8fCAnXFxuXFxuSW1wb3J0IHRyYWNlIGZvciByZXF1ZXN0ZWQgbW9kdWxlOicpICsgZmlsdGVyZWRNb2R1bGVUcmFjZS5tYXAoKHRyYWNlKT0+YFxcbiR7dHJhY2UubW9kdWxlTmFtZX1gKS5qb2luKCcnKSA6ICcnKSArIChtZXNzYWdlLnN0YWNrICYmIHZlcmJvc2UgPyAnXFxuJyArIG1lc3NhZ2Uuc3RhY2sgOiAnJyk7XG4gICAgfVxuICAgIGxldCBsaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgIC8vIFN0cmlwIFdlYnBhY2stYWRkZWQgaGVhZGVycyBvZmYgZXJyb3JzL3dhcm5pbmdzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL21hc3Rlci9saWIvTW9kdWxlRXJyb3IuanNcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigobGluZSk9PiEvTW9kdWxlIFtBLXogXStcXChmcm9tLy50ZXN0KGxpbmUpKTtcbiAgICAvLyBUcmFuc2Zvcm0gcGFyc2luZyBlcnJvciBpbnRvIHN5bnRheCBlcnJvclxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBvdXIgRVNMaW50IGZvcm1hdHRlcj9cbiAgICBsaW5lcyA9IGxpbmVzLm1hcCgobGluZSk9PntcbiAgICAgICAgY29uc3QgcGFyc2luZ0Vycm9yID0gL0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKCFwYXJzaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFssIGVycm9yTGluZSwgZXJyb3JDb2x1bW4sIGVycm9yTWVzc2FnZV0gPSBwYXJzaW5nRXJyb3I7XG4gICAgICAgIHJldHVybiBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICR7ZXJyb3JNZXNzYWdlfSAoJHtlcnJvckxpbmV9OiR7ZXJyb3JDb2x1bW59KWA7XG4gICAgfSk7XG4gICAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIC8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvU3ludGF4RXJyb3JcXHMrXFwoKFxcZCspOihcXGQrKVxcKVxccyooLis/KVxcbi9nLCBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICQzICgkMTokMilcXG5gKTtcbiAgICAvLyBDbGVhbiB1cCBleHBvcnQgZXJyb3JzXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXi4qZXhwb3J0ICcoLis/KScgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLCBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQxJyBpcyBub3QgZXhwb3J0ZWQgZnJvbSAnJDInLmApO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL14uKmV4cG9ydCAnZGVmYXVsdCcgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDInIGRvZXMgbm90IGNvbnRhaW4gYSBkZWZhdWx0IGV4cG9ydCAoaW1wb3J0ZWQgYXMgJyQxJykuYCk7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXi4qZXhwb3J0ICcoLis/KScgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMycgKGltcG9ydGVkIGFzICckMicpLmApO1xuICAgIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgbmV3bGluZVxuICAgIGlmIChsaW5lcy5sZW5ndGggPiAyICYmIGxpbmVzWzFdLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKDEsIDEpO1xuICAgIH1cbiAgICAvLyBDbGVhbnMgdXAgdmVyYm9zZSBcIm1vZHVsZSBub3QgZm91bmRcIiBtZXNzYWdlcyBmb3IgZmlsZXMgYW5kIHBhY2thZ2VzLlxuICAgIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5pbmRleE9mKCdNb2R1bGUgbm90IGZvdW5kOiAnKSA9PT0gMCkge1xuICAgICAgICBsaW5lcyA9IFtcbiAgICAgICAgICAgIGxpbmVzWzBdLFxuICAgICAgICAgICAgbGluZXNbMV0ucmVwbGFjZSgnRXJyb3I6ICcsICcnKS5yZXBsYWNlKCdNb2R1bGUgbm90IGZvdW5kOiBDYW5ub3QgZmluZCBmaWxlOicsICdDYW5ub3QgZmluZCBmaWxlOicpLFxuICAgICAgICAgICAgLi4ubGluZXMuc2xpY2UoMiksIFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBBZGQgaGVscGZ1bCBtZXNzYWdlIGZvciB1c2VycyB0cnlpbmcgdG8gdXNlIFNhc3MgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLm1hdGNoKC9DYW5ub3QgZmluZCBtb2R1bGUuK3Nhc3MvKSkge1xuICAgICAgICAvLyAuL2ZpbGUubW9kdWxlLnNjc3MgKDw8bG9hZGVyIGluZm8+PikgPT4gLi9maWxlLm1vZHVsZS5zY3NzXG4gICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGxpbmVzWzBdLnNwbGl0KCchJyk7XG4gICAgICAgIGxpbmVzWzBdID0gZmlyc3RMaW5lW2ZpcnN0TGluZS5sZW5ndGggLSAxXTtcbiAgICAgICAgbGluZXNbMV0gPSBcIlRvIHVzZSBOZXh0LmpzJyBidWlsdC1pbiBTYXNzIHN1cHBvcnQsIHlvdSBmaXJzdCBuZWVkIHRvIGluc3RhbGwgYHNhc3NgLlxcblwiO1xuICAgICAgICBsaW5lc1sxXSArPSAnUnVuIGBucG0gaSBzYXNzYCBvciBgeWFybiBhZGQgc2Fzc2AgaW5zaWRlIHlvdXIgd29ya3NwYWNlLlxcbic7XG4gICAgICAgIGxpbmVzWzFdICs9ICdcXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnN0YWxsLXNhc3MnO1xuICAgICAgICAvLyBkaXNwb3NlIG9mIHVuaGVscGZ1bCBzdGFjayB0cmFjZVxuICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIDIpO1xuICAgICAgICBoYWRNaXNzaW5nU2Fzc0Vycm9yID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhZE1pc3NpbmdTYXNzRXJyb3IgJiYgbWVzc2FnZS5tYXRjaCgvKHNhc3MtbG9hZGVyfHJlc29sdmUtdXJsLWxvYWRlcjogQ1NTIGVycm9yKS8pKSB7XG4gICAgICAgIC8vIGRpc3Bvc2Ugb2YgdW5oZWxwZnVsIHN0YWNrIHRyYWNlIGZvbGxvd2luZyBtaXNzaW5nIHNhc3MgbW9kdWxlXG4gICAgICAgIGxpbmVzID0gW107XG4gICAgfVxuICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICBtZXNzYWdlID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIC8vIEludGVybmFsIHN0YWNrcyBhcmUgZ2VuZXJhbGx5IHVzZWxlc3Mgc28gd2Ugc3RyaXAgdGhlbS4uLiB3aXRoIHRoZVxuICAgICAgICAvLyBleGNlcHRpb24gb2Ygc3RhY2tzIGNvbnRhaW5pbmcgYHdlYnBhY2s6YCBiZWNhdXNlIHRoZXkncmUgbm9ybWFsbHlcbiAgICAgICAgLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9wdWxsLzEwNTBcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sICcnKSAvLyBhdCAuLi4gLi4uOng6eVxuICAgICAgICA7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL15cXHMqYXRcXHM8YW5vbnltb3VzPihcXG58JCkvZ20sICcnKSAvLyBhdCA8YW5vbnltb3VzPlxuICAgICAgICA7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL0ZpbGUgd2FzIHByb2Nlc3NlZCB3aXRoIHRoZXNlIGxvYWRlcnM6XFxuKC4rW1xcXFwvXShuZXh0W1xcXFwvXWRpc3RbXFxcXC9dLit8QG5leHRbXFxcXC9dcmVhY3QtcmVmcmVzaC11dGlsc1tcXFxcL11sb2FkZXIpXFwuanNcXG4pKllvdSBtYXkgbmVlZCBhbiBhZGRpdGlvbmFsIGxvYWRlciB0byBoYW5kbGUgdGhlIHJlc3VsdCBvZiB0aGVzZSBsb2FkZXJzLlxcbi9nLCAnJyk7XG4gICAgICAgIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKGxpbmUsIGluZGV4LCBhcnIpPT5pbmRleCA9PT0gMCB8fCBsaW5lLnRyaW0oKSAhPT0gJycgfHwgbGluZS50cmltKCkgIT09IGFycltpbmRleCAtIDFdLnRyaW0oKSk7XG4gICAgLy8gUmVhc3NlbWJsZSB0aGUgbWVzc2FnZVxuICAgIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gbWVzc2FnZS50cmltKCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJmb3JtYXRXZWJwYWNrTWVzc2FnZXMiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfc3RyaXBBbnNpIiwianNvbiIsInZlcmJvc2UiLCJmb3JtYXR0ZWRFcnJvcnMiLCJlcnJvcnMiLCJtYXAiLCJtZXNzYWdlIiwiaXNVbmtub3duTmV4dEZvbnRFcnJvciIsImluY2x1ZGVzIiwiZm9ybWF0TWVzc2FnZSIsImZvcm1hdHRlZFdhcm5pbmdzIiwid2FybmluZ3MiLCJyZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciIsImkiLCJsZW5ndGgiLCJlcnJvciIsInNwbGljZSIsInVuc2hpZnQiLCJyZXN1bHQiLCJzb21lIiwiaXNMaWtlbHlBU3ludGF4RXJyb3IiLCJmaWx0ZXIiLCJmcmllbmRseVN5bnRheEVycm9yTGFiZWwiLCJXRUJQQUNLX0JSRUFLSU5HX0NIQU5HRV9QT0xZRklMTFMiLCJpbmRleE9mIiwiaGFkTWlzc2luZ1Nhc3NFcnJvciIsImltcG9ydFRyYWNlTm90ZSIsImZpbHRlcmVkTW9kdWxlVHJhY2UiLCJtb2R1bGVUcmFjZSIsInRyYWNlIiwidGVzdCIsIm9yaWdpbk5hbWUiLCJib2R5IiwiYnJlYWtpbmdDaGFuZ2VJbmRleCIsInNsaWNlIiwibW9kdWxlTmFtZSIsImZpbGUiLCJkZXRhaWxzIiwiam9pbiIsInN0YWNrIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJwYXJzaW5nRXJyb3IiLCJleGVjIiwiZXJyb3JMaW5lIiwiZXJyb3JDb2x1bW4iLCJlcnJvck1lc3NhZ2UiLCJyZXBsYWNlIiwidHJpbSIsIm1hdGNoIiwiZmlyc3RMaW5lIiwiaW5kZXgiLCJhcnIiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _head = _interop_require_default(__webpack_require__(/*! ../shared/lib/head */ \"(sc_client)/./node_modules/next/dist/shared/lib/head.js\"));\nvar _imageBlurSvg = __webpack_require__(/*! ../shared/lib/image-blur-svg */ \"../shared/lib/image-blur-svg\");\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"../shared/lib/image-config\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"../shared/lib/image-config-context\");\nvar _warnOnce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"./utils/warn-once\");\nvar _imageLoader = _interop_require_default(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"next/dist/shared/lib/image-loader\"));\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nconst allImgs = new Map();\nlet perfObserver;\nif (true) {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths({ deviceSizes , allSizes  }, width, sizes) {\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs({ config , src , unoptimized , width , quality , sizes , loader  }) {\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths , kind  } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>`${loader({\n                config,\n                src,\n                quality,\n                width: w\n            })} ${kind === \"w\" ? w : i + 1}${kind}`).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\" || typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current(_extends({}, event, {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnOnce).warnOnce(`Image with src \"${src}\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);\n                    }\n                }\n                if (img.parentElement) {\n                    const { position  } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnOnce).warnOnce(`Image with src \"${src}\" has \"fill\" and parent element with invalid \"position\". Provided \"${position}\" should be one of ${valid.map(String).join(\",\")}.`);\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnOnce).warnOnce(`Image with src \"${src}\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`);\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnOnce).warnOnce(`Image with src \"${src}\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio.`);\n            }\n        }\n    });\n}\nconst ImageElement = /*#__PURE__*/ (0, _react).forwardRef((_param, forwardedRef)=>{\n    var { imgAttributes , heightInt , widthInt , qualityInt , className , imgStyle , blurStyle , isLazy , fill , placeholder , loading , srcString , config , unoptimized , loader , onLoadRef , onLoadingCompleteRef , setBlurComplete , setShowAltText , onLoad , onError  } = _param, rest = _object_without_properties_loose(_param, [\n        \"imgAttributes\",\n        \"heightInt\",\n        \"widthInt\",\n        \"qualityInt\",\n        \"className\",\n        \"imgStyle\",\n        \"blurStyle\",\n        \"isLazy\",\n        \"fill\",\n        \"placeholder\",\n        \"loading\",\n        \"srcString\",\n        \"config\",\n        \"unoptimized\",\n        \"loader\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    loading = isLazy ? \"lazy\" : loading;\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, {\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: _extends({}, imgStyle, blurStyle)\n    }, imgAttributes, {\n        ref: (0, _react).useCallback((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!srcString) {\n                    console.error(`Image is missing required \"src\" property:`, img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error(`Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.`);\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, srcString, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            srcString,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, srcString, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    })));\n});\nconst Image = /*#__PURE__*/ (0, _react).forwardRef((_param, forwardedRef)=>{\n    var { src , sizes , unoptimized =false , priority =false , loading , className , quality , width , height , fill , style , onLoad , onLoadingComplete , placeholder =\"empty\" , blurDataURL , layout , objectFit , objectPosition , lazyBoundary , lazyRoot  } = _param, all = _object_without_properties_loose(_param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    const configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n    const config = (0, _react).useMemo(()=>{\n        const c = configEnv || configContext || _imageConfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return _extends({}, c, {\n            allSizes,\n            deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    let rest = all;\n    let loader = rest.loader || _imageLoader.default;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error(`Image with src \"${src}\" is missing \"loader\" prop.` + `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`);\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        var _tmp;\n        _tmp = (obj)=>{\n            const { config: _  } = obj, opts = _object_without_properties_loose(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        }, loader = _tmp, _tmp;\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _extends({}, style, layoutStyle);\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(staticImageData)}`);\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(staticImageData)}`);\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const [blurComplete, setBlurComplete] = (0, _react).useState(false);\n    const [showAltText, setShowAltText] = (0, _react).useState(false);\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error(`Image with src \"${src}\" has both \"width\" and \"fill\" properties. Only one should be used.`);\n                }\n                if (height) {\n                    throw new Error(`Image with src \"${src}\" has both \"height\" and \"fill\" properties. Only one should be used.`);\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error(`Image with src \"${src}\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.`);\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error(`Image with src \"${src}\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.`);\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error(`Image with src \"${src}\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.`);\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error(`Image with src \"${src}\" is missing required \"width\" property.`);\n                } else if (isNaN(widthInt)) {\n                    throw new Error(`Image with src \"${src}\" has invalid \"width\" property. Expected a numeric value in pixels but received \"${width}\".`);\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error(`Image with src \"${src}\" is missing required \"height\" property.`);\n                } else if (isNaN(heightInt)) {\n                    throw new Error(`Image with src \"${src}\" has invalid \"height\" property. Expected a numeric value in pixels but received \"${height}\".`);\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error(`Image with src \"${src}\" has invalid \"loading\" property. Provided \"${loading}\" should be one of ${VALID_LOADING_VALUES.map(String).join(\",\")}.`);\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error(`Image with src \"${src}\" has both \"priority\" and \"loading='lazy'\" properties. Only one should be used.`);\n        }\n        if (placeholder === \"blur\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnOnce).warnOnce(`Image with src \"${src}\" is smaller than 40x40. Consider removing the \"placeholder='blur'\" property to improve performance.`);\n            }\n            if (!blurDataURL) {\n                const VALID_BLUR_EXT = [\n                    \"jpeg\",\n                    \"png\",\n                    \"webp\",\n                    \"avif\"\n                ] // should match next-image-loader\n                ;\n                throw new Error(`Image with src \"${src}\" has \"placeholder='blur'\" property but is missing the \"blurDataURL\" property.\n          Possible solutions:\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\n            - Change the \"src\" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(\",\")}\n            - Remove the \"placeholder\" property, effectively no blur effect\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`);\n            }\n        }\n        if (\"ref\" in rest) {\n            (0, _warnOnce).warnOnce(`Image with src \"${src}\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.`);\n        }\n        if (!unoptimized && loader !== _imageLoader.default) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnOnce).warnOnce(`Image with src \"${src}\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.` + `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`);\n            }\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnOnce).warnOnce(`Image with src \"${src}\" has legacy prop \"${legacyKey}\". Did you forget to run the codemod?` + `\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13`);\n            }\n        }\n        if (false) {}\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const blurStyle = placeholder === \"blur\" && blurDataURL && !blurComplete ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"data:image/svg+xml;charset=utf-8,${(0, _imageBlurSvg).getImageBlurSvg({\n            widthInt,\n            heightInt,\n            blurWidth,\n            blurHeight,\n            blurDataURL,\n            objectFit: imgStyle.objectFit\n        })}\")`\n    } : {};\n    if (true) {\n        if (blurStyle.backgroundImage && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            blurStyle.backgroundImage = `url(\"${blurDataURL}\")`;\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    let srcString = src;\n    if (true) {\n        if (false) {}\n    }\n    const linkProps = {\n        // @ts-expect-error upgrade react types to react 18\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: rest.crossOrigin\n    };\n    const onLoadRef = (0, _react).useRef(onLoad);\n    (0, _react).useEffect(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n    (0, _react).useEffect(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const imgElementArgs = _extends({\n        isLazy,\n        imgAttributes,\n        heightInt,\n        widthInt,\n        qualityInt,\n        className,\n        imgStyle,\n        blurStyle,\n        loading,\n        config,\n        fill,\n        unoptimized,\n        placeholder,\n        loader,\n        srcString,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        setShowAltText\n    }, rest);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs, {\n        ref: forwardedRef\n    })), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", Object.assign({\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src\n    }, linkProps))) : null);\n});\nvar _default = Image;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsV0FBV0MsK0hBQStDO0FBQzlELElBQUlDLDJCQUEyQkQsK0pBQStEO0FBQzlGLElBQUlFLDRCQUE0QkYsaUtBQWdFO0FBQ2hHLElBQUlHLG1DQUFtQ0gsK0tBQXVFO0FBQzlHLElBQUlJLFNBQVNGLDBCQUEwQkYsbUJBQU9BLENBQUMsb0JBQU87QUFDdEQsSUFBSUssUUFBUUoseUJBQXlCRCxtQkFBT0EsQ0FBQyxtRkFBb0I7QUFDakUsSUFBSU0sZ0JBQWdCTixtQkFBT0EsQ0FBQyxrRUFBOEI7QUFDMUQsSUFBSU8sZUFBZVAsbUJBQU9BLENBQUMsOERBQTRCO0FBQ3ZELElBQUlRLHNCQUFzQlIsbUJBQU9BLENBQUMsOEVBQW9DO0FBQ3RFLElBQUlTLFlBQVlULG1CQUFPQSxDQUFDLHdEQUErQjtBQUN2RCxJQUFJVSxlQUFlVCx5QkFBeUJELG1CQUFPQSxDQUFDLDRFQUFtQztBQUV2RixNQUFNVyxZQUFZQywwTkFBNkI7QUFDL0MsTUFBTUcsVUFBVSxJQUFJQztBQUNwQixJQUFJQztBQUNKLElBQUksSUFBa0IsRUFBYTtJQUMvQkMsV0FBV0MscUJBQXFCLEdBQUcsSUFBSTtBQUMzQyxDQUFDO0FBQ0QsTUFBTUMsdUJBQXVCO0lBQ3pCO0lBQ0E7SUFDQUM7Q0FDSDtBQUNELFNBQVNDLGdCQUFnQkMsR0FBRyxFQUFFO0lBQzFCLE9BQU9BLElBQUl6QixPQUFPLEtBQUt1QjtBQUMzQjtBQUNBLFNBQVNHLGtCQUFrQkQsR0FBRyxFQUFFO0lBQzVCLE9BQU9BLElBQUlBLEdBQUcsS0FBS0Y7QUFDdkI7QUFDQSxTQUFTSSxlQUFlRixHQUFHLEVBQUU7SUFDekIsT0FBTyxPQUFPQSxRQUFRLFlBQWFE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c291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xudmFyIF9pbWFnZUJsdXJTdmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Z1wiKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF93YXJuT25jZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbnZhciBfaW1hZ2VMb2FkZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlclwiKSk7XG5cbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTO1xuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWxUaGlzLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XG59XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICAnbGF6eScsXG4gICAgJ2VhZ2VyJyxcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyh7IGRldmljZVNpemVzICwgYWxsU2l6ZXMgIH0sIHdpZHRoLCBzaXplcykge1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB3aWR0aHMgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAgIC8vID4gYmx1ZSBjb2xvcnMuIFNob3dpbmcgYSAzeCByZXNvbHV0aW9uIGltYWdlIGluIHRoZSBhcHAgdnMgYSAyeFxuICAgICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgICAvLyA+IHdhc3RlZnVsIGFzIHRoZSBodW1hbiBleWUgY2Fubm90IHNlZSB0aGF0IGxldmVsIG9mIGRldGFpbCB3aXRob3V0XG4gICAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICAgIFtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgd2lkdGggKiAyIC8qLCB3aWR0aCAqIDMqLyBcbiAgICAgICAgXS5tYXAoKHcpPT5hbGxTaXplcy5maW5kKChwKT0+cCA+PSB3KSB8fCBhbGxTaXplc1thbGxTaXplcy5sZW5ndGggLSAxXSkpLCBcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogJ3gnXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoeyBjb25maWcgLCBzcmMgLCB1bm9wdGltaXplZCAsIHdpZHRoICwgcXVhbGl0eSAsIHNpemVzICwgbG9hZGVyICB9KSB7XG4gICAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aHMgLCBraW5kICB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIHNpemVzKTtcbiAgICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmAke2xvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWApLmpvaW4oJywgJyksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNyYzogbG9hZGVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2xhc3RdXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEludCh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBOYU47XG59XG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhpbWcsIHNyYywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpIHtcbiAgICBpZiAoIWltZyB8fCBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID0gc3JjO1xuICAgIGNvbnN0IHAgPSAnZGVjb2RlJyBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgU3ludGhldGljRXZlbnQgaGVyZSxcbiAgICAgICAgICAgIC8vIHdlIG11c3QgY3JlYXRlIG9uZSB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbFxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2xvYWQnKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGltZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQoX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGltZyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGltZyxcbiAgICAgICAgICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6ICgpPT5wcmV2ZW50ZWQsXG4gICAgICAgICAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6ICgpPT5zdG9wcGVkLFxuICAgICAgICAgICAgICAgIHBlcnNpc3Q6ICgpPT57fSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogKCk9PntcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmltZycpID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghaW1nLmdldEF0dHJpYnV0ZSgnc2l6ZXMnKSB8fCBpbWcuZ2V0QXR0cmlidXRlKCdzaXplcycpID09PSAnMTAwdncnKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhWaWV3cG9ydFJhdGlvID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybk9uY2UpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcImZpbGxcIiBidXQgaXMgbWlzc2luZyBcInNpemVzXCIgcHJvcC4gUGxlYXNlIGFkZCBpdCB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24gIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVsYXRpdmUnXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIHBhcmVudCBlbGVtZW50IHdpdGggaW52YWxpZCBcInBvc2l0aW9uXCIuIFByb3ZpZGVkIFwiJHtwb3NpdGlvbn1cIiBzaG91bGQgYmUgb25lIG9mICR7dmFsaWQubWFwKFN0cmluZykuam9pbignLCcpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1nLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIGEgaGVpZ2h0IHZhbHVlIG9mIDAuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gc3R5bGVkIHRvIGhhdmUgYSBzZXQgaGVpZ2h0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlaWdodE1vZGlmaWVkID0gaW1nLmhlaWdodC50b1N0cmluZygpICE9PSBpbWcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoTW9kaWZpZWQgPSBpbWcud2lkdGgudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCB8fCAhaGVpZ2h0TW9kaWZpZWQgJiYgd2lkdGhNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybk9uY2UpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzICd3aWR0aDogXCJhdXRvXCInIG9yICdoZWlnaHQ6IFwiYXV0b1wiJyB0byBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QpLmZvcndhcmRSZWYoKF9wYXJhbSwgZm9yd2FyZGVkUmVmKT0+e1xuICAgIHZhciB7IGltZ0F0dHJpYnV0ZXMgLCBoZWlnaHRJbnQgLCB3aWR0aEludCAsIHF1YWxpdHlJbnQgLCBjbGFzc05hbWUgLCBpbWdTdHlsZSAsIGJsdXJTdHlsZSAsIGlzTGF6eSAsIGZpbGwgLCBwbGFjZWhvbGRlciAsIGxvYWRpbmcgLCBzcmNTdHJpbmcgLCBjb25maWcgLCB1bm9wdGltaXplZCAsIGxvYWRlciAsIG9uTG9hZFJlZiAsIG9uTG9hZGluZ0NvbXBsZXRlUmVmICwgc2V0Qmx1ckNvbXBsZXRlICwgc2V0U2hvd0FsdFRleHQgLCBvbkxvYWQgLCBvbkVycm9yICB9ID0gX3BhcmFtLCByZXN0ID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoX3BhcmFtLCBbXG4gICAgICAgIFwiaW1nQXR0cmlidXRlc1wiLFxuICAgICAgICBcImhlaWdodEludFwiLFxuICAgICAgICBcIndpZHRoSW50XCIsXG4gICAgICAgIFwicXVhbGl0eUludFwiLFxuICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcImltZ1N0eWxlXCIsXG4gICAgICAgIFwiYmx1clN0eWxlXCIsXG4gICAgICAgIFwiaXNMYXp5XCIsXG4gICAgICAgIFwiZmlsbFwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwibG9hZGluZ1wiLFxuICAgICAgICBcInNyY1N0cmluZ1wiLFxuICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgIFwib25Mb2FkUmVmXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVSZWZcIixcbiAgICAgICAgXCJzZXRCbHVyQ29tcGxldGVcIixcbiAgICAgICAgXCJzZXRTaG93QWx0VGV4dFwiLFxuICAgICAgICBcIm9uTG9hZFwiLFxuICAgICAgICBcIm9uRXJyb3JcIlxuICAgIF0pO1xuICAgIGxvYWRpbmcgPSBpc0xhenkgPyAnbGF6eScgOiBsb2FkaW5nO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0LCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGZpbGwgPyAnZmlsbCcgOiAnMScsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpXG4gICAgfSwgaW1nQXR0cmlidXRlcywge1xuICAgICAgICByZWY6ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChpbWcpPT57XG4gICAgICAgICAgICBpZiAoZm9yd2FyZGVkUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdmdW5jdGlvbicpIGZvcndhcmRlZFJlZihpbWcpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcmNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwiYWx0XCIgcHJvcGVydHkuIFBsZWFzZSBhZGQgQWx0ZXJuYXRpdmUgVGV4dCB0byBkZXNjcmliZSB0aGUgaW1hZ2UgZm9yIHNjcmVlbiByZWFkZXJzIGFuZCBzZWFyY2ggZW5naW5lcy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgZm9yd2FyZGVkUmVmLCBcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIHBsYWNlaG9sZGVyLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUsIHVub3B0aW1pemVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGV2ZW50KT0+e1xuICAgICAgICAgICAgLy8gaWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIGVuc3VyZSBcImFsdFwiIGlzIHZpc2libGVcbiAgICAgICAgICAgIHNldFNob3dBbHRUZXh0KHRydWUpO1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgc3RpbGwgcmVtb3ZlIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpKTtcbn0pO1xuY29uc3QgSW1hZ2UgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QpLmZvcndhcmRSZWYoKF9wYXJhbSwgZm9yd2FyZGVkUmVmKT0+e1xuICAgIHZhciB7IHNyYyAsIHNpemVzICwgdW5vcHRpbWl6ZWQgPWZhbHNlICwgcHJpb3JpdHkgPWZhbHNlICwgbG9hZGluZyAsIGNsYXNzTmFtZSAsIHF1YWxpdHkgLCB3aWR0aCAsIGhlaWdodCAsIGZpbGwgLCBzdHlsZSAsIG9uTG9hZCAsIG9uTG9hZGluZ0NvbXBsZXRlICwgcGxhY2Vob2xkZXIgPSdlbXB0eScgLCBibHVyRGF0YVVSTCAsIGxheW91dCAsIG9iamVjdEZpdCAsIG9iamVjdFBvc2l0aW9uICwgbGF6eUJvdW5kYXJ5ICwgbGF6eVJvb3QgIH0gPSBfcGFyYW0sIGFsbCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9wYXJhbSwgW1xuICAgICAgICBcInNyY1wiLFxuICAgICAgICBcInNpemVzXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJwcmlvcml0eVwiLFxuICAgICAgICBcImxvYWRpbmdcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJxdWFsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgXCJvbkxvYWRcIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwiYmx1ckRhdGFVUkxcIixcbiAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgXCJvYmplY3RGaXRcIixcbiAgICAgICAgXCJvYmplY3RQb3NpdGlvblwiLFxuICAgICAgICBcImxhenlCb3VuZGFyeVwiLFxuICAgICAgICBcImxhenlSb290XCJcbiAgICBdKTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYywge1xuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbG9hZGVyID0gcmVzdC5sb2FkZXIgfHwgX2ltYWdlTG9hZGVyLmRlZmF1bHQ7XG4gICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPiBlbGVtZW50XG4gICAgZGVsZXRlIHJlc3QubG9hZGVyO1xuICAgIC8vIFRoaXMgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgdXNlclxuICAgIC8vIGRpZG4ndCBkZWZpbmUgYSBcImxvYWRlclwiIHByb3Agb3IgXCJsb2FkZXJcIiBjb25maWcuXG4gICAgY29uc3QgaXNEZWZhdWx0TG9hZGVyID0gJ19fbmV4dF9pbWdfZGVmYXVsdCcgaW4gbG9hZGVyO1xuICAgIGlmIChpc0RlZmF1bHRMb2FkZXIpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5sb2FkZXIgPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyBcImxvYWRlclwiIHByb3AuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSB1c2VyIGRlZmluZWQgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgICAgICAvLyBTaW5jZSB0aGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5LCB3ZVxuICAgICAgICAvLyBtdXN0IG5vdCBwYXNzIGl0IHRvIHRoZSB1c2VyLWRlZmluZWQgXCJsb2FkZXJcIi5cbiAgICAgICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHZhciBfdG1wO1xuICAgICAgICBfdG1wID0gKG9iaik9PntcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiBfICB9ID0gb2JqLCBvcHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uob2JqLCBbXG4gICAgICAgICAgICAgICAgXCJjb25maWdcIlxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tSW1hZ2VMb2FkZXIob3B0cyk7XG4gICAgICAgIH0sIGxvYWRlciA9IF90bXAsIF90bXA7XG4gICAgfVxuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgICAgICBmaWxsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRUb1N0eWxlID0ge1xuICAgICAgICAgICAgaW50cmluc2ljOiB7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFRvU2l6ZXMgPSB7XG4gICAgICAgICAgICByZXNwb25zaXZlOiAnMTAwdncnLFxuICAgICAgICAgICAgZmlsbDogJzEwMHZ3J1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsYXlvdXRTdHlsZSA9IGxheW91dFRvU3R5bGVbbGF5b3V0XTtcbiAgICAgICAgaWYgKGxheW91dFN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZSA9IF9leHRlbmRzKHt9LCBzdHlsZSwgbGF5b3V0U3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheW91dFNpemVzID0gbGF5b3V0VG9TaXplc1tsYXlvdXRdO1xuICAgICAgICBpZiAobGF5b3V0U2l6ZXMgJiYgIXNpemVzKSB7XG4gICAgICAgICAgICBzaXplcyA9IGxheW91dFNpemVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSAnJztcbiAgICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KTtcbiAgICBsZXQgYmx1cldpZHRoO1xuICAgIGxldCBibHVySGVpZ2h0O1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgaGVpZ2h0IGFuZCB3aWR0aC4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xuICAgICAgICB9XG4gICAgICAgIGJsdXJXaWR0aCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVyV2lkdGg7XG4gICAgICAgIGJsdXJIZWlnaHQgPSBzdGF0aWNJbWFnZURhdGEuYmx1ckhlaWdodDtcbiAgICAgICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkw7XG4gICAgICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmM7XG4gICAgICAgIGlmICghZmlsbCkge1xuICAgICAgICAgICAgaWYgKCF3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SW50ID0gc3RhdGljSW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gd2lkdGhJbnQgLyBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEuaGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghd2lkdGhJbnQgJiYgaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBoZWlnaHRJbnQgLyBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoSW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEud2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBzdGF0aWNTcmM7XG4gICAgbGV0IGlzTGF6eSA9ICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJyk7XG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb25maWcudW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyICYmIHNyYy5lbmRzV2l0aCgnLnN2ZycpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgICAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJ3aWR0aFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHN0eWxlID09IG51bGwgPyB2b2lkIDAgOiBzdHlsZS53aWR0aCkgJiYgc3R5bGUud2lkdGggIT09ICcxMDAlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUud2lkdGhcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHdpZHRoIDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLmhlaWdodCkgJiYgc3R5bGUuaGVpZ2h0ICE9PSAnMTAwJScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcIndpZHRoXCIgcHJvcGVydHkuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih3aWR0aEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke3dpZHRofVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhlaWdodEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHtoZWlnaHR9XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybk9uY2UpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHNtYWxsZXIgdGhhbiA0MHg0MC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2pwZWcnLFxuICAgICAgICAgICAgICAgICAgICAncG5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYnAnLFxuICAgICAgICAgICAgICAgICAgICAnYXZpZidcbiAgICAgICAgICAgICAgICBdIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbignLCcpfVxuICAgICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBfaW1hZ2VMb2FkZXIuZGVmYXVsdCkge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbGVnYWN5S2V5LCBsZWdhY3lWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICAgICAgICBsYXp5Qm91bmRhcnksXG4gICAgICAgICAgICBsYXp5Um9vdFxuICAgICAgICB9KSl7XG4gICAgICAgICAgICBpZiAobGVnYWN5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgbGVnYWN5IHByb3AgXCIke2xlZ2FjeUtleX1cIi4gRGlkIHlvdSBmb3JnZXQgdG8gcnVuIHRoZSBjb2RlbW9kP2AgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zcmMpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsY3BJbWFnZSAmJiAhbGNwSW1hZ2UucHJpb3JpdHkgJiYgbGNwSW1hZ2UucGxhY2Vob2xkZXIgIT09ICdibHVyJyAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKGZpbGwgPyB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfSA6IHt9LCBzaG93QWx0VGV4dCA/IHt9IDoge1xuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgIH0sIHN0eWxlKTtcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmIGJsdXJEYXRhVVJMICYmICFibHVyQ29tcGxldGUgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBpbWdTdHlsZS5vYmplY3RQb3NpdGlvbiB8fCAnNTAlIDUwJScsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwkeygwLCBfaW1hZ2VCbHVyU3ZnKS5nZXRJbWFnZUJsdXJTdmcoe1xuICAgICAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgICAgICBibHVyV2lkdGgsXG4gICAgICAgICAgICBibHVySGVpZ2h0LFxuICAgICAgICAgICAgYmx1ckRhdGFVUkwsXG4gICAgICAgICAgICBvYmplY3RGaXQ6IGltZ1N0eWxlLm9iamVjdEZpdFxuICAgICAgICB9KX1cIilgXG4gICAgfSA6IHt9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAoYmx1clN0eWxlLmJhY2tncm91bmRJbWFnZSAmJiAoYmx1ckRhdGFVUkwgPT0gbnVsbCA/IHZvaWQgMCA6IGJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoJy8nKSkpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyBgbmV4dCBkZXZgLCB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGJsdXIgcGxhY2Vob2xkZXJzIHdpdGggd2VicGFja1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gZGVsYXkgc3RhcnRpbmcgdGhlIGRldiBzZXJ2ZXIuIEluc3RlYWQsIGBuZXh0LWltYWdlLWxvYWRlci5qc2BcbiAgICAgICAgICAgIC8vIHdpbGwgaW5saW5lIGEgc3BlY2lhbCB1cmwgdG8gbGF6aWx5IGdlbmVyYXRlIHRoZSBibHVyIHBsYWNlaG9sZGVyIGF0IHJlcXVlc3QgdGltZS5cbiAgICAgICAgICAgIGJsdXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHtibHVyRGF0YVVSTH1cIilgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBzcmMsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgIHNpemVzLFxuICAgICAgICBsb2FkZXJcbiAgICB9KTtcbiAgICBsZXQgc3JjU3RyaW5nID0gc3JjO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW5rUHJvcHMgPSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdXBncmFkZSByZWFjdCB0eXBlcyB0byByZWFjdCAxOFxuICAgICAgICBpbWFnZVNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIGNyb3NzT3JpZ2luOiByZXN0LmNyb3NzT3JpZ2luXG4gICAgfTtcbiAgICBjb25zdCBvbkxvYWRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYob25Mb2FkKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQgPSBvbkxvYWQ7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRcbiAgICBdKTtcbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZTtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXG4gICAgXSk7XG4gICAgY29uc3QgaW1nRWxlbWVudEFyZ3MgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlzTGF6eSxcbiAgICAgICAgaW1nQXR0cmlidXRlcyxcbiAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eUludCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBpbWdTdHlsZSxcbiAgICAgICAgYmx1clN0eWxlLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2V0U2hvd0FsdFRleHRcbiAgICB9LCByZXN0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBpbWdFbGVtZW50QXJncywge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0pKSwgcHJpb3JpdHkgPyAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgLy8gaXQgd291bGQgbGlrZWx5IGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGtleTogJ19fbmltZy0nICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgIGhyZWY6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmNcbiAgICB9LCBsaW5rUHJvcHMpKSkgOiBudWxsKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gSW1hZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9oZWFkIiwiX2ltYWdlQmx1clN2ZyIsIl9pbWFnZUNvbmZpZyIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfd2Fybk9uY2UiLCJfaW1hZ2VMb2FkZXIiLCJjb25maWdFbnYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJhbGxJbWdzIiwiTWFwIiwicGVyZk9ic2VydmVyIiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImdldFdpZHRocyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ3aWR0aCIsInNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsInBhcnNlSW50IiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJnZXRJbnQiLCJ4IiwidGVzdCIsIk5hTiIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnROb2RlIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJ3cml0YWJsZSIsInByZXZlbnRlZCIsInN0b3BwZWQiLCJuYXRpdmVFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInBlcnNpc3QiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBhcmVudEVsZW1lbnQiLCJwb3NpdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJ2YWxpZCIsImluY2x1ZGVzIiwiU3RyaW5nIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiX3BhcmFtIiwiZm9yd2FyZGVkUmVmIiwiaW1nQXR0cmlidXRlcyIsImhlaWdodEludCIsIndpZHRoSW50IiwicXVhbGl0eUludCIsImNsYXNzTmFtZSIsImltZ1N0eWxlIiwiYmx1clN0eWxlIiwiaXNMYXp5IiwiZmlsbCIsImxvYWRpbmciLCJzcmNTdHJpbmciLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiYXNzaWduIiwiZGVjb2RpbmciLCJzdHlsZSIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29uc29sZSIsImVycm9yIiwiY29tcGxldGUiLCJJbWFnZSIsInByaW9yaXR5Iiwib25Mb2FkaW5nQ29tcGxldGUiLCJibHVyRGF0YVVSTCIsImxheW91dCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwibGF6eUJvdW5kYXJ5IiwibGF6eVJvb3QiLCJhbGwiLCJjb25maWdDb250ZXh0IiwidXNlQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsInVzZU1lbW8iLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsImlzRGVmYXVsdExvYWRlciIsIkVycm9yIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJfdG1wIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0Iiwic3RhdGljSW1hZ2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInJhdGlvIiwicm91bmQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiYmx1ckNvbXBsZXRlIiwidXNlU3RhdGUiLCJzaG93QWx0VGV4dCIsImlzTmFOIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiZW50cmllcyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsImxpbmtQcm9wcyIsImltYWdlU3JjU2V0IiwiY3Jvc3NPcmlnaW4iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJpbWdFbGVtZW50QXJncyIsImtleSIsInJlbCIsImFzIiwiX2RlZmF1bHQiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/image.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathTrailingSlash = void 0;\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"../shared/lib/router/utils/remove-trailing-slash\");\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"../shared/lib/router/utils/parse-path\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith(\"/\") || undefined) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    if (false) {}\n    return `${(0, _removeTrailingSlash).removeTrailingSlash(pathname)}${query}${hash}`;\n};\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0NBQWtDLEdBQUcsS0FBSztBQUMxQyxJQUFJRyx1QkFBdUJDLG1CQUFPQSxDQUFDLDBHQUFrRDtBQUNyRixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyxvRkFBdUM7QUFDaEUsTUFBTUYsNkJBQTZCLENBQUNJLE9BQU87SUFDdkMsSUFBSSxDQUFDQSxLQUFLQyxVQUFVLENBQUMsUUFBUUMsU0FBd0MsRUFBRTtRQUNuRSxPQUFPRjtJQUNYLENBQUM7SUFDRCxNQUFNLEVBQUVLLFNBQVEsRUFBR0MsTUFBSyxFQUFHQyxLQUFJLEVBQUcsR0FBRyxDQUFDLEdBQUdSLFVBQVUsRUFBRVMsU0FBUyxDQUFDUjtJQUMvRCxJQUFJRSxLQUFpQyxFQUFFLEVBUXRDO0lBQ0QsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHTCxvQkFBb0IsRUFBRWMsbUJBQW1CLENBQUNOLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLENBQUM7QUFDdEY7QUFDQWIsa0NBQWtDLEdBQUdFO0FBRXJDLElBQUksQ0FBQyxPQUFPRixRQUFRbUIsT0FBTyxLQUFLLGNBQWUsT0FBT25CLFFBQVFtQixPQUFPLEtBQUssWUFBWW5CLFFBQVFtQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9uQixRQUFRbUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3RCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW1CLE9BQU8sRUFBRSxjQUFjO1FBQUVsQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3VCLE1BQU0sQ0FBQ3JCLFFBQVFtQixPQUFPLEVBQUVuQjtJQUMvQnNCLE9BQU90QixPQUFPLEdBQUdBLFFBQVFtQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCxvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoLmpzPzRjMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xudmFyIF9yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXBhdGhcIik7XG5jb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IChwYXRoKT0+e1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICwgaGFzaCAgfSA9ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgocGF0aCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7KDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKX0ke3F1ZXJ5fSR7aGFzaH1gO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtwYXRobmFtZX0ke3F1ZXJ5fSR7aGFzaH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfS8ke3F1ZXJ5fSR7aGFzaH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgJHsoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWA7XG59O1xuZXhwb3J0cy5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJfcmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJfcGFyc2VQYXRoIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX01BTlVBTF9UUkFJTElOR19TTEFTSCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwidGVzdCIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJlbmRzV2l0aCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/client/normalize-trailing-slash.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defaultHead = defaultHead;\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"react\"));\nvar _sideEffect = _interop_require_default(__webpack_require__(/*! ./side-effect */ \"./side-effect\"));\nvar _ampContext = __webpack_require__(/*! ./amp-context */ \"./amp-context\");\nvar _headManagerContext = __webpack_require__(/*! ./head-manager-context */ \"./head-manager-context\");\nvar _ampMode = __webpack_require__(/*! ./amp-mode */ \"./amp-mode\");\nvar _warnOnce = __webpack_require__(/*! ./utils/warn-once */ \"./utils/warn-once\");\nfunction defaultHead(inAmpMode = false) {\n    const head = [\n        /*#__PURE__*/ _react.default.createElement(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ _react.default.createElement(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode  } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? `<script> tag with src=\"${c.props[\"src\"]}\"` : `inline <script>`;\n                (0, _warnOnce).warnOnce(`Do not add <script> tags using next/head (see ${srcMessage}). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component`);\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnOnce).warnOnce(`Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"${c.props[\"href\"]}\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component`);\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head({ children  }) {\n    const ampState = (0, _react).useContext(_ampContext.AmpStateContext);\n    const headManager = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    return /*#__PURE__*/ _react.default.createElement(_sideEffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampMode).isInAmpMode(ampState)\n    }, children);\n}\nvar _default = Head;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBR0U7QUFDdEJGLGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJSSxXQUFXQywrSEFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCwrSkFBK0Q7QUFDOUYsSUFBSUUsNEJBQTRCRixpS0FBZ0U7QUFDaEcsSUFBSUcsU0FBU0QsMEJBQTBCRixtQkFBT0EsQ0FBQyxvQkFBTztBQUN0RCxJQUFJSSxjQUFjSCx5QkFBeUJELG1CQUFPQSxDQUFDLG9DQUFlO0FBQ2xFLElBQUlLLGNBQWNMLG1CQUFPQSxDQUFDLG9DQUFlO0FBQ3pDLElBQUlNLHNCQUFzQk4sbUJBQU9BLENBQUMsc0RBQXdCO0FBQzFELElBQUlPLFdBQVdQLG1CQUFPQSxDQUFDLDhCQUFZO0FBQ25DLElBQUlRLFlBQVlSLG1CQUFPQSxDQUFDLDRDQUFtQjtBQUUzQyxTQUFTSCxZQUFZWSxZQUFZLEtBQUssRUFBRTtJQUNwQyxNQUFNQyxPQUFPO1FBQ1QsV0FBVyxHQUFHUCxPQUFPTCxPQUFPLENBQUNhLGFBQWEsQ0FBQyxRQUFRO1lBQy9DQyxTQUFTO1FBQ2I7S0FDSDtJQUNELElBQUksQ0FBQ0gsV0FBVztRQUNaQyxLQUFLRyxJQUFJLENBQUMsV0FBVyxHQUFHVixPQUFPTCxPQUFPLENBQUNhLGFBQWEsQ0FBQyxRQUFRO1lBQ3pERyxNQUFNO1lBQ05DLFNBQVM7UUFDYjtJQUNKLENBQUM7SUFDRCxPQUFPTDtBQUNYO0FBQ0EsU0FBU00saUJBQWlCQyxJQUFJLEVBQUVDLEtBQUssRUFBRTtJQUNuQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQ3hELE9BQU9EO0lBQ1gsQ0FBQztJQUNELGtDQUFrQztJQUNsQyxJQUFJ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Q0FBQ2hFLG9CQUFvQm1FLGtCQUFrQjtJQUNqRixPQUFPLFdBQVcsR0FBR3RFLE9BQU9MLE9BQU8sQ0FBQ2EsYUFBYSxDQUFDUCxZQUFZTixPQUFPLEVBQUU7UUFDbkU0RSx5QkFBeUJ2QjtRQUN6QnFCLGFBQWFBO1FBQ2IvRCxXQUFXLENBQUMsR0FBR0YsUUFBUSxFQUFFb0UsV0FBVyxDQUFDTjtJQUN6QyxHQUFHNUM7QUFDUDtBQUNBLElBQUltRCxXQUFXUjtBQUNmekUsa0JBQWUsR0FBR2lGO0FBRWxCLElBQUksQ0FBQyxPQUFPakYsUUFBUUcsT0FBTyxLQUFLLGNBQWUsT0FBT0gsUUFBUUcsT0FBTyxLQUFLLFlBQVlILFFBQVFHLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0gsUUFBUUcsT0FBTyxDQUFDK0UsVUFBVSxLQUFLLGFBQWE7SUFDcktwRixPQUFPQyxjQUFjLENBQUNDLFFBQVFHLE9BQU8sRUFBRSxjQUFjO1FBQUVGLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPcUYsTUFBTSxDQUFDbkYsUUFBUUcsT0FBTyxFQUFFSDtJQUMvQm9GLE9BQU9wRixPQUFPLEdBQUdBLFFBQVFHLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhdHN0YWdyYW0vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHRIZWFkID0gZGVmYXVsdEhlYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9zaWRlRWZmZWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3NpZGUtZWZmZWN0XCIpKTtcbnZhciBfYW1wQ29udGV4dCA9IHJlcXVpcmUoXCIuL2FtcC1jb250ZXh0XCIpO1xudmFyIF9oZWFkTWFuYWdlckNvbnRleHQgPSByZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTtcbnZhciBfYW1wTW9kZSA9IHJlcXVpcmUoXCIuL2FtcC1tb2RlXCIpO1xudmFyIF93YXJuT25jZSA9IHJlcXVpcmUoXCIuL3V0aWxzL3dhcm4tb25jZVwiKTtcblxuZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpIHtcbiAgICBjb25zdCBoZWFkID0gW1xuICAgICAgICAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICAgICAgICB9KVxuICAgIF07XG4gICAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICAgICAgaGVhZC5wdXNoKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgICAgICAgICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGhcIlxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkO1xufVxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChsaXN0LCBjaGlsZCkge1xuICAgIC8vIFJlYWN0IGNoaWxkcmVuIGNhbiBiZSBcInN0cmluZ1wiIG9yIFwibnVtYmVyXCIgaW4gdGhpcyBjYXNlIHdlIGlnbm9yZSB0aGVtIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICAgIGlmIChjaGlsZC50eXBlID09PSBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKChmcmFnbWVudExpc3QsIGZyYWdtZW50Q2hpbGQpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTtcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKTtcbn1cbmNvbnN0IE1FVEFUWVBFUyA9IFtcbiAgICAnbmFtZScsXG4gICAgJ2h0dHBFcXVpdicsXG4gICAgJ2NoYXJTZXQnLFxuICAgICdpdGVtUHJvcCdcbl07XG4vKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi8gZnVuY3Rpb24gdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgbWV0YUNhdGVnb3JpZXMgPSB7fTtcbiAgICByZXR1cm4gKGgpPT57XG4gICAgICAgIGxldCBpc1VuaXF1ZSA9IHRydWU7XG4gICAgICAgIGxldCBoYXNLZXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoJyQnKSArIDEpO1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgc3dpdGNoKGgudHlwZSl7XG4gICAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICBjYXNlICdiYXNlJzpcbiAgICAgICAgICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShtZXRhdHlwZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YXR5cGUgPT09ICdjaGFyU2V0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVR5cGVzLmFkZChtZXRhdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSB8fCBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1ldGF0eXBlICE9PSAnbmFtZScgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5pcXVlO1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqLyBmdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKGhlYWRDaGlsZHJlbkVsZW1lbnRzLCBwcm9wcykge1xuICAgIGNvbnN0IHsgaW5BbXBNb2RlICB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIGhlYWRDaGlsZHJlbkVsZW1lbnRzLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSkucmV2ZXJzZSgpLmNvbmNhdChkZWZhdWx0SGVhZChpbkFtcE1vZGUpLnJldmVyc2UoKSkuZmlsdGVyKHVuaXF1ZSgpKS5yZXZlcnNlKCkubWFwKChjLCBpKT0+e1xuICAgICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmICFpbkFtcE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydocmVmJ10gJiYgLy8gVE9ETyhwcmF0ZWVrYmhAKTogUmVwbGFjZSB0aGlzIHdpdGggY29uc3QgZnJvbSBgY29uc3RhbnRzYCB3aGVuIHRoZSB0cmVlIHNoYWtpbmcgd29ya3MuXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJyxcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly91c2UudHlwZWtpdC5uZXQvJ1xuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gX2V4dGVuZHMoe30sIGMucHJvcHMgfHwge30pO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ107XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtb3B0aW1pemVkLWZvbnRzJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAvLyBvbWl0IEpTT04tTEQgc3RydWN0dXJlZCBkYXRhIHNuaXBwZXRzIGZyb20gdGhlIHdhcm5pbmdcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09ICdzY3JpcHQnICYmIGMucHJvcHNbJ3R5cGUnXSAhPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjTWVzc2FnZSA9IGMucHJvcHNbJ3NyYyddID8gYDxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIiR7Yy5wcm9wc1snc3JjJ119XCJgIDogYGlubGluZSA8c2NyaXB0PmA7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYERvIG5vdCBhZGQgPHNjcmlwdD4gdGFncyB1c2luZyBuZXh0L2hlYWQgKHNlZSAke3NyY01lc3NhZ2V9KS4gVXNlIG5leHQvc2NyaXB0IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc2NyaXB0LXRhZ3MtaW4taGVhZC1jb21wb25lbnRgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSAnbGluaycgJiYgYy5wcm9wc1sncmVsJ10gPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybk9uY2UpLndhcm5PbmNlKGBEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIiR7Yy5wcm9wc1snaHJlZiddfVwiKS4gVXNlIERvY3VtZW50IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc3R5bGVzaGVldHMtaW4taGVhZC1jb21wb25lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoYywge1xuICAgICAgICAgICAga2V5XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqLyBmdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FtcENvbnRleHQuQW1wU3RhdGVDb250ZXh0KTtcbiAgICBjb25zdCBoZWFkTWFuYWdlciA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3NpZGVFZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wTW9kZSkuaXNJbkFtcE1vZGUoYW1wU3RhdGUpXG4gICAgfSwgY2hpbGRyZW4pO1xufVxudmFyIF9kZWZhdWx0ID0gSGVhZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHRIZWFkIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVhY3QiLCJfc2lkZUVmZmVjdCIsIl9hbXBDb250ZXh0IiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9hbXBNb2RlIiwiX3dhcm5PbmNlIiwiaW5BbXBNb2RlIiwiaGVhZCIsImNyZWF0ZUVsZW1lbnQiLCJjaGFyU2V0IiwicHVzaCIsIm5hbWUiLCJjb250ZW50Iiwib25seVJlYWN0RWxlbWVudCIsImxpc3QiLCJjaGlsZCIsInR5cGUiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX09QVElNSVpFX0ZPTlRTIiwic29tZSIsInVybCIsInN0YXJ0c1dpdGgiLCJuZXdQcm9wcyIsInVuZGVmaW5lZCIsImNsb25lRWxlbWVudCIsInNyY01lc3NhZ2UiLCJ3YXJuT25jZSIsIkhlYWQiLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/shared/lib/head.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.suspense = suspense;\nexports.NoSSR = NoSSR;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(sc_client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"react\"));\nvar _noSsrError = __webpack_require__(/*! ./no-ssr-error */ \"(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js\");\nfunction suspense() {\n    const error = new Error(_noSsrError.NEXT_DYNAMIC_NO_SSR_CODE);\n    error.digest = _noSsrError.NEXT_DYNAMIC_NO_SSR_CODE;\n    throw error;\n}\nfunction NoSSR({ children  }) {\n    if (true) {\n        suspense();\n    }\n    return children;\n} //# sourceMappingURL=dynamic-no-ssr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2R5bmFtaWMtbm8tc3NyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHRTtBQUNuQkYsYUFBYSxHQUFHRztBQUNoQixJQUFJQywyQkFBMkJDLCtKQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQ3JELElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLG9HQUFnQjtBQUUxQyxTQUFTSCxXQUFXO0lBQ2hCLE1BQU1PLFFBQVEsSUFBSUMsTUFBTUYsWUFBWUcsd0JBQXdCO0lBQzVERixNQUFNRyxNQUFNLEdBQUdKLFlBQVlHLHdCQUF3QjtJQUNuRCxNQUFNRixNQUFNO0FBQ2hCO0FBQ0EsU0FBU04sTUFBTSxFQUFFVSxTQUFRLEVBQUcsRUFBRTtJQUMxQixJQUFJLElBQWtCLEVBQWE7UUFDL0JYO0lBQ0osQ0FBQztJQUNELE9BQU9XO0FBQ1gsRUFFQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2xhenktZHluYW1pYy9keW5hbWljLW5vLXNzci5qcz9jMWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN1c3BlbnNlID0gc3VzcGVuc2U7XG5leHBvcnRzLk5vU1NSID0gTm9TU1I7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX25vU3NyRXJyb3IgPSByZXF1aXJlKFwiLi9uby1zc3ItZXJyb3JcIik7XG5cbmZ1bmN0aW9uIHN1c3BlbnNlKCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKF9ub1NzckVycm9yLk5FWFRfRFlOQU1JQ19OT19TU1JfQ09ERSk7XG4gICAgZXJyb3IuZGlnZXN0ID0gX25vU3NyRXJyb3IuTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFO1xuICAgIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gTm9TU1IoeyBjaGlsZHJlbiAgfSkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdXNwZW5zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWMtbm8tc3NyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInN1c3BlbnNlIiwiTm9TU1IiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl9ub1NzckVycm9yIiwiZXJyb3IiLCJFcnJvciIsIk5FWFRfRFlOQU1JQ19OT19TU1JfQ09ERSIsImRpZ2VzdCIsImNoaWxkcmVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NEXT_DYNAMIC_NO_SSR_CODE = void 0;\nconst NEXT_DYNAMIC_NO_SSR_CODE = \"DYNAMIC_SERVER_USAGE\";\nexports.NEXT_DYNAMIC_NO_SSR_CODE = NEXT_DYNAMIC_NO_SSR_CODE; //# sourceMappingURL=no-ssr-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL25vLXNzci1lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1FLDJCQUEyQjtBQUNqQ0YsZ0NBQWdDLEdBQUdFLDBCQUVuQyx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2xhenktZHluYW1pYy9uby1zc3ItZXJyb3IuanM/MzBiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFID0gdm9pZCAwO1xuY29uc3QgTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFID0gJ0RZTkFNSUNfU0VSVkVSX1VTQUdFJztcbmV4cG9ydHMuTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFID0gTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uby1zc3ItZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTkVYVF9EWU5BTUlDX05PX1NTUl9DT0RFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/client/image */ \"(sc_client)/./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1SEFBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXRzdGFncmFtLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/NTQ3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/next/image.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/recoil/cjs/index.js":
/*!******************************************!*\
  !*** ./node_modules/recoil/cjs/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar react = _interopDefault(__webpack_require__(/*! react */ \"react\"));\nvar reactDom = _interopDefault(__webpack_require__(/*! react-dom */ \"react-dom\"));\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err;\n\n// @oss-only\n\n\nvar Recoil_err = err_1;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }).catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce((out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\n\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\n\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nconst gks = new Map().set('recoil_hamt_2020', true).set('recoil_sync_external_store', true).set('recoil_suppress_rerender_in_callback', true).set('recoil_memory_managament_2020', true);\n\nfunction Recoil_gkx_OSS(gk) {\n  var _gks$get;\n\n  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  gks.set(gk, true);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  gks.set(gk, false);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  gks.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation;\n\n// @oss-only\n\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\n\n\n\n\n\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = react.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : react.unstable_createMutableSource;\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = react.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : react.unstable_useMutableSource; // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = react.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\nreact.unstable_useSyncExternalStore;\nlet ReactRendererVersionMismatchWarnOnce = false; // Check if the current renderer supports `useSyncExternalStore()`.\n// Since React goes through a proxy dispatcher and the current renderer can\n// change we can't simply check if `React.useSyncExternalStore()` is defined.\n\nfunction currentRendererSupportsUseSyncExternalStore() {\n  var _ReactCurrentDispatch;\n\n  // $FlowFixMe[incompatible-use]\n  const {\n    ReactCurrentDispatcher,\n    ReactCurrentOwner\n  } =\n  /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism\n   * to detect if the current renderer supports useSyncExternalStore()\n   * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */\n  react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;\n  const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;\n\n  if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {\n    ReactRendererVersionMismatchWarnOnce = true;\n    Recoil_recoverableViolation('A React renderer without React 18+ API support is being used with React 18+.');\n  }\n\n  return isUseSyncExternalStoreSupported;\n}\n\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  currentRendererSupportsUseSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n\nconst env = {\n  RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true\n};\n/**\n * Allow NodeJS/NextJS/etc to set the initial state through process.env variable\n * Note:  we don't assume 'process' is available in all runtime environments\n *\n * @see https://github.com/facebookexperimental/Recoil/issues/733\n */\n\nfunction applyProcessEnvFlagOverrides() {\n  var _process, _process$env$RECOIL_D, _process$env$RECOIL_D2;\n\n  // note: this check is needed in addition to the check below, runtime error will occur without it!\n  // eslint-disable-next-line fb-www/typeof-undefined\n  if (typeof process === 'undefined') {\n    return;\n  }\n\n  if (((_process = process) === null || _process === void 0 ? void 0 : _process.env) == null) {\n    return;\n  }\n\n  const sanitizedValue = (_process$env$RECOIL_D = process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) === null || _process$env$RECOIL_D === void 0 ? void 0 : (_process$env$RECOIL_D2 = _process$env$RECOIL_D.toLowerCase()) === null || _process$env$RECOIL_D2 === void 0 ? void 0 : _process$env$RECOIL_D2.trim();\n\n  if (sanitizedValue == null || sanitizedValue === '') {\n    return;\n  }\n\n  const allowedValues = ['true', 'false'];\n\n  if (!allowedValues.includes(sanitizedValue)) {\n    throw Recoil_err(`process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED value must be 'true', 'false', or empty: ${sanitizedValue}`);\n  }\n\n  env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = sanitizedValue === 'true';\n}\n\napplyProcessEnvFlagOverrides();\nvar Recoil_RecoilEnv = env;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n// eslint-disable-next-line no-unused-vars\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\n\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\n\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation;\n\n// @oss-only\n\n\nvar Recoil_expectationViolation = expectationViolation_1;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue();\n// flowlint-next-line unclear-type:off\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction checkForDuplicateAtomKey(key) {\n  if (nodes.has(key)) {\n    const message = `Duplicate atom key \"${key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n}\n\nfunction registerNode(node) {\n  if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {\n    checkForDuplicateAtomKey(node.key);\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\n\n\nvar hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\n\nvar SIZE = 5;\nvar BUCKET_SIZE = Math.pow(2, SIZE);\nvar MASK = BUCKET_SIZE - 1;\nvar MAX_INDEX_NODE = BUCKET_SIZE / 2;\nvar MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n/*\n ******************************************************************************/\n\nvar nothing = {};\n\nvar constant = function constant(x) {\n  return function () {\n    return x;\n  };\n};\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\n\n\nvar hash = hamt.hash = function (str) {\n  var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n  if (type === 'number') return str;\n  if (type !== 'string') str += '';\n  var hash = 0;\n\n  for (var i = 0, len = str.length; i < len; ++i) {\n    var c = str.charCodeAt(i);\n    hash = (hash << 5) - hash + c | 0;\n  }\n\n  return hash;\n};\n/* Bit Ops\n ******************************************************************************/\n\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\n\n\nvar popcount = function popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n};\n\nvar hashFragment = function hashFragment(shift, h) {\n  return h >>> shift & MASK;\n};\n\nvar toBitmap = function toBitmap(x) {\n  return 1 << x;\n};\n\nvar fromBitmap = function fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n};\n/* Array Ops\n ******************************************************************************/\n\n/**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\n\n\nvar arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n  var out = arr;\n\n  if (!mutate) {\n    var len = arr.length;\n    out = new Array(len);\n\n    for (var i = 0; i < len; ++i) {\n      out[i] = arr[i];\n    }\n  }\n\n  out[at] = v;\n  return out;\n};\n/**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/\n\n\nvar arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n  var newLen = arr.length - 1;\n  var i = 0;\n  var g = 0;\n  var out = arr;\n\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n  }\n\n  ++i;\n\n  while (i <= newLen) {\n    out[g++] = arr[i++];\n  }\n\n  if (mutate) {\n    out.length = newLen;\n  }\n\n  return out;\n};\n/**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\n\n\nvar arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n  var len = arr.length;\n\n  if (mutate) {\n    var _i = len;\n\n    while (_i >= at) {\n      arr[_i--] = arr[_i];\n    }\n\n    arr[at] = v;\n    return arr;\n  }\n\n  var i = 0,\n      g = 0;\n  var out = new Array(len + 1);\n\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n\n  out[at] = v;\n\n  while (i < len) {\n    out[++g] = arr[i++];\n  }\n\n  return out;\n};\n/* Node Structures\n ******************************************************************************/\n\n\nvar LEAF = 1;\nvar COLLISION = 2;\nvar INDEX = 3;\nvar ARRAY = 4;\n/**\n    Empty node.\n*/\n\nvar empty = {\n  __hamt_isEmpty: true\n};\n\nvar isEmptyNode = function isEmptyNode(x) {\n  return x === empty || x && x.__hamt_isEmpty;\n};\n/**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\n\n\nvar Leaf = function Leaf(edit, hash, key, value) {\n  return {\n    type: LEAF,\n    edit: edit,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n  };\n};\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\n\n\nvar Collision = function Collision(edit, hash, children) {\n  return {\n    type: COLLISION,\n    edit: edit,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n  };\n};\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\n\n\nvar IndexedNode = function IndexedNode(edit, mask, children) {\n  return {\n    type: INDEX,\n    edit: edit,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n  };\n};\n/**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\n\n\nvar ArrayNode = function ArrayNode(edit, size, children) {\n  return {\n    type: ARRAY,\n    edit: edit,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n  };\n};\n/**\n    Is `node` a leaf node?\n*/\n\n\nvar isLeaf = function isLeaf(node) {\n  return node === empty || node.type === LEAF || node.type === COLLISION;\n};\n/* Internal node operations.\n ******************************************************************************/\n\n/**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\n\n\nvar expand = function expand(edit, frag, child, bitmap, subNodes) {\n  var arr = [];\n  var bit = bitmap;\n  var count = 0;\n\n  for (var i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n\n  arr[frag] = child;\n  return ArrayNode(edit, count + 1, arr);\n};\n/**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\n\n\nvar pack = function pack(edit, count, removed, elements) {\n  var children = new Array(count - 1);\n  var g = 0;\n  var bitmap = 0;\n\n  for (var i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      var elem = elements[i];\n\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n\n  return IndexedNode(edit, bitmap, children);\n};\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\n\n\nvar mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n  var subH1 = hashFragment(shift, h1);\n  var subH2 = hashFragment(shift, h2);\n  return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n/**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/\n\n\nvar updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n  var len = list.length;\n\n  for (var i = 0; i < len; ++i) {\n    var child = list[i];\n\n    if (keyEq(k, child.key)) {\n      var value = child.value;\n\n      var _newValue = f(value);\n\n      if (_newValue === value) return list;\n\n      if (_newValue === nothing) {\n        --size.value;\n        return arraySpliceOut(mutate, i, list);\n      }\n\n      return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n    }\n  }\n\n  var newValue = f();\n  if (newValue === nothing) return list;\n  ++size.value;\n  return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n};\n\nvar canEditNode = function canEditNode(edit, node) {\n  return edit === node.edit;\n};\n/* Editing\n ******************************************************************************/\n\n\nvar Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n  if (keyEq(k, this.key)) {\n    var _v = f(this.value);\n\n    if (_v === this.value) return this;else if (_v === nothing) {\n      --size.value;\n      return empty;\n    }\n\n    if (canEditNode(edit, this)) {\n      this.value = _v;\n      return this;\n    }\n\n    return Leaf(edit, h, k, _v);\n  }\n\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nvar Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n  if (h === this.hash) {\n    var canEdit = canEditNode(edit, this);\n    var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n    if (list === this.children) return this;\n    return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n  }\n\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nvar IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var mask = this.mask;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var bit = toBitmap(frag);\n  var indx = fromBitmap(mask, bit);\n  var exists = mask & bit;\n  var current = exists ? children[indx] : empty;\n\n  var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n  if (current === child) return this;\n  var canEdit = canEditNode(edit, this);\n  var bitmap = mask;\n  var newChildren = void 0;\n\n  if (exists && isEmptyNode(child)) {\n    // remove\n    bitmap &= ~bit;\n    if (!bitmap) return empty;\n    if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n    newChildren = arraySpliceOut(canEdit, indx, children);\n  } else if (!exists && !isEmptyNode(child)) {\n    // add\n    if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n    bitmap |= bit;\n    newChildren = arraySpliceIn(canEdit, indx, child, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, indx, child, children);\n  }\n\n  if (canEdit) {\n    this.mask = bitmap;\n    this.children = newChildren;\n    return this;\n  }\n\n  return IndexedNode(edit, bitmap, newChildren);\n};\n\nvar ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var count = this.size;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var child = children[frag];\n\n  var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n  if (child === newChild) return this;\n  var canEdit = canEditNode(edit, this);\n  var newChildren = void 0;\n\n  if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n    // add\n    ++count;\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n    // remove\n    --count;\n    if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n    newChildren = arrayUpdate(canEdit, frag, empty, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  }\n\n  if (canEdit) {\n    this.size = count;\n    this.children = newChildren;\n    return this;\n  }\n\n  return ArrayNode(edit, count, newChildren);\n};\n\nempty._modify = function (edit, keyEq, shift, f, h, k, size) {\n  var v = f();\n  if (v === nothing) return empty;\n  ++size.value;\n  return Leaf(edit, h, k, v);\n};\n/*\n ******************************************************************************/\n\n\nfunction Map(editable, edit, config, root, size) {\n  this._editable = editable;\n  this._edit = edit;\n  this._config = config;\n  this._root = root;\n  this._size = size;\n}\n\nMap.prototype.setTree = function (newRoot, newSize) {\n  if (this._editable) {\n    this._root = newRoot;\n    this._size = newSize;\n    return this;\n  }\n\n  return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n};\n/* Queries\n ******************************************************************************/\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\n\n\nvar tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n  var node = map._root;\n  var shift = 0;\n  var keyEq = map._config.keyEq;\n\n  while (true) {\n    switch (node.type) {\n      case LEAF:\n        {\n          return keyEq(key, node.key) ? node.value : alt;\n        }\n\n      case COLLISION:\n        {\n          if (hash === node.hash) {\n            var children = node.children;\n\n            for (var i = 0, len = children.length; i < len; ++i) {\n              var child = children[i];\n              if (keyEq(key, child.key)) return child.value;\n            }\n          }\n\n          return alt;\n        }\n\n      case INDEX:\n        {\n          var frag = hashFragment(shift, hash);\n          var bit = toBitmap(frag);\n\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n\n          return alt;\n        }\n\n      case ARRAY:\n        {\n          node = node.children[hashFragment(shift, hash)];\n\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n\n          return alt;\n        }\n\n      default:\n        return alt;\n    }\n  }\n};\n\nMap.prototype.tryGetHash = function (alt, hash, key) {\n  return tryGetHash(alt, hash, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\n\n\nvar tryGet = hamt.tryGet = function (alt, key, map) {\n  return tryGetHash(alt, map._config.hash(key), key, map);\n};\n\nMap.prototype.tryGet = function (alt, key) {\n  return tryGet(alt, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\n\n\nvar getHash = hamt.getHash = function (hash, key, map) {\n  return tryGetHash(undefined, hash, key, map);\n};\n\nMap.prototype.getHash = function (hash, key) {\n  return getHash(hash, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\n\n\nvar get = hamt.get = function (key, map) {\n  return tryGetHash(undefined, map._config.hash(key), key, map);\n};\n\nMap.prototype.get = function (key, alt) {\n  return tryGet(alt, key, this);\n};\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\n\n\nvar hasHash = hamt.has = function (hash, key, map) {\n  return tryGetHash(nothing, hash, key, map) !== nothing;\n};\n\nMap.prototype.hasHash = function (hash, key) {\n  return hasHash(hash, key, this);\n};\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\n\n\nvar has = hamt.has = function (key, map) {\n  return hasHash(map._config.hash(key), key, map);\n};\n\nMap.prototype.has = function (key) {\n  return has(key, this);\n};\n\nvar defKeyCompare = function defKeyCompare(x, y) {\n  return x === y;\n};\n/**\n    Create an empty map.\n\n    @param config Configuration.\n*/\n\n\nhamt.make = function (config) {\n  return new Map(0, 0, {\n    keyEq: config && config.keyEq || defKeyCompare,\n    hash: config && config.hash || hash\n  }, empty, 0);\n};\n/**\n    Empty map.\n*/\n\n\nhamt.empty = hamt.make();\n/**\n    Does `map` contain any elements?\n*/\n\nvar isEmpty = hamt.isEmpty = function (map) {\n  return map && !!isEmptyNode(map._root);\n};\n\nMap.prototype.isEmpty = function () {\n  return isEmpty(this);\n};\n/* Updates\n ******************************************************************************/\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\n\n\nvar modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n  var size = {\n    value: map._size\n  };\n\n  var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n  return map.setTree(newRoot, size.value);\n};\n\nMap.prototype.modifyHash = function (hash, key, f) {\n  return modifyHash(f, hash, key, this);\n};\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\n\n\nvar modify = hamt.modify = function (f, key, map) {\n  return modifyHash(f, map._config.hash(key), key, map);\n};\n\nMap.prototype.modify = function (key, f) {\n  return modify(f, key, this);\n};\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\n\n\nvar setHash = hamt.setHash = function (hash, key, value, map) {\n  return modifyHash(constant(value), hash, key, map);\n};\n\nMap.prototype.setHash = function (hash, key, value) {\n  return setHash(hash, key, value, this);\n};\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\n\n\nvar set = hamt.set = function (key, value, map) {\n  return setHash(map._config.hash(key), key, value, map);\n};\n\nMap.prototype.set = function (key, value) {\n  return set(key, value, this);\n};\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\n\n\nvar del = constant(nothing);\n\nvar removeHash = hamt.removeHash = function (hash, key, map) {\n  return modifyHash(del, hash, key, map);\n};\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n  return removeHash(hash, key, this);\n};\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\n\n\nvar remove = hamt.remove = function (key, map) {\n  return removeHash(map._config.hash(key), key, map);\n};\n\nMap.prototype.remove = Map.prototype.delete = function (key) {\n  return remove(key, this);\n};\n/* Mutation\n ******************************************************************************/\n\n/**\n    Mark `map` as mutable.\n */\n\n\nvar beginMutation = hamt.beginMutation = function (map) {\n  return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n};\n\nMap.prototype.beginMutation = function () {\n  return beginMutation(this);\n};\n/**\n    Mark `map` as immutable.\n */\n\n\nvar endMutation = hamt.endMutation = function (map) {\n  map._editable = map._editable && map._editable - 1;\n  return map;\n};\n\nMap.prototype.endMutation = function () {\n  return endMutation(this);\n};\n/**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/\n\n\nvar mutate = hamt.mutate = function (f, map) {\n  var transient = beginMutation(map);\n  f(transient);\n  return endMutation(transient);\n};\n\nMap.prototype.mutate = function (f) {\n  return mutate(f, this);\n};\n/* Traversal\n ******************************************************************************/\n\n/**\n    Apply a continuation.\n*/\n\n\nvar appk = function appk(k) {\n  return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n};\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\n\n\nvar lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n  while (i < len) {\n    var child = children[i++];\n    if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n  }\n\n  return appk(k);\n};\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\n\n\nvar lazyVisit = function lazyVisit(node, f, k) {\n  switch (node.type) {\n    case LEAF:\n      return {\n        value: f(node),\n        rest: k\n      };\n\n    case COLLISION:\n    case ARRAY:\n    case INDEX:\n      var children = node.children;\n      return lazyVisitChildren(children.length, children, 0, f, k);\n\n    default:\n      return appk(k);\n  }\n};\n\nvar DONE = {\n  done: true\n};\n/**\n    Javascript iterator over a map.\n*/\n\nfunction MapIterator(v) {\n  this.v = v;\n}\n\nMapIterator.prototype.next = function () {\n  if (!this.v) return DONE;\n  var v0 = this.v;\n  this.v = appk(v0.rest);\n  return v0;\n};\n\nMapIterator.prototype[Symbol.iterator] = function () {\n  return this;\n};\n/**\n    Lazily visit each value in map with function `f`.\n*/\n\n\nvar visit = function visit(map, f) {\n  return new MapIterator(lazyVisit(map._root, f));\n};\n/**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\n\n\nvar buildPairs = function buildPairs(x) {\n  return [x.key, x.value];\n};\n\nvar entries = hamt.entries = function (map) {\n  return visit(map, buildPairs);\n};\n\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n  return entries(this);\n};\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\n\n\nvar buildKeys = function buildKeys(x) {\n  return x.key;\n};\n\nvar keys = hamt.keys = function (map) {\n  return visit(map, buildKeys);\n};\n\nMap.prototype.keys = function () {\n  return keys(this);\n};\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\n\n\nvar buildValues = function buildValues(x) {\n  return x.value;\n};\n\nvar values = hamt.values = Map.prototype.values = function (map) {\n  return visit(map, buildValues);\n};\n\nMap.prototype.values = function () {\n  return values(this);\n};\n/* Fold\n ******************************************************************************/\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\n\n\nvar fold = hamt.fold = function (f, z, m) {\n  var root = m._root;\n  if (root.type === LEAF) return f(z, root.value, root.key);\n  var toVisit = [root.children];\n  var children = void 0;\n\n  while (children = toVisit.pop()) {\n    for (var i = 0, len = children.length; i < len;) {\n      var child = children[i++];\n\n      if (child && child.type) {\n        if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n      }\n    }\n  }\n\n  return z;\n};\n\nMap.prototype.fold = function (f, z) {\n  return fold(f, z, this);\n};\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\n\n\nvar forEach = hamt.forEach = function (f, map) {\n  return fold(function (_, value, key) {\n    return f(value, key, map);\n  }, null, map);\n};\n\nMap.prototype.forEach = function (f) {\n  return forEach(f, this);\n};\n/* Aggregate\n ******************************************************************************/\n\n/**\n    Get the number of entries in `map`.\n*/\n\n\nvar count = hamt.count = function (map) {\n  return map._size;\n};\n\nMap.prototype.count = function () {\n  return count(this);\n};\n\nObject.defineProperty(Map.prototype, 'size', {\n  get: Map.prototype.count\n});\n/* Export\n ******************************************************************************/\n\nif ( module.exports) {\n  module.exports = hamt;\n} else {\n  undefined.hamt = hamt;\n}\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\n\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\n\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\n\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\n\nconst {\n  graph\n} = Recoil_Graph;\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\n\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\n\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\n\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite;\n\n\n\n\n\n\n\n // flowlint-next-line unclear-type:off\n\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\n\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\n\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\n\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\n\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\n\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\n\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\n\n\n\n\n\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT;\n\n  // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate;\n\n    // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\n\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\n\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\n\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone;\n\n\n\n\n\n\n\n // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention;\n\n      // Not releasable if configured to be retained forever:\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\nconst {\n  unstable_batchedUpdates\n} = reactDom;\n\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates;\n\nlet batcher = unstable_batchedUpdates$2; // flowlint-next-line unclear-type:off\n\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */\n\n\nconst getBatcher = () => batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n\n  const memoizedFn = (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  return memoizedFn;\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\n\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\n\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\n\nconst {\n  graph: graph$1\n} = Recoil_Graph;\n\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\n\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\n\n\n\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\n\n\n\n\n\n\n\n\n\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize;\n\n\n\n // Opaque at this surface because it's part of the public API from here.\n\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1((store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\n\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\n\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\n\nconst {\n  useRef\n} = react;\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */\n\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce;\n\n// @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\n\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\n\nconst {\n  graph: graph$2\n} = Recoil_Graph;\n\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\n\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\n\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\n\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\n\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\n\n\n\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = react;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react.createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react.createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]);\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react.createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react.createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react.createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react.createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\n\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = react;\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\n\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\n\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\n\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\n\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\n\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = react;\n\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment;\n\n\n\n\n\n // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n\n\n// flowlint-line unclear-type:off\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\n\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\n\nconst {\n  currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\n\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\n\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\n\n\n\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = react;\n\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    // Recoil will attemp to detect if `useSyncExternalStore()` is supported with\n    // `reactMode()` before calling it.  However, sometimes the host React\n    // environment supports it but uses additional React renderers (such as with\n    // `react-three-fiber`) which do not.  While this is technically a user issue\n    // by using a renderer with React 18+ that doesn't fully support React 18 we\n    // don't want to break users if it can be avoided. As the current renderer can\n    // change at runtime, we need to dynamically check and fallback if necessary.\n    SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\n * Experimental variants of hooks with support for useTransition()\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\n\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\n\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\n\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\n\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = react;\n\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$3) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$3) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\n\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\n\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4();\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\n\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\n\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\n\n\n\nconst {\n  useMemo: useMemo$2\n} = react;\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react.createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\n\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\n\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\n\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\n\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\n\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\n\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant;\n\n// @oss-only\n\n\nvar Recoil_invariant = invariant_1;\n\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\n\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\n\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\n\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\n\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\n\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\n\nconst {\n  useCallback: useCallback$3\n} = react;\n\n\n\n\n\n\n\n\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  }\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\n\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\n\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\n\nconst {\n  useCallback: useCallback$4\n} = react;\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\n\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\n\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\n\nconst {\n  useMemo: useMemo$3\n} = react;\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\n\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\n\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\n\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\n\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;\n\n      // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root;\n\n        // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\n\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\n\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\n\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\n\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\n\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\n\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\n\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\n\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\n\n\n\n\n\n\n\n\n\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\n\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\n\n\n\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\n\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\n\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\n\n\n\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\n\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\n\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\n\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\n\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\n\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo;\n\n      // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n      state.atomValues.set(key, cachedLoadable);\n      /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n// $FlowFixMe[missing-local-annot]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector;\n\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\n\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\n\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\n\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\n\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\n\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            );\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu;\n\n          // eslint-disable-next-line prefer-const\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  });\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n} // $FlowFixMe[missing-local-annot]\n\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\n\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\n\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\n\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\n\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\n\n\n\n\n\n\n\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy;\n\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node;\n\n\n\n\n\n// Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node;\n\n\n\n\n\n // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n\n\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify;\n\n    // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily;\n\n// flowlint-next-line unclear-type:off\n\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector;\n\n// flowlint-next-line unclear-type:off\n\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\n\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1;\n\n\n\n\n\n /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\n\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\n\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\n\n\n\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\n\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\n\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\n\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\n\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\n\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\n\n\n\n\n\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\n\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Global Recoil environment settiongs\n  RecoilEnv: Recoil_RecoilEnv,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilEnv;\nvar Recoil_index_5 = Recoil_index.RecoilRoot;\nvar Recoil_index_6 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_8 = Recoil_index.atom;\nvar Recoil_index_9 = Recoil_index.selector;\nvar Recoil_index_10 = Recoil_index.atomFamily;\nvar Recoil_index_11 = Recoil_index.selectorFamily;\nvar Recoil_index_12 = Recoil_index.constSelector;\nvar Recoil_index_13 = Recoil_index.errorSelector;\nvar Recoil_index_14 = Recoil_index.readOnlySelector;\nvar Recoil_index_15 = Recoil_index.noWait;\nvar Recoil_index_16 = Recoil_index.waitForNone;\nvar Recoil_index_17 = Recoil_index.waitForAny;\nvar Recoil_index_18 = Recoil_index.waitForAll;\nvar Recoil_index_19 = Recoil_index.waitForAllSettled;\nvar Recoil_index_20 = Recoil_index.useRecoilValue;\nvar Recoil_index_21 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_22 = Recoil_index.useRecoilState;\nvar Recoil_index_23 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_24 = Recoil_index.useSetRecoilState;\nvar Recoil_index_25 = Recoil_index.useResetRecoilState;\nvar Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_31 = Recoil_index.useRecoilCallback;\nvar Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_37 = Recoil_index.useRetain;\nvar Recoil_index_38 = Recoil_index.retentionZone;\n\nexports.DefaultValue = Recoil_index_1;\nexports.RecoilEnv = Recoil_index_4;\nexports.RecoilLoadable = Recoil_index_3;\nexports.RecoilRoot = Recoil_index_5;\nexports.atom = Recoil_index_8;\nexports.atomFamily = Recoil_index_10;\nexports.constSelector = Recoil_index_12;\nexports[\"default\"] = Recoil_index;\nexports.errorSelector = Recoil_index_13;\nexports.isRecoilValue = Recoil_index_2;\nexports.noWait = Recoil_index_15;\nexports.readOnlySelector = Recoil_index_14;\nexports.retentionZone = Recoil_index_38;\nexports.selector = Recoil_index_9;\nexports.selectorFamily = Recoil_index_11;\nexports.snapshot_UNSTABLE = Recoil_index_36;\nexports.useGetRecoilValueInfo_UNSTABLE = Recoil_index_26;\nexports.useGotoRecoilSnapshot = Recoil_index_33;\nexports.useRecoilBridgeAcrossReactRoots_UNSTABLE = Recoil_index_7;\nexports.useRecoilCallback = Recoil_index_31;\nexports.useRecoilRefresher_UNSTABLE = Recoil_index_27;\nexports.useRecoilSnapshot = Recoil_index_34;\nexports.useRecoilState = Recoil_index_22;\nexports.useRecoilStateLoadable = Recoil_index_23;\nexports.useRecoilState_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_30;\nexports.useRecoilStoreID = Recoil_index_6;\nexports.useRecoilTransactionObserver_UNSTABLE = Recoil_index_35;\nexports.useRecoilTransaction_UNSTABLE = Recoil_index_32;\nexports.useRecoilValue = Recoil_index_20;\nexports.useRecoilValueLoadable = Recoil_index_21;\nexports.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_28;\nexports.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE = Recoil_index_29;\nexports.useResetRecoilState = Recoil_index_25;\nexports.useRetain = Recoil_index_37;\nexports.useSetRecoilState = Recoil_index_24;\nexports.waitForAll = Recoil_index_18;\nexports.waitForAllSettled = Recoil_index_19;\nexports.waitForAny = Recoil_index_17;\nexports.waitForNone = Recoil_index_16;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvcmVjb2lsL2Nqcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdDQUFnQzs7QUFFaEMsNEJBQTRCLG1CQUFPLENBQUMsb0JBQU87QUFDM0MsK0JBQStCLG1CQUFPLENBQUMsNEJBQVc7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxhQUFhOztBQUVuQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0EsNklBQTZJOztBQUU3STtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3SEFBd0gsZUFBZTtBQUN2STs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCRjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLLEVBR047QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0NBQXdDOzs7QUFHeEM7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxJQUFJO0FBQzNFOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Rjs7QUFFdkY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7QUFRRjs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0YsSUFBSTtBQUNwRjs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7QUFRRjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR04sNkNBQTZDO0FBQzdDLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9NQUFvTTtBQUNwTTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLElBQUk7QUFDekY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7QUFRRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsRUFBRSx1QkFBdUI7OztBQUd6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRix5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0ZBQStGOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsa0RBQWtEOzs7QUFHbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEdBQUc7QUFDSDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2TkFBNk47O0FBRTdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHFCQUFxQixnQ0FBZ0M7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7Ozs7O0FBVUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5UUFBeVEsb0JBQW9COztBQUU3UjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBLGlEQUFpRCw4RUFBOEU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILGdDQUFnQyxLQUFxQyx1RUFBdUUsQ0FBdUI7O0FBRW5LO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsNkJBQTZCO0FBQzdCOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLCtNQUErTTs7QUFFL007QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGLFdBQVc7QUFDcEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLE9BQU87QUFDbEM7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixXQUFXLEVBQUU7QUFDYixlQUFlLGtCQUFrQixHQUFHLHdCQUF3QixjQUFjO0FBQzFFLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7OztBQVVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsU0FBUztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CRjtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDZEQUE2RDs7QUFFN0QsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEtBQXFDLCtEQUErRCxDQUF1QjtBQUM1SjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsMEJBQTBCLFlBQVk7QUFDdEMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFD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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7OztBQU1GO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLGtCQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLGdEQUFnRDtBQUNoRCx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLGtEQUFrRDtBQUNsRCx3QkFBd0I7QUFDeEIsNkNBQTZDO0FBQzdDLHFDQUFxQztBQUNyQyxzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLDBEQUEwRDtBQUMxRCxrREFBa0Q7QUFDbEQsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2F0c3RhZ3JhbS8uL25vZGVfbW9kdWxlcy9yZWNvaWwvY2pzL2luZGV4LmpzPzU3MzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHJlYWN0ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JlYWN0JykpO1xudmFyIHJlYWN0RG9tID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JlYWN0LWRvbScpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBlcnIobWVzc2FnZSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcbiAgLy8gZXJyLnN0YWNrIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSUUgc2V0cyB0aGUgc3RhY2sgb25seSBpZiBlcnJvciBpcyB0aHJvd25cbiAgICB0cnkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBjYXRjaCAoXykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvbm8tdW51c2VkLWNhdGNoLWJpbmRpbmdzLCBuby1lbXB0eVxuXG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbnZhciBlcnJfMSA9IGVycjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9lcnIgPSBlcnJfMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gU3BsaXQgZGVjbGFyYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIHRvIGFsbG93IHRoaXMgZnVuY3Rpb24gdG8gcHJldGVuZCB0b1xuLy8gY2hlY2sgZm9yIGFjdHVhbCBpbnN0YW5jZSBvZiBQcm9taXNlIGluc3RlYWQgb2Ygc29tZXRoaW5nIHdpdGggYSBgdGhlbmBcbi8vIG1ldGhvZC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAhIXAgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIFJlY29pbF9pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIG51bGx0aHJvd3MoeCwgbWVzc2FnZSkge1xuICBpZiAoeCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdHb3QgdW5leHBlY3RlZCBudWxsIG9yIHVuZGVmaW5lZCcpO1xufVxuXG52YXIgUmVjb2lsX251bGx0aHJvd3MgPSBudWxsdGhyb3dzO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY2xhc3MgQmFzZUxvYWRhYmxlIHtcbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgdmFsdWVPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHZhbHVlLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHByb21pc2VPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIHByb21pc2UsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIGVycm9yT3JUaHJvdygpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBMb2FkYWJsZSBleHBlY3RlZCBlcnJvciwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBpcyhvdGhlcikge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHJldHVybiBvdGhlci5zdGF0ZSA9PT0gdGhpcy5zdGF0ZSAmJiBvdGhlci5jb250ZW50cyA9PT0gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIG1hcChfbWFwKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxufVxuXG5jbGFzcyBWYWx1ZUxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc1ZhbHVlJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbnRlbnRzKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh0aGlzLmNvbnRlbnRzKTtcbiAgICAgIHJldHVybiBSZWNvaWxfaXNQcm9taXNlKG5leHQpID8gbG9hZGFibGVXaXRoUHJvbWlzZShuZXh0KSA6IGlzTG9hZGFibGUobmV4dCkgPyBuZXh0IDogbG9hZGFibGVXaXRoVmFsdWUobmV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFJlY29pbF9pc1Byb21pc2UoZSkgPyAvLyBJZiB3ZSBcInN1c3BlbmRlZFwiLCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIGVycm9ycyBhbmQgc3Vic2VxdWVudCByZXRyaWVzIHdpbGwgYmUgaGFuZGxlZCBpbiAnbG9hZGluZycgY2FzZVxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBsb2FkYWJsZVdpdGhQcm9taXNlKGUubmV4dCgoKSA9PiB0aGlzLm1hcChtYXApKSkgOiBsb2FkYWJsZVdpdGhFcnJvcihlKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBFcnJvckxvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2hhc0Vycm9yJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IGVycm9yO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jb250ZW50cyk7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBlcnJvck9yVGhyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBtYXAoX21hcCkge1xuICAgIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIExvYWRpbmdMb2FkYWJsZSBleHRlbmRzIEJhc2VMb2FkYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgJ2xvYWRpbmcnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHRocm93IHRoaXMuY29udGVudHM7XG4gIH1cblxuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICB2YWx1ZU1heWJlKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9taXNlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cblxuICBwcm9taXNlT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIGVycm9yTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIG1hcChtYXApIHtcbiAgICByZXR1cm4gbG9hZGFibGVXaXRoUHJvbWlzZSh0aGlzLmNvbnRlbnRzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgY29uc3QgbmV4dCA9IG1hcCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc0xvYWRhYmxlKG5leHQpKSB7XG4gICAgICAgIGNvbnN0IG5leHRMb2FkYWJsZSA9IG5leHQ7XG5cbiAgICAgICAgc3dpdGNoIChuZXh0TG9hZGFibGUuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnaGFzRXJyb3InOlxuICAgICAgICAgICAgdGhyb3cgbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV4dExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGUpKSB7XG4gICAgICAgIC8vIHdlIHdlcmUgXCJzdXNwZW5kZWQsXCIgdHJ5IGFnYWluXG4gICAgICAgIHJldHVybiBlLnRoZW4oKCkgPT4gdGhpcy5tYXAobWFwKS5jb250ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfSkpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IFZhbHVlTG9hZGFibGUodmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IEVycm9yTG9hZGFibGUoZXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVXaXRoUHJvbWlzZShwcm9taXNlKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUocHJvbWlzZSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUxvYWRpbmcoKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBMb2FkaW5nTG9hZGFibGUobmV3IFByb21pc2UoKCkgPT4ge30pKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlQWxsQXJyYXkoaW5wdXRzKSB7XG4gIHJldHVybiBpbnB1dHMuZXZlcnkoaSA9PiBpLnN0YXRlID09PSAnaGFzVmFsdWUnKSA/IGxvYWRhYmxlV2l0aFZhbHVlKGlucHV0cy5tYXAoaSA9PiBpLmNvbnRlbnRzKSkgOiBpbnB1dHMuc29tZShpID0+IGkuc3RhdGUgPT09ICdoYXNFcnJvcicpID8gbG9hZGFibGVXaXRoRXJyb3IoUmVjb2lsX251bGx0aHJvd3MoaW5wdXRzLmZpbmQoaSA9PiBpLnN0YXRlID09PSAnaGFzRXJyb3InKSwgJ0ludmFsaWQgbG9hZGFibGUgcGFzc2VkIHRvIGxvYWRhYmxlQWxsJykuY29udGVudHMpIDogbG9hZGFibGVXaXRoUHJvbWlzZShQcm9taXNlLmFsbChpbnB1dHMubWFwKGkgPT4gaS5jb250ZW50cykpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVBbGwoaW5wdXRzKSB7XG4gIGNvbnN0IHVud3JhcGVkSW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXRzKS5tYXAoa2V5ID0+IGlucHV0c1trZXldKTtcbiAgY29uc3Qgbm9ybWFsaXplZElucHV0cyA9IHVud3JhcGVkSW5wdXRzLm1hcCh4ID0+IGlzTG9hZGFibGUoeCkgPyB4IDogUmVjb2lsX2lzUHJvbWlzZSh4KSA/IGxvYWRhYmxlV2l0aFByb21pc2UoeCkgOiBsb2FkYWJsZVdpdGhWYWx1ZSh4KSk7XG4gIGNvbnN0IG91dHB1dCA9IGxvYWRhYmxlQWxsQXJyYXkobm9ybWFsaXplZElucHV0cyk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0cykgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gIG91dHB1dCA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gIG91dHB1dC5tYXAob3V0cHV0cyA9PiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLnJlZHVjZSgob3V0LCBrZXksIGlkeCkgPT4gKHsgLi4ub3V0LFxuICAgIFtrZXldOiBvdXRwdXRzW2lkeF1cbiAgfSksIHt9KSk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGFibGUoeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIEJhc2VMb2FkYWJsZTtcbn1cblxuY29uc3QgTG9hZGFibGVTdGF0aWNJbnRlcmZhY2UgPSB7XG4gIG9mOiB2YWx1ZSA9PiBSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UodmFsdWUpIDogaXNMb2FkYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IGxvYWRhYmxlV2l0aFZhbHVlKHZhbHVlKSxcbiAgZXJyb3I6IGVycm9yID0+IGxvYWRhYmxlV2l0aEVycm9yKGVycm9yKSxcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICBsb2FkaW5nOiAoKSA9PiBsb2FkYWJsZUxvYWRpbmcoKSxcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGFsbDogbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGVcbn07XG52YXIgUmVjb2lsX0xvYWRhYmxlID0ge1xuICBsb2FkYWJsZVdpdGhWYWx1ZSxcbiAgbG9hZGFibGVXaXRoRXJyb3IsXG4gIGxvYWRhYmxlV2l0aFByb21pc2UsXG4gIGxvYWRhYmxlTG9hZGluZyxcbiAgbG9hZGFibGVBbGwsXG4gIGlzTG9hZGFibGUsXG4gIFJlY29pbExvYWRhYmxlOiBMb2FkYWJsZVN0YXRpY0ludGVyZmFjZVxufTtcblxudmFyIFJlY29pbF9Mb2FkYWJsZV8xID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFZhbHVlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8yID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aEVycm9yO1xudmFyIFJlY29pbF9Mb2FkYWJsZV8zID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlV2l0aFByb21pc2U7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzQgPSBSZWNvaWxfTG9hZGFibGUubG9hZGFibGVMb2FkaW5nO1xudmFyIFJlY29pbF9Mb2FkYWJsZV81ID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlQWxsO1xudmFyIFJlY29pbF9Mb2FkYWJsZV82ID0gUmVjb2lsX0xvYWRhYmxlLmlzTG9hZGFibGU7XG52YXIgUmVjb2lsX0xvYWRhYmxlXzcgPSBSZWNvaWxfTG9hZGFibGUuUmVjb2lsTG9hZGFibGU7XG5cbnZhciBSZWNvaWxfTG9hZGFibGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogUmVjb2lsX0xvYWRhYmxlXzEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBSZWNvaWxfTG9hZGFibGVfMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogUmVjb2lsX0xvYWRhYmxlXzMsXG4gIGxvYWRhYmxlTG9hZGluZzogUmVjb2lsX0xvYWRhYmxlXzQsXG4gIGxvYWRhYmxlQWxsOiBSZWNvaWxfTG9hZGFibGVfNSxcbiAgaXNMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzYsXG4gIFJlY29pbExvYWRhYmxlOiBSZWNvaWxfTG9hZGFibGVfN1xufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNvbnN0IGdrcyA9IG5ldyBNYXAoKS5zZXQoJ3JlY29pbF9oYW10XzIwMjAnLCB0cnVlKS5zZXQoJ3JlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlJywgdHJ1ZSkuc2V0KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snLCB0cnVlKS5zZXQoJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XG4gIHZhciBfZ2tzJGdldDtcblxuICByZXR1cm4gKF9na3MkZ2V0ID0gZ2tzLmdldChnaykpICE9PSBudWxsICYmIF9na3MkZ2V0ICE9PSB2b2lkIDAgPyBfZ2tzJGdldCA6IGZhbHNlO1xufVxuXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xuICBna3Muc2V0KGdrLCB0cnVlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLnNldEZhaWwgPSBnayA9PiB7XG4gIGdrcy5zZXQoZ2ssIGZhbHNlKTtcbn07XG5cblJlY29pbF9na3hfT1NTLmNsZWFyID0gKCkgPT4ge1xuICBna3MuY2xlYXIoKTtcbn07XG5cbnZhciBSZWNvaWxfZ2t4ID0gUmVjb2lsX2dreF9PU1M7IC8vIEBvc3Mtb25seVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHJlY292ZXJhYmxlVmlvbGF0aW9uKG1lc3NhZ2UsIF9wcm9qZWN0TmFtZSwge1xuICBlcnJvclxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVjb3ZlcmFibGVWaW9sYXRpb25fMSA9IHJlY292ZXJhYmxlVmlvbGF0aW9uO1xuXG4vLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uID0gcmVjb3ZlcmFibGVWaW9sYXRpb25fMTtcblxudmFyIF9jcmVhdGVNdXRhYmxlU291cmNlLCBfdXNlTXV0YWJsZVNvdXJjZSwgX3VzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG5cblxuXG5cblxuXG5jb25zdCBjcmVhdGVNdXRhYmxlU291cmNlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbihfY3JlYXRlTXV0YWJsZVNvdXJjZSA9IHJlYWN0LmNyZWF0ZU11dGFibGVTb3VyY2UpICE9PSBudWxsICYmIF9jcmVhdGVNdXRhYmxlU291cmNlICE9PSB2b2lkIDAgPyBfY3JlYXRlTXV0YWJsZVNvdXJjZSA6IHJlYWN0LnVuc3RhYmxlX2NyZWF0ZU11dGFibGVTb3VyY2U7XG5jb25zdCB1c2VNdXRhYmxlU291cmNlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbihfdXNlTXV0YWJsZVNvdXJjZSA9IHJlYWN0LnVzZU11dGFibGVTb3VyY2UpICE9PSBudWxsICYmIF91c2VNdXRhYmxlU291cmNlICE9PSB2b2lkIDAgPyBfdXNlTXV0YWJsZVNvdXJjZSA6IHJlYWN0LnVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2U7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdHdnL3JlYWN0LTE4L2Rpc2N1c3Npb25zLzg2XG5cbmNvbnN0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbihfdXNlU3luY0V4dGVybmFsU3RvcmUgPSByZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSkgIT09IG51bGwgJiYgX3VzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB2b2lkIDAgPyBfdXNlU3luY0V4dGVybmFsU3RvcmUgOiAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxucmVhY3QudW5zdGFibGVfdXNlU3luY0V4dGVybmFsU3RvcmU7XG5sZXQgUmVhY3RSZW5kZXJlclZlcnNpb25NaXNtYXRjaFdhcm5PbmNlID0gZmFsc2U7IC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnRzIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZSgpYC5cbi8vIFNpbmNlIFJlYWN0IGdvZXMgdGhyb3VnaCBhIHByb3h5IGRpc3BhdGNoZXIgYW5kIHRoZSBjdXJyZW50IHJlbmRlcmVyIGNhblxuLy8gY2hhbmdlIHdlIGNhbid0IHNpbXBseSBjaGVjayBpZiBgUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoKWAgaXMgZGVmaW5lZC5cblxuZnVuY3Rpb24gY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSgpIHtcbiAgdmFyIF9SZWFjdEN1cnJlbnREaXNwYXRjaDtcblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdXG4gIGNvbnN0IHtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudE93bmVyXG4gIH0gPVxuICAvKiAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gVGhpcyB3b3JrYXJvdW5kIHdhcyBhcHByb3ZlZCBhcyBhIHNhZmVyIG1lY2hhbmlzbVxuICAgKiB0byBkZXRlY3QgaWYgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydHMgdXNlU3luY0V4dGVybmFsU3RvcmUoKVxuICAgKiBodHRwczovL2ZiLndvcmtwbGFjZS5jb20vZ3JvdXBzL3JlYWN0anMvcG9zdHMvOTU1ODY4MjMzMDg0Njk2My8gKi9cbiAgcmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gIGNvbnN0IGRpc3BhdGNoZXIgPSAoX1JlYWN0Q3VycmVudERpc3BhdGNoID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9PT0gbnVsbCB8fCBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQpICE9PSBudWxsICYmIF9SZWFjdEN1cnJlbnREaXNwYXRjaCAhPT0gdm9pZCAwID8gX1JlYWN0Q3VycmVudERpc3BhdGNoIDogUmVhY3RDdXJyZW50T3duZXIuY3VycmVudERpc3BhdGNoZXI7XG4gIGNvbnN0IGlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQgPSBkaXNwYXRjaGVyLnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9IG51bGw7XG5cbiAgaWYgKHVzZVN5bmNFeHRlcm5hbFN0b3JlICYmICFpc1VzZVN5bmNFeHRlcm5hbFN0b3JlU3VwcG9ydGVkICYmICFSZWFjdFJlbmRlcmVyVmVyc2lvbk1pc21hdGNoV2Fybk9uY2UpIHtcbiAgICBSZWFjdFJlbmRlcmVyVmVyc2lvbk1pc21hdGNoV2Fybk9uY2UgPSB0cnVlO1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignQSBSZWFjdCByZW5kZXJlciB3aXRob3V0IFJlYWN0IDE4KyBBUEkgc3VwcG9ydCBpcyBiZWluZyB1c2VkIHdpdGggUmVhY3QgMTgrLicpO1xuICB9XG5cbiAgcmV0dXJuIGlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQ7XG59XG5cbi8qKlxuICogbW9kZTogVGhlIFJlYWN0IEFQSSBhbmQgYXBwcm9hY2ggdG8gdXNlIGZvciBzeW5jaW5nIHN0YXRlIHdpdGggUmVhY3RcbiAqIGVhcmx5OiBSZS1yZW5kZXJzIGZyb20gUmVjb2lsIHVwZGF0ZXMgb2NjdXI6XG4gKiAgICAxKSBlYXJsaWVyXG4gKiAgICAyKSBpbiBzeW5jIHdpdGggUmVhY3QgdXBkYXRlcyBpbiB0aGUgc2FtZSBiYXRjaFxuICogICAgMykgYmVmb3JlIHRyYW5zYWN0aW9uIG9ic2VydmVycyBpbnN0ZWFkIG9mIGFmdGVyLlxuICogY29uY3VycmVudDogSXMgdGhlIGN1cnJlbnQgbW9kZSBjb21wYXRpYmxlIHdpdGggQ29uY3VycmVudCBNb2RlIGFuZCB1c2VUcmFuc2l0aW9uKClcbiAqL1xuZnVuY3Rpb24gcmVhY3RNb2RlKCkge1xuICAvLyBOT1RFOiBUaGlzIG1vZGUgaXMgY3VycmVudGx5IGJyb2tlbiB3aXRoIHNvbWUgU3VzcGVuc2UgY2FzZXNcbiAgLy8gc2VlIFJlY29pbF9zZWxlY3Rvci10ZXN0LmpzXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfdHJhbnNpdGlvbl9zdXBwb3J0JykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogJ1RSQU5TSVRJT05fU1VQUE9SVCcsXG4gICAgICBlYXJseTogdHJ1ZSxcbiAgICAgIGNvbmN1cnJlbnQ6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlJykgJiYgdXNlU3luY0V4dGVybmFsU3RvcmUgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlOiAnU1lOQ19FWFRFUk5BTF9TVE9SRScsXG4gICAgICBlYXJseTogdHJ1ZSxcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbXV0YWJsZV9zb3VyY2UnKSAmJiB1c2VNdXRhYmxlU291cmNlICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy4kZGlzYWJsZVJlY29pbFZhbHVlTXV0YWJsZVNvdXJjZV9URU1QX0hBQ0tfRE9fTk9UX1VTRSkge1xuICAgIHJldHVybiBSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSA/IHtcbiAgICAgIG1vZGU6ICdNVVRBQkxFX1NPVVJDRScsXG4gICAgICBlYXJseTogdHJ1ZSxcbiAgICAgIGNvbmN1cnJlbnQ6IHRydWVcbiAgICB9IDoge1xuICAgICAgbW9kZTogJ01VVEFCTEVfU09VUkNFJyxcbiAgICAgIGVhcmx5OiBmYWxzZSxcbiAgICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSA/IHtcbiAgICBtb2RlOiAnTEVHQUNZJyxcbiAgICBlYXJseTogdHJ1ZSxcbiAgICBjb25jdXJyZW50OiBmYWxzZVxuICB9IDoge1xuICAgIG1vZGU6ICdMRUdBQ1knLFxuICAgIGVhcmx5OiBmYWxzZSxcbiAgICBjb25jdXJyZW50OiBmYWxzZVxuICB9O1xufSAvLyBUT0RPIE5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGVyZSBpcyBhIHN0YW5kYXJkL29wZW4tc291cmNlIGVxdWl2YWxlbnQgdG8gc2VlIGlmIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQgaXMgaGFwcGVuaW5nOlxuXG5cbmZ1bmN0aW9uIGlzRmFzdFJlZnJlc2hFbmFibGVkKCkge1xuICAvLyBAZmItb25seTogY29uc3Qge2lzQWNjZXB0aW5nVXBkYXRlfSA9IHJlcXVpcmUoJ19fZGVidWcnKTtcbiAgLy8gQGZiLW9ubHk6IHJldHVybiB0eXBlb2YgaXNBY2NlcHRpbmdVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaXNBY2NlcHRpbmdVcGRhdGUoKTtcbiAgcmV0dXJuIGZhbHNlOyAvLyBAb3NzLW9ubHlcbn1cblxudmFyIFJlY29pbF9SZWFjdE1vZGUgPSB7XG4gIGNyZWF0ZU11dGFibGVTb3VyY2UsXG4gIHVzZU11dGFibGVTb3VyY2UsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlLFxuICBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlLFxuICByZWFjdE1vZGUsXG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkXG59O1xuXG5jb25zdCBlbnYgPSB7XG4gIFJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRDogdHJ1ZVxufTtcbi8qKlxuICogQWxsb3cgTm9kZUpTL05leHRKUy9ldGMgdG8gc2V0IHRoZSBpbml0aWFsIHN0YXRlIHRocm91Z2ggcHJvY2Vzcy5lbnYgdmFyaWFibGVcbiAqIE5vdGU6ICB3ZSBkb24ndCBhc3N1bWUgJ3Byb2Nlc3MnIGlzIGF2YWlsYWJsZSBpbiBhbGwgcnVudGltZSBlbnZpcm9ubWVudHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzczM1xuICovXG5cbmZ1bmN0aW9uIGFwcGx5UHJvY2Vzc0VudkZsYWdPdmVycmlkZXMoKSB7XG4gIHZhciBfcHJvY2VzcywgX3Byb2Nlc3MkZW52JFJFQ09JTF9ELCBfcHJvY2VzcyRlbnYkUkVDT0lMX0QyO1xuXG4gIC8vIG5vdGU6IHRoaXMgY2hlY2sgaXMgbmVlZGVkIGluIGFkZGl0aW9uIHRvIHRoZSBjaGVjayBiZWxvdywgcnVudGltZSBlcnJvciB3aWxsIG9jY3VyIHdpdGhvdXQgaXQhXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCgoX3Byb2Nlc3MgPSBwcm9jZXNzKSA9PT0gbnVsbCB8fCBfcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2Nlc3MuZW52KSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2FuaXRpemVkVmFsdWUgPSAoX3Byb2Nlc3MkZW52JFJFQ09JTF9EID0gcHJvY2Vzcy5lbnYuUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEKSA9PT0gbnVsbCB8fCBfcHJvY2VzcyRlbnYkUkVDT0lMX0QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcHJvY2VzcyRlbnYkUkVDT0lMX0QyID0gX3Byb2Nlc3MkZW52JFJFQ09JTF9ELnRvTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9wcm9jZXNzJGVudiRSRUNPSUxfRDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9jZXNzJGVudiRSRUNPSUxfRDIudHJpbSgpO1xuXG4gIGlmIChzYW5pdGl6ZWRWYWx1ZSA9PSBudWxsIHx8IHNhbml0aXplZFZhbHVlID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFsbG93ZWRWYWx1ZXMgPSBbJ3RydWUnLCAnZmFsc2UnXTtcblxuICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMoc2FuaXRpemVkVmFsdWUpKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgcHJvY2Vzcy5lbnYuUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEIHZhbHVlIG11c3QgYmUgJ3RydWUnLCAnZmFsc2UnLCBvciBlbXB0eTogJHtzYW5pdGl6ZWRWYWx1ZX1gKTtcbiAgfVxuXG4gIGVudi5SRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQgPSBzYW5pdGl6ZWRWYWx1ZSA9PT0gJ3RydWUnO1xufVxuXG5hcHBseVByb2Nlc3NFbnZGbGFnT3ZlcnJpZGVzKCk7XG52YXIgUmVjb2lsX1JlY29pbEVudiA9IGVudjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5jbGFzcyBBYnN0cmFjdFJlY29pbFZhbHVlIHtcbiAgY29uc3RydWN0b3IobmV3S2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmtleSA9IG5ld0tleTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cblxufVxuXG5jbGFzcyBSZWNvaWxTdGF0ZSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuZnVuY3Rpb24gaXNSZWNvaWxWYWx1ZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWUsXG4gIFJlY29pbFN0YXRlLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxuICBpc1JlY29pbFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzEgPSBSZWNvaWxfUmVjb2lsVmFsdWUuQWJzdHJhY3RSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMiA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV80ID0gUmVjb2lsX1JlY29pbFZhbHVlLmlzUmVjb2lsVmFsdWU7XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxfUmVjb2lsVmFsdWVfMyxcbiAgaXNSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHNwcmludGYoZm9ybWF0LCAuLi5hcmdzKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJXMvZywgKCkgPT4gU3RyaW5nKGFyZ3NbaW5kZXgrK10pKTtcbn1cblxudmFyIHNwcmludGZfMSA9IHNwcmludGY7XG5cbmZ1bmN0aW9uIGV4cGVjdGF0aW9uVmlvbGF0aW9uKGZvcm1hdCwgLi4uYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHNwcmludGZfMS5jYWxsKG51bGwsIGZvcm1hdCwgLi4uYXJncyk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdFeHBlY3RhdGlvbiBWaW9sYXRpb24nO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBleHBlY3RhdGlvblZpb2xhdGlvbl8xID0gZXhwZWN0YXRpb25WaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24gPSBleHBlY3RhdGlvblZpb2xhdGlvbl8xO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGl0ZXJhYmxlIHdob3NlIG91dHB1dCBpcyBnZW5lcmF0ZWQgYnkgcGFzc2luZyB0aGUgaW5wdXRcbiAqIGl0ZXJhYmxlJ3MgdmFsdWVzIHRocm91Z2ggdGhlIG1hcHBlciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtYXBJdGVyYWJsZShpdGVyYWJsZSwgY2FsbGJhY2spIHtcbiAgLy8gVXNlIGdlbmVyYXRvciB0byBjcmVhdGUgaXRlcmFibGUvaXRlcmF0b3JcbiAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgIHlpZWxkIGNhbGxiYWNrKHZhbHVlLCBpbmRleCsrKTtcbiAgICB9XG4gIH0oKTtcbn1cblxudmFyIFJlY29pbF9tYXBJdGVyYWJsZSA9IG1hcEl0ZXJhYmxlO1xuXG5jb25zdCB7XG4gIGlzRmFzdFJlZnJlc2hFbmFibGVkOiBpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIERlZmF1bHRWYWx1ZSB7fVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFID0gbmV3IERlZmF1bHRWYWx1ZSgpO1xuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbmNvbnN0IG5vZGVzID0gbmV3IE1hcCgpOyAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5jb25zdCByZWNvaWxWYWx1ZXMgPSBuZXcgTWFwKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuZnVuY3Rpb24gcmVjb2lsVmFsdWVzRm9yS2V5cyhrZXlzKSB7XG4gIHJldHVybiBSZWNvaWxfbWFwSXRlcmFibGUoa2V5cywga2V5ID0+IFJlY29pbF9udWxsdGhyb3dzKHJlY29pbFZhbHVlcy5nZXQoa2V5KSkpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckR1cGxpY2F0ZUF0b21LZXkoa2V5KSB7XG4gIGlmIChub2Rlcy5oYXMoa2V5KSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRHVwbGljYXRlIGF0b20ga2V5IFwiJHtrZXl9XCIuIFRoaXMgaXMgYSBGQVRBTCBFUlJPUiBpblxuICAgICAgcHJvZHVjdGlvbi4gQnV0IGl0IGlzIHNhZmUgdG8gaWdub3JlIHRoaXMgd2FybmluZyBpZiBpdCBvY2N1cnJlZCBiZWNhdXNlIG9mXG4gICAgICBob3QgbW9kdWxlIHJlcGxhY2VtZW50LmA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAvLyBUT0RPIEZpZ3VyZSB0aGlzIG91dCBmb3Igb3Blbi1zb3VyY2VcbiAgICAgIGlmICghaXNGYXN0UmVmcmVzaEVuYWJsZWQkMSgpKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihtZXNzYWdlLCAncmVjb2lsJyk7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7IC8vIEBvc3Mtb25seVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck5vZGUobm9kZSkge1xuICBpZiAoUmVjb2lsX1JlY29pbEVudi5SRUNPSUxfRFVQTElDQVRFX0FUT01fS0VZX0NIRUNLSU5HX0VOQUJMRUQpIHtcbiAgICBjaGVja0ZvckR1cGxpY2F0ZUF0b21LZXkobm9kZS5rZXkpO1xuICB9XG5cbiAgbm9kZXMuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgY29uc3QgcmVjb2lsVmFsdWUgPSBub2RlLnNldCA9PSBudWxsID8gbmV3IFJlY29pbF9SZWNvaWxWYWx1ZSQxLlJlY29pbFZhbHVlUmVhZE9ubHkobm9kZS5rZXkpIDogbmV3IFJlY29pbF9SZWNvaWxWYWx1ZSQxLlJlY29pbFN0YXRlKG5vZGUua2V5KTtcbiAgcmVjb2lsVmFsdWVzLnNldChub2RlLmtleSwgcmVjb2lsVmFsdWUpO1xuICByZXR1cm4gcmVjb2lsVmFsdWU7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5cbmNsYXNzIE5vZGVNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7fSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmZ1bmN0aW9uIGdldE5vZGUoa2V5KSB7XG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoa2V5KTtcblxuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vZGVNaXNzaW5nRXJyb3IoYE1pc3NpbmcgZGVmaW5pdGlvbiBmb3IgUmVjb2lsVmFsdWU6IFwiJHtrZXl9XCJcImApO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZU1heWJlKGtleSkge1xuICByZXR1cm4gbm9kZXMuZ2V0KGtleSk7XG59XG5cbmNvbnN0IGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlKGtleSkge1xuICB2YXIgX25vZGUkc2hvdWxkRGVsZXRlQ29uO1xuXG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoa2V5KTtcblxuICBpZiAobm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSB2b2lkIDAgJiYgKF9ub2RlJHNob3VsZERlbGV0ZUNvbiA9IG5vZGUuc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlKSAhPT0gbnVsbCAmJiBfbm9kZSRzaG91bGREZWxldGVDb24gIT09IHZvaWQgMCAmJiBfbm9kZSRzaG91bGREZWxldGVDb24uY2FsbChub2RlKSkge1xuICAgIHZhciBfZ2V0Q29uZmlnRGVsZXRpb25IYW47XG5cbiAgICBub2Rlcy5kZWxldGUoa2V5KTtcbiAgICAoX2dldENvbmZpZ0RlbGV0aW9uSGFuID0gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSkpID09PSBudWxsIHx8IF9nZXRDb25maWdEZWxldGlvbkhhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldENvbmZpZ0RlbGV0aW9uSGFuKCk7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5kZWxldGUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5LCBmbikge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbmZpZ0RlbGV0aW9uSGFuZGxlcnMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5zZXQoa2V5LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyKGtleSkge1xuICByZXR1cm4gY29uZmlnRGVsZXRpb25IYW5kbGVycy5nZXQoa2V5KTtcbn1cblxudmFyIFJlY29pbF9Ob2RlID0ge1xuICBub2RlcyxcbiAgcmVjb2lsVmFsdWVzLFxuICByZWdpc3Rlck5vZGUsXG4gIGdldE5vZGUsXG4gIGdldE5vZGVNYXliZSxcbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUsXG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzLFxuICBOb2RlTWlzc2luZ0Vycm9yLFxuICBEZWZhdWx0VmFsdWUsXG4gIERFRkFVTFRfVkFMVUVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGVucXVldWVFeGVjdXRpb24ocywgZikge1xuICBmKCk7XG59XG5cbnZhciBSZWNvaWxfUXVldWUgPSB7XG4gIGVucXVldWVFeGVjdXRpb25cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaGFtdF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcbi8qKlxuICAgIEBmaWxlT3ZlcnZpZXcgSGFzaCBBcnJheSBNYXBwZWQgVHJpZS5cblxuICAgIENvZGUgYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNsaXB5L3BkYXRhXG4qL1xuXG5cbnZhciBoYW10ID0ge307IC8vIGV4cG9ydFxuXG4vKiBDb25maWd1cmF0aW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgU0laRSA9IDU7XG52YXIgQlVDS0VUX1NJWkUgPSBNYXRoLnBvdygyLCBTSVpFKTtcbnZhciBNQVNLID0gQlVDS0VUX1NJWkUgLSAxO1xudmFyIE1BWF9JTkRFWF9OT0RFID0gQlVDS0VUX1NJWkUgLyAyO1xudmFyIE1JTl9BUlJBWV9OT0RFID0gQlVDS0VUX1NJWkUgLyA0O1xuLypcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBub3RoaW5nID0ge307XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG4vKipcbiAgICBHZXQgMzIgYml0IGhhc2ggb2Ygc3RyaW5nLlxuXG4gICAgQmFzZWQgb246XG4gICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjE2NDYxL2dlbmVyYXRlLWEtaGFzaC1mcm9tLXN0cmluZy1pbi1qYXZhc2NyaXB0LWpxdWVyeVxuKi9cblxuXG52YXIgaGFzaCA9IGhhbXQuaGFzaCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHIpO1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHJldHVybiBzdHI7XG4gIGlmICh0eXBlICE9PSAnc3RyaW5nJykgc3RyICs9ICcnO1xuICB2YXIgaGFzaCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGMgfCAwO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59O1xuLyogQml0IE9wc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgSGFtbWluZyB3ZWlnaHQuXG5cbiAgICBUYWtlbiBmcm9tOiBodHRwOi8vanNwZXJmLmNvbS9oYW1taW5nLXdlaWdodFxuKi9cblxuXG52YXIgcG9wY291bnQgPSBmdW5jdGlvbiBwb3Bjb3VudCh4KSB7XG4gIHggLT0geCA+PiAxICYgMHg1NTU1NTU1NTtcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoeCA+PiAyICYgMHgzMzMzMzMzMyk7XG4gIHggPSB4ICsgKHggPj4gNCkgJiAweDBmMGYwZjBmO1xuICB4ICs9IHggPj4gODtcbiAgeCArPSB4ID4+IDE2O1xuICByZXR1cm4geCAmIDB4N2Y7XG59O1xuXG52YXIgaGFzaEZyYWdtZW50ID0gZnVuY3Rpb24gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKSB7XG4gIHJldHVybiBoID4+PiBzaGlmdCAmIE1BU0s7XG59O1xuXG52YXIgdG9CaXRtYXAgPSBmdW5jdGlvbiB0b0JpdG1hcCh4KSB7XG4gIHJldHVybiAxIDw8IHg7XG59O1xuXG52YXIgZnJvbUJpdG1hcCA9IGZ1bmN0aW9uIGZyb21CaXRtYXAoYml0bWFwLCBiaXQpIHtcbiAgcmV0dXJuIHBvcGNvdW50KGJpdG1hcCAmIGJpdCAtIDEpO1xufTtcbi8qIEFycmF5IE9wc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgU2V0IGEgdmFsdWUgaW4gYW4gYXJyYXkuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gY2hhbmdlLlxuICAgIEBwYXJhbSB2IE5ldyB2YWx1ZVxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVVwZGF0ZSA9IGZ1bmN0aW9uIGFycmF5VXBkYXRlKG11dGF0ZSwgYXQsIHYsIGFycikge1xuICB2YXIgb3V0ID0gYXJyO1xuXG4gIGlmICghbXV0YXRlKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgb3V0ID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBvdXRbaV0gPSBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgb3V0W2F0XSA9IHY7XG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gICAgUmVtb3ZlIGEgdmFsdWUgZnJvbSBhbiBhcnJheS5cblxuICAgIEBwYXJhbSBtdXRhdGUgU2hvdWxkIHRoZSBpbnB1dCBhcnJheSBiZSBtdXRhdGVkP1xuICAgIEBwYXJhbSBhdCBJbmRleCB0byByZW1vdmUuXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5U3BsaWNlT3V0ID0gZnVuY3Rpb24gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBhdCwgYXJyKSB7XG4gIHZhciBuZXdMZW4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZyA9IDA7XG4gIHZhciBvdXQgPSBhcnI7XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIGkgPSBnID0gYXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0ID0gbmV3IEFycmF5KG5ld0xlbik7XG5cbiAgICB3aGlsZSAoaSA8IGF0KSB7XG4gICAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICAgIH1cbiAgfVxuXG4gICsraTtcblxuICB3aGlsZSAoaSA8PSBuZXdMZW4pIHtcbiAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICB9XG5cbiAgaWYgKG11dGF0ZSkge1xuICAgIG91dC5sZW5ndGggPSBuZXdMZW47XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICAgIEluc2VydCBhIHZhbHVlIGludG8gYW4gYXJyYXkuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gaW5zZXJ0IGF0LlxuICAgIEBwYXJhbSB2IFZhbHVlIHRvIGluc2VydCxcbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlTcGxpY2VJbiA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlSW4obXV0YXRlLCBhdCwgdiwgYXJyKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGlmIChtdXRhdGUpIHtcbiAgICB2YXIgX2kgPSBsZW47XG5cbiAgICB3aGlsZSAoX2kgPj0gYXQpIHtcbiAgICAgIGFycltfaS0tXSA9IGFycltfaV07XG4gICAgfVxuXG4gICAgYXJyW2F0XSA9IHY7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHZhciBpID0gMCxcbiAgICAgIGcgPSAwO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuXG4gIHdoaWxlIChpIDwgYXQpIHtcbiAgICBvdXRbZysrXSA9IGFycltpKytdO1xuICB9XG5cbiAgb3V0W2F0XSA9IHY7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBvdXRbKytnXSA9IGFycltpKytdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4vKiBOb2RlIFN0cnVjdHVyZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxudmFyIExFQUYgPSAxO1xudmFyIENPTExJU0lPTiA9IDI7XG52YXIgSU5ERVggPSAzO1xudmFyIEFSUkFZID0gNDtcbi8qKlxuICAgIEVtcHR5IG5vZGUuXG4qL1xuXG52YXIgZW1wdHkgPSB7XG4gIF9faGFtdF9pc0VtcHR5OiB0cnVlXG59O1xuXG52YXIgaXNFbXB0eU5vZGUgPSBmdW5jdGlvbiBpc0VtcHR5Tm9kZSh4KSB7XG4gIHJldHVybiB4ID09PSBlbXB0eSB8fCB4ICYmIHguX19oYW10X2lzRW1wdHk7XG59O1xuLyoqXG4gICAgTGVhZiBob2xkaW5nIGEgdmFsdWUuXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIGhhc2ggSGFzaCBvZiBrZXkuXG4gICAgQG1lbWJlciBrZXkgS2V5LlxuICAgIEBtZW1iZXIgdmFsdWUgVmFsdWUgc3RvcmVkLlxuKi9cblxuXG52YXIgTGVhZiA9IGZ1bmN0aW9uIExlYWYoZWRpdCwgaGFzaCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IExFQUYsXG4gICAgZWRpdDogZWRpdCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIGtleToga2V5LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBfbW9kaWZ5OiBMZWFmX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBMZWFmIGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzIHdpdGggdGhlIHNhbWUgaGFzaCBidXQgZGlmZmVyZW50IGtleXMuXG5cbiAgICBAbWVtYmVyIGVkaXQgRWRpdCBvZiB0aGUgbm9kZS5cbiAgICBAbWVtYmVyIGhhc2ggSGFzaCBvZiBrZXkuXG4gICAgQG1lbWJlciBjaGlsZHJlbiBBcnJheSBvZiBjb2xsaXNpb24gY2hpbGRyZW4gbm9kZS5cbiovXG5cblxudmFyIENvbGxpc2lvbiA9IGZ1bmN0aW9uIENvbGxpc2lvbihlZGl0LCBoYXNoLCBjaGlsZHJlbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENPTExJU0lPTixcbiAgICBlZGl0OiBlZGl0LFxuICAgIGhhc2g6IGhhc2gsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IENvbGxpc2lvbl9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgSW50ZXJuYWwgbm9kZSB3aXRoIGEgc3BhcnNlIHNldCBvZiBjaGlsZHJlbi5cblxuICAgIFVzZXMgYSBiaXRtYXAgYW5kIGFycmF5IHRvIHBhY2sgY2hpbGRyZW4uXG5cbiAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBtYXNrIEJpdG1hcCB0aGF0IGVuY29kZSB0aGUgcG9zaXRpb25zIG9mIGNoaWxkcmVuIGluIHRoZSBhcnJheS5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNoaWxkIG5vZGVzLlxuKi9cblxuXG52YXIgSW5kZXhlZE5vZGUgPSBmdW5jdGlvbiBJbmRleGVkTm9kZShlZGl0LCBtYXNrLCBjaGlsZHJlbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOREVYLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgbWFzazogbWFzayxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogSW5kZXhlZE5vZGVfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIEludGVybmFsIG5vZGUgd2l0aCBtYW55IGNoaWxkcmVuLlxuXG4gICAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBzaXplIE51bWJlciBvZiBjaGlsZHJlbi5cbiAgICBAbWVtYmVyIGNoaWxkcmVuIEFycmF5IG9mIGNoaWxkIG5vZGVzLlxuKi9cblxuXG52YXIgQXJyYXlOb2RlID0gZnVuY3Rpb24gQXJyYXlOb2RlKGVkaXQsIHNpemUsIGNoaWxkcmVuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVJSQVksXG4gICAgZWRpdDogZWRpdCxcbiAgICBzaXplOiBzaXplLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBBcnJheU5vZGVfX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIElzIGBub2RlYCBhIGxlYWYgbm9kZT9cbiovXG5cblxudmFyIGlzTGVhZiA9IGZ1bmN0aW9uIGlzTGVhZihub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBlbXB0eSB8fCBub2RlLnR5cGUgPT09IExFQUYgfHwgbm9kZS50eXBlID09PSBDT0xMSVNJT047XG59O1xuLyogSW50ZXJuYWwgbm9kZSBvcGVyYXRpb25zLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgRXhwYW5kIGFuIGluZGV4ZWQgbm9kZSBpbnRvIGFuIGFycmF5IG5vZGUuXG5cbiAgQHBhcmFtIGVkaXQgQ3VycmVudCBlZGl0LlxuICAgIEBwYXJhbSBmcmFnIEluZGV4IG9mIGFkZGVkIGNoaWxkLlxuICAgIEBwYXJhbSBjaGlsZCBBZGRlZCBjaGlsZC5cbiAgICBAcGFyYW0gbWFzayBJbmRleCBub2RlIG1hc2sgYmVmb3JlIGNoaWxkIGFkZGVkLlxuICAgIEBwYXJhbSBzdWJOb2RlcyBJbmRleCBub2RlIGNoaWxkcmVuIGJlZm9yZSBjaGlsZCBhZGRlZC5cbiovXG5cblxudmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChlZGl0LCBmcmFnLCBjaGlsZCwgYml0bWFwLCBzdWJOb2Rlcykge1xuICB2YXIgYXJyID0gW107XG4gIHZhciBiaXQgPSBiaXRtYXA7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGJpdDsgKytpKSB7XG4gICAgaWYgKGJpdCAmIDEpIGFycltpXSA9IHN1Yk5vZGVzW2NvdW50KytdO1xuICAgIGJpdCA+Pj49IDE7XG4gIH1cblxuICBhcnJbZnJhZ10gPSBjaGlsZDtcbiAgcmV0dXJuIEFycmF5Tm9kZShlZGl0LCBjb3VudCArIDEsIGFycik7XG59O1xuLyoqXG4gICAgQ29sbGFwc2UgYW4gYXJyYXkgbm9kZSBpbnRvIGEgaW5kZXhlZCBub2RlLlxuXG4gIEBwYXJhbSBlZGl0IEN1cnJlbnQgZWRpdC5cbiAgICBAcGFyYW0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIGluIG5ldyBhcnJheS5cbiAgICBAcGFyYW0gcmVtb3ZlZCBJbmRleCBvZiByZW1vdmVkIGVsZW1lbnQuXG4gICAgQHBhcmFtIGVsZW1lbnRzIEFycmF5IG5vZGUgY2hpbGRyZW4gYmVmb3JlIHJlbW92ZS5cbiovXG5cblxudmFyIHBhY2sgPSBmdW5jdGlvbiBwYWNrKGVkaXQsIGNvdW50LCByZW1vdmVkLCBlbGVtZW50cykge1xuICB2YXIgY2hpbGRyZW4gPSBuZXcgQXJyYXkoY291bnQgLSAxKTtcbiAgdmFyIGcgPSAwO1xuICB2YXIgYml0bWFwID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoaSAhPT0gcmVtb3ZlZCkge1xuICAgICAgdmFyIGVsZW0gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYgKGVsZW0gJiYgIWlzRW1wdHlOb2RlKGVsZW0pKSB7XG4gICAgICAgIGNoaWxkcmVuW2crK10gPSBlbGVtO1xuICAgICAgICBiaXRtYXAgfD0gMSA8PCBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCBiaXRtYXAsIGNoaWxkcmVuKTtcbn07XG4vKipcbiAgICBNZXJnZSB0d28gbGVhZiBub2Rlcy5cblxuICAgIEBwYXJhbSBzaGlmdCBDdXJyZW50IHNoaWZ0LlxuICAgIEBwYXJhbSBoMSBOb2RlIDEgaGFzaC5cbiAgICBAcGFyYW0gbjEgTm9kZSAxLlxuICAgIEBwYXJhbSBoMiBOb2RlIDIgaGFzaC5cbiAgICBAcGFyYW0gbjIgTm9kZSAyLlxuKi9cblxuXG52YXIgbWVyZ2VMZWF2ZXMgPSBmdW5jdGlvbiBtZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCwgaDEsIG4xLCBoMiwgbjIpIHtcbiAgaWYgKGgxID09PSBoMikgcmV0dXJuIENvbGxpc2lvbihlZGl0LCBoMSwgW24yLCBuMV0pO1xuICB2YXIgc3ViSDEgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgxKTtcbiAgdmFyIHN1YkgyID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoMik7XG4gIHJldHVybiBJbmRleGVkTm9kZShlZGl0LCB0b0JpdG1hcChzdWJIMSkgfCB0b0JpdG1hcChzdWJIMiksIHN1YkgxID09PSBzdWJIMiA/IFttZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCArIFNJWkUsIGgxLCBuMSwgaDIsIG4yKV0gOiBzdWJIMSA8IHN1YkgyID8gW24xLCBuMl0gOiBbbjIsIG4xXSk7XG59O1xuLyoqXG4gICAgVXBkYXRlIGFuIGVudHJ5IGluIGEgY29sbGlzaW9uIGxpc3QuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCBtdXRhdGlvbiBiZSB1c2VkP1xuICAgIEBwYXJhbSBlZGl0IEN1cnJlbnQgZWRpdC5cbiAgICBAcGFyYW0ga2V5RXEgS2V5IGNvbXBhcmUgZnVuY3Rpb24uXG4gICAgQHBhcmFtIGhhc2ggSGFzaCBvZiBjb2xsaXNpb24uXG4gICAgQHBhcmFtIGxpc3QgQ29sbGlzaW9uIGxpc3QuXG4gICAgQHBhcmFtIGYgVXBkYXRlIGZ1bmN0aW9uLlxuICAgIEBwYXJhbSBrIEtleSB0byB1cGRhdGUuXG4gICAgQHBhcmFtIHNpemUgU2l6ZSByZWYuXG4qL1xuXG5cbnZhciB1cGRhdGVDb2xsaXNpb25MaXN0ID0gZnVuY3Rpb24gdXBkYXRlQ29sbGlzaW9uTGlzdChtdXRhdGUsIGVkaXQsIGtleUVxLCBoLCBsaXN0LCBmLCBrLCBzaXplKSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGNoaWxkID0gbGlzdFtpXTtcblxuICAgIGlmIChrZXlFcShrLCBjaGlsZC5rZXkpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjaGlsZC52YWx1ZTtcblxuICAgICAgdmFyIF9uZXdWYWx1ZSA9IGYodmFsdWUpO1xuXG4gICAgICBpZiAoX25ld1ZhbHVlID09PSB2YWx1ZSkgcmV0dXJuIGxpc3Q7XG5cbiAgICAgIGlmIChfbmV3VmFsdWUgPT09IG5vdGhpbmcpIHtcbiAgICAgICAgLS1zaXplLnZhbHVlO1xuICAgICAgICByZXR1cm4gYXJyYXlTcGxpY2VPdXQobXV0YXRlLCBpLCBsaXN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgaSwgTGVhZihlZGl0LCBoLCBrLCBfbmV3VmFsdWUpLCBsaXN0KTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3VmFsdWUgPSBmKCk7XG4gIGlmIChuZXdWYWx1ZSA9PT0gbm90aGluZykgcmV0dXJuIGxpc3Q7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIGFycmF5VXBkYXRlKG11dGF0ZSwgbGVuLCBMZWFmKGVkaXQsIGgsIGssIG5ld1ZhbHVlKSwgbGlzdCk7XG59O1xuXG52YXIgY2FuRWRpdE5vZGUgPSBmdW5jdGlvbiBjYW5FZGl0Tm9kZShlZGl0LCBub2RlKSB7XG4gIHJldHVybiBlZGl0ID09PSBub2RlLmVkaXQ7XG59O1xuLyogRWRpdGluZ1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgTGVhZl9fbW9kaWZ5ID0gZnVuY3Rpb24gTGVhZl9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICBpZiAoa2V5RXEoaywgdGhpcy5rZXkpKSB7XG4gICAgdmFyIF92ID0gZih0aGlzLnZhbHVlKTtcblxuICAgIGlmIChfdiA9PT0gdGhpcy52YWx1ZSkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAoX3YgPT09IG5vdGhpbmcpIHtcbiAgICAgIC0tc2l6ZS52YWx1ZTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICBpZiAoY2FuRWRpdE5vZGUoZWRpdCwgdGhpcykpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBfdjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBMZWFmKGVkaXQsIGgsIGssIF92KTtcbiAgfVxuXG4gIHZhciB2ID0gZigpO1xuICBpZiAodiA9PT0gbm90aGluZykgcmV0dXJuIHRoaXM7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xufTtcblxudmFyIENvbGxpc2lvbl9fbW9kaWZ5ID0gZnVuY3Rpb24gQ29sbGlzaW9uX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIGlmIChoID09PSB0aGlzLmhhc2gpIHtcbiAgICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICAgIHZhciBsaXN0ID0gdXBkYXRlQ29sbGlzaW9uTGlzdChjYW5FZGl0LCBlZGl0LCBrZXlFcSwgdGhpcy5oYXNoLCB0aGlzLmNoaWxkcmVuLCBmLCBrLCBzaXplKTtcbiAgICBpZiAobGlzdCA9PT0gdGhpcy5jaGlsZHJlbikgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoID4gMSA/IENvbGxpc2lvbihlZGl0LCB0aGlzLmhhc2gsIGxpc3QpIDogbGlzdFswXTsgLy8gY29sbGFwc2Ugc2luZ2xlIGVsZW1lbnQgY29sbGlzaW9uIGxpc3RcbiAgfVxuXG4gIHZhciB2ID0gZigpO1xuICBpZiAodiA9PT0gbm90aGluZykgcmV0dXJuIHRoaXM7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIG1lcmdlTGVhdmVzKGVkaXQsIHNoaWZ0LCB0aGlzLmhhc2gsIHRoaXMsIGgsIExlYWYoZWRpdCwgaCwgaywgdikpO1xufTtcblxudmFyIEluZGV4ZWROb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBJbmRleGVkTm9kZV9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICB2YXIgbWFzayA9IHRoaXMubWFzaztcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpO1xuICB2YXIgYml0ID0gdG9CaXRtYXAoZnJhZyk7XG4gIHZhciBpbmR4ID0gZnJvbUJpdG1hcChtYXNrLCBiaXQpO1xuICB2YXIgZXhpc3RzID0gbWFzayAmIGJpdDtcbiAgdmFyIGN1cnJlbnQgPSBleGlzdHMgPyBjaGlsZHJlbltpbmR4XSA6IGVtcHR5O1xuXG4gIHZhciBjaGlsZCA9IGN1cnJlbnQuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcblxuICBpZiAoY3VycmVudCA9PT0gY2hpbGQpIHJldHVybiB0aGlzO1xuICB2YXIgY2FuRWRpdCA9IGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpO1xuICB2YXIgYml0bWFwID0gbWFzaztcbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuXG4gIGlmIChleGlzdHMgJiYgaXNFbXB0eU5vZGUoY2hpbGQpKSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgYml0bWFwICY9IH5iaXQ7XG4gICAgaWYgKCFiaXRtYXApIHJldHVybiBlbXB0eTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoIDw9IDIgJiYgaXNMZWFmKGNoaWxkcmVuW2luZHggXiAxXSkpIHJldHVybiBjaGlsZHJlbltpbmR4IF4gMV07IC8vIGNvbGxhcHNlXG5cbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlT3V0KGNhbkVkaXQsIGluZHgsIGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmICghZXhpc3RzICYmICFpc0VtcHR5Tm9kZShjaGlsZCkpIHtcbiAgICAvLyBhZGRcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID49IE1BWF9JTkRFWF9OT0RFKSByZXR1cm4gZXhwYW5kKGVkaXQsIGZyYWcsIGNoaWxkLCBtYXNrLCBjaGlsZHJlbik7XG4gICAgYml0bWFwIHw9IGJpdDtcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5U3BsaWNlSW4oY2FuRWRpdCwgaW5keCwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtb2RpZnlcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGluZHgsIGNoaWxkLCBjaGlsZHJlbik7XG4gIH1cblxuICBpZiAoY2FuRWRpdCkge1xuICAgIHRoaXMubWFzayA9IGJpdG1hcDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgYml0bWFwLCBuZXdDaGlsZHJlbik7XG59O1xuXG52YXIgQXJyYXlOb2RlX19tb2RpZnkgPSBmdW5jdGlvbiBBcnJheU5vZGVfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgdmFyIGNvdW50ID0gdGhpcy5zaXplO1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaCk7XG4gIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ZyYWddO1xuXG4gIHZhciBuZXdDaGlsZCA9IChjaGlsZCB8fCBlbXB0eSkuX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQgKyBTSVpFLCBmLCBoLCBrLCBzaXplKTtcblxuICBpZiAoY2hpbGQgPT09IG5ld0NoaWxkKSByZXR1cm4gdGhpcztcbiAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuXG4gIGlmIChpc0VtcHR5Tm9kZShjaGlsZCkgJiYgIWlzRW1wdHlOb2RlKG5ld0NoaWxkKSkge1xuICAgIC8vIGFkZFxuICAgICsrY291bnQ7XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBuZXdDaGlsZCwgY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKCFpc0VtcHR5Tm9kZShjaGlsZCkgJiYgaXNFbXB0eU5vZGUobmV3Q2hpbGQpKSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgLS1jb3VudDtcbiAgICBpZiAoY291bnQgPD0gTUlOX0FSUkFZX05PREUpIHJldHVybiBwYWNrKGVkaXQsIGNvdW50LCBmcmFnLCBjaGlsZHJlbik7XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBmcmFnLCBlbXB0eSwgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vZGlmeVxuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgbmV3Q2hpbGQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIGlmIChjYW5FZGl0KSB7XG4gICAgdGhpcy5zaXplID0gY291bnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5Tm9kZShlZGl0LCBjb3VudCwgbmV3Q2hpbGRyZW4pO1xufTtcblxuZW1wdHkuX21vZGlmeSA9IGZ1bmN0aW9uIChlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgdmFyIHYgPSBmKCk7XG4gIGlmICh2ID09PSBub3RoaW5nKSByZXR1cm4gZW1wdHk7XG4gICsrc2l6ZS52YWx1ZTtcbiAgcmV0dXJuIExlYWYoZWRpdCwgaCwgaywgdik7XG59O1xuLypcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuZnVuY3Rpb24gTWFwKGVkaXRhYmxlLCBlZGl0LCBjb25maWcsIHJvb3QsIHNpemUpIHtcbiAgdGhpcy5fZWRpdGFibGUgPSBlZGl0YWJsZTtcbiAgdGhpcy5fZWRpdCA9IGVkaXQ7XG4gIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3NpemUgPSBzaXplO1xufVxuXG5NYXAucHJvdG90eXBlLnNldFRyZWUgPSBmdW5jdGlvbiAobmV3Um9vdCwgbmV3U2l6ZSkge1xuICBpZiAodGhpcy5fZWRpdGFibGUpIHtcbiAgICB0aGlzLl9yb290ID0gbmV3Um9vdDtcbiAgICB0aGlzLl9zaXplID0gbmV3U2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXdSb290ID09PSB0aGlzLl9yb290ID8gdGhpcyA6IG5ldyBNYXAodGhpcy5fZWRpdGFibGUsIHRoaXMuX2VkaXQsIHRoaXMuX2NvbmZpZywgbmV3Um9vdCwgbmV3U2l6ZSk7XG59O1xuLyogUXVlcmllc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgYSBjdXN0b20gYGhhc2hgLlxuXG4gICAgUmV0dXJucyB0aGUgdmFsdWUgb3IgYGFsdGAgaWYgbm9uZS5cbiovXG5cblxudmFyIHRyeUdldEhhc2ggPSBoYW10LnRyeUdldEhhc2ggPSBmdW5jdGlvbiAoYWx0LCBoYXNoLCBrZXksIG1hcCkge1xuICB2YXIgbm9kZSA9IG1hcC5fcm9vdDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGtleUVxID0gbWFwLl9jb25maWcua2V5RXE7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBMRUFGOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGtleUVxKGtleSwgbm9kZS5rZXkpID8gbm9kZS52YWx1ZSA6IGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENPTExJU0lPTjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChoYXNoID09PSBub2RlLmhhc2gpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgaWYgKGtleUVxKGtleSwgY2hpbGQua2V5KSkgcmV0dXJuIGNoaWxkLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBJTkRFWDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKTtcbiAgICAgICAgICB2YXIgYml0ID0gdG9CaXRtYXAoZnJhZyk7XG5cbiAgICAgICAgICBpZiAobm9kZS5tYXNrICYgYml0KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltmcm9tQml0bWFwKG5vZGUubWFzaywgYml0KV07XG4gICAgICAgICAgICBzaGlmdCArPSBTSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEFSUkFZOlxuICAgICAgICB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baGFzaEZyYWdtZW50KHNoaWZ0LCBoYXNoKV07XG5cbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgc2hpZnQgKz0gU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICB9XG4gIH1cbn07XG5cbk1hcC5wcm90b3R5cGUudHJ5R2V0SGFzaCA9IGZ1bmN0aW9uIChhbHQsIGhhc2gsIGtleSkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChhbHQsIGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYHRyeUdldEhhc2hgXG4qL1xuXG5cbnZhciB0cnlHZXQgPSBoYW10LnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKGFsdCwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnRyeUdldCA9IGZ1bmN0aW9uIChhbHQsIGtleSkge1xuICByZXR1cm4gdHJ5R2V0KGFsdCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBhIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIHRoZSB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lLlxuKi9cblxuXG52YXIgZ2V0SGFzaCA9IGhhbXQuZ2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaCh1bmRlZmluZWQsIGhhc2gsIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZ2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIGdldEhhc2goaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBMb29rdXAgdGhlIHZhbHVlIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgZ2V0YFxuKi9cblxuXG52YXIgZ2V0ID0gaGFtdC5nZXQgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2godW5kZWZpbmVkLCBtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgYWx0KSB7XG4gIHJldHVybiB0cnlHZXQoYWx0LCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIERvZXMgYW4gZW50cnkgZXhpc3QgZm9yIGBrZXlgIGluIGBtYXBgPyBVc2VzIGN1c3RvbSBgaGFzaGAuXG4qL1xuXG5cbnZhciBoYXNIYXNoID0gaGFtdC5oYXMgPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2gobm90aGluZywgaGFzaCwga2V5LCBtYXApICE9PSBub3RoaW5nO1xufTtcblxuTWFwLnByb3RvdHlwZS5oYXNIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSkge1xuICByZXR1cm4gaGFzSGFzaChoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIERvZXMgYW4gZW50cnkgZXhpc3QgZm9yIGBrZXlgIGluIGBtYXBgPyBVc2VzIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG4qL1xuXG5cbnZhciBoYXMgPSBoYW10LmhhcyA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gaGFzSGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gaGFzKGtleSwgdGhpcyk7XG59O1xuXG52YXIgZGVmS2V5Q29tcGFyZSA9IGZ1bmN0aW9uIGRlZktleUNvbXBhcmUoeCwgeSkge1xuICByZXR1cm4geCA9PT0geTtcbn07XG4vKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgbWFwLlxuXG4gICAgQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uLlxuKi9cblxuXG5oYW10Lm1ha2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgTWFwKDAsIDAsIHtcbiAgICBrZXlFcTogY29uZmlnICYmIGNvbmZpZy5rZXlFcSB8fCBkZWZLZXlDb21wYXJlLFxuICAgIGhhc2g6IGNvbmZpZyAmJiBjb25maWcuaGFzaCB8fCBoYXNoXG4gIH0sIGVtcHR5LCAwKTtcbn07XG4vKipcbiAgICBFbXB0eSBtYXAuXG4qL1xuXG5cbmhhbXQuZW1wdHkgPSBoYW10Lm1ha2UoKTtcbi8qKlxuICAgIERvZXMgYG1hcGAgY29udGFpbiBhbnkgZWxlbWVudHM/XG4qL1xuXG52YXIgaXNFbXB0eSA9IGhhbXQuaXNFbXB0eSA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG1hcCAmJiAhIWlzRW1wdHlOb2RlKG1hcC5fcm9vdCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0VtcHR5KHRoaXMpO1xufTtcbi8qIFVwZGF0ZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xuICAgIGN1c3RvbSBoYXNoLlxuXG4gICAgYGZgIGlzIGludm9rZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYGtgIGlmIGl0IGV4aXN0cyxcbiAgICBvciBubyBhcmd1bWVudHMgaWYgbm8gc3VjaCB2YWx1ZSBleGlzdHMuIGBtb2RpZnlgIHdpbGwgYWx3YXlzIGVpdGhlclxuICAgIHVwZGF0ZSBvciBpbnNlcnQgYSB2YWx1ZSBpbnRvIHRoZSBtYXAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIG1vZGlmeUhhc2ggPSBoYW10Lm1vZGlmeUhhc2ggPSBmdW5jdGlvbiAoZiwgaGFzaCwga2V5LCBtYXApIHtcbiAgdmFyIHNpemUgPSB7XG4gICAgdmFsdWU6IG1hcC5fc2l6ZVxuICB9O1xuXG4gIHZhciBuZXdSb290ID0gbWFwLl9yb290Ll9tb2RpZnkobWFwLl9lZGl0YWJsZSA/IG1hcC5fZWRpdCA6IE5hTiwgbWFwLl9jb25maWcua2V5RXEsIDAsIGYsIGhhc2gsIGtleSwgc2l6ZSk7XG5cbiAgcmV0dXJuIG1hcC5zZXRUcmVlKG5ld1Jvb3QsIHNpemUudmFsdWUpO1xufTtcblxuTWFwLnByb3RvdHlwZS5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgZikge1xuICByZXR1cm4gbW9kaWZ5SGFzaChmLCBoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIEFsdGVyIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGZ1bmN0aW9uIGBmYCB1c2luZ1xuICAgIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBtb2RpZnlIYXNoYFxuKi9cblxuXG52YXIgbW9kaWZ5ID0gaGFtdC5tb2RpZnkgPSBmdW5jdGlvbiAoZiwga2V5LCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goZiwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChrZXksIGYpIHtcbiAgcmV0dXJuIG1vZGlmeShmLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIFN0b3JlIGB2YWx1ZWAgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGN1c3RvbSBgaGFzaGAuXG5cbiAgICBSZXR1cm5zIGEgbWFwIHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIHNldEhhc2ggPSBoYW10LnNldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCB2YWx1ZSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGNvbnN0YW50KHZhbHVlKSwgaGFzaCwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5zZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldEhhc2goaGFzaCwga2V5LCB2YWx1ZSwgdGhpcyk7XG59O1xuLyoqXG4gICAgU3RvcmUgYHZhbHVlYCBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYHNldEhhc2hgXG4qL1xuXG5cbnZhciBzZXQgPSBoYW10LnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXApIHtcbiAgcmV0dXJuIHNldEhhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIHZhbHVlLCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc2V0KGtleSwgdmFsdWUsIHRoaXMpO1xufTtcbi8qKlxuICAgIFJlbW92ZSB0aGUgZW50cnkgZm9yIGBrZXlgIGluIGBtYXBgLlxuXG4gICAgUmV0dXJucyBhIG1hcCB3aXRoIHRoZSB2YWx1ZSByZW1vdmVkLiBEb2VzIG5vdCBhbHRlciBgbWFwYC5cbiovXG5cblxudmFyIGRlbCA9IGNvbnN0YW50KG5vdGhpbmcpO1xuXG52YXIgcmVtb3ZlSGFzaCA9IGhhbXQucmVtb3ZlSGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChkZWwsIGhhc2gsIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUucmVtb3ZlSGFzaCA9IE1hcC5wcm90b3R5cGUuZGVsZXRlSGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIHJlbW92ZUhhc2goaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgcmVtb3ZlSGFzaGBcbiovXG5cblxudmFyIHJlbW92ZSA9IGhhbXQucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiByZW1vdmVIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHJlbW92ZShrZXksIHRoaXMpO1xufTtcbi8qIE11dGF0aW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBNYXJrIGBtYXBgIGFzIG11dGFibGUuXG4gKi9cblxuXG52YXIgYmVnaW5NdXRhdGlvbiA9IGhhbXQuYmVnaW5NdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG5ldyBNYXAobWFwLl9lZGl0YWJsZSArIDEsIG1hcC5fZWRpdCArIDEsIG1hcC5fY29uZmlnLCBtYXAuX3Jvb3QsIG1hcC5fc2l6ZSk7XG59O1xuXG5NYXAucHJvdG90eXBlLmJlZ2luTXV0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBiZWdpbk11dGF0aW9uKHRoaXMpO1xufTtcbi8qKlxuICAgIE1hcmsgYG1hcGAgYXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIGVuZE11dGF0aW9uID0gaGFtdC5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uIChtYXApIHtcbiAgbWFwLl9lZGl0YWJsZSA9IG1hcC5fZWRpdGFibGUgJiYgbWFwLl9lZGl0YWJsZSAtIDE7XG4gIHJldHVybiBtYXA7XG59O1xuXG5NYXAucHJvdG90eXBlLmVuZE11dGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW5kTXV0YXRpb24odGhpcyk7XG59O1xuLyoqXG4gICAgTXV0YXRlIGBtYXBgIHdpdGhpbiB0aGUgY29udGV4dCBvZiBgZmAuXG4gICAgQHBhcmFtIGZcbiAgICBAcGFyYW0gbWFwIEhBTVRcbiovXG5cblxudmFyIG11dGF0ZSA9IGhhbXQubXV0YXRlID0gZnVuY3Rpb24gKGYsIG1hcCkge1xuICB2YXIgdHJhbnNpZW50ID0gYmVnaW5NdXRhdGlvbihtYXApO1xuICBmKHRyYW5zaWVudCk7XG4gIHJldHVybiBlbmRNdXRhdGlvbih0cmFuc2llbnQpO1xufTtcblxuTWFwLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gbXV0YXRlKGYsIHRoaXMpO1xufTtcbi8qIFRyYXZlcnNhbFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgQXBwbHkgYSBjb250aW51YXRpb24uXG4qL1xuXG5cbnZhciBhcHBrID0gZnVuY3Rpb24gYXBwayhrKSB7XG4gIHJldHVybiBrICYmIGxhenlWaXNpdENoaWxkcmVuKGtbMF0sIGtbMV0sIGtbMl0sIGtbM10sIGtbNF0pO1xufTtcbi8qKlxuICAgIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB2YWx1ZXMgc3RvcmVkIGluIGFuIGFycmF5IG9mIG5vZGVzIGxhemlseS5cbiovXG5cblxudmFyIGxhenlWaXNpdENoaWxkcmVuID0gZnVuY3Rpb24gbGF6eVZpc2l0Q2hpbGRyZW4obGVuLCBjaGlsZHJlbiwgaSwgZiwgaykge1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2krK107XG4gICAgaWYgKGNoaWxkICYmICFpc0VtcHR5Tm9kZShjaGlsZCkpIHJldHVybiBsYXp5VmlzaXQoY2hpbGQsIGYsIFtsZW4sIGNoaWxkcmVuLCBpLCBmLCBrXSk7XG4gIH1cblxuICByZXR1cm4gYXBwayhrKTtcbn07XG4vKipcbiAgICBSZWN1cnNpdmVseSB2aXNpdCBhbGwgdmFsdWVzIHN0b3JlZCBpbiBgbm9kZWAgbGF6aWx5LlxuKi9cblxuXG52YXIgbGF6eVZpc2l0ID0gZnVuY3Rpb24gbGF6eVZpc2l0KG5vZGUsIGYsIGspIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIExFQUY6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZihub2RlKSxcbiAgICAgICAgcmVzdDoga1xuICAgICAgfTtcblxuICAgIGNhc2UgQ09MTElTSU9OOlxuICAgIGNhc2UgQVJSQVk6XG4gICAgY2FzZSBJTkRFWDpcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICByZXR1cm4gbGF6eVZpc2l0Q2hpbGRyZW4oY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZHJlbiwgMCwgZiwgayk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFwcGsoayk7XG4gIH1cbn07XG5cbnZhciBET05FID0ge1xuICBkb25lOiB0cnVlXG59O1xuLyoqXG4gICAgSmF2YXNjcmlwdCBpdGVyYXRvciBvdmVyIGEgbWFwLlxuKi9cblxuZnVuY3Rpb24gTWFwSXRlcmF0b3Iodikge1xuICB0aGlzLnYgPSB2O1xufVxuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnYpIHJldHVybiBET05FO1xuICB2YXIgdjAgPSB0aGlzLnY7XG4gIHRoaXMudiA9IGFwcGsodjAucmVzdCk7XG4gIHJldHVybiB2MDtcbn07XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAgICBMYXppbHkgdmlzaXQgZWFjaCB2YWx1ZSBpbiBtYXAgd2l0aCBmdW5jdGlvbiBgZmAuXG4qL1xuXG5cbnZhciB2aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG1hcCwgZikge1xuICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKGxhenlWaXNpdChtYXAuX3Jvb3QsIGYpKTtcbn07XG4vKipcbiAgICBHZXQgYSBKYXZhc2NzcmlwdCBpdGVyYXRvciBvZiBgbWFwYC5cblxuICAgIEl0ZXJhdGVzIG92ZXIgYFtrZXksIHZhbHVlXWAgYXJyYXlzLlxuKi9cblxuXG52YXIgYnVpbGRQYWlycyA9IGZ1bmN0aW9uIGJ1aWxkUGFpcnMoeCkge1xuICByZXR1cm4gW3gua2V5LCB4LnZhbHVlXTtcbn07XG5cbnZhciBlbnRyaWVzID0gaGFtdC5lbnRyaWVzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZFBhaXJzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZW50cmllcyA9IE1hcC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudHJpZXModGhpcyk7XG59O1xuLyoqXG4gICAgR2V0IGFycmF5IG9mIGFsbCBrZXlzIGluIGBtYXBgLlxuXG4gICAgT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQuXG4qL1xuXG5cbnZhciBidWlsZEtleXMgPSBmdW5jdGlvbiBidWlsZEtleXMoeCkge1xuICByZXR1cm4geC5rZXk7XG59O1xuXG52YXIga2V5cyA9IGhhbXQua2V5cyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRLZXlzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGtleXModGhpcyk7XG59O1xuLyoqXG4gICAgR2V0IGFycmF5IG9mIGFsbCB2YWx1ZXMgaW4gYG1hcGAuXG5cbiAgICBPcmRlciBpcyBub3QgZ3VhcmFudGVlZCwgZHVwbGljYXRlcyBhcmUgcHJlc2VydmVkLlxuKi9cblxuXG52YXIgYnVpbGRWYWx1ZXMgPSBmdW5jdGlvbiBidWlsZFZhbHVlcyh4KSB7XG4gIHJldHVybiB4LnZhbHVlO1xufTtcblxudmFyIHZhbHVlcyA9IGhhbXQudmFsdWVzID0gTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkVmFsdWVzKTtcbn07XG5cbk1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdmFsdWVzKHRoaXMpO1xufTtcbi8qIEZvbGRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIFZpc2l0IGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAsIGFnZ3JlZ2F0aW5nIGRhdGEuXG5cbiAgICBPcmRlciBvZiBub2RlcyBpcyBub3QgZ3VhcmFudGVlZC5cblxuICAgIEBwYXJhbSBmIEZ1bmN0aW9uIG1hcHBpbmcgYWNjdW11bGF0ZWQgdmFsdWUsIHZhbHVlLCBhbmQga2V5IHRvIG5ldyB2YWx1ZS5cbiAgICBAcGFyYW0geiBTdGFydGluZyB2YWx1ZS5cbiAgICBAcGFyYW0gbSBIQU1UXG4qL1xuXG5cbnZhciBmb2xkID0gaGFtdC5mb2xkID0gZnVuY3Rpb24gKGYsIHosIG0pIHtcbiAgdmFyIHJvb3QgPSBtLl9yb290O1xuICBpZiAocm9vdC50eXBlID09PSBMRUFGKSByZXR1cm4gZih6LCByb290LnZhbHVlLCByb290LmtleSk7XG4gIHZhciB0b1Zpc2l0ID0gW3Jvb3QuY2hpbGRyZW5dO1xuICB2YXIgY2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAgd2hpbGUgKGNoaWxkcmVuID0gdG9WaXNpdC5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xuXG4gICAgICBpZiAoY2hpbGQgJiYgY2hpbGQudHlwZSkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTEVBRikgeiA9IGYoeiwgY2hpbGQudmFsdWUsIGNoaWxkLmtleSk7ZWxzZSB0b1Zpc2l0LnB1c2goY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB6O1xufTtcblxuTWFwLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24gKGYsIHopIHtcbiAgcmV0dXJuIGZvbGQoZiwgeiwgdGhpcyk7XG59O1xuLyoqXG4gICAgVmlzaXQgZXZlcnkgZW50cnkgaW4gdGhlIG1hcCwgYWdncmVnYXRpbmcgZGF0YS5cblxuICAgIE9yZGVyIG9mIG5vZGVzIGlzIG5vdCBndWFyYW50ZWVkLlxuXG4gICAgQHBhcmFtIGYgRnVuY3Rpb24gaW52b2tlZCB3aXRoIHZhbHVlIGFuZCBrZXlcbiAgICBAcGFyYW0gbWFwIEhBTVRcbiovXG5cblxudmFyIGZvckVhY2ggPSBoYW10LmZvckVhY2ggPSBmdW5jdGlvbiAoZiwgbWFwKSB7XG4gIHJldHVybiBmb2xkKGZ1bmN0aW9uIChfLCB2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGYodmFsdWUsIGtleSwgbWFwKTtcbiAgfSwgbnVsbCwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBmb3JFYWNoKGYsIHRoaXMpO1xufTtcbi8qIEFnZ3JlZ2F0ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgR2V0IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiBgbWFwYC5cbiovXG5cblxudmFyIGNvdW50ID0gaGFtdC5jb3VudCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIG1hcC5fc2l6ZTtcbn07XG5cbk1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjb3VudCh0aGlzKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBNYXAucHJvdG90eXBlLmNvdW50XG59KTtcbi8qIEV4cG9ydFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaWYgKCBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGhhbXQ7XG59IGVsc2Uge1xuICB1bmRlZmluZWQuaGFtdCA9IGhhbXQ7XG59XG59KTtcblxuY2xhc3MgQnVpbHRJbk1hcCB7XG4gIGNvbnN0cnVjdG9yKGV4aXN0aW5nKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcFwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChleGlzdGluZyA9PT0gbnVsbCB8fCBleGlzdGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmcuZW50cmllcygpKTtcbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XG4gIH1cblxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpO1xuICB9XG5cbiAgZ2V0KGspIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrKTtcbiAgfVxuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoayk7XG4gIH1cblxuICBzZXQoaywgdikge1xuICAgIHRoaXMuX21hcC5zZXQoaywgdik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShrKSB7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHBlcnNpc3RlbnRNYXAodGhpcyk7XG4gIH1cblxuICB0b01hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLl9tYXApO1xuICB9XG5cbn1cblxuY2xhc3MgSGFzaEFycmF5TWFwcGVkVHJpZU1hcCB7XG4gIC8vIEJlY2F1c2UgaGFtdC5lbXB0eSBpcyBub3QgYSBmdW5jdGlvbiB0aGVyZSBpcyBubyB3YXkgdG8gaW50cm9kdWNlIHR5cGVcbiAgLy8gcGFyYW1ldGVycyBvbiBpdCwgc28gZW1wdHkgaXMgdHlwZWQgYXMgSEFNVFBsdXNNYXA8c3RyaW5nLCBtaXhlZD4uXG4gIC8vICRGbG93SXNzdWVcbiAgY29uc3RydWN0b3IoZXhpc3RpbmcpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGFtdFwiLCBoYW10XzEuZW1wdHkuYmVnaW5NdXRhdGlvbigpKTtcblxuICAgIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEhhc2hBcnJheU1hcHBlZFRyaWVNYXApIHtcbiAgICAgIGNvbnN0IGggPSBleGlzdGluZy5faGFtdC5lbmRNdXRhdGlvbigpO1xuXG4gICAgICBleGlzdGluZy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xuICAgICAgdGhpcy5faGFtdCA9IGguYmVnaW5NdXRhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGV4aXN0aW5nLmVudHJpZXMoKSkge1xuICAgICAgICB0aGlzLl9oYW10LnNldChrLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmtleXMoKTtcbiAgfVxuXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuZW50cmllcygpO1xuICB9XG5cbiAgZ2V0KGspIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5nZXQoayk7XG4gIH1cblxuICBoYXMoaykge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmhhcyhrKTtcbiAgfVxuXG4gIHNldChrLCB2KSB7XG4gICAgdGhpcy5faGFtdC5zZXQoaywgdik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShrKSB7XG4gICAgdGhpcy5faGFtdC5kZWxldGUoayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBwZXJzaXN0ZW50TWFwKHRoaXMpO1xuICB9XG5cbiAgdG9NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5faGFtdCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBwZXJzaXN0ZW50TWFwKGV4aXN0aW5nKSB7XG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfaGFtdF8yMDIwJykpIHtcbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcHBlZFRyaWVNYXAoZXhpc3RpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVpbHRJbk1hcChleGlzdGluZyk7XG4gIH1cbn1cblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwID0ge1xuICBwZXJzaXN0ZW50TWFwXG59O1xuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXBfMSA9IFJlY29pbF9QZXJzaXN0ZW50TWFwLnBlcnNpc3RlbnRNYXA7XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHBlcnNpc3RlbnRNYXA6IFJlY29pbF9QZXJzaXN0ZW50TWFwXzFcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgZmlyc3Qgc2V0IHRoYXQgYXJlIG5vdFxuICogcHJlc2VudCBpbiBhbnkgb2YgdGhlIHN1YnNlcXVlbnQgc2V0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIHdyaXR0ZW4gcHJvY2VkdXJhbGx5IChpLmUuLCB3aXRob3V0IGZpbHRlclNldCkgZm9yIHBlcmZvcm1hbnRcbiAqIHVzZSBpbiB0aWdodCBsb29wcy5cbiAqL1xuXG5mdW5jdGlvbiBkaWZmZXJlbmNlU2V0cyhzZXQsIC4uLnNldHNXaXRoVmFsdWVzVG9SZW1vdmUpIHtcbiAgY29uc3QgcmV0ID0gbmV3IFNldCgpO1xuXG4gIEZJUlNUOiBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgIGZvciAoY29uc3Qgb3RoZXJTZXQgb2Ygc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICAgICAgaWYgKG90aGVyU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWUgRklSU1Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0LmFkZCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG52YXIgUmVjb2lsX2RpZmZlcmVuY2VTZXRzID0gZGlmZmVyZW5jZVNldHM7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybnMgYSBuZXcgTWFwIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9yaWdpbmFsLCBidXQgd2l0aCB0aGVcbiAqIHZhbHVlcyByZXBsYWNlZCB3aXRoIHRoZSBvdXRwdXQgb2YgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG1hcE1hcChtYXAsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICByZXN1bHQuc2V0KGtleSwgY2FsbGJhY2sodmFsdWUsIGtleSkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9tYXBNYXAgPSBtYXBNYXA7XG5cbmZ1bmN0aW9uIG1ha2VHcmFwaCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlRGVwczogbmV3IE1hcCgpLFxuICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOiBuZXcgTWFwKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVHcmFwaChncmFwaCkge1xuICByZXR1cm4ge1xuICAgIG5vZGVEZXBzOiBSZWNvaWxfbWFwTWFwKGdyYXBoLm5vZGVEZXBzLCBzID0+IG5ldyBTZXQocykpLFxuICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOiBSZWNvaWxfbWFwTWFwKGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLCBzID0+IG5ldyBTZXQocykpXG4gIH07XG59IC8vIE5vdGUgdGhhdCB0aGlzIG92ZXJ3cml0ZXMgdGhlIGRlcHMgb2YgZXhpc3Rpbmcgbm9kZXMsIHJhdGhlciB0aGFuIHVuaW9uaW5nXG4vLyB0aGUgbmV3IGRlcHMgd2l0aCB0aGUgb2xkIGRlcHMuXG5cblxuZnVuY3Rpb24gbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgbmV3RGVwcywgZ3JhcGgsIC8vIElmIG9sZGVyR3JhcGggaXMgZ2l2ZW4gdGhlbiB3ZSB3aWxsIG5vdCBvdmVyd3JpdGUgY2hhbmdlcyBtYWRlIHRvIHRoZSBnaXZlblxuLy8gZ3JhcGggY29tcGFyZWQgd2l0aCBvbGRlckdyYXBoOlxub2xkZXJHcmFwaCkge1xuICBjb25zdCB7XG4gICAgbm9kZURlcHMsXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnNcbiAgfSA9IGdyYXBoO1xuICBjb25zdCBvbGREZXBzID0gbm9kZURlcHMuZ2V0KGtleSk7XG5cbiAgaWYgKG9sZERlcHMgJiYgb2xkZXJHcmFwaCAmJiBvbGREZXBzICE9PSBvbGRlckdyYXBoLm5vZGVEZXBzLmdldChrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFVwZGF0ZSBub2RlRGVwczpcblxuXG4gIG5vZGVEZXBzLnNldChrZXksIG5ld0RlcHMpOyAvLyBBZGQgbmV3IGRlcHMgdG8gbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6XG5cbiAgY29uc3QgYWRkZWREZXBzID0gb2xkRGVwcyA9PSBudWxsID8gbmV3RGVwcyA6IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhuZXdEZXBzLCBvbGREZXBzKTtcblxuICBmb3IgKGNvbnN0IGRlcCBvZiBhZGRlZERlcHMpIHtcbiAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XG4gICAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5zZXQoZGVwLCBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nID0gUmVjb2lsX251bGx0aHJvd3Mobm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KGRlcCkpO1xuICAgIGV4aXN0aW5nLmFkZChrZXkpO1xuICB9IC8vIFJlbW92ZSByZW1vdmVkIGRlcHMgZnJvbSBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcblxuXG4gIGlmIChvbGREZXBzKSB7XG4gICAgY29uc3QgcmVtb3ZlZERlcHMgPSBSZWNvaWxfZGlmZmVyZW5jZVNldHMob2xkRGVwcywgbmV3RGVwcyk7XG5cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiByZW1vdmVkRGVwcykge1xuICAgICAgaWYgKCFub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5oYXMoZGVwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gUmVjb2lsX251bGx0aHJvd3Mobm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KGRlcCkpO1xuICAgICAgZXhpc3RpbmcuZGVsZXRlKGtleSk7XG5cbiAgICAgIGlmIChleGlzdGluZy5zaXplID09PSAwKSB7XG4gICAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmRlbGV0ZShkZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYXZlRGVwc1RvU3RvcmUoa2V5LCBkZXBzLCBzdG9yZSwgdmVyc2lvbikge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVCwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMiwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMztcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoISh2ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5leHRUcmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZS52ZXJzaW9uKSB8fCB2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJHByZXZpb3VzVC52ZXJzaW9uKSkpIHtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyaWVkIHRvIHNhdmUgZGVwZW5kZW5jaWVzIHRvIGEgZGlzY2FyZGVkIHRyZWUnKTtcbiAgfSAvLyBNZXJnZSB0aGUgZGVwZW5kZW5jaWVzIGRpc2NvdmVyZWQgaW50byB0aGUgc3RvcmUncyBkZXBlbmRlbmN5IG1hcFxuICAvLyBmb3IgdGhlIHZlcnNpb24gdGhhdCB3YXMgcmVhZDpcblxuXG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgodmVyc2lvbik7XG4gIG1lcmdlRGVwc0ludG9HcmFwaChrZXksIGRlcHMsIGdyYXBoKTsgLy8gSWYgdGhpcyB2ZXJzaW9uIGlzIG5vdCB0aGUgbGF0ZXN0IHZlcnNpb24sIGFsc28gd3JpdGUgdGhlc2UgZGVwZW5kZW5jaWVzXG4gIC8vIGludG8gbGF0ZXIgdmVyc2lvbnMgaWYgdGhleSBkb24ndCBhbHJlYWR5IGhhdmUgdGhlaXIgb3duOlxuXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDIgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMi52ZXJzaW9uKSkge1xuICAgIGNvbnN0IGN1cnJlbnRHcmFwaCA9IHN0b3JlLmdldEdyYXBoKHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbik7XG4gICAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgY3VycmVudEdyYXBoLCBncmFwaCk7XG4gIH1cblxuICBpZiAodmVyc2lvbiA9PT0gKChfc3RvcmVTdGF0ZSRwcmV2aW91c1QzID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJHByZXZpb3VzVDMudmVyc2lvbikgfHwgdmVyc2lvbiA9PT0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKSB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMjtcblxuICAgIGNvbnN0IG5leHRWZXJzaW9uID0gKF9zdG9yZVN0YXRlJG5leHRUcmVlMiA9IHN0b3JlU3RhdGUubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5leHRUcmVlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUyLnZlcnNpb247XG5cbiAgICBpZiAobmV4dFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV4dEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgobmV4dFZlcnNpb24pO1xuICAgICAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgbmV4dEdyYXBoLCBncmFwaCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfR3JhcGggPSB7XG4gIGNsb25lR3JhcGgsXG4gIGdyYXBoOiBtYWtlR3JhcGgsXG4gIHNhdmVEZXBzVG9TdG9yZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IG5leHRUcmVlU3RhdGVWZXJzaW9uID0gMDtcblxuY29uc3QgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24gPSAoKSA9PiBuZXh0VHJlZVN0YXRlVmVyc2lvbisrO1xuXG5sZXQgbmV4dFN0b3JlSUQgPSAwO1xuXG5jb25zdCBnZXROZXh0U3RvcmVJRCA9ICgpID0+IG5leHRTdG9yZUlEKys7XG5cbmxldCBuZXh0Q29tcG9uZW50SUQgPSAwO1xuXG5jb25zdCBnZXROZXh0Q29tcG9uZW50SUQgPSAoKSA9PiBuZXh0Q29tcG9uZW50SUQrKztcblxudmFyIFJlY29pbF9LZXlzID0ge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbixcbiAgZ2V0TmV4dFN0b3JlSUQsXG4gIGdldE5leHRDb21wb25lbnRJRFxufTtcblxuY29uc3Qge1xuICBwZXJzaXN0ZW50TWFwOiBwZXJzaXN0ZW50TWFwJDFcbn0gPSBSZWNvaWxfUGVyc2lzdGVudE1hcCQxO1xuXG5jb25zdCB7XG4gIGdyYXBoXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eVRyZWVTdGF0ZSgpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDEoKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uLFxuICAgIHN0YXRlSUQ6IHZlcnNpb24sXG4gICAgdHJhbnNhY3Rpb25NZXRhZGF0YToge30sXG4gICAgZGlydHlBdG9tczogbmV3IFNldCgpLFxuICAgIGF0b21WYWx1ZXM6IHBlcnNpc3RlbnRNYXAkMSgpLFxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBwZXJzaXN0ZW50TWFwJDEoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRW1wdHlTdG9yZVN0YXRlKCkge1xuICBjb25zdCBjdXJyZW50VHJlZSA9IG1ha2VFbXB0eVRyZWVTdGF0ZSgpO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnRUcmVlLFxuICAgIG5leHRUcmVlOiBudWxsLFxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcbiAgICBjb21taXREZXB0aDogMCxcbiAgICBrbm93bkF0b21zOiBuZXcgU2V0KCksXG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoKSxcbiAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEOiBbXSxcbiAgICBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnM6IG5ldyBTZXQoKSxcbiAgICBncmFwaHNCeVZlcnNpb246IG5ldyBNYXAoKS5zZXQoY3VycmVudFRyZWUudmVyc2lvbiwgZ3JhcGgoKSksXG4gICAgcmV0ZW50aW9uOiB7XG4gICAgICByZWZlcmVuY2VDb3VudHM6IG5ldyBNYXAoKSxcbiAgICAgIG5vZGVzUmV0YWluZWRCeVpvbmU6IG5ldyBNYXAoKSxcbiAgICAgIHJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2U6IG5ldyBTZXQoKVxuICAgIH0sXG4gICAgbm9kZUNsZWFudXBGdW5jdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG52YXIgUmVjb2lsX1N0YXRlID0ge1xuICBtYWtlRW1wdHlUcmVlU3RhdGUsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGUsXG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5jbGFzcyBSZXRlbnRpb25ab25lIHt9XG5cbmZ1bmN0aW9uIHJldGVudGlvblpvbmUoKSB7XG4gIHJldHVybiBuZXcgUmV0ZW50aW9uWm9uZSgpO1xufVxuXG52YXIgUmVjb2lsX1JldGVudGlvblpvbmUgPSB7XG4gIFJldGVudGlvblpvbmUsXG4gIHJldGVudGlvblpvbmVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggYnVpbHQtaW4gTWFwcyBhbmQgU2V0cyB3aXRob3V0IG11dGF0aW5nIHRoZW0uXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHNldEJ5QWRkaW5nVG9TZXQoc2V0LCB2KSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgU2V0KHNldCk7XG4gIG5leHQuYWRkKHYpO1xuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QnlEZWxldGluZ0Zyb21TZXQoc2V0LCB2KSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgU2V0KHNldCk7XG4gIG5leHQuZGVsZXRlKHYpO1xuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gbWFwQnlTZXR0aW5nSW5NYXAobWFwLCBrLCB2KSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuc2V0KGssIHYpO1xuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gbWFwQnlVcGRhdGluZ0luTWFwKG1hcCwgaywgdXBkYXRlcikge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LnNldChrLCB1cGRhdGVyKG5leHQuZ2V0KGspKSk7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nRnJvbU1hcChtYXAsIGspIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5kZWxldGUoayk7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwKG1hcCwga3MpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAga3MuZm9yRWFjaChrID0+IG5leHQuZGVsZXRlKGspKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbnZhciBSZWNvaWxfQ29weU9uV3JpdGUgPSB7XG4gIHNldEJ5QWRkaW5nVG9TZXQsXG4gIHNldEJ5RGVsZXRpbmdGcm9tU2V0LFxuICBtYXBCeVNldHRpbmdJbk1hcCxcbiAgbWFwQnlVcGRhdGluZ0luTWFwLFxuICBtYXBCeURlbGV0aW5nRnJvbU1hcCxcbiAgbWFwQnlEZWxldGluZ011bHRpcGxlRnJvbU1hcFxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpdGVyYWJsZSB3aG9zZSBvdXRwdXQgaXMgZ2VuZXJhdGVkIGJ5IHBhc3NpbmcgdGhlIGlucHV0XG4gKiBpdGVyYWJsZSdzIHZhbHVlcyB0aHJvdWdoIHRoZSBmaWx0ZXIgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgLy8gVXNlIGdlbmVyYXRvciB0byBjcmVhdGUgaXRlcmFibGUvaXRlcmF0b3JcbiAgbGV0IGluZGV4ID0gMDtcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgrKykpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX2ZpbHRlckl0ZXJhYmxlID0gZmlsdGVySXRlcmFibGU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybiBhIHByb3h5IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmFzZSBhbmQgZmFjdG9yaWVzIG9iamVjdHMuXG4gKiBUaGUgcHJveHkgd2lsbCBpbmNsdWRlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBiYXNlIG9iamVjdCBhcy1pcy5cbiAqIFRoZSBmYWN0b3JpZXMgb2JqZWN0IGNvbnRhaW5zIGNhbGxiYWNrcyB0byBvYnRhaW4gdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVyaWVzXG4gKiBmb3IgaXRzIGtleXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHByb3ZpZGluZyB1c2VycyBhbiBvYmplY3Qgd2hlcmUgc29tZSBwcm9wZXJ0aWVzIG1heSBiZVxuICogbGF6aWx5IGNvbXB1dGVkIG9ubHkgb24gZmlyc3QgYWNjZXNzLlxuICovXG4vLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuZnVuY3Rpb24gbGF6eVByb3h5KGJhc2UsIGZhY3Rvcmllcykge1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShiYXNlLCB7XG4gICAgLy8gQ29tcHV0ZSBhbmQgY2FjaGUgbGF6eSBwcm9wZXJ0eSBpZiBub3QgYWxyZWFkeSBkb25lLlxuICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpICYmIHByb3AgaW4gZmFjdG9yaWVzKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGZhY3Rvcmllc1twcm9wXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH0sXG4gICAgLy8gVGhpcyBtZXRob2QgYWxsb3dzIHVzZXIgdG8gaXRlcmF0ZSBrZXlzIGFzIG5vcm1hbFxuICAgIG93bktleXM6IHRhcmdldCA9PiB7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgIH1cbiAgfSk7IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICByZXR1cm4gcHJveHk7XG59XG5cbnZhciBSZWNvaWxfbGF6eVByb3h5ID0gbGF6eVByb3h5O1xuXG5jb25zdCB7XG4gIGdldE5vZGU6IGdldE5vZGUkMSxcbiAgZ2V0Tm9kZU1heWJlOiBnZXROb2RlTWF5YmUkMSxcbiAgcmVjb2lsVmFsdWVzRm9yS2V5czogcmVjb2lsVmFsdWVzRm9yS2V5cyQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgUmV0ZW50aW9uWm9uZTogUmV0ZW50aW9uWm9uZSQxXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XG5cbmNvbnN0IHtcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQxXG59ID0gUmVjb2lsX0NvcHlPbldyaXRlO1xuXG5cblxuXG5cblxuXG4gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5jb25zdCBlbXB0eVNldCA9IE9iamVjdC5mcmVlemUobmV3IFNldCgpKTtcblxuY2xhc3MgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUoc3RvcmUsIG5vZGVLZXksIHJldGFpbmVkQnkpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBub2Rlc1JldGFpbmVkQnlab25lXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbjtcblxuICBmdW5jdGlvbiBhZGRUb1pvbmUoem9uZSkge1xuICAgIGxldCBzZXQgPSBub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKTtcblxuICAgIGlmICghc2V0KSB7XG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lLnNldCh6b25lLCBzZXQgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIHNldC5hZGQobm9kZUtleSk7XG4gIH1cblxuICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgIGFkZFRvWm9uZShyZXRhaW5lZEJ5KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcbiAgICAgIGFkZFRvWm9uZSh6b25lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHJldGVudGlvblxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlRnJvbVpvbmUoem9uZSkge1xuICAgICAgY29uc3Qgc2V0ID0gcmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuICAgICAgc2V0ID09PSBudWxsIHx8IHNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0LmRlbGV0ZShub2RlS2V5KTtcblxuICAgICAgaWYgKHNldCAmJiBzZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5kZWxldGUoem9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldGFpbmVkQnkgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDEpIHtcbiAgICAgIGRlbGV0ZUZyb21ab25lKHJldGFpbmVkQnkpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRhaW5lZEJ5KSkge1xuICAgICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcbiAgICAgICAgZGVsZXRlRnJvbVpvbmUoem9uZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgdHJlZVN0YXRlLCBrZXksIHRyaWdnZXIpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuaGFzKGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG4gIGNvbnN0IHJldGVudGlvbkNsZWFudXAgPSBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwga2V5LCBub2RlLnJldGFpbmVkQnkpO1xuICBjb25zdCBub2RlQ2xlYW51cCA9IG5vZGUuaW5pdChzdG9yZSwgdHJlZVN0YXRlLCB0cmlnZ2VyKTtcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5zZXQoa2V5LCAoKSA9PiB7XG4gICAgbm9kZUNsZWFudXAoKTtcbiAgICByZXRlbnRpb25DbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZShzdG9yZSwga2V5LCB0cmlnZ2VyKSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCBrZXksIHRyaWdnZXIpO1xufVxuXG5mdW5jdGlvbiBjbGVhblVwTm9kZShzdG9yZSwga2V5KSB7XG4gIHZhciBfc3RhdGUkbm9kZUNsZWFudXBGdW47XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAoX3N0YXRlJG5vZGVDbGVhbnVwRnVuID0gc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRub2RlQ2xlYW51cEZ1biA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJG5vZGVDbGVhbnVwRnVuKCk7XG4gIHN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xufSAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgbG9hZGFibGUgb2YgYSBub2RlIGFuZCB1cGRhdGUgdGhlIHN0YXRlLlxuLy8gVXBkYXRlIGRlcGVuZGVuY2llcyBhbmQgc3Vic2NyaXB0aW9ucyBmb3Igc2VsZWN0b3JzLlxuLy8gVXBkYXRlIHNhdmVkIHZhbHVlIHZhbGlkYXRpb24gZm9yIGF0b21zLlxuXG5cbmZ1bmN0aW9uIGdldE5vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RhdGUsIGtleSwgJ2dldCcpO1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkuZ2V0KHN0b3JlLCBzdGF0ZSk7XG59IC8vIFBlZWsgYXQgdGhlIGN1cnJlbnQgdmFsdWUgbG9hZGFibGUgZm9yIGEgbm9kZSB3aXRob3V0IGFueSBldmFsdWF0aW9uIG9yIHN0YXRlIGNoYW5nZVxuXG5cbmZ1bmN0aW9uIHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpIHtcbiAgcmV0dXJuIGdldE5vZGUkMShrZXkpLnBlZWsoc3RvcmUsIHN0YXRlKTtcbn0gLy8gV3JpdGUgdmFsdWUgZGlyZWN0bHkgdG8gc3RhdGUgYnlwYXNzaW5nIHRoZSBOb2RlIGludGVyZmFjZSBhcyB0aGUgbm9kZVxuLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG5cblxuZnVuY3Rpb24gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRChzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICB2YXIgX25vZGUkaW52YWxpZGF0ZTtcblxuICBjb25zdCBub2RlID0gZ2V0Tm9kZU1heWJlJDEoa2V5KTtcbiAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgYXRvbVZhbHVlczogc3RhdGUuYXRvbVZhbHVlcy5jbG9uZSgpLmRlbGV0ZShrZXkpLFxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpLnNldChrZXksIG5ld1ZhbHVlKSxcbiAgICBkaXJ0eUF0b21zOiBzZXRCeUFkZGluZ1RvU2V0JDEoc3RhdGUuZGlydHlBdG9tcywga2V5KVxuICB9O1xufSAvLyBSZXR1cm4gdGhlIGRpc2NvdmVyZWQgZGVwZW5kZW5jaWVzIGFuZCB2YWx1ZXMgdG8gYmUgd3JpdHRlbiBieSBzZXR0aW5nXG4vLyBhIG5vZGUgdmFsdWUuIChNdWx0aXBsZSB2YWx1ZXMgbWF5IGJlIHdyaXR0ZW4gZHVlIHRvIHNlbGVjdG9ycyBnZXR0aW5nIHRvXG4vLyBzZXQgdXBzdHJlYW1zOyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIGJlY2F1c2Ugb2YgcmVhZHMgaW4gdXBkYXRlciBmdW5jdGlvbnMuKVxuXG5cbmZ1bmN0aW9uIHNldE5vZGVWYWx1ZShzdG9yZSwgc3RhdGUsIGtleSwgbmV3VmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMShrZXkpO1xuXG4gIGlmIChub2RlLnNldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRPbmx5UmVjb2lsVmFsdWVFcnJvcihgQXR0ZW1wdCB0byBzZXQgcmVhZC1vbmx5IFJlY29pbFZhbHVlOiAke2tleX1gKTtcbiAgfVxuXG4gIGNvbnN0IHNldCA9IG5vZGUuc2V0OyAvLyBzbyBmbG93IGRvZXNuJ3QgbG9zZSB0aGUgYWJvdmUgcmVmaW5lbWVudC5cblxuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RhdGUsIGtleSwgJ3NldCcpO1xuICByZXR1cm4gc2V0KHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwZWVrTm9kZUluZm8oc3RvcmUsIHN0YXRlLCBrZXkpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RhdGUudmVyc2lvbik7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlJDEoa2V5KS5ub2RlVHlwZTtcbiAgcmV0dXJuIFJlY29pbF9sYXp5UHJveHkoe1xuICAgIHR5cGVcbiAgfSwge1xuICAgIGxvYWRhYmxlOiAoKSA9PiBwZWVrTm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSxcbiAgICBpc0FjdGl2ZTogKCkgPT4gc3RvcmVTdGF0ZS5rbm93bkF0b21zLmhhcyhrZXkpIHx8IHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMuaGFzKGtleSksXG4gICAgaXNTZXQ6ICgpID0+IHR5cGUgPT09ICdzZWxlY3RvcicgPyBmYWxzZSA6IHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSksXG4gICAgaXNNb2RpZmllZDogKCkgPT4gc3RhdGUuZGlydHlBdG9tcy5oYXMoa2V5KSxcbiAgICAvLyBSZXBvcnQgY3VycmVudCBkZXBlbmRlbmNpZXMuICBJZiB0aGUgbm9kZSBoYXNuJ3QgYmVlbiBldmFsdWF0ZWQsIHRoZW5cbiAgICAvLyBkZXBlbmRlbmNpZXMgbWF5IGJlIG1pc3NpbmcgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgZGVwczogKCkgPT4ge1xuICAgICAgdmFyIF9ncmFwaCRub2RlRGVwcyRnZXQ7XG5cbiAgICAgIHJldHVybiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVEZXBzJGdldCAhPT0gdm9pZCAwID8gX2dyYXBoJG5vZGVEZXBzJGdldCA6IFtdKTtcbiAgICB9LFxuICAgIC8vIFJlcG9ydHMgYWxsIFwiY3VycmVudFwiIHN1YnNjcmliZXJzLiAgRXZhbHVhdGluZyBvdGhlciBub2RlcyBvclxuICAgIC8vIHByZXZpb3VzIGluLXByb2dyZXNzIGFzeW5jIGV2YWx1YXRpb25zIG1heSBpbnRyb2R1Y2UgbmV3IHN1YnNjcmliZXJzLlxuICAgIHN1YnNjcmliZXJzOiAoKSA9PiB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkbm9kZVRvQ29tLCBfc3RvcmVTdGF0ZSRub2RlVG9Db20yO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogcmVjb2lsVmFsdWVzRm9yS2V5cyQxKFJlY29pbF9maWx0ZXJJdGVyYWJsZShnZXREb3duc3RyZWFtTm9kZXMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KFtrZXldKSksIG5vZGVLZXkgPT4gbm9kZUtleSAhPT0ga2V5KSksXG4gICAgICAgIGNvbXBvbmVudHM6IFJlY29pbF9tYXBJdGVyYWJsZSgoX3N0b3JlU3RhdGUkbm9kZVRvQ29tID0gKF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIudmFsdWVzKCkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbm9kZVRvQ29tIDogW10sIChbbmFtZV0pID0+ICh7XG4gICAgICAgICAgbmFtZVxuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn0gLy8gRmluZCBhbGwgb2YgdGhlIHJlY3Vyc2l2ZWx5IGRlcGVuZGVudCBub2Rlc1xuXG5cbmZ1bmN0aW9uIGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIGtleXMpIHtcbiAgY29uc3QgdmlzaXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBjb25zdCB2aXNpdGluZ05vZGVzID0gQXJyYXkuZnJvbShrZXlzKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcblxuICBmb3IgKGxldCBrZXkgPSB2aXNpdGluZ05vZGVzLnBvcCgpOyBrZXk7IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCkpIHtcbiAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xuXG4gICAgdmlzaXRlZE5vZGVzLmFkZChrZXkpO1xuICAgIGNvbnN0IHN1YnNjcmliZWROb2RlcyA9IChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVUb05vZGVTdWJzICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgOiBlbXB0eVNldDtcblxuICAgIGZvciAoY29uc3QgZG93bnN0cmVhbU5vZGUgb2Ygc3Vic2NyaWJlZE5vZGVzKSB7XG4gICAgICBpZiAoIXZpc2l0ZWROb2Rlcy5oYXMoZG93bnN0cmVhbU5vZGUpKSB7XG4gICAgICAgIHZpc2l0aW5nTm9kZXMucHVzaChkb3duc3RyZWFtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZpc2l0ZWROb2Rlcztcbn1cblxudmFyIFJlY29pbF9GdW5jdGlvbmFsQ29yZSA9IHtcbiAgZ2V0Tm9kZUxvYWRhYmxlLFxuICBwZWVrTm9kZUxvYWRhYmxlLFxuICBzZXROb2RlVmFsdWUsXG4gIGluaXRpYWxpemVOb2RlLFxuICBjbGVhblVwTm9kZSxcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCxcbiAgcGVla05vZGVJbmZvLFxuICBnZXREb3duc3RyZWFtTm9kZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmxldCBfaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QgPSBudWxsO1xuXG5mdW5jdGlvbiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdChpbnZhbGlkYXRlKSB7XG4gIF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IGludmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KCkge1xuICB2YXIgX2ludmFsaWRhdGVNZW1vaXplZFNuO1xuXG4gIChfaW52YWxpZGF0ZU1lbW9pemVkU24gPSBfaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QpID09PSBudWxsIHx8IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ludmFsaWRhdGVNZW1vaXplZFNuKCk7XG59XG5cbnZhciBSZWNvaWxfU25hcHNob3RDYWNoZSA9IHtcbiAgc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QsXG4gIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90XG59O1xuXG5jb25zdCB7XG4gIGdldERvd25zdHJlYW1Ob2RlczogZ2V0RG93bnN0cmVhbU5vZGVzJDEsXG4gIGdldE5vZGVMb2FkYWJsZTogZ2V0Tm9kZUxvYWRhYmxlJDEsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dENvbXBvbmVudElEOiBnZXROZXh0Q29tcG9uZW50SUQkMVxufSA9IFJlY29pbF9LZXlzO1xuXG5jb25zdCB7XG4gIGdldE5vZGU6IGdldE5vZGUkMixcbiAgZ2V0Tm9kZU1heWJlOiBnZXROb2RlTWF5YmUkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDFcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDEsXG4gIFJlY29pbFN0YXRlOiBSZWNvaWxTdGF0ZSQxLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxWYWx1ZVJlYWRPbmx5JDEsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90OiBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90Q2FjaGU7XG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZShzdG9yZSwge1xuICBrZXlcbn0sIHRyZWVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUpIHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1Q7XG5cbiAgLy8gUmVhZGluZyBmcm9tIGFuIG9sZGVyIHRyZWUgY2FuIGNhdXNlIGJ1Z3MgYmVjYXVzZSB0aGUgZGVwZW5kZW5jaWVzIHRoYXQgd2VcbiAgLy8gZGlzY292ZXIgZHVyaW5nIHRoZSByZWFkIGFyZSBsb3N0LlxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoISh0cmVlU3RhdGUudmVyc2lvbiA9PT0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uIHx8IHRyZWVTdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlLnZlcnNpb24pIHx8IHRyZWVTdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJHByZXZpb3VzVC52ZXJzaW9uKSkpIHtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyaWVkIHRvIHJlYWQgZnJvbSBhIGRpc2NhcmRlZCB0cmVlJyk7XG4gIH1cblxuICBjb25zdCBsb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQxKHN0b3JlLCB0cmVlU3RhdGUsIGtleSk7XG5cbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICBsb2FkYWJsZS5jb250ZW50cy5jYXRjaCgoKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEhBQ0s6IGludGVyY2VwdCB0aHJvd24gZXJyb3IgaGVyZSB0byBwcmV2ZW50IGFuIHVuY2F1Z2h0IHByb21pc2UgZXhjZXB0aW9uLiBJZGVhbGx5IHRoaXMgd291bGQgaGFwcGVuIGNsb3NlciB0byBzZWxlY3RvclxuICAgICAgICogZXhlY3V0aW9uIChwZXJoYXBzIGludHJvZHVjaW5nIGEgbmV3IEVSUk9SIGNsYXNzIHRvIGJlIHJlc29sdmVkIGJ5IGFzeW5jIHNlbGVjdG9ycyB0aGF0IGFyZSBpbiBhbiBlcnJvciBzdGF0ZSlcbiAgICAgICAqL1xuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiBhcHBseUF0b21WYWx1ZVdyaXRlcyhhdG9tVmFsdWVzLCB3cml0ZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gYXRvbVZhbHVlcy5jbG9uZSgpO1xuICB3cml0ZXMuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgIGlmICh2LnN0YXRlID09PSAnaGFzVmFsdWUnICYmIHYuY29udGVudHMgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgcmVzdWx0LmRlbGV0ZShrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrLCB2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlcihzdG9yZSwgc3RhdGUsIHtcbiAga2V5XG59LCB2YWx1ZU9yVXBkYXRlcikge1xuICBpZiAodHlwZW9mIHZhbHVlT3JVcGRhdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXBkYXRlciBmb3JtOiBwYXNzIGluIHRoZSBjdXJyZW50IHZhbHVlLiBUaHJvdyBpZiB0aGUgY3VycmVudCB2YWx1ZVxuICAgIC8vIGlzIHVuYXZhaWxhYmxlIChuYW1lbHkgd2hlbiB1cGRhdGluZyBhbiBhc3luYyBzZWxlY3RvciB0aGF0J3NcbiAgICAvLyBwZW5kaW5nIG9yIGVycm9yZWQpOlxuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXROb2RlTG9hZGFibGUkMShzdG9yZSwgc3RhdGUsIGtleSk7XG5cbiAgICBpZiAoY3VycmVudC5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBjb25zdCBtc2cgPSBgVHJpZWQgdG8gc2V0IGF0b20gb3Igc2VsZWN0b3IgXCIke2tleX1cIiB1c2luZyBhbiB1cGRhdGVyIGZ1bmN0aW9uIHdoaWxlIHRoZSBjdXJyZW50IHN0YXRlIGlzIHBlbmRpbmcsIHRoaXMgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuYDtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihtc2cpO1xuICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgdGhyb3cgY3VycmVudC5jb250ZW50cztcbiAgICB9IC8vIFQgaXRzZWxmIG1heSBiZSBhIGZ1bmN0aW9uLCBzbyBvdXIgcmVmaW5lbWVudCBpcyBub3Qgc3VmZmljaWVudDpcblxuXG4gICAgcmV0dXJuIHZhbHVlT3JVcGRhdGVyKGN1cnJlbnQuY29udGVudHMpOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVPclVwZGF0ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb24oc3RvcmUsIHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0Jykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY29pbFZhbHVlLFxuICAgICAgdmFsdWVPclVwZGF0ZXJcbiAgICB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWVGcm9tVmFsdWVPclVwZGF0ZXIoc3RvcmUsIHN0YXRlLCByZWNvaWxWYWx1ZSwgdmFsdWVPclVwZGF0ZXIpO1xuICAgIGNvbnN0IHdyaXRlcyA9IHNldE5vZGVWYWx1ZSQxKHN0b3JlLCBzdGF0ZSwgcmVjb2lsVmFsdWUua2V5LCBuZXdWYWx1ZSk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIGxvYWRhYmxlXSBvZiB3cml0ZXMuZW50cmllcygpKSB7XG4gICAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gJ3NldExvYWRhYmxlJykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY29pbFZhbHVlOiB7XG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIGxvYWRhYmxlXG4gICAgfSA9IGFjdGlvbjtcbiAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpO1xuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnbWFya01vZGlmaWVkJykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY29pbFZhbHVlOiB7XG4gICAgICAgIGtleVxuICAgICAgfVxuICAgIH0gPSBhY3Rpb247XG4gICAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcbiAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gJ3NldFVudmFsaWRhdGVkJykge1xuICAgIHZhciBfbm9kZSRpbnZhbGlkYXRlO1xuXG4gICAgLy8gV3JpdGUgdmFsdWUgZGlyZWN0bHkgdG8gc3RhdGUgYnlwYXNzaW5nIHRoZSBOb2RlIGludGVyZmFjZSBhcyB0aGUgbm9kZVxuICAgIC8vIGRlZmluaXRpb25zIG1heSBub3QgaGF2ZSBiZWVuIGxvYWRlZCB5ZXQgd2hlbiBwcm9jZXNzaW5nIHRoZSBpbml0aWFsIHNuYXBzaG90LlxuICAgIGNvbnN0IHtcbiAgICAgIHJlY29pbFZhbHVlOiB7XG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIHVudmFsaWRhdGVkVmFsdWVcbiAgICB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlTWF5YmUkMihrZXkpO1xuICAgIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGludmFsaWRhdGUgPSBub2RlLmludmFsaWRhdGUpID09PSBudWxsIHx8IF9ub2RlJGludmFsaWRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGludmFsaWRhdGUuY2FsbChub2RlLCBzdGF0ZSk7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5zZXQoa2V5LCB1bnZhbGlkYXRlZFZhbHVlKTtcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihgVW5rbm93biBhY3Rpb24gJHthY3Rpb24udHlwZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUoc3RhdGUsIGtleSwgbG9hZGFibGUpIHtcbiAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnICYmIGxvYWRhYmxlLmNvbnRlbnRzIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDEpIHtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgbG9hZGFibGUpO1xuICB9XG5cbiAgc3RhdGUuZGlydHlBdG9tcy5hZGQoa2V5KTtcbiAgc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZGVsZXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpIHtcbiAgc3RvcmUucmVwbGFjZVN0YXRlKHN0YXRlID0+IHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNvcHlUcmVlU3RhdGUoc3RhdGUpO1xuXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgYXBwbHlBY3Rpb24oc3RvcmUsIG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEb3duc3RyZWFtcyhzdG9yZSwgbmV3U3RhdGUpO1xuICAgIGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEoKTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCBhY3Rpb24pIHtcbiAgaWYgKGJhdGNoU3RhY2subGVuZ3RoKSB7XG4gICAgY29uc3QgYWN0aW9uc0J5U3RvcmUgPSBiYXRjaFN0YWNrW2JhdGNoU3RhY2subGVuZ3RoIC0gMV07XG4gICAgbGV0IGFjdGlvbnMgPSBhY3Rpb25zQnlTdG9yZS5nZXQoc3RvcmUpO1xuXG4gICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICBhY3Rpb25zQnlTdG9yZS5zZXQoc3RvcmUsIGFjdGlvbnMgPSBbXSk7XG4gICAgfVxuXG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgW2FjdGlvbl0pO1xuICB9XG59XG5cbmNvbnN0IGJhdGNoU3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gYmF0Y2hTdGFydCgpIHtcbiAgY29uc3QgYWN0aW9uc0J5U3RvcmUgPSBuZXcgTWFwKCk7XG4gIGJhdGNoU3RhY2sucHVzaChhY3Rpb25zQnlTdG9yZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBbc3RvcmUsIGFjdGlvbnNdIG9mIGFjdGlvbnNCeVN0b3JlKSB7XG4gICAgICBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBhY3Rpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3BwZWQgPSBiYXRjaFN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKHBvcHBlZCAhPT0gYWN0aW9uc0J5U3RvcmUpIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignSW5jb3JyZWN0IG9yZGVyIG9mIGJhdGNoIHBvcHBpbmcnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvcHlUcmVlU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgYXRvbVZhbHVlczogc3RhdGUuYXRvbVZhbHVlcy5jbG9uZSgpLFxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpLFxuICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoc3RhdGUuZGlydHlBdG9tcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZURvd25zdHJlYW1zKHN0b3JlLCBzdGF0ZSkge1xuICAvLyBJbmZvcm0gYW55IG5vZGVzIHRoYXQgd2VyZSBjaGFuZ2VkIG9yIGRvd25zdHJlYW0gb2YgY2hhbmdlcyBzbyB0aGF0IHRoZXlcbiAgLy8gY2FuIGNsZWFyIG91dCBhbnkgY2FjaGVzIGFzIG5lZWRlZCBkdWUgdG8gdGhlIHVwZGF0ZTpcbiAgY29uc3QgZG93bnN0cmVhbXMgPSBnZXREb3duc3RyZWFtTm9kZXMkMShzdG9yZSwgc3RhdGUsIHN0YXRlLmRpcnR5QXRvbXMpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGRvd25zdHJlYW1zKSB7XG4gICAgdmFyIF9nZXROb2RlTWF5YmUsIF9nZXROb2RlTWF5YmUkaW52YWxpZDtcblxuICAgIChfZ2V0Tm9kZU1heWJlID0gZ2V0Tm9kZU1heWJlJDIoa2V5KSkgPT09IG51bGwgfHwgX2dldE5vZGVNYXliZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9nZXROb2RlTWF5YmUkaW52YWxpZCA9IF9nZXROb2RlTWF5YmUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX2dldE5vZGVNYXliZSRpbnZhbGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Tm9kZU1heWJlJGludmFsaWQuY2FsbChfZ2V0Tm9kZU1heWJlLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlLCB2YWx1ZU9yVXBkYXRlcikge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldCcsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgdmFsdWVPclVwZGF0ZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlY29pbFZhbHVlTG9hZGFibGUoc3RvcmUsIHJlY29pbFZhbHVlLCBsb2FkYWJsZSkge1xuICBpZiAobG9hZGFibGUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgIHJldHVybiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKTtcbiAgfVxuXG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0TG9hZGFibGUnLFxuICAgIHJlY29pbFZhbHVlLFxuICAgIGxvYWRhYmxlOiBsb2FkYWJsZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFya1JlY29pbFZhbHVlTW9kaWZpZWQoc3RvcmUsIHJlY29pbFZhbHVlKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnbWFya01vZGlmaWVkJyxcbiAgICByZWNvaWxWYWx1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIHVudmFsaWRhdGVkVmFsdWUpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXRVbnZhbGlkYXRlZCcsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgdW52YWxpZGF0ZWRWYWx1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZShzdG9yZSwge1xuICBrZXlcbn0sIGNhbGxiYWNrLCBjb21wb25lbnREZWJ1Z05hbWUgPSBudWxsKSB7XG4gIGNvbnN0IHN1YklEID0gZ2V0TmV4dENvbXBvbmVudElEJDEoKTtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKCFzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuaGFzKGtleSkpIHtcbiAgICBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuc2V0KGtleSwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkuc2V0KHN1YklELCBbY29tcG9uZW50RGVidWdOYW1lICE9PSBudWxsICYmIGNvbXBvbmVudERlYnVnTmFtZSAhPT0gdm9pZCAwID8gY29tcG9uZW50RGVidWdOYW1lIDogJzxub3QgY2FwdHVyZWQ+JywgY2FsbGJhY2tdKTsgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQsIGR1cmluZyB0aGUgc2FtZSB0aWNrIHRoYXQgd2UgYXJlIHN1YnNjcmliaW5nLCBhbiBhdG9tXG4gIC8vIGhhcyBiZWVuIHVwZGF0ZWQgYnkgc29tZSBlZmZlY3QgaGFuZGxlci4gT3RoZXJ3aXNlIHdlIHdpbGwgbWlzcyB0aGUgdXBkYXRlLlxuXG4gIGNvbnN0IG1vZGUgPSByZWFjdE1vZGUkMSgpO1xuXG4gIGlmIChtb2RlLmVhcmx5ICYmIChtb2RlLm1vZGUgPT09ICdMRUdBQ1knIHx8IG1vZGUubW9kZSA9PT0gJ01VVEFCTEVfU09VUkNFJykpIHtcbiAgICBjb25zdCBuZXh0VHJlZSA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWU7XG5cbiAgICBpZiAobmV4dFRyZWUgJiYgbmV4dFRyZWUuZGlydHlBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgY2FsbGJhY2sobmV4dFRyZWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgY29uc3QgcmVsZWFzZVN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qgc3VicyA9IHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChzdWJzID09PSB1bmRlZmluZWQgfHwgIXN1YnMuaGFzKHN1YklEKSkge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oYFN1YnNjcmlwdGlvbiBtaXNzaW5nIGF0IHJlbGVhc2UgdGltZSBmb3IgYXRvbSAke2tleX0uIFRoaXMgaXMgYSBidWcgaW4gUmVjb2lsLmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN1YnMuZGVsZXRlKHN1YklEKTtcblxuICAgICAgaWYgKHN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZWxlYXNlU3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSkge1xuICB2YXIgX25vZGUkY2xlYXJDYWNoZTtcblxuICBjb25zdCB7XG4gICAgY3VycmVudFRyZWVcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlJDIocmVjb2lsVmFsdWUua2V5KTtcbiAgKF9ub2RlJGNsZWFyQ2FjaGUgPSBub2RlLmNsZWFyQ2FjaGUpID09PSBudWxsIHx8IF9ub2RlJGNsZWFyQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGNsZWFyQ2FjaGUuY2FsbChub2RlLCBzdG9yZSwgY3VycmVudFRyZWUpO1xufVxuXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlID0ge1xuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxWYWx1ZVJlYWRPbmx5JDEsXG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSxcbiAgc2V0UmVjb2lsVmFsdWUsXG4gIHNldFJlY29pbFZhbHVlTG9hZGFibGUsXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkLFxuICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlLFxuICBzdWJzY3JpYmVUb1JlY29pbFZhbHVlLFxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDEsXG4gIGFwcGx5QXRvbVZhbHVlV3JpdGVzLFxuICAvLyBUT0RPIFJlbW92ZSBleHBvcnQgd2hlbiBkZXByZWNhdGluZyBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEIGluIFJlY29pbFJvb3RcbiAgYmF0Y2hTdGFydCxcbiAgd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlLFxuICBpbnZhbGlkYXRlRG93bnN0cmVhbXMsXG4gIGNvcHlUcmVlU3RhdGUsXG4gIHJlZnJlc2hSZWNvaWxWYWx1ZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogVGhlIHNvbWVTZXQoKSBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBTZXQgcGFzcyB0aGVcbiAqIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHNvbWVTZXQoc2V0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICBjb25zdCBpdGVyYXRvciA9IHNldC5lbnRyaWVzKCk7XG4gIGxldCBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gIHdoaWxlICghY3VycmVudC5kb25lKSB7XG4gICAgY29uc3QgZW50cnkgPSBjdXJyZW50LnZhbHVlO1xuXG4gICAgaWYgKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGVudHJ5WzBdLCBzZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gaXRlcmF0b3IubmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUmVjb2lsX3NvbWVTZXQgPSBzb21lU2V0O1xuXG5jb25zdCB7XG4gIGNsZWFuVXBOb2RlOiBjbGVhblVwTm9kZSQxXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIGRlbGV0ZU5vZGVDb25maWdJZlBvc3NpYmxlOiBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxLFxuICBnZXROb2RlOiBnZXROb2RlJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuXG5cblxuXG5cblxuIC8vIENvbXBvbmVudHMgdGhhdCBhcmVuJ3QgbW91bnRlZCBhZnRlciBzdXNwZW5kaW5nIGZvciB0aGlzIGxvbmcgd2lsbCBiZSBhc3N1bWVkXG4vLyB0byBiZSBkaXNjYXJkZWQgYW5kIHRoZWlyIHJlc291cmNlcyByZWxlYXNlZC5cblxuXG5jb25zdCBTVVNQRU5TRV9USU1FT1VUX01TID0gMTIwMDAwO1xuY29uc3QgZW1wdHlTZXQkMSA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gcmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZShzdG9yZSwgcmV0YWluYWJsZXMpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG5cbiAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUpIHtcbiAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ3JlbGVhc2VOb2Rlc05vd09uQ3VycmVudFRyZWUgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYSBiYXRjaCcpO1xuICAgIHJldHVybjsgLy8gbGVhayBtZW1vcnkgcmF0aGVyIHRoYW4gZXJhc2Ugc29tZXRoaW5nIHRoYXQncyBhYm91dCB0byBiZSB1c2VkLlxuICB9XG5cbiAgY29uc3Qgbm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDIpIHtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHIpKSB7XG4gICAgICAgIG5vZGVzLmFkZChuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMuYWRkKHIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlbGVhc2FibGVOb2RlcyA9IGZpbmRSZWxlYXNhYmxlTm9kZXMoc3RvcmUsIG5vZGVzKTtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzKSB7XG4gICAgcmVsZWFzZU5vZGUoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFJlbGVhc2FibGVOb2RlcyhzdG9yZSwgc2VhcmNoRnJvbU5vZGVzKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgcmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpOyAvLyBtdXRhdGVkIHRvIGNvbGxlY3QgYW5zd2VyXG5cbiAgY29uc3Qgbm9uUmVsZWFzYWJsZU5vZGVzID0gbmV3IFNldCgpO1xuICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKTtcbiAgcmV0dXJuIHJlbGVhc2FibGVOb2RlcztcblxuICBmdW5jdGlvbiBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIoc2VhcmNoRnJvbU5vZGVzKSB7XG4gICAgY29uc3QgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRvd25zdHJlYW1zID0gZ2V0RG93bnN0cmVhbU5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyKHN0b3JlLCB0cmVlU3RhdGUsIHNlYXJjaEZyb21Ob2RlcywgcmVsZWFzYWJsZU5vZGVzLCAvLyBkb24ndCBkZXNjZW5kIGludG8gdGhlc2VcbiAgICBub25SZWxlYXNhYmxlTm9kZXMgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXG4gICAgKTsgLy8gRmluZCB3aGljaCBvZiB0aGUgZG93bnN0cmVhbSBub2RlcyBhcmUgcmVsZWFzYWJsZSBhbmQgd2hpY2ggYXJlIG5vdDpcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkb3duc3RyZWFtcykge1xuICAgICAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjtcblxuICAgICAgLy8gTm90IHJlbGVhc2FibGUgaWYgY29uZmlndXJlZCB0byBiZSByZXRhaW5lZCBmb3JldmVyOlxuICAgICAgaWYgKGdldE5vZGUkMyhub2RlKS5yZXRhaW5lZEJ5ID09PSAncmVjb2lsUm9vdCcpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIHJldGFpbmVkIGRpcmVjdGx5IGJ5IGEgY29tcG9uZW50OlxuXG5cbiAgICAgIGlmICgoKF9zdG9yZVN0YXRlJHJldGVudGlvbiA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cy5nZXQobm9kZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbiAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkcmV0ZW50aW9uIDogMCkgPiAwKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBOb3QgcmVsZWFzYWJsZSBpZiByZXRhaW5lZCBieSBhIHpvbmU6XG5cblxuICAgICAgaWYgKHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKS5zb21lKHogPT4gc3RvcmVTdGF0ZS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzLmdldCh6KSkpIHtcbiAgICAgICAgbm9uUmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE5vdCByZWxlYXNhYmxlIGlmIGl0IGhhcyBhIG5vbi1yZWxlYXNhYmxlIGNoaWxkICh3aGljaCB3aWxsIGFscmVhZHkgYmUgaW5cbiAgICAgIC8vIG5vblJlbGVhc2FibGVOb2RlcyBiZWNhdXNlIHdlIGFyZSBnb2luZyBpbiB0b3BvbG9naWNhbCBvcmRlcik6XG5cblxuICAgICAgY29uc3Qgbm9kZUNoaWxkcmVuID0gZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KG5vZGUpO1xuXG4gICAgICBpZiAobm9kZUNoaWxkcmVuICYmIFJlY29pbF9zb21lU2V0KG5vZGVDaGlsZHJlbiwgY2hpbGQgPT4gbm9uUmVsZWFzYWJsZU5vZGVzLmhhcyhjaGlsZCkpKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uLmFkZChub2RlKTtcbiAgICB9IC8vIElmIHdlIGZvdW5kIGFueSByZWxlYXNhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIHdhbGsgVVAgZnJvbSB0aG9zZSBub2RlcyB0b1xuICAgIC8vIGZpbmQgd2hldGhlciB0aGVpciBwYXJlbnRzIGNhbiBub3cgYmUgcmVsZWFzZWQgYXMgd2VsbDpcblxuXG4gICAgY29uc3QgcGFyZW50cyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZWxlYXNhYmxlTm9kZXNGb3VuZFRoaXNJdGVyYXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIChfZ3JhcGgkbm9kZURlcHMkZ2V0ID0gZ3JhcGgubm9kZURlcHMuZ2V0KG5vZGUpKSAhPT0gbnVsbCAmJiBfZ3JhcGgkbm9kZURlcHMkZ2V0ICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZURlcHMkZ2V0IDogZW1wdHlTZXQkMSkge1xuICAgICAgICB2YXIgX2dyYXBoJG5vZGVEZXBzJGdldDtcblxuICAgICAgICBpZiAoIXJlbGVhc2FibGVOb2Rlcy5oYXMocGFyZW50KSkge1xuICAgICAgICAgIHBhcmVudHMuYWRkKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50cy5zaXplKSB7XG4gICAgICBmaW5kUmVsZWFzYWJsZU5vZGVzSW5uZXIocGFyZW50cyk7XG4gICAgfVxuICB9XG59IC8vIENoaWxkcmVuIGJlZm9yZSBwYXJlbnRzXG5cblxuZnVuY3Rpb24gZ2V0RG93bnN0cmVhbU5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyKHN0b3JlLCB0cmVlU3RhdGUsIG5vZGVzLCAvLyBNdXRhYmxlIHNldCBpcyBkZXN0cm95ZWQgaW4gcGxhY2VcbmRvTm90RGVzY2VuZEludG8xLCBkb05vdERlc2NlbmRJbnRvMikge1xuICBjb25zdCBncmFwaCA9IHN0b3JlLmdldEdyYXBoKHRyZWVTdGF0ZS52ZXJzaW9uKTtcbiAgY29uc3QgYW5zd2VyID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG5cbiAgd2hpbGUgKG5vZGVzLnNpemUgPiAwKSB7XG4gICAgdmlzaXQoUmVjb2lsX251bGx0aHJvd3Mobm9kZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gYW5zd2VyO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICBpZiAoZG9Ob3REZXNjZW5kSW50bzEuaGFzKG5vZGUpIHx8IGRvTm90RGVzY2VuZEludG8yLmhhcyhub2RlKSkge1xuICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2aXNpdGVkLmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICBub2Rlcy5kZWxldGUobm9kZSk7XG4gICAgYW5zd2VyLnB1c2gobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZU5vZGUoc3RvcmUsIHRyZWVTdGF0ZSwgbm9kZSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQXRvbSBlZmZlY3RzLCBpbi1jbG9zdXJlIGNhY2hlcywgZXRjLjpcblxuXG4gIGNsZWFuVXBOb2RlJDEoc3RvcmUsIG5vZGUpOyAvLyBEZWxldGUgZnJvbSBzdG9yZSBzdGF0ZTpcblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgc3RvcmVTdGF0ZS5rbm93bkF0b21zLmRlbGV0ZShub2RlKTtcbiAgc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycy5kZWxldGUobm9kZSk7XG4gIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gIHN0b3JlU3RhdGUucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IHpvbmVzID0gem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpO1xuXG4gIGZvciAoY29uc3Qgem9uZSBvZiB6b25lcykge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRyZXRlbnRpb24yO1xuXG4gICAgKF9zdG9yZVN0YXRlJHJldGVudGlvbjIgPSBzdG9yZVN0YXRlLnJldGVudGlvbi5ub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcmV0ZW50aW9uMi5kZWxldGUobm9kZSk7XG4gIH0gLy8gTm90ZSB0aGF0IHdlIERPIE5PVCBkZWxldGUgZnJvbSBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zIGJlY2F1c2UgdGhpc1xuICAvLyBhbHJlYWR5IGhhcHBlbnMgd2hlbiB0aGUgbGFzdCBjb21wb25lbnQgdGhhdCB3YXMgcmV0YWluaW5nIHRoZSBub2RlIHVubW91bnRzLFxuICAvLyBhbmQgdGhpcyBjb3VsZCBoYXBwZW4gZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGF0LlxuICAvLyBEZWxldGUgZnJvbSBUcmVlU3RhdGUgYW5kIGRlcCBncmFwaDpcblxuXG4gIHRyZWVTdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShub2RlKTtcbiAgdHJlZVN0YXRlLmRpcnR5QXRvbXMuZGVsZXRlKG5vZGUpO1xuICB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZGVsZXRlKG5vZGUpO1xuICBjb25zdCBncmFwaCA9IHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmdldCh0cmVlU3RhdGUudmVyc2lvbik7XG5cbiAgaWYgKGdyYXBoKSB7XG4gICAgY29uc3QgZGVwcyA9IGdyYXBoLm5vZGVEZXBzLmdldChub2RlKTtcblxuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyYXBoLm5vZGVEZXBzLmRlbGV0ZShub2RlKTtcblxuICAgICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xuXG4gICAgICAgIChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSkgPT09IG51bGwgfHwgX2dyYXBoJG5vZGVUb05vZGVTdWJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMuZGVsZXRlKG5vZGUpO1xuICAgICAgfVxuICAgIH0gLy8gTm8gbmVlZCB0byBkZWxldGUgc3ViJ3MgZGVwcyBhcyB0aGVyZSBzaG91bGQgYmUgbm8gc3VicyBhdCB0aGlzIHBvaW50LlxuICAgIC8vIEJ1dCBhbiBpbnZhcmlhbnQgd291bGQgcmVxdWlyZSBkZWxldGluZyBub2RlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cblxuXG4gICAgZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKG5vZGUpO1xuICB9IC8vIE5vZGUgY29uZmlnIChmb3IgZmFtaWx5IG1lbWJlcnMgb25seSBhcyB0aGVpciBjb25maWdzIGNhbiBiZSByZWNyZWF0ZWQsIGFuZFxuICAvLyBvbmx5IGlmIHRoZXkgYXJlIG5vdCByZXRhaW5lZCB3aXRoaW4gYW55IG90aGVyIFN0b3Jlcyk6XG5cblxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSQxKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBub2Rlc1JldGFpbmVkQnlab25lKHN0b3JlU3RhdGUsIHpvbmUpIHtcbiAgdmFyIF9zdG9yZVN0YXRlJHJldGVudGlvbjM7XG5cbiAgcmV0dXJuIChfc3RvcmVTdGF0ZSRyZXRlbnRpb24zID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJHJldGVudGlvbjMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJHJldGVudGlvbjMgOiBlbXB0eVNldCQxO1xufVxuXG5mdW5jdGlvbiB6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSkge1xuICBjb25zdCByZXRhaW5lZEJ5ID0gZ2V0Tm9kZSQzKG5vZGUpLnJldGFpbmVkQnk7XG5cbiAgaWYgKHJldGFpbmVkQnkgPT09IHVuZGVmaW5lZCB8fCByZXRhaW5lZEJ5ID09PSAnY29tcG9uZW50cycgfHwgcmV0YWluZWRCeSA9PT0gJ3JlY29pbFJvb3QnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKHJldGFpbmVkQnkgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDIpIHtcbiAgICByZXR1cm4gW3JldGFpbmVkQnldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXRhaW5lZEJ5OyAvLyBpdCdzIGFuIGFycmF5IG9mIHpvbmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVPclBlcmZvcm1Qb3NzaWJsZVJlbGVhc2VPZlJldGFpbmFibGUoc3RvcmUsIHJldGFpbmFibGUpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xuICAgIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlLmFkZChyZXRhaW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICByZWxlYXNlUmV0YWluYWJsZXNOb3dPbkN1cnJlbnRUcmVlKHN0b3JlLCBuZXcgU2V0KFtyZXRhaW5hYmxlXSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJldGFpbkNvdW50KHN0b3JlLCByZXRhaW5hYmxlLCBkZWx0YSkge1xuICB2YXIgX21hcCRnZXQ7XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbWFwID0gc3RvcmUuZ2V0U3RhdGUoKS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzO1xuICBjb25zdCBuZXdDb3VudCA9ICgoX21hcCRnZXQgPSBtYXAuZ2V0KHJldGFpbmFibGUpKSAhPT0gbnVsbCAmJiBfbWFwJGdldCAhPT0gdm9pZCAwID8gX21hcCRnZXQgOiAwKSArIGRlbHRhO1xuXG4gIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHN0b3JlLCByZXRhaW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBtYXAuc2V0KHJldGFpbmFibGUsIG5ld0NvdW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyhzdG9yZSwgcmV0YWluYWJsZSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXAgPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHM7XG4gIG1hcC5kZWxldGUocmV0YWluYWJsZSk7XG4gIHNjaGVkdWxlT3JQZXJmb3JtUG9zc2libGVSZWxlYXNlT2ZSZXRhaW5hYmxlKHN0b3JlLCByZXRhaW5hYmxlKTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93KHN0b3JlKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgcmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZShzdG9yZSwgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UpO1xuICBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZS5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQocikge1xuICAvLyBUaGUgZGVmYXVsdCB3aWxsIGNoYW5nZSBmcm9tICdyZWNvaWxSb290JyB0byAnY29tcG9uZW50cycgaW4gdGhlIGZ1dHVyZS5cbiAgcmV0dXJuIHIgPT09IHVuZGVmaW5lZCA/ICdyZWNvaWxSb290JyA6IHI7XG59XG5cbnZhciBSZWNvaWxfUmV0ZW50aW9uID0ge1xuICBTVVNQRU5TRV9USU1FT1VUX01TLFxuICB1cGRhdGVSZXRhaW5Db3VudCxcbiAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8sXG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyxcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xufSA9IHJlYWN0RG9tO1xuXG52YXIgUmVhY3RCYXRjaGVkVXBkYXRlcyA9IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn0gPSBSZWFjdEJhdGNoZWRVcGRhdGVzOyAvLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMgPSB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuY29uc3Qge1xuICBiYXRjaFN0YXJ0OiBiYXRjaFN0YXJ0JDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDJcbn0gPSBSZWNvaWxfUmVhY3RCYXRjaGVkVXBkYXRlcztcblxubGV0IGJhdGNoZXIgPSB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQyOyAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG4vKipcbiAqIFNldHMgdGhlIHByb3ZpZGVkIGJhdGNoZXIgZnVuY3Rpb24gYXMgdGhlIGJhdGNoZXIgZnVuY3Rpb24gdXNlZCBieSBSZWNvaWwuXG4gKlxuICogU2V0IHRoZSBiYXRjaGVyIHRvIGEgY3VzdG9tIGJhdGNoZXIgZm9yIHlvdXIgcmVuZGVyZXIsXG4gKiBpZiB5b3UgdXNlIGEgcmVuZGVyZXIgb3RoZXIgdGhhbiBSZWFjdCBET00gb3IgUmVhY3QgTmF0aXZlLlxuICovXG5jb25zdCBzZXRCYXRjaGVyID0gbmV3QmF0Y2hlciA9PiB7XG4gIGJhdGNoZXIgPSBuZXdCYXRjaGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XG4vKipcbiAqIENhbGxzIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24gYW5kIHBhc3NlcyB0aGVcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgYmF0Y2hVcGRhdGVzID0gY2FsbGJhY2sgPT4ge1xuICBiYXRjaGVyKCgpID0+IHtcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGJhdGNoRW5kKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBSZWNvaWxfQmF0Y2hpbmcgPSB7XG4gIGdldEJhdGNoZXIsXG4gIHNldEJhdGNoZXIsXG4gIGJhdGNoVXBkYXRlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgSXRlcmFibGVzIGludG8gYSBzaW5nbGUgSXRlcmFibGUuXG4gKiBUcmF2ZXJzZXMgdGhlIGlucHV0IEl0ZXJhYmxlcyBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYW5kIG1haW50YWlucyB0aGUgb3JkZXJcbiAqIG9mIHRoZWlyIGVsZW1lbnRzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIGNvbnN0IHIgPSBBcnJheS5mcm9tKGNvbmNhdEl0ZXJhYmxlcyhbJ2EnLCAnYiddLCBbJ2MnXSwgWydkJywgJ2UnLCAnZiddKSk7XG4gKiByID09IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXTtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uKiBjb25jYXRJdGVyYWJsZXMoaXRlcnMpIHtcbiAgZm9yIChjb25zdCBpdGVyIG9mIGl0ZXJzKSB7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgaXRlcikge1xuICAgICAgeWllbGQgdmFsO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyA9IGNvbmNhdEl0ZXJhYmxlcztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbmNvbnN0IGlzU1NSID0gLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XG50eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8qIGVzbGludC1lbmFibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuY29uc3QgaXNXaW5kb3cgPSB2YWx1ZSA9PiAhaXNTU1IgJiYgKCAvLyAkRmxvd0ZpeE1lKHNpdGU9cmVjb2lsKSBXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIEZsb3dUeXBlIGRlZmluaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzY3MDlcbnZhbHVlID09PSB3aW5kb3cgfHwgdmFsdWUgaW5zdGFuY2VvZiBXaW5kb3cpO1xuXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3R5cGVvZi11bmRlZmluZWRcblxudmFyIFJlY29pbF9FbnZpcm9ubWVudCA9IHtcbiAgaXNTU1IsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzV2luZG93XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXG4gKiBoYXNoRnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBjYWNoZTtcblxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfTtcblxuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cbi8qKlxuICogQ2FjaGVzIGEgZnVuY3Rpb24ncyByZXN1bHRzIGJhc2VkIG9uIGEgY29tcGFyaXNvbiBvZiB0aGUgYXJndW1lbnRzLlxuICogT25seSBjYWNoZXMgdGhlIGxhc3QgcmV0dXJuIG9mIHRoZSBmdW5jdGlvbi5cbiAqIERlZmF1bHRzIHRvIHJlZmVyZW5jZSBlcXVhbGl0eVxuICovXG5cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBsYXN0S2V5O1xuICBsZXQgbGFzdFJlc3VsdDsgLy8gYnJlYWtpbmcgY2FjaGUgd2hlbiBhcmd1bWVudHMgY2hhbmdlXG5cbiAgY29uc3QgbWVtb2l6ZWRGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGFzaEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXG4gICAgaWYgKGxhc3RLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdEtleSA9IGtleTtcbiAgICBsYXN0UmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIG1lbW9pemVkRm47XG59XG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiBhIGNvbXBhcmlzb24gb2YgdGhlIGFyZ3VtZW50cy5cbiAqIE9ubHkgY2FjaGVzIHRoZSBsYXN0IHJldHVybiBvZiB0aGUgZnVuY3Rpb24uXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24oZm4sIGhhc2hGdW5jdGlvbikge1xuICBsZXQgbGFzdEtleTtcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuXG4gIGNvbnN0IG1lbW9pemVkRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmIChsYXN0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgbGFzdFJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGludmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgbGFzdEtleSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFttZW1vaXplZEZuLCBpbnZhbGlkYXRlXTtcbn1cblxudmFyIFJlY29pbF9NZW1vaXplID0ge1xuICBtZW1vaXplV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoLFxuICBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uXG59O1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDFcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDEsXG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ3JhcGg6IGdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDFcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBERUZBVUxUX1ZBTFVFOiBERUZBVUxUX1ZBTFVFJDEsXG4gIHJlY29pbFZhbHVlczogcmVjb2lsVmFsdWVzJDEsXG4gIHJlY29pbFZhbHVlc0ZvcktleXM6IHJlY29pbFZhbHVlc0ZvcktleXMkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMixcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMSxcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDEsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1cGRhdGVSZXRhaW5Db3VudDogdXBkYXRlUmV0YWluQ291bnQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgc2V0SW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMixcbiAgbWFrZUVtcHR5U3RvcmVTdGF0ZTogbWFrZUVtcHR5U3RvcmVTdGF0ZSQxXG59ID0gUmVjb2lsX1N0YXRlO1xuXG5cblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbjogbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvbiQxXG59ID0gUmVjb2lsX01lbW9pemU7XG5cblxuXG4gLy8gT3BhcXVlIGF0IHRoaXMgc3VyZmFjZSBiZWNhdXNlIGl0J3MgcGFydCBvZiB0aGUgcHVibGljIEFQSSBmcm9tIGhlcmUuXG5cblxuY29uc3QgcmV0YWluV2FybmluZyA9IGBcblJlY29pbCBTbmFwc2hvdHMgb25seSBsYXN0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGxiYWNrIHRoZXkgYXJlIHByb3ZpZGVkIHRvLiBUbyBrZWVwIGEgU25hcHNob3QgbG9uZ2VyLCBkbyB0aGlzOlxuXG4gIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1NvbWV0aGluZ1dpdGhTbmFwc2hvdChzbmFwc2hvdCk7XG4gIH0gZmluYWxseSB7XG4gICAgcmVsZWFzZSgpO1xuICB9XG5cblRoaXMgaXMgY3VycmVudGx5IGEgREVWLW9ubHkgd2FybmluZyBidXQgd2lsbCBiZWNvbWUgYSB0aHJvd24gZXhjZXB0aW9uIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgUmVjb2lsLlxuYDsgLy8gQSBcIlNuYXBzaG90XCIgaXMgXCJyZWFkLW9ubHlcIiBhbmQgY2FwdHVyZXMgYSBzcGVjaWZpYyBzZXQgb2YgdmFsdWVzIG9mIGF0b21zLlxuLy8gSG93ZXZlciwgdGhlIGRhdGEtZmxvdy1ncmFwaCBhbmQgc2VsZWN0b3IgdmFsdWVzIG1heSBldm9sdmUgYXMgc2VsZWN0b3Jcbi8vIGV2YWx1YXRpb24gZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBhbmQgYXN5bmMgc2VsZWN0b3JzIHJlc29sdmUuXG5cbmNsYXNzIFNuYXBzaG90IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby11bmluaXRpYWxpemVkLXByb3BlcnRpZXNcbiAgY29uc3RydWN0b3Ioc3RvcmVTdGF0ZSwgcGFyZW50U3RvcmVJRCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlZkNvdW50XCIsIDEpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TG9hZGFibGVcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEodGhpcy5fc3RvcmUsIHJlY29pbFZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFByb21pc2VcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXROb2Rlc19VTlNUQUJMRVwiLCBvcHQgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7IC8vIFRPRE8gRGVhbCB3aXRoIG1vZGlmaWVkIHNlbGVjdG9yc1xuXG4gICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc01vZGlmaWVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgcmV0dXJuIHJlY29pbFZhbHVlc0ZvcktleXMkMihzdGF0ZS5kaXJ0eUF0b21zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga25vd25BdG9tcyA9IHRoaXMuX3N0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcztcblxuICAgICAgY29uc3Qga25vd25TZWxlY3RvcnMgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duU2VsZWN0b3JzO1xuXG4gICAgICByZXR1cm4gKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5pc0luaXRpYWxpemVkKSA9PSBudWxsID8gcmVjb2lsVmFsdWVzJDEudmFsdWVzKCkgOiBvcHQuaXNJbml0aWFsaXplZCA9PT0gdHJ1ZSA/IHJlY29pbFZhbHVlc0ZvcktleXMkMihSZWNvaWxfY29uY2F0SXRlcmFibGVzKFtrbm93bkF0b21zLCBrbm93blNlbGVjdG9yc10pKSA6IFJlY29pbF9maWx0ZXJJdGVyYWJsZShyZWNvaWxWYWx1ZXMkMS52YWx1ZXMoKSwgKHtcbiAgICAgICAga2V5XG4gICAgICB9KSA9PiAha25vd25BdG9tcy5oYXMoa2V5KSAmJiAha25vd25TZWxlY3RvcnMuaGFzKGtleSkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SW5mb19VTlNUQUJMRVwiLCAoe1xuICAgICAga2V5XG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICByZXR1cm4gcGVla05vZGVJbmZvJDEodGhpcy5fc3RvcmUsIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwgbWFwcGVyID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3QgbXV0YWJsZVNuYXBzaG90ID0gbmV3IE11dGFibGVTbmFwc2hvdCh0aGlzLCBiYXRjaFVwZGF0ZXMkMSk7XG4gICAgICBtYXBwZXIobXV0YWJsZVNuYXBzaG90KTsgLy8gaWYgcmVtb3ZpbmcgYmF0Y2hVcGRhdGVzIGZyb20gYHNldGAgYWRkIGl0IGhlcmVcblxuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTWFwXCIsIGFzeW5jIG1hcHBlciA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IG11dGFibGVTbmFwc2hvdCA9IG5ldyBNdXRhYmxlU25hcHNob3QodGhpcywgYmF0Y2hVcGRhdGVzJDEpO1xuICAgICAgbXV0YWJsZVNuYXBzaG90LnJldGFpbigpOyAvLyBSZXRhaW4gbmV3IHNuYXBzaG90IGR1cmluZyBhc3luYyBtYXBwZXJcblxuICAgICAgYXdhaXQgbWFwcGVyKG11dGFibGVTbmFwc2hvdCk7IC8vIENvbnRpbnVlIHRvIHJldGFpbiB0aGUgbmV3IHNuYXBzaG90IGZvciB0aGUgdXNlciwgYnV0IGF1dG8tcmVsZWFzZSBpdFxuICAgICAgLy8gYWZ0ZXIgdGhlIG5leHQgdGljaywgdGhlIHNhbWUgYXMgYSBuZXcgc3luY2hyb25vdXMgc25hcHNob3QuXG5cbiAgICAgIG11dGFibGVTbmFwc2hvdC5hdXRvUmVsZWFzZV9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIG11dGFibGVTbmFwc2hvdDtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0b3JlID0ge1xuICAgICAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMSgpLFxuICAgICAgcGFyZW50U3RvcmVJRCxcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdG9yZVN0YXRlLFxuICAgICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlciA9PiB7XG4gICAgICAgIC8vIG5vIGJhdGNoaW5nLCBzbyBuZXh0VHJlZSBpcyBuZXZlciBhY3RpdmVcbiAgICAgICAgc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA9IHJlcGxhY2VyKHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoOiB2ZXJzaW9uID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhzID0gc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb247XG5cbiAgICAgICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3MoZ3JhcGhzLmdldCh2ZXJzaW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDEoKTtcbiAgICAgICAgZ3JhcGhzLnNldCh2ZXJzaW9uLCBuZXdHcmFwaCk7XG4gICAgICAgIHJldHVybiBuZXdHcmFwaDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogKCkgPT4gKHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge31cbiAgICAgIH0pLFxuICAgICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdDYW5ub3Qgc3Vic2NyaWJlIHRvIFNuYXBzaG90cycpO1xuICAgICAgfVxuICAgIH07IC8vIEluaXRpYWxpemUgYW55IG5vZGVzIHRoYXQgYXJlIGxpdmUgaW4gdGhlIHBhcmVudCBzdG9yZSAocHJpbWFyaWx5IHNvIHRoYXRcbiAgICAvLyB0aGlzIHNuYXBzaG90IGdldHMgY291bnRlZCB0b3dhcmRzIHRoZSBub2RlJ3MgbGl2ZSBzdG9yZXMgY291bnQpLlxuICAgIC8vIFRPRE8gT3B0aW1pemUgdGhpcyB3aGVuIGNsb25pbmcgc25hcHNob3RzIGZvciBjYWxsYmFja3NcblxuICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDEodGhpcy5fc3RvcmUsIG5vZGVLZXksICdnZXQnKTtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEodGhpcy5fc3RvcmUsIG5vZGVLZXksIDEpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcbiAgfVxuXG4gIHJldGFpbigpIHtcbiAgICBpZiAodGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTbmFwc2hvdCBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlbXB0IHRvIHJldGFpbigpIFNuYXBzaG90IHRoYXQgd2FzIGFscmVhZHkgcmVsZWFzZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmQ291bnQrKztcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZWxlYXNlZCkge1xuICAgICAgICByZWxlYXNlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIHNuYXBzaG90IG9uIHRoZSBuZXh0IHRpY2suICBUaGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBpcyByZXRhaW5lZFxuICAgKiBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2luZyBpdC5cbiAgICovXG5cblxuICBhdXRvUmVsZWFzZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAoIWlzU1NSJDEpIHtcbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcmVsZWFzZSgpLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgX3JlbGVhc2UoKSB7XG4gICAgdGhpcy5fcmVmQ291bnQtLTtcblxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcblxuICAgICAgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUZW1wb3JhcmlseSBuZXJmaW5nIHRoaXMgdG8gYWxsb3cgdXMgdG8gZmluZCBicm9rZW4gY2FsbCBzaXRlcyB3aXRob3V0XG4gICAgICAvLyBhY3R1YWxseSBicmVha2luZyBhbnlib2R5IHlldC5cbiAgICAgIC8vIGZvciAoY29uc3QgayBvZiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgIC8vICAgdXBkYXRlUmV0YWluQ291bnRUb1plcm8odGhpcy5fc3RvcmUsIGspO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZWZDb3VudCA8IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdTbmFwc2hvdCByZWxlYXNlZCBhbiBleHRyYSB0aW1lLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmV0YWluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50ID4gMDtcbiAgfVxuXG4gIGNoZWNrUmVmQ291bnRfSU5URVJOQUwoKSB7XG4gICAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgJiYgdGhpcy5fcmVmQ291bnQgPD0gMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24ocmV0YWluV2FybmluZyk7XG4gICAgICB9IC8vIFdoYXQgd2Ugd2lsbCBzaGlwIGxhdGVyOlxuICAgICAgLy8gdGhyb3cgZXJyKHJldGFpbldhcm5pbmcpO1xuXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RvcmVfSU5URVJOQUwoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlO1xuICB9XG5cbiAgZ2V0SUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUuc3RhdGVJRDtcbiAgfVxuXG4gIGdldFN0b3JlSUQoKSB7XG4gICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnN0b3JlSUQ7XG4gIH0gLy8gV2Ugd2FudCB0byBhbGxvdyB0aGUgbWV0aG9kcyB0byBiZSBkZXN0cnVjdHVyZWQgYW5kIHVzZWQgYXMgYWNjZXNzb3JzXG5cbiAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyICovXG5cbiAgLyogZXNsaW50LWVuYWJsZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXIgKi9cblxuXG59XG5cbmZ1bmN0aW9uIGNsb25lU3RvcmVTdGF0ZShzdG9yZSwgdHJlZVN0YXRlLCBidW1wVmVyc2lvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB2ZXJzaW9uID0gYnVtcFZlcnNpb24gPyBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQyKCkgOiB0cmVlU3RhdGUudmVyc2lvbjtcbiAgcmV0dXJuIHtcbiAgICAvLyBBbHdheXMgY2xvbmUgdGhlIFRyZWVTdGF0ZSB0byBpc29sYXRlIHN0b3JlcyBmcm9tIGFjY2lkZW50YWwgbXV0YXRpb25zLlxuICAgIC8vIEZvciBleGFtcGxlLCByZWFkaW5nIGEgc2VsZWN0b3IgZnJvbSBhIGNsb25lZCBzbmFwc2hvdCBzaG91bGRuJ3QgY2FjaGVcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgdHJlZXN0YXRlIHdoaWNoIG1heSBjYXVzZSB0aGUgb3JpZ2luYWwgdG8gc2tpcFxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9mIHVwc3RyZWFtIGF0b21zLlxuICAgIGN1cnJlbnRUcmVlOiB7XG4gICAgICAvLyBUT0RPIHNuYXBzaG90cyBzaG91bGRuJ3QgcmVhbGx5IGhhdmUgdmVyc2lvbnMgYmVjYXVzZSBhIG5ldyB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gaXMgYWx3YXlzIGFzc2lnbmVkIHdoZW4gdGhlIHNuYXBzaG90IGlzIGdvbmUgdG8uXG4gICAgICB2ZXJzaW9uOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUudmVyc2lvbixcbiAgICAgIHN0YXRlSUQ6IGJ1bXBWZXJzaW9uID8gdmVyc2lvbiA6IHRyZWVTdGF0ZS5zdGF0ZUlELFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi50cmVlU3RhdGUudHJhbnNhY3Rpb25NZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQodHJlZVN0YXRlLmRpcnR5QXRvbXMpLFxuICAgICAgYXRvbVZhbHVlczogdHJlZVN0YXRlLmF0b21WYWx1ZXMuY2xvbmUoKSxcbiAgICAgIG5vbnZhbGlkYXRlZEF0b21zOiB0cmVlU3RhdGUubm9udmFsaWRhdGVkQXRvbXMuY2xvbmUoKVxuICAgIH0sXG4gICAgY29tbWl0RGVwdGg6IDAsXG4gICAgbmV4dFRyZWU6IG51bGwsXG4gICAgcHJldmlvdXNUcmVlOiBudWxsLFxuICAgIGtub3duQXRvbXM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93bkF0b21zKSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAga25vd25TZWxlY3RvcnM6IG5ldyBTZXQoc3RvcmVTdGF0ZS5rbm93blNlbGVjdG9ycyksXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgcXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQ6IFtdLFxuICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVyczogbmV3IFNldCgpLFxuICAgIGdyYXBoc0J5VmVyc2lvbjogbmV3IE1hcCgpLnNldCh2ZXJzaW9uLCBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbikpLFxuICAgIHJldGVudGlvbjoge1xuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXG4gICAgICByZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICAvLyBDcmVhdGUgYmxhbmsgY2xlYW51cCBoYW5kbGVycyBmb3IgYXRvbXMgc28gc25hcHNob3RzIGRvbid0IHJlLXJ1blxuICAgIC8vIGF0b20gZWZmZWN0cy5cbiAgICBub2RlQ2xlYW51cEZ1bmN0aW9uczogbmV3IE1hcChSZWNvaWxfbWFwSXRlcmFibGUoc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5lbnRyaWVzKCksIChba2V5XSkgPT4gW2tleSwgKCkgPT4ge31dKSlcbiAgfTtcbn0gLy8gRmFjdG9yeSB0byBidWlsZCBhIGZyZXNoIHNuYXBzaG90XG5cblxuZnVuY3Rpb24gZnJlc2hTbmFwc2hvdChpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBuZXcgU25hcHNob3QobWFrZUVtcHR5U3RvcmVTdGF0ZSQxKCkpO1xuICByZXR1cm4gaW5pdGlhbGl6ZVN0YXRlICE9IG51bGwgPyBzbmFwc2hvdC5tYXAoaW5pdGlhbGl6ZVN0YXRlKSA6IHNuYXBzaG90O1xufSAvLyBGYWN0b3J5IHRvIGNsb25lIGEgc25hcHNob3Qgc3RhdGVcblxuXG5jb25zdCBbbWVtb2l6ZWRDbG9uZVNuYXBzaG90LCBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyXSA9IG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMSgoc3RvcmUsIHZlcnNpb24pID0+IHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSB2ZXJzaW9uID09PSAnbGF0ZXN0JyA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSk7XG4gIHJldHVybiBuZXcgU25hcHNob3QoY2xvbmVTdG9yZVN0YXRlKHN0b3JlLCB0cmVlU3RhdGUpLCBzdG9yZS5zdG9yZUlEKTtcbn0sIChzdG9yZSwgdmVyc2lvbikgPT4ge1xuICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUkcHJldmk7XG5cbiAgcmV0dXJuIFN0cmluZyh2ZXJzaW9uKSArIFN0cmluZyhzdG9yZS5zdG9yZUlEKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJG5leHRUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQudmVyc2lvbikgKyBTdHJpbmcoc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZS52ZXJzaW9uKSArIFN0cmluZygoX3N0b3JlJGdldFN0YXRlJHByZXZpID0gc3RvcmUuZ2V0U3RhdGUoKS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRwcmV2aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJHByZXZpLnZlcnNpb24pO1xufSk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5zZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxKGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDIpO1xuXG5mdW5jdGlvbiBjbG9uZVNuYXBzaG90KHN0b3JlLCB2ZXJzaW9uID0gJ2xhdGVzdCcpIHtcbiAgY29uc3Qgc25hcHNob3QgPSBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuXG4gIGlmICghc25hcHNob3QuaXNSZXRhaW5lZCgpKSB7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMigpO1xuICAgIHJldHVybiBtZW1vaXplZENsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24pO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuXG5jbGFzcyBNdXRhYmxlU25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdCB7XG4gIGNvbnN0cnVjdG9yKHNuYXBzaG90LCBiYXRjaCkge1xuICAgIHN1cGVyKGNsb25lU3RvcmVTdGF0ZShzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLCBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCkuY3VycmVudFRyZWUsIHRydWUpLCBzbmFwc2hvdC5nZXRTdG9yZUlEKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2JhdGNoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRcIiwgKHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcikgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gVGhpcyBiYXRjaFVwZGF0ZXMgZW5zdXJlcyB0aGlzIGBzZXRgIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHkgYW5kIHlvdSBjYW5cbiAgICAgIC8vIHJlYWQgdGhlIHdyaXR0ZW4gdmFsdWUgYWZ0ZXIgY2FsbGluZyBgc2V0YC4gSSB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzXG4gICAgICAvLyBiZWhhdmlvciBhbmQgb25seSBiYXRjaCBpbiBgU25hcHNob3QubWFwYCwgYnV0IHRoaXMgd291bGQgYmUgYSBicmVha2luZ1xuICAgICAgLy8gY2hhbmdlIHBvdGVudGlhbGx5LlxuXG4gICAgICB0aGlzLl9iYXRjaCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgMSk7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDEodGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpLCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFwiLCByZWNvaWxTdGF0ZSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXG5cbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMSh0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCksIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXNfREVQUkVDQVRFRFwiLCB2YWx1ZXMgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKTsgLy8gU2VlIG5vdGUgYXQgYHNldGAgYWJvdXQgYmF0Y2hlZCB1cGRhdGVzLlxuXG4gICAgICBiYXRjaFVwZGF0ZXMkMSgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCBrLCAxKTtcbiAgICAgICAgICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDIoayksIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JhdGNoID0gYmF0Y2g7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX1NuYXBzaG90ID0ge1xuICBTbmFwc2hvdCxcbiAgTXV0YWJsZVNuYXBzaG90LFxuICBmcmVzaFNuYXBzaG90LFxuICBjbG9uZVNuYXBzaG90XG59O1xuXG52YXIgUmVjb2lsX1NuYXBzaG90XzEgPSBSZWNvaWxfU25hcHNob3QuU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzIgPSBSZWNvaWxfU25hcHNob3QuTXV0YWJsZVNuYXBzaG90O1xudmFyIFJlY29pbF9TbmFwc2hvdF8zID0gUmVjb2lsX1NuYXBzaG90LmZyZXNoU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzQgPSBSZWNvaWxfU25hcHNob3QuY2xvbmVTbmFwc2hvdDtcblxudmFyIFJlY29pbF9TbmFwc2hvdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMSxcbiAgTXV0YWJsZVNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMixcbiAgZnJlc2hTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzMsXG4gIGNsb25lU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF80XG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gdW5pb25TZXRzKC4uLnNldHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3Qgc2V0IG9mIHNldHMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF91bmlvblNldHMgPSB1bmlvblNldHM7XG5cbmNvbnN0IHtcbiAgdXNlUmVmXG59ID0gcmVhY3Q7XG4vKipcbiAqIFRoZSBzYW1lIGFzIGB1c2VSZWYoKWAgZXhjZXB0IHRoYXQgaWYgYSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgdGhlbiBpdCB3aWxsXG4gKiBjYWxsIHRoYXQgZnVuY3Rpb24gdG8gZ2V0IHRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSByZWZlcmVuY2Ugd2l0aC5cbiAqIFRoaXMgaXMgc2ltaWxhciB0byBob3cgYHVzZVN0YXRlKClgIGJlaGF2ZXMgd2hlbiBnaXZlbiBhIGZ1bmN0aW9uLiAgSXQgYWxsb3dzXG4gKiB0aGUgdXNlciB0byBhdm9pZCBnZW5lcmF0aW5nIHRoZSBpbml0aWFsIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB0byBzZXQgdGhlIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIGl0c2VsZiB5b3UgbmVlZCB0b1xuICogbmVzdCBpdDogdXNlUmVmSW5pdE9uY2UoKCkgPT4gKCkgPT4gey4uLn0pO1xuICovXG5cblxuZnVuY3Rpb24gdXNlUmVmSW5pdE9uY2UoaW5pdGlhbFZhbHVlKSB7XG4gIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cbiAgY29uc3QgcmVmID0gdXNlUmVmKGluaXRpYWxWYWx1ZSk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSBpbml0aWFsVmFsdWUgJiYgdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtdXNlXVxuICAgIHJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gcmVmO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlZkluaXRPbmNlID0gdXNlUmVmSW5pdE9uY2U7XG5cbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWx1c2FnZWxvZ0V2ZW50ID0gcmVxdWlyZSgnUmVjb2lsdXNhZ2Vsb2dFdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudCA9IHJlcXVpcmUoJ1JlY29pbFVzYWdlTG9nRmFsY29FdmVudCcpO1xuLy8gQGZiLW9ubHk6IGNvbnN0IFVSSSA9IHJlcXVpcmUoJ1VSSScpO1xuXG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGU6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMlxufSA9IFJlY29pbF9TdGF0ZTtcblxuY29uc3Qge1xuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMixcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMixcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDIsXG4gIHNldE5vZGVWYWx1ZTogc2V0Tm9kZVZhbHVlJDIsXG4gIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQ6IHNldFVudmFsaWRhdGVkQXRvbVZhbHVlX0RFUFJFQ0FURUQkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBncmFwaDogZ3JhcGgkMlxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBjbG9uZUdyYXBoOiBjbG9uZUdyYXBoJDFcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDJcbn0gPSBSZWNvaWxfS2V5cztcblxuY29uc3Qge1xuICBjcmVhdGVNdXRhYmxlU291cmNlOiBjcmVhdGVNdXRhYmxlU291cmNlJDEsXG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIGFwcGx5QXRvbVZhbHVlV3JpdGVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdzogcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5cblxuY29uc3Qge1xuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWY6IHVzZVJlZiQxLFxuICB1c2VTdGF0ZVxufSA9IHJlYWN0O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gbm90SW5BQ29udGV4dCgpIHtcbiAgdGhyb3cgUmVjb2lsX2VycignVGhpcyBjb21wb25lbnQgbXVzdCBiZSB1c2VkIGluc2lkZSBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG59XG5cbmNvbnN0IGRlZmF1bHRTdG9yZSA9IE9iamVjdC5mcmVlemUoe1xuICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gIGdldFN0YXRlOiBub3RJbkFDb250ZXh0LFxuICByZXBsYWNlU3RhdGU6IG5vdEluQUNvbnRleHQsXG4gIGdldEdyYXBoOiBub3RJbkFDb250ZXh0LFxuICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9uczogbm90SW5BQ29udGV4dCxcbiAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YTogbm90SW5BQ29udGV4dFxufSk7XG5sZXQgc3RhdGVSZXBsYWNlcklzQmVpbmdFeGVjdXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmUpIHtcbiAgaWYgKHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdBbiBhdG9tIHVwZGF0ZSB3YXMgdHJpZ2dlcmVkIHdpdGhpbiB0aGUgZXhlY3V0aW9uIG9mIGEgc3RhdGUgdXBkYXRlciBmdW5jdGlvbi4gU3RhdGUgdXBkYXRlciBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gUmVjb2lsIG11c3QgYmUgcHVyZSBmdW5jdGlvbnMuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSA9PT0gbnVsbCkge1xuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpICYmIFJlY29pbF9na3goJ3JlY29pbF9yZWxlYXNlX29uX2Nhc2NhZGluZ191cGRhdGVfa2lsbHN3aXRjaF8yMDIxJykpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjYXNjYWRpbmcgdXBkYXRlICh0aGF0IGlzLCByZW5kZXJpbmcgZHVlIHRvIG9uZSBzdGF0ZSBjaGFuZ2VcbiAgICAgIC8vIGludm9rZXMgYSBzZWNvbmQgc3RhdGUgY2hhbmdlKSwgd2Ugd29uJ3QgaGF2ZSBjbGVhbmVkIHVwIHJldGFpbmFibGVzIHlldFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vcm1hbGx5IGhhcHBlbnMgYWZ0ZXIgbm90aWZ5aW5nIGNvbXBvbmVudHMuIERvIGl0IGJlZm9yZVxuICAgICAgLy8gcHJvY2VlZGluZyB3aXRoIHRoZSBjYXNjYWRpbmcgdXBkYXRlIHNvIHRoYXQgaXQgcmVtYWlucyBwcmVkaWN0YWJsZTpcbiAgICAgIGlmIChzdG9yZVN0YXRlLmNvbW1pdERlcHRoID4gMCkge1xuICAgICAgICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3ckMShzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbjtcbiAgICBjb25zdCBuZXh0VmVyc2lvbiA9IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDMoKTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0geyAuLi5zdG9yZVN0YXRlLmN1cnJlbnRUcmVlLFxuICAgICAgdmVyc2lvbjogbmV4dFZlcnNpb24sXG4gICAgICBzdGF0ZUlEOiBuZXh0VmVyc2lvbixcbiAgICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoKSxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9XG4gICAgfTtcbiAgICBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5zZXQobmV4dFZlcnNpb24sIGNsb25lR3JhcGgkMShSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodmVyc2lvbikpKSk7XG4gIH1cbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBjdXJyZW50OiBkZWZhdWx0U3RvcmVcbn0pO1xuXG5jb25zdCB1c2VTdG9yZVJlZiA9ICgpID0+IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7IC8vICRGbG93RXhwZWN0ZWRFcnJvcltpbmNvbXBhdGlibGUtY2FsbF1cblxuXG5jb25zdCBNdXRhYmxlU291cmNlQ29udGV4dCA9IHJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbE11dGFibGVTb3VyY2UoKSB7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VDb250ZXh0KE11dGFibGVTb3VyY2VDb250ZXh0KTtcblxuICBpZiAobXV0YWJsZVNvdXJjZSA9PSBudWxsKSB7XG4gICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKCdBdHRlbXB0ZWQgdG8gdXNlIGEgUmVjb2lsIGhvb2sgb3V0c2lkZSBvZiBhIDxSZWNvaWxSb290Pi4gJyArICc8UmVjb2lsUm9vdD4gbXVzdCBiZSBhbiBhbmNlc3RvciBvZiBhbnkgY29tcG9uZW50IHRoYXQgdXNlcyAnICsgJ1JlY29pbCBob29rcy4nKTtcbiAgfVxuXG4gIHJldHVybiBtdXRhYmxlU291cmNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnlDb21wb25lbnRzKHN0b3JlLCBzdG9yZVN0YXRlLCB0cmVlU3RhdGUpIHtcbiAgY29uc3QgZGVwZW5kZW50Tm9kZXMgPSBnZXREb3duc3RyZWFtTm9kZXMkMihzdG9yZSwgdHJlZVN0YXRlLCB0cmVlU3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZGVwZW5kZW50Tm9kZXMpIHtcbiAgICBjb25zdCBjb21wcyA9IHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgIGlmIChjb21wcykge1xuICAgICAgZm9yIChjb25zdCBbX3N1YklELCBbX2RlYnVnTmFtZSwgY2FsbGJhY2tdXSBvZiBjb21wcykge1xuICAgICAgICBjYWxsYmFjayh0cmVlU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7IC8vIEluZm9ybSB0cmFuc2FjdGlvbiBzdWJzY3JpYmVycyBvZiB0aGUgdHJhbnNhY3Rpb246XG5cbiAgY29uc3QgZGlydHlBdG9tcyA9IHRyZWVTdGF0ZS5kaXJ0eUF0b21zO1xuXG4gIGlmIChkaXJ0eUF0b21zLnNpemUpIHtcbiAgICAvLyBFeGVjdXRlIE5vZGUtc3BlY2lmaWMgc3Vic2NyaWJlcnMgYmVmb3JlIGdsb2JhbCBzdWJzY3JpYmVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgc3Vic2NyaXB0aW9uc10gb2Ygc3RvcmVTdGF0ZS5ub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAoZGlydHlBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtfLCBzdWJzY3JpcHRpb25dIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiBzdG9yZVN0YXRlLnRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xuICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlYWN0TW9kZSQyKCkuZWFybHkgfHwgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIE5vdGlmeWluZyBjb21wb25lbnRzIGlzIG5lZWRlZCB0byB3YWtlIGZyb20gc3VzcGVuc2UsIGV2ZW4gd2hlbiB1c2luZ1xuICAgICAgLy8gZWFybHkgcmVuZGVyaW5nLlxuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZSwgc3RvcmVTdGF0ZSwgdHJlZVN0YXRlKTsgLy8gV2FrZSBhbGwgc3VzcGVuZGVkIGNvbXBvbmVudHMgc28gdGhlIHJpZ2h0IG9uZShzKSBjYW4gdHJ5IHRvIHJlLXJlbmRlci5cbiAgICAgIC8vIFdlIG5lZWQgdG8gd2FrZSB1cCBjb21wb25lbnRzIG5vdCBqdXN0IHdoZW4gc29tZSBhc3luY2hyb25vdXMgc2VsZWN0b3JcbiAgICAgIC8vIHJlc29sdmVkLCBidXQgYWxzbyB3aGVuIGNoYW5naW5nIHN5bmNocm9ub3VzIHZhbHVlcyBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlXG4gICAgICAvLyBhIHNlbGVjdG9yIHRvIGNoYW5nZSBmcm9tIGFzeW5jaHJvbm91cyB0byBzeW5jaHJvbm91cywgaW4gd2hpY2ggY2FzZSB0aGVyZVxuICAgICAgLy8gd291bGQgYmUgbm8gZm9sbG93LXVwIGFzeW5jaHJvbm91cyByZXNvbHV0aW9uIHRvIHdha2UgdXMgdXAuXG4gICAgICAvLyBUT0RPIE9QVElNSVpBVElPTiBPbmx5IHdha2UgdXAgcmVsYXRlZCBkb3duc3RyZWFtIGNvbXBvbmVudHNcblxuICAgICAgc3RvcmVTdGF0ZS5zdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnMuZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICAgIHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9IC8vIFNwZWNpYWwgYmVoYXZpb3IgT05MWSBpbnZva2VkIGJ5IHVzZUludGVyZmFjZS5cbiAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG5cbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5mb3JFYWNoKGNiID0+IGNiKHRyZWVTdGF0ZSkpO1xuICBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnNwbGljZSgwLCBzdG9yZVN0YXRlLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZEJhdGNoKHN0b3JlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoKys7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0VHJlZVxuICAgIH0gPSBzdG9yZVN0YXRlOyAvLyBJZ25vcmUgY29tbWl0cyB0aGF0IGFyZSBub3QgYmVjYXVzZSBvZiBSZWNvaWwgdHJhbnNhY3Rpb25zIC0tIG5hbWVseSxcbiAgICAvLyBiZWNhdXNlIHNvbWV0aGluZyBhYm92ZSBSZWNvaWxSb290IHJlLXJlbmRlcmVkOlxuXG4gICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5leHRUcmVlIGlzIG5vdyBjb21taXR0ZWQgLS0gbm90ZSB0aGF0IGNvcHlpbmcgYW5kIHJlc2V0IG9jY3VycyB3aGVuXG4gICAgLy8gYSB0cmFuc2FjdGlvbiBiZWdpbnMsIGluIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZDpcblxuXG4gICAgc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHN0b3JlU3RhdGUuY3VycmVudFRyZWUgPSBuZXh0VHJlZTtcbiAgICBzdG9yZVN0YXRlLm5leHRUcmVlID0gbnVsbDtcbiAgICBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnMoc3RvcmUpO1xuXG4gICAgaWYgKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlICE9IG51bGwpIHtcbiAgICAgIHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uLmRlbGV0ZShzdG9yZVN0YXRlLnByZXZpb3VzVHJlZS52ZXJzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdFbmRlZCBiYXRjaCB3aXRoIG5vIHByZXZpb3VzIHN0YXRlLCB3aGljaCBpcyB1bmV4cGVjdGVkJywgJ3JlY29pbCcpO1xuICAgIH1cblxuICAgIHN0b3JlU3RhdGUucHJldmlvdXNUcmVlID0gbnVsbDtcblxuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICAvLyBPbmx5IHJlbGVhc2UgcmV0YWluYWJsZXMgaWYgdGhlcmUgd2VyZSBubyB3cml0ZXMgZHVyaW5nIHRoZSBlbmQgb2YgdGhlXG4gICAgICAvLyBiYXRjaC4gIFRoaXMgYXZvaWRzIHJlbGVhc2luZyBzb21ldGhpbmcgd2UgbWlnaHQgYmUgYWJvdXQgdG8gdXNlLlxuICAgICAgaWYgKG5leHRUcmVlID09IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzdG9yZVN0YXRlLmNvbW1pdERlcHRoLS07XG4gIH1cbn1cbi8qXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgQmF0Y2hlciBpcyB0byBvYnNlcnZlIHdoZW4gUmVhY3QgYmF0Y2hlcyBlbmQgc28gdGhhdFxuICogUmVjb2lsIHN0YXRlIGNoYW5nZXMgY2FuIGJlIGJhdGNoZWQuIFdoZW5ldmVyIFJlY29pbCBzdGF0ZSBjaGFuZ2VzLCB3ZSBjYWxsXG4gKiBzZXRTdGF0ZSBvbiB0aGUgYmF0Y2hlci4gVGhlbiB3ZSB3YWl0IGZvciB0aGF0IGNoYW5nZSB0byBiZSBjb21taXR0ZWQsIHdoaWNoXG4gKiBzaWduaWZpZXMgdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoYXQncyB3aGVuIHdlIHJlc3BvbmQgdG8gdGhlIFJlY29pbCBjaGFuZ2UuXG4gKi9cblxuXG5mdW5jdGlvbiBCYXRjaGVyKHtcbiAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcbiAgY29uc3QgWywgc2V0U3RhdGVdID0gdXNlU3RhdGUoW10pO1xuICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTsgLy8gSWYgYW4gYXN5bmNocm9ub3VzIHNlbGVjdG9yIHJlc29sdmVzIGFmdGVyIHRoZSBCYXRjaGVyIGlzIHVubW91bnRlZCxcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2Ugd2lsbCBzdGlsbCBiZSBjYWxsZWQuIEFuIGVycm9yIGdldHMgdGhyb3duIHdoZW5ldmVyXG4gICAgLy8gc2V0U3RhdGUgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50IGlzIGFscmVhZHkgdW5tb3VudGVkLCBzbyB0aGlzIHNldHNcbiAgICAvLyBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgdG8gYmUgYSBuby1vcC5cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4ge30pO1xuICAgIH07XG4gIH0sIFtzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2VdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBlbnF1ZXVlRXhlY3V0aW9uIHJ1bnMgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseTsgaXQgaXMgb25seSB1c2VkIHRvXG4gICAgLy8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgb2YgdXNlRWZmZWN0cyBkdXJpbmcgdGVzdHMsIHNpbmNlIFJlYWN0IHNlZW1zIHRvXG4gICAgLy8gY2FsbCB1c2VFZmZlY3QgaW4gYW4gdW5wcmVkaWN0YWJsZSBvcmRlciBzb21ldGltZXMuXG4gICAgUmVjb2lsX1F1ZXVlLmVucXVldWVFeGVjdXRpb24oJ0JhdGNoZXInLCAoKSA9PiB7XG4gICAgICBlbmRCYXRjaChzdG9yZVJlZi5jdXJyZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcykge1xuICAgIHdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMgPSBbXTtcbiAgfVxufSAvLyBXaGVuIHJlbW92aW5nIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiwgcmVtb3ZlIHN0YXRlQnlTZXR0aW5nUmVjb2lsVmFsdWVcbi8vIHdoaWNoIHdpbGwgbm8gbG9uZ2VyIGJlIG5lZWRlZC5cblxuXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlLCBpbml0aWFsaXplU3RhdGUpIHtcbiAgY29uc3QgaW5pdGlhbCA9IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpO1xuICBpbml0aWFsaXplU3RhdGUoe1xuICAgIHNldDogKGF0b20sIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGluaXRpYWwuY3VycmVudFRyZWU7XG4gICAgICBjb25zdCB3cml0ZXMgPSBzZXROb2RlVmFsdWUkMihzdG9yZSwgc3RhdGUsIGF0b20ua2V5LCB2YWx1ZSk7XG4gICAgICBjb25zdCB3cml0dGVuTm9kZXMgPSBuZXcgU2V0KHdyaXRlcy5rZXlzKCkpO1xuICAgICAgY29uc3Qgbm9udmFsaWRhdGVkQXRvbXMgPSBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpO1xuXG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygd3JpdHRlbk5vZGVzKSB7XG4gICAgICAgIG5vbnZhbGlkYXRlZEF0b21zLmRlbGV0ZShuKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbC5jdXJyZW50VHJlZSA9IHsgLi4uc3RhdGUsXG4gICAgICAgIGRpcnR5QXRvbXM6IFJlY29pbF91bmlvblNldHMoc3RhdGUuZGlydHlBdG9tcywgd3JpdHRlbk5vZGVzKSxcbiAgICAgICAgYXRvbVZhbHVlczogYXBwbHlBdG9tVmFsdWVXcml0ZXMkMShzdGF0ZS5hdG9tVmFsdWVzLCB3cml0ZXMpLFxuICAgICAgICAvLyBOQjogUExFQVNFIHVuLWV4cG9ydCBhcHBseUF0b21WYWx1ZVdyaXRlcyB3aGVuIGRlbGV0aW5nIHRoaXMgY29kZVxuICAgICAgICBub252YWxpZGF0ZWRBdG9tc1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNldFVudmFsaWRhdGVkQXRvbVZhbHVlczogYXRvbVZhbHVlcyA9PiB7XG4gICAgICAvLyBGSVhNRSByZXBsYWNlIHRoaXMgd2l0aCBhIG11dGF0aXZlIGxvb3BcbiAgICAgIGF0b21WYWx1ZXMuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCQxKGluaXRpYWwuY3VycmVudFRyZWUsIGssIHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluaXRpYWw7XG59IC8vIEluaXRpYWxpemUgc3RhdGUgc25hcHNob3QgZm9yIDxSZWNvaWxSb290PiBmb3IgdGhlIGluaXRpYWxpemVTdGF0ZSBwcm9wLlxuLy8gQXRvbSBlZmZlY3QgaW5pdGlhbGl6YXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcHJvcC5cbi8vIEFueSBhdG9tIGVmZmVjdHMgd2lsbCBiZSBydW4gYmVmb3JlIGluaXRpYWxpemF0aW9uLCBidXQgdGhlbiBjbGVhbmVkIHVwLFxuLy8gdGhleSBhcmUgdGhlbiByZS1ydW4gd2hlbiB1c2VkIGFzIHBhcnQgb2YgcmVuZGVyaW5nLiAgVGhlc2Ugc2VtYW50aWNzIGFyZVxuLy8gY29tcGF0aWJsZSB3aXRoIFJlYWN0IFN0cmljdE1vZGUgd2hlcmUgZWZmZWN0cyBtYXkgYmUgcmUtcnVuIG11bHRpcGxlIHRpbWVzXG4vLyBidXQgc3RhdGUgaW5pdGlhbGl6YXRpb24gb25seSBoYXBwZW5zIG9uY2UgdGhlIGZpcnN0IHRpbWUuXG5cblxuZnVuY3Rpb24gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSB7XG4gIC8vIEluaXRpYWxpemUgYSBzbmFwc2hvdCBhbmQgZ2V0IGl0cyBzdG9yZVxuICBjb25zdCBzbmFwc2hvdCA9IGZyZXNoU25hcHNob3QkMShpbml0aWFsaXplU3RhdGUpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpOyAvLyBDb3VudGVyYWN0IHRoZSBzbmFwc2hvdCBhdXRvLXJlbGVhc2VcblxuICBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gQ2xlYW51cCBhbnkgZWZmZWN0cyBydW4gZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBjbGVhciB0aGUgaGFuZGxlcnMgc29cbiAgLy8gdGhleSB3aWxsIHJlLWluaXRpYWxpemUgaWYgdXNlZCBkdXJpbmcgcmVuZGVyaW5nLiAgVGhpcyBhbGxvd3MgYXRvbSBlZmZlY3RcbiAgLy8gaW5pdGlhbGl6YXRpb24gdG8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgaW5pdGlhbGl6ZVN0YXRlIGFuZCBiZSBjb21wYXRpYmxlXG4gIC8vIHdpdGggU3RyaWN0TW9kZSBzZW1hbnRpY3MuXG5cbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5jbGVhcigpO1xuICByZXR1cm4gc3RvcmVTdGF0ZTtcbn1cblxubGV0IG5leHRJRCA9IDA7XG5cbmZ1bmN0aW9uIFJlY29pbFJvb3RfSU5URVJOQUwoe1xuICBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCxcbiAgaW5pdGlhbGl6ZVN0YXRlLFxuICBzdG9yZV9JTlRFUk5BTDogc3RvcmVQcm9wLFxuICAvLyBGb3IgdXNlIHdpdGggUmVhY3QgXCJjb250ZXh0IGJyaWRnaW5nXCJcbiAgY2hpbGRyZW5cbn0pIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEBmYi1vbmx5OiB1c2VFZmZlY3QoKCkgPT4ge1xuICAvLyBAZmItb25seTogaWYgKGdreCgncmVjb2lsX3VzYWdlX2xvZ2dpbmcnKSkge1xuICAvLyBAZmItb25seTogdHJ5IHtcbiAgLy8gQGZiLW9ubHk6IFJlY29pbFVzYWdlTG9nRmFsY29FdmVudC5sb2coKCkgPT4gKHtcbiAgLy8gQGZiLW9ubHk6IHR5cGU6IFJlY29pbHVzYWdlbG9nRXZlbnQuUkVDT0lMX1JPT1RfTU9VTlRFRCxcbiAgLy8gQGZiLW9ubHk6IHBhdGg6IFVSSS5nZXRSZXF1ZXN0VVJJKCkuZ2V0UGF0aCgpLFxuICAvLyBAZmItb25seTogfSkpO1xuICAvLyBAZmItb25seTogfSBjYXRjaCB7XG4gIC8vIEBmYi1vbmx5OiByZWNvdmVyYWJsZVZpb2xhdGlvbihcbiAgLy8gQGZiLW9ubHk6ICdFcnJvciB3aGVuIGxvZ2dpbmcgUmVjb2lsIFVzYWdlIGV2ZW50JyxcbiAgLy8gQGZiLW9ubHk6ICdyZWNvaWwnLFxuICAvLyBAZmItb25seTogKTtcbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH1cbiAgLy8gQGZiLW9ubHk6IH0sIFtdKTtcbiAgbGV0IHN0b3JlU3RhdGVSZWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG5cbiAgY29uc3QgZ2V0R3JhcGggPSB2ZXJzaW9uID0+IHtcbiAgICBjb25zdCBncmFwaHMgPSBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuZ3JhcGhzQnlWZXJzaW9uO1xuXG4gICAgaWYgKGdyYXBocy5oYXModmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhncmFwaHMuZ2V0KHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdHcmFwaCA9IGdyYXBoJDIoKTtcbiAgICBncmFwaHMuc2V0KHZlcnNpb24sIG5ld0dyYXBoKTtcbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH07XG5cbiAgY29uc3Qgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMgPSAoY2FsbGJhY2ssIGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgLy8gR2xvYmFsIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgaWQgPSBuZXh0SUQrKztcbiAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS1zcGVjaWZpYyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zOlxuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zXG4gICAgICB9ID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoIW5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuaGFzKGtleSkpIHtcbiAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xuICAgICAgUmVjb2lsX251bGx0aHJvd3Mobm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkuc2V0KGlkLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VicyA9IG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgc3Vicy5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhID0gbWV0YWRhdGEgPT4ge1xuICAgIHN0YXJ0TmV4dFRyZWVJZk5lZWRlZChzdG9yZVJlZi5jdXJyZW50KTtcblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgIFJlY29pbF9udWxsdGhyb3dzKHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5uZXh0VHJlZSkudHJhbnNhY3Rpb25NZXRhZGF0YVtrXSA9IG1ldGFkYXRhW2tdO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXBsYWNlU3RhdGUgPSByZXBsYWNlciA9PiB7XG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpOyAvLyBVc2UgcmVwbGFjZXIgdG8gZ2V0IHRoZSBuZXh0IHN0YXRlOlxuXG4gICAgY29uc3QgbmV4dFRyZWUgPSBSZWNvaWxfbnVsbHRocm93cyhzdG9yZVN0YXRlUmVmLmN1cnJlbnQubmV4dFRyZWUpO1xuICAgIGxldCByZXBsYWNlZDtcblxuICAgIHRyeSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gdHJ1ZTtcbiAgICAgIHJlcGxhY2VkID0gcmVwbGFjZXIobmV4dFRyZWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VkID09PSBuZXh0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzLnB1c2gocmVwbGFjZWQpOyAvLyBUT0RPIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlIGJlY2F1c2UgaXQncyBub3QgYmF0Y2hlZFxuICAgICAgfVxuICAgIH0gLy8gU2F2ZSBjaGFuZ2VzIHRvIG5leHRUcmVlIGFuZCBzY2hlZHVsZSBhIFJlYWN0IHVwZGF0ZTpcblxuXG4gICAgc3RvcmVTdGF0ZVJlZi5jdXJyZW50Lm5leHRUcmVlID0gcmVwbGFjZWQ7XG5cbiAgICBpZiAocmVhY3RNb2RlJDIoKS5lYXJseSkge1xuICAgICAgbm90aWZ5Q29tcG9uZW50cyhzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVN0YXRlUmVmLmN1cnJlbnQsIHJlcGxhY2VkKTtcbiAgICB9XG5cbiAgICBSZWNvaWxfbnVsbHRocm93cyhub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCkoKTtcbiAgfTtcblxuICBjb25zdCBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UgPSB1c2VSZWYkMShudWxsKTtcbiAgY29uc3Qgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlID0gdXNlQ2FsbGJhY2soeCA9PiB7XG4gICAgbm90aWZ5QmF0Y2hlck9mQ2hhbmdlLmN1cnJlbnQgPSB4O1xuICB9LCBbbm90aWZ5QmF0Y2hlck9mQ2hhbmdlXSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IHN0b3JlUHJvcCAhPT0gbnVsbCAmJiBzdG9yZVByb3AgIT09IHZvaWQgMCA/IHN0b3JlUHJvcCA6IHtcbiAgICBzdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyKCksXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0b3JlU3RhdGVSZWYuY3VycmVudCxcbiAgICByZXBsYWNlU3RhdGUsXG4gICAgZ2V0R3JhcGgsXG4gICAgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMsXG4gICAgYWRkVHJhbnNhY3Rpb25NZXRhZGF0YVxuICB9KTtcblxuICBpZiAoc3RvcmVQcm9wICE9IG51bGwpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gc3RvcmVQcm9wO1xuICB9XG5cbiAgc3RvcmVTdGF0ZVJlZiA9IFJlY29pbF91c2VSZWZJbml0T25jZSgoKSA9PiBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGVfREVQUkVDQVRFRChzdG9yZVJlZi5jdXJyZW50LCBpbml0aWFsaXplU3RhdGVfREVQUkVDQVRFRCkgOiBpbml0aWFsaXplU3RhdGUgIT0gbnVsbCA/IGluaXRpYWxTdG9yZVN0YXRlKGluaXRpYWxpemVTdGF0ZSkgOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDIoKSk7XG4gIGNvbnN0IG11dGFibGVTb3VyY2UgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZU11dGFibGVTb3VyY2UkMSA9PT0gbnVsbCB8fCBjcmVhdGVNdXRhYmxlU291cmNlJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWF0ZU11dGFibGVTb3VyY2UkMShzdG9yZVN0YXRlUmVmLCAoKSA9PiBzdG9yZVN0YXRlUmVmLmN1cnJlbnQuY3VycmVudFRyZWUudmVyc2lvbiksIFtzdG9yZVN0YXRlUmVmXSk7IC8vIENsZWFudXAgd2hlbiB0aGUgPFJlY29pbFJvb3Q+IGlzIHVubW91bnRlZFxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmVhY3QgaXMgZnJlZSB0byBjYWxsIGVmZmVjdCBjbGVhbnVwIGhhbmRsZXJzIGFuZCBlZmZlY3RzIGF0IHdpbGwsIHRoZVxuICAgIC8vIGRlcHMgYXJyYXkgaXMgb25seSBhbiBvcHRpbWl6YXRpb24uICBGb3IgZXhhbXBsZSwgUmVhY3Qgc3RyaWN0IG1vZGVcbiAgICAvLyB3aWxsIGV4ZWN1dGUgZWFjaCBlZmZlY3QgdHdpY2UgZm9yIHRlc3RpbmcuICBUaGVyZWZvcmUsIHdlIG5lZWQgc3ltbWV0cnlcbiAgICAvLyB0byByZS1pbml0aWFsaXplIGFsbCBrbm93biBhdG9tcyBhZnRlciB0aGV5IHdlcmUgY2xlYW5lZCB1cC5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGF0b21LZXkgb2YgbmV3IFNldChzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpKSB7XG4gICAgICBpbml0aWFsaXplTm9kZSQyKHN0b3JlLCBhdG9tS2V5LCAnZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYXRvbUtleSBvZiBzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMpIHtcbiAgICAgICAgY2xlYW5VcE5vZGUkMihzdG9yZSwgYXRvbUtleSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3N0b3JlUmVmXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KE11dGFibGVTb3VyY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG11dGFibGVTb3VyY2VcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoQmF0Y2hlciwge1xuICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZTogc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlXG4gIH0pLCBjaGlsZHJlbikpO1xufVxuXG5mdW5jdGlvbiBSZWNvaWxSb290KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvdmVycmlkZSxcbiAgICAuLi5wcm9wc0V4Y2VwdE92ZXJyaWRlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYW5jZXN0b3JTdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSAmJiBhbmNlc3RvclN0b3JlUmVmLmN1cnJlbnQgIT09IGRlZmF1bHRTdG9yZSkge1xuICAgIC8vIElmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlLCBpdCBtZWFucyB0aGF0IHRoaXNcbiAgICAvLyBSZWNvaWxSb290IGlzIG5vdCBuZXN0ZWQgd2l0aGluIGFub3RoZXIuXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KFJlY29pbFJvb3RfSU5URVJOQUwsIHByb3BzRXhjZXB0T3ZlcnJpZGUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdG9yZUlEKCkge1xuICByZXR1cm4gdXNlU3RvcmVSZWYoKS5jdXJyZW50LnN0b3JlSUQ7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsUm9vdCA9IHtcbiAgUmVjb2lsUm9vdCxcbiAgdXNlU3RvcmVSZWYsXG4gIHVzZVJlY29pbE11dGFibGVTb3VyY2UsXG4gIHVzZVJlY29pbFN0b3JlSUQsXG4gIG5vdGlmeUNvbXBvbmVudHNfRk9SX1RFU1RJTkc6IG5vdGlmeUNvbXBvbmVudHMsXG4gIHNlbmRFbmRPZkJhdGNoTm90aWZpY2F0aW9uc19GT1JfVEVTVElORzogc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93QXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBSZWNvaWxfc2hhbGxvd0FycmF5RXF1YWwgPSBzaGFsbG93QXJyYXlFcXVhbDtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQxLFxuICB1c2VSZWY6IHVzZVJlZiQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZiQyKCk7XG4gIHVzZUVmZmVjdCQxKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgUmVjb2lsX3VzZVByZXZpb3VzID0gdXNlUHJldmlvdXM7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDFcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDNcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQyLFxuICB1c2VSZWY6IHVzZVJlZiQzXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuIC8vIEkgZG9uJ3Qgc2VlIGEgd2F5IHRvIGF2b2lkIHRoZSBhbnkgdHlwZSBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBhY2NlcHQgcmVhZGFibGVcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcbi8vIFJlY29pbFN0YXRlPFNvbWVUPiBpcyBub3QgYSBzdWJ0eXBlIG9mIFJlY29pbFN0YXRlPG1peGVkPi5cblxuXG4vLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbmZ1bmN0aW9uIHVzZVJldGFpbih0b1JldGFpbikge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuXG5cbiAgcmV0dXJuIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKSB7XG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XG4gIGNvbnN0IHJldGFpbmFibGVzID0gYXJyYXkubWFwKGEgPT4gYSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMyA/IGEgOiBhLmtleSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMSgpO1xuICB1c2VFZmZlY3QkMigoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQyKSB7XG4gICAgICAvLyBBbHJlYWR5IHBlcmZvcm1lZCBhIHRlbXBvcmFyeSByZXRhaW4gb24gcmVuZGVyLCBzaW1wbHkgY2FuY2VsIHRoZSByZWxlYXNlXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICB9LCBbc3RvcmVSZWYsIC4uLnJldGFpbmFibGVzXSk7IC8vIFdlIHdhbnQgdG8gcmV0YWluIGlmIHRoZSBjb21wb25lbnQgc3VzcGVuZHMuIFRoaXMgaXMgdGVycmlibGUgYnV0IHRoZSBTdXNwZW5zZVxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxuICAvLyBzZWNvbmRzLCB0aGVuIHJlbGVhc2UuIFRoZSAnYWN0dWFsJyByZXRhaW4vcmVsZWFzZSBpbiB0aGUgZWZmZWN0IGFib3ZlXG4gIC8vIGNhbmNlbHMgdGhpcy5cblxuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkMygpO1xuICBjb25zdCBwcmV2aW91c1JldGFpbmFibGVzID0gUmVjb2lsX3VzZVByZXZpb3VzKHJldGFpbmFibGVzKTtcblxuICBpZiAoIWlzU1NSJDIgJiYgKHByZXZpb3VzUmV0YWluYWJsZXMgPT09IHVuZGVmaW5lZCB8fCAhUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsKHByZXZpb3VzUmV0YWluYWJsZXMsIHJldGFpbmFibGVzKSkpIHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xuICB9XG59XG5cbnZhciBSZWNvaWxfdXNlUmV0YWluID0gdXNlUmV0YWluO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBUSElTIENPREUgSEFTIEJFRU4gQ09NTUVOVEVEIE9VVCBJTlRFTlRJT05BTExZXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgb2YgZ2V0dGluZyB0aGUgY29tcG9uZW50IG5hbWUgaXMgaW1wZXJmZWN0LCBzaW5jZSBpdCBib3RoIG9ubHlcbiAqIHdvcmtzIGluIGEgbm9uLW1pbmlmaWVkIGNvZGUgYmFzZSwgYW5kIG1vcmUgaW1wb3J0YW50bHkgaW50cm9kdWNlcyBwZXJmb3JtYW5jZVxuICogcHJvYmxlbXMgc2luY2UgaXQgcmVsaWVzIGluIHRocm93aW5nIGVycm9ycyB3aGljaCBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgbWF5IHdhbnQgdG8gcmVldmFsdWF0ZSB0aGlzIHRlY2huaXF1ZSBoZW5jZSB3aHkgd2UgaGF2ZSBjb21tZW50ZWRcbiAqIHRoaXMgY29kZSBvdXQsIHJhdGhlciB0aGFuIGRlbGV0ZSBpdCBhbGwgdG9nZXRoZXIuXG4gKi9cbi8vIGNvbnN0IHt1c2VSZWZ9ID0gcmVxdWlyZSgncmVhY3QnKTtcbi8vIGNvbnN0IGdreCA9IHJlcXVpcmUoJ3JlY29pbC1zaGFyZWQvdXRpbC9SZWNvaWxfZ2t4Jyk7XG4vLyBjb25zdCBzdGFja1RyYWNlUGFyc2VyID0gcmVxdWlyZSgncmVjb2lsLXNoYXJlZC91dGlsL1JlY29pbF9zdGFja1RyYWNlUGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHVzZUNvbXBvbmVudE5hbWUoKSB7XG4gIC8vIGNvbnN0IG5hbWVSZWYgPSB1c2VSZWYoKTtcbiAgLy8gaWYgKF9fREVWX18pIHtcbiAgLy8gICBpZiAoZ2t4KCdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJykpIHtcbiAgLy8gICAgIGlmIChuYW1lUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAvLyAgICAgICAvLyBUaGVyZSBpcyBubyBibGVzc2VkIHdheSB0byBkZXRlcm1pbmUgdGhlIGNhbGxpbmcgUmVhY3QgY29tcG9uZW50IGZyb21cbiAgLy8gICAgICAgLy8gd2l0aGluIGEgaG9vay4gVGhpcyBoYWNrIHVzZXMgdGhlIGZhY3QgdGhhdCBob29rcyBtdXN0IHN0YXJ0IHdpdGggJ3VzZSdcbiAgLy8gICAgICAgLy8gYW5kIHRoYXQgaG9va3MgYXJlIGVpdGhlciBjYWxsZWQgYnkgUmVhY3QgQ29tcG9uZW50cyBvciBvdGhlciBob29rcy4gSXRcbiAgLy8gICAgICAgLy8gZm9sbG93cyB0aGVyZWZvcmUsIHRoYXQgdG8gZmluZCB0aGUgY2FsbGluZyBjb21wb25lbnQsIHlvdSBzaW1wbHkgbmVlZFxuICAvLyAgICAgICAvLyB0byBsb29rIGRvd24gdGhlIHN0YWNrIGFuZCBmaW5kIHRoZSBmaXJzdCBmdW5jdGlvbiB3aGljaCBkb2Vzbid0IHN0YXJ0XG4gIC8vICAgICAgIC8vIHdpdGggJ3VzZScuIFdlIGFyZSBvbmx5IGVuYWJsaW5nIHRoaXMgaW4gZGV2IGZvciBub3csIHNpbmNlIG9uY2UgdGhlXG4gIC8vICAgICAgIC8vIGNvZGViYXNlIGlzIG1pbmlmaWVkLCB0aGUgbmFtaW5nIGFzc3VtcHRpb25zIG5vIGxvbmdlciBob2xkIHRydWUuXG4gIC8vICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tbmV3LWVycm9yXG4gIC8vICAgICAgIGNvbnN0IGZyYW1lcyA9IHN0YWNrVHJhY2VQYXJzZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAvLyAgICAgICBmb3IgKGNvbnN0IHttZXRob2ROYW1lfSBvZiBmcmFtZXMpIHtcbiAgLy8gICAgICAgICAvLyBJIG9ic2VydmVkIGNhc2VzIHdoZXJlIHRoZSBmcmFtZSB3YXMgb2YgdGhlIGZvcm0gJ09iamVjdC51c2VYWFgnXG4gIC8vICAgICAgICAgLy8gaGVuY2Ugd2h5IEknbSBzZWFyY2hpbmcgZm9yIGhvb2tzIGZvbGxvd2luZyBhIHdvcmQgYm91bmRhcnlcbiAgLy8gICAgICAgICBpZiAoIW1ldGhvZE5hbWUubWF0Y2goL1xcYnVzZVteXFxiXSskLykpIHtcbiAgLy8gICAgICAgICAgIHJldHVybiAobmFtZVJlZi5jdXJyZW50ID0gbWV0aG9kTmFtZSk7XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICAgIG5hbWVSZWYuY3VycmVudCA9IG51bGw7XG4gIC8vICAgICB9XG4gIC8vICAgICByZXR1cm4gbmFtZVJlZi5jdXJyZW50ID8/ICc8dW5hYmxlIHRvIGRldGVybWluZSBjb21wb25lbnQgbmFtZT4nO1xuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBAZmItb25seTogcmV0dXJuIFwiPGNvbXBvbmVudCBuYW1lIG9ubHkgYXZhaWxhYmxlIHdoZW4gYm90aCBpbiBkZXYgbW9kZSBhbmQgd2hlbiBwYXNzaW5nIEdLICdyZWNvaWxfaW5mZXJfY29tcG9uZW50X25hbWVzJz5cIjtcbiAgcmV0dXJuICc8Y29tcG9uZW50IG5hbWUgbm90IGF2YWlsYWJsZT4nOyAvLyBAb3NzLW9ubHlcbn1cblxudmFyIFJlY29pbF91c2VDb21wb25lbnROYW1lID0gdXNlQ29tcG9uZW50TmFtZTtcblxuY29uc3Qge1xuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQyXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmU6IGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUkMSxcbiAgcmVhY3RNb2RlOiByZWFjdE1vZGUkMyxcbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZSQxLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmUkMVxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cbmNvbnN0IHtcbiAgdXNlUmVjb2lsTXV0YWJsZVNvdXJjZTogdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxLFxuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkMlxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMlxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMyxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMixcbiAgc2V0UmVjb2lsVmFsdWU6IHNldFJlY29pbFZhbHVlJDIsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWU6IHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMixcbiAgc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZTogc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5cblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skMSxcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMyxcbiAgdXNlTWVtbzogdXNlTWVtbyQxLFxuICB1c2VSZWY6IHVzZVJlZiQ0LFxuICB1c2VTdGF0ZTogdXNlU3RhdGUkMVxufSA9IHJlYWN0O1xuXG5jb25zdCB7XG4gIHNldEJ5QWRkaW5nVG9TZXQ6IHNldEJ5QWRkaW5nVG9TZXQkMlxufSA9IFJlY29pbF9Db3B5T25Xcml0ZTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZikge1xuICAvLyBXZSBjYW4ndCBqdXN0IHRocm93IHRoZSBwcm9taXNlIHdlIGFyZSB3YWl0aW5nIG9uIHRvIFN1c3BlbnNlLiAgSWYgdGhlXG4gIC8vIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBjaGFuZ2UgaXQgbWF5IHByb2R1Y2UgYSBzdGF0ZSBpbiB3aGljaCB0aGUgY29tcG9uZW50XG4gIC8vIGNhbiByZW5kZXIsIGJ1dCBpdCB3b3VsZCBzdGlsbCBiZSBzdXNwZW5kZWQgb24gYSBQcm9taXNlIHRoYXQgbWF5IG5ldmVyIHJlc29sdmUuXG4gIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5hZGQocmVzb2x2ZSk7XG4gICAgfSk7IC8vICRGbG93RXhwZWN0ZWRFcnJvciBGbG93KHByb3AtbWlzc2luZykgZm9yIGludGVncmF0aW5nIHdpdGggdG9vbHMgdGhhdCBpbnNwZWN0IHRocm93biBwcm9taXNlcyBAZmItb25seVxuICAgIC8vIEBmYi1vbmx5OiBwcm9taXNlLmRpc3BsYXlOYW1lID0gYFJlY29pbCBTdGF0ZTogJHtyZWNvaWxWYWx1ZS5rZXl9YDtcblxuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKGBJbnZhbGlkIHZhbHVlIG9mIGxvYWRhYmxlIGF0b20gXCIke3JlY29pbFZhbHVlLmtleX1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsIGhvb2tOYW1lKSB7XG4gIGlmICghaXNSZWNvaWxWYWx1ZSQyKHJlY29pbFZhbHVlKSkge1xuICAgIHRocm93IFJlY29pbF9lcnIoYEludmFsaWQgYXJndW1lbnQgdG8gJHtob29rTmFtZX06IGV4cGVjdGVkIGFuIGF0b20gb3Igc2VsZWN0b3IgYnV0IGdvdCAke1N0cmluZyhyZWNvaWxWYWx1ZSl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYXJpb3VzIHRoaW5ncyBhcmUgYnJva2VuIHdpdGggdXNlUmVjb2lsSW50ZXJmYWNlLCBwYXJ0aWN1bGFybHkgY29uY3VycmVudFxuICogbW9kZSwgUmVhY3Qgc3RyaWN0IG1vZGUsIGFuZCBtZW1vcnkgbWFuYWdlbWVudC4gVGhleSB3aWxsIG5vdCBiZSBmaXhlZC5cbiAqICovXG5mdW5jdGlvbiB1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCgpIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LW5vLXVudXNlZC1zdGF0ZS1ob29rXG5cbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gdXNlU3RhdGUkMShbXSk7XG4gIGNvbnN0IHJlY29pbFZhbHVlc1VzZWQgPSB1c2VSZWYkNChuZXcgU2V0KCkpO1xuICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBuZXcgU2V0KCk7IC8vIFRyYWNrIHRoZSBSZWNvaWxWYWx1ZXMgdXNlZCBqdXN0IGR1cmluZyB0aGlzIHJlbmRlclxuXG4gIGNvbnN0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB1c2VSZWYkNChuZXcgTWFwKCkpO1xuICBjb25zdCB1bnN1YnNjcmliZUZyb20gPSB1c2VDYWxsYmFjayQxKGtleSA9PiB7XG4gICAgY29uc3Qgc3ViID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50LmdldChrZXkpO1xuXG4gICAgaWYgKHN1Yikge1xuICAgICAgc3ViLnJlbGVhc2UoKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0sIFtzdWJzY3JpcHRpb25zXSk7XG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2skMSgoX3N0YXRlLCBrZXkpID0+IHtcbiAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICBmb3JjZVVwZGF0ZShbXSk7XG4gICAgfVxuICB9LCBbXSk7IC8vIEVmZmVjdCB0byBhZGQvcmVtb3ZlIHN1YnNjcmlwdGlvbnMgYXMgbm9kZXMgYXJlIHVzZWRcblxuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9ucy5jdXJyZW50LmhhcyhrZXkpKSB7XG4gICAgICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbihgRG91YmxlIHN1YnNjcmlwdGlvbiB0byBSZWNvaWxWYWx1ZSBcIiR7a2V5fVwiYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCBuZXcgQWJzdHJhY3RSZWNvaWxWYWx1ZSQzKGtleSksIHN0YXRlID0+IHVwZGF0ZVN0YXRlKHN0YXRlLCBrZXkpLCBjb21wb25lbnROYW1lKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuY3VycmVudC5zZXQoa2V5LCBzdWIpO1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5jZSB3ZSdyZSBzdWJzY3JpYmluZyBpbiBhbiBlZmZlY3Qgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIGxhdGVzdFxuICAgICAgICogdmFsdWUgb2YgdGhlIGF0b20gc2luY2UgaXQgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB3ZSByZW5kZXJlZC4gV2UgY2FuXG4gICAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgICAqIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRvIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLCBkdWUgdG8gdGhlXG4gICAgICAgKiBmb2xsb3dpbmcgZWRnZSBjYXNlOiBTdXBwb3NlIGFuIGF0b20gaXMgdXBkYXRlZCBpbiBhbm90aGVyIHVzZUVmZmVjdFxuICAgICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgICAqIDEuIEF0b20gaXMgdXBkYXRlZCBhbmQgc3VicyBmaXJlZCAoYnV0IHdlIG1heSBub3QgYmUgc3Vic2NyaWJlZFxuICAgICAgICogICAgeWV0IGRlcGVuZGluZyBvbiBvcmRlciBvZiBlZmZlY3RzLCBzbyB3ZSBtaXNzIHRoaXMpIFVwZGF0ZWQgdmFsdWVcbiAgICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgICAqIDIuIFRoaXMgZWZmZWN0IGhhcHBlbnMuIFdlIHN1YnNjcmliZSBhbmQgdXBkYXRlLlxuICAgICAgICogMy4gRnJvbSB0aGUgdXBkYXRlIHdlIHJlLXJlbmRlciBhbmQgcmVhZCBjdXJyZW50VHJlZSwgd2l0aCBvbGQgdmFsdWUuXG4gICAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICAgKiBJbiB0aGlzIHNlcXVlbmNlIHdlIG1pc3MgdGhlIHVwZGF0ZS4gVG8gYXZvaWQgdGhhdCwgYWRkIHRoZSB1cGRhdGVcbiAgICAgICAqIHRvIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrIGlmIGEgYmF0Y2ggaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgKi9cbiAgICAgIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cblxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICBpZiAoc3RhdGUubmV4dFRyZWUpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50LCByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlRnJvbShrZXkpO1xuICAgIH0pO1xuICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucy5jdXJyZW50ID0gcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50O1xuICB9KTsgLy8gRWZmZWN0IHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHdoZW4gdW5tb3VudGluZ1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnMuY3VycmVudDsgLy8gUmVzdG9yZSBzdWJzY3JpcHRpb25zIHRoYXQgd2VyZSBjbGVhcmVkIGR1ZSB0byBTdHJpY3RNb2RlIHJ1bm5pbmcgdGhpcyBlZmZlY3QgdHdpY2VcblxuICAgIFJlY29pbF9kaWZmZXJlbmNlU2V0cyhyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIG5ldyBTZXQoY3VycmVudFN1YnNjcmlwdGlvbnMua2V5cygpKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3Qgc3ViID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgc3RhdGUgPT4gdXBkYXRlU3RhdGUoc3RhdGUsIGtleSksIGNvbXBvbmVudE5hbWUpO1xuICAgICAgY3VycmVudFN1YnNjcmlwdGlvbnMuc2V0KGtleSwgc3ViKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoXywga2V5KSA9PiB1bnN1YnNjcmliZUZyb20oa2V5KSk7XG4gIH0sIFtjb21wb25lbnROYW1lLCBzdG9yZVJlZiwgdW5zdWJzY3JpYmVGcm9tLCB1cGRhdGVTdGF0ZV0pO1xuICByZXR1cm4gdXNlTWVtbyQxKCgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgZnVuY3Rpb24gdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVNldFJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdWYWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKTtcbiAgICAgIH07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlc2V0UmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpIHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlY29pbFZhbHVlc1VzZWQuY3VycmVudC5oYXMocmVjb2lsVmFsdWUua2V5KSkge1xuICAgICAgICByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQgPSBzZXRCeUFkZGluZ1RvU2V0JDIocmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LCByZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgfSAvLyBUT0RPIFJlc3RvcmUgb3B0aW1pemF0aW9uIHRvIG1lbW9pemUgbG9va3VwXG5cblxuICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSk7XG4gICAgICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cblxuICAgIGZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVMb2FkYWJsZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3VzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRSZWNvaWxWYWx1ZTogdXNlUmVjb2lsVmFsdWUsXG4gICAgICBnZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlLFxuICAgICAgZ2V0UmVjb2lsU3RhdGVMb2FkYWJsZTogdXNlUmVjb2lsU3RhdGVMb2FkYWJsZSxcbiAgICAgIGdldFNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSxcbiAgICAgIGdldFJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGVcbiAgICB9O1xuICB9LCBbcmVjb2lsVmFsdWVzVXNlZCwgc3RvcmVSZWZdKTtcbn1cblxuY29uc3QgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyA9IHtcbiAgY3VycmVudDogMFxufTtcblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHRyZWVTdGF0ZSA9IHJlYWN0TW9kZSQzKCkuZWFybHkgPyAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUyICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICBjb25zdCBsb2FkYWJsZSA9IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGFibGUsXG4gICAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxuICAgIH07XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTsgLy8gTWVtb2l6ZSB0aGUgc3RhdGUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXG5cbiAgY29uc3QgbWVtb2l6ZVByZXZpb3VzU25hcHNob3QgPSB1c2VDYWxsYmFjayQxKGdldFN0YXRlID0+IHtcbiAgICBsZXQgcHJldlN0YXRlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX3ByZXZTdGF0ZSwgX3ByZXZTdGF0ZTI7XG5cbiAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgICAgIGlmICgoX3ByZXZTdGF0ZSA9IHByZXZTdGF0ZSkgIT09IG51bGwgJiYgX3ByZXZTdGF0ZSAhPT0gdm9pZCAwICYmIF9wcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiAoKF9wcmV2U3RhdGUyID0gcHJldlN0YXRlKSA9PT0gbnVsbCB8fCBfcHJldlN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZTdGF0ZTIua2V5KSA9PT0gbmV4dFN0YXRlLmtleSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuXG4gICAgICBwcmV2U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0TWVtb2l6ZWRTbmFwc2hvdCA9IHVzZU1lbW8kMSgoKSA9PiBtZW1vaXplUHJldmlvdXNTbmFwc2hvdChnZXRTbmFwc2hvdCksIFtnZXRTbmFwc2hvdCwgbWVtb2l6ZVByZXZpb3VzU25hcHNob3RdKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMShub3RpZnkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBub3RpZnksIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZV0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldE1lbW9pemVkU25hcHNob3QsIC8vIGdldFNuYXBzaG90KClcbiAgZ2V0TWVtb2l6ZWRTbmFwc2hvdCAvLyBnZXRTZXJ2ZXJTbmFwc2hvdCgpIGZvciBTU1Igc3VwcG9ydFxuICApLmxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX01VVEFCTEVfU09VUkNFKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTM7XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTMgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlMyA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0TG9hZGFibGVXaXRoVGVzdGluZyA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRMb2FkYWJsZSgpO1xuICB9LCBbZ2V0TG9hZGFibGVdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHVzZUNhbGxiYWNrJDEoKF9zdG9yZVN0YXRlLCBub3RpZnkpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZWNvaWxWYWx1ZSQxKHN0b3JlLCByZWNvaWxWYWx1ZSwgKCkgPT4ge1xuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gbm90aWZ5KCk7XG4gICAgICB9IC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBldmFsdWF0ZSB0aGUgYXRvbS9zZWxlY3RvciBub3cgYXMgd2VsbCBhcyB3aGVuIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHJlbmRlcnMsIGJ1dCB0aGF0IG1heSBoZWxwIHdpdGggcHJlZmV0Y2hpbmcuXG5cblxuICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuXG4gICAgICBpZiAoIXByZXZMb2FkYWJsZVJlZi5jdXJyZW50LmlzKG5ld0xvYWRhYmxlKSkge1xuICAgICAgICBub3RpZnkoKTtcbiAgICAgIH0gLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQgdGhlbiB0aGUgZWZmZWN0IHNldHRpbmcgcHJldkxvYWRhYmxlUmVmXG4gICAgICAvLyB3aWxsIG5vdCBydW4uICBTbywgc2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBoZXJlIHdoZW4gaXRzIHN1YnNjcmlwdGlvblxuICAgICAgLy8gaXMgZmlyZWQgdG8gd2FrZSBpdCB1cC4gIFdlIGNhbid0IGp1c3QgcmVseSBvbiB0aGlzLCB0aG91Z2gsIGJlY2F1c2VcbiAgICAgIC8vIHRoaXMgb25seSBleGVjdXRlcyB3aGVuIGFuIGF0b20vc2VsZWN0b3IgaXMgZGlydHkgYW5kIHRoZSBhdG9tL3NlbGVjdG9yXG4gICAgICAvLyBwYXNzZWQgdG8gdGhlIGhvb2sgY2FuIGR5bmFtaWNhbGx5IGNoYW5nZS5cblxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH0sIGNvbXBvbmVudE5hbWUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZSwgY29tcG9uZW50TmFtZSwgZ2V0TG9hZGFibGVdKTtcbiAgY29uc3Qgc291cmNlID0gdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSQxKCk7XG5cbiAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignUmVjb2lsIGhvb2tzIG11c3QgYmUgdXNlZCBpbiBjb21wb25lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xuICB9XG5cbiAgY29uc3QgbG9hZGFibGUgPSB1c2VNdXRhYmxlU291cmNlJDEoc291cmNlLCBnZXRMb2FkYWJsZVdpdGhUZXN0aW5nLCBzdWJzY3JpYmUpO1xuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IGxvYWRhYmxlO1xuICB9KTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVChyZWNvaWxWYWx1ZSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7IC8vIEFjY2Vzc29ycyB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcblxuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTQgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlNCA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjayQxKCgpID0+ICh7XG4gICAgbG9hZGFibGU6IGdldExvYWRhYmxlKCksXG4gICAga2V5OiByZWNvaWxWYWx1ZS5rZXlcbiAgfSksIFtnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUua2V5XSk7IC8vIE1lbW9pemUgc3RhdGUgc25hcHNob3RzXG5cbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKHByZXZTdGF0ZSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gcHJldlN0YXRlLmxvYWRhYmxlLmlzKG5leHRTdGF0ZS5sb2FkYWJsZSkgJiYgcHJldlN0YXRlLmtleSA9PT0gbmV4dFN0YXRlLmtleSA/IHByZXZTdGF0ZSA6IG5leHRTdGF0ZTtcbiAgfSwgW2dldFN0YXRlXSk7IC8vIFN1YnNjcmliZSB0byBSZWNvaWwgc3RhdGUgY2hhbmdlc1xuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICBzZXRTdGF0ZSh1cGRhdGVTdGF0ZSk7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7IC8vIFVwZGF0ZSBzdGF0ZSBpbiBjYXNlIHdlIGFyZSB1c2luZyBhIGRpZmZlcmVudCBrZXlcblxuICAgIHNldFN0YXRlKHVwZGF0ZVN0YXRlKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtjb21wb25lbnROYW1lLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYsIHVwZGF0ZVN0YXRlXSk7IC8vIEdldCB0aGUgY3VycmVudCBzdGF0ZVxuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUkMShnZXRTdGF0ZSk7IC8vIElmIHdlIGNoYW5nZWQga2V5cywgdGhlbiByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgbmV3IGtleS5cbiAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgb2xkIGtleSB3b3VsZCBjYXVzZSB0aGUgY29tcG9uZW50IHRvIHN1c3BlbmQuXG4gIC8vIFdlIGRvbid0IGhhdmUgdG8gc2V0IHRoZSBuZXcgc3RhdGUgaGVyZSBzaW5jZSB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0IGFib3ZlXG4gIC8vIHdpbGwgZG8gdGhhdC5cblxuICByZXR1cm4gc3RhdGUua2V5ICE9PSByZWNvaWxWYWx1ZS5rZXkgPyBnZXRTdGF0ZSgpLmxvYWRhYmxlIDogc3RhdGUubG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LW5vLXVudXNlZC1zdGF0ZS1ob29rXG5cbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gdXNlU3RhdGUkMShbXSk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBnZXRMb2FkYWJsZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlNSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkMihzdG9yZSwgcmVjb2lsVmFsdWUsIHRyZWVTdGF0ZSk7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsVmFsdWVdKTtcbiAgY29uc3QgbG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuICBjb25zdCBwcmV2TG9hZGFibGVSZWYgPSB1c2VSZWYkNChsb2FkYWJsZSk7XG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IGxvYWRhYmxlO1xuICB9KTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCBfc3RhdGUgPT4ge1xuICAgICAgdmFyIF9wcmV2TG9hZGFibGVSZWYkY3VycjtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIgPSBwcmV2TG9hZGFibGVSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyICE9PSB2b2lkIDAgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyLmlzKG5ld0xvYWRhYmxlKSkpIHtcbiAgICAgICAgZm9yY2VVcGRhdGUobmV3TG9hZGFibGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH0sIGNvbXBvbmVudE5hbWUpO1xuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlJ3JlIHN1YnNjcmliaW5nIGluIGFuIGVmZmVjdCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgbGF0ZXN0XG4gICAgICogdmFsdWUgb2YgdGhlIGF0b20gc2luY2UgaXQgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB3ZSByZW5kZXJlZC4gV2UgY2FuXG4gICAgICogZ28gYWhlYWQgYW5kIGRvIHRoYXQgbm93LCB1bmxlc3Mgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJhdGNoIC0tXG4gICAgICogaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgZG8gaXQgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2gsIGR1ZSB0byB0aGVcbiAgICAgKiBmb2xsb3dpbmcgZWRnZSBjYXNlOiBTdXBwb3NlIGFuIGF0b20gaXMgdXBkYXRlZCBpbiBhbm90aGVyIHVzZUVmZmVjdFxuICAgICAqIG9mIHRoaXMgc2FtZSBjb21wb25lbnQuIFRoZW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBvZiBldmVudHMgb2NjdXI6XG4gICAgICogMS4gQXRvbSBpcyB1cGRhdGVkIGFuZCBzdWJzIGZpcmVkIChidXQgd2UgbWF5IG5vdCBiZSBzdWJzY3JpYmVkXG4gICAgICogICAgeWV0IGRlcGVuZGluZyBvbiBvcmRlciBvZiBlZmZlY3RzLCBzbyB3ZSBtaXNzIHRoaXMpIFVwZGF0ZWQgdmFsdWVcbiAgICAgKiAgICBpcyBub3cgaW4gbmV4dFRyZWUsIGJ1dCBub3QgY3VycmVudFRyZWUuXG4gICAgICogMi4gVGhpcyBlZmZlY3QgaGFwcGVucy4gV2Ugc3Vic2NyaWJlIGFuZCB1cGRhdGUuXG4gICAgICogMy4gRnJvbSB0aGUgdXBkYXRlIHdlIHJlLXJlbmRlciBhbmQgcmVhZCBjdXJyZW50VHJlZSwgd2l0aCBvbGQgdmFsdWUuXG4gICAgICogNC4gQmF0Y2hlcidzIGVmZmVjdCBzZXRzIGN1cnJlbnRUcmVlIHRvIG5leHRUcmVlLlxuICAgICAqIEluIHRoaXMgc2VxdWVuY2Ugd2UgbWlzcyB0aGUgdXBkYXRlLiBUbyBhdm9pZCB0aGF0LCBhZGQgdGhlIHVwZGF0ZVxuICAgICAqIHRvIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrIGlmIGEgYmF0Y2ggaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG5cbiAgICBpZiAoc3RvcmVTdGF0ZS5uZXh0VHJlZSkge1xuICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5wdXNoKCgpID0+IHtcbiAgICAgICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wcmV2TG9hZGFibGVSZWYkY3VycjI7XG5cbiAgICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJykpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSBnZXRMb2FkYWJsZSgpO1xuXG4gICAgICBpZiAoISgoX3ByZXZMb2FkYWJsZVJlZiRjdXJyMiA9IHByZXZMb2FkYWJsZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyICE9PSB2b2lkIDAgJiYgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMi5pcyhuZXdMb2FkYWJsZSkpKSB7XG4gICAgICAgIGZvcmNlVXBkYXRlKG5ld0xvYWRhYmxlKTtcbiAgICAgIH1cblxuICAgICAgcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQgPSBuZXdMb2FkYWJsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnJlbGVhc2U7XG4gIH0sIFtjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmXSk7XG4gIHJldHVybiBsb2FkYWJsZTtcbn1cbi8qKlxuICBMaWtlIHVzZVJlY29pbFZhbHVlKCksIGJ1dCBlaXRoZXIgcmV0dXJucyB0aGUgdmFsdWUgaWYgYXZhaWxhYmxlIG9yXG4gIGp1c3QgdW5kZWZpbmVkIGlmIG5vdCBhdmFpbGFibGUgZm9yIGFueSByZWFzb24sIHN1Y2ggYXMgcGVuZGluZyBvciBlcnJvci5cbiovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlTG9hZGFibGUnKTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuICAgIFJlY29pbF91c2VSZXRhaW4ocmVjb2lsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBUUkFOU0lUSU9OX1NVUFBPUlQ6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JULFxuICAgIC8vIFJlY29pbCB3aWxsIGF0dGVtcCB0byBkZXRlY3QgaWYgYHVzZVN5bmNFeHRlcm5hbFN0b3JlKClgIGlzIHN1cHBvcnRlZCB3aXRoXG4gICAgLy8gYHJlYWN0TW9kZSgpYCBiZWZvcmUgY2FsbGluZyBpdC4gIEhvd2V2ZXIsIHNvbWV0aW1lcyB0aGUgaG9zdCBSZWFjdFxuICAgIC8vIGVudmlyb25tZW50IHN1cHBvcnRzIGl0IGJ1dCB1c2VzIGFkZGl0aW9uYWwgUmVhY3QgcmVuZGVyZXJzIChzdWNoIGFzIHdpdGhcbiAgICAvLyBgcmVhY3QtdGhyZWUtZmliZXJgKSB3aGljaCBkbyBub3QuICBXaGlsZSB0aGlzIGlzIHRlY2huaWNhbGx5IGEgdXNlciBpc3N1ZVxuICAgIC8vIGJ5IHVzaW5nIGEgcmVuZGVyZXIgd2l0aCBSZWFjdCAxOCsgdGhhdCBkb2Vzbid0IGZ1bGx5IHN1cHBvcnQgUmVhY3QgMTggd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIGJyZWFrIHVzZXJzIGlmIGl0IGNhbiBiZSBhdm9pZGVkLiBBcyB0aGUgY3VycmVudCByZW5kZXJlciBjYW5cbiAgICAvLyBjaGFuZ2UgYXQgcnVudGltZSwgd2UgbmVlZCB0byBkeW5hbWljYWxseSBjaGVjayBhbmQgZmFsbGJhY2sgaWYgbmVjZXNzYXJ5LlxuICAgIFNZTkNfRVhURVJOQUxfU1RPUkU6IGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUkMSgpID8gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9TWU5DX0VYVEVSTkFMX1NUT1JFIDogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQsXG4gICAgTVVUQUJMRV9TT1VSQ0U6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UsXG4gICAgTEVHQUNZOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX0xFR0FDWVxuICB9W3JlYWN0TW9kZSQzKCkubW9kZV0ocmVjb2lsVmFsdWUpO1xufVxuLyoqXG4gIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBSZWNvaWxWYWx1ZS5cbiAgSWYgdGhlIHZhbHVlIGlzIHBlbmRpbmcsIGl0IHdpbGwgdGhyb3cgYSBQcm9taXNlIHRvIHN1c3BlbmQgdGhlIGNvbXBvbmVudCxcbiAgaWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yIGl0IHdpbGwgdGhyb3cgaXQgZm9yIHRoZSBuZWFyZXN0IFJlYWN0IGVycm9yIGJvdW5kYXJ5LlxuICBUaGlzIHdpbGwgYWxzbyBzdWJzY3JpYmUgdGhlIGNvbXBvbmVudCBmb3IgYW55IHVwZGF0ZXMgaW4gdGhlIHZhbHVlLlxuICAqL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGUocmVjb2lsVmFsdWUpO1xuICByZXR1cm4gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZik7XG59XG4vKipcbiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGJlIHVwZGF0ZWQsIGJ1dCBkb2VzXG4gIG5vdCBzdWJzY3JpYmUgdGhlIGNvbXBvbmVudCB0byBjaGFuZ2VzIHRvIHRoYXQgUmVjb2lsU3RhdGUuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlU2V0UmVjb2lsU3RhdGUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skMShuZXdWYWx1ZU9yVXBkYXRlciA9PiB7XG4gICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFN0YXRlXSk7XG59XG4vKipcbiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXNldCB0aGUgdmFsdWUgb2YgYSBSZWNvaWxTdGF0ZSB0byBpdHMgZGVmYXVsdFxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZXNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVzZXRSZWNvaWxTdGF0ZScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQxKCgpID0+IHtcbiAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBERUZBVUxUX1ZBTFVFJDIpO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFN0YXRlXSk7XG59XG4vKipcbiAgRXF1aXZhbGVudCB0byB1c2VTdGF0ZSgpLiBBbGxvd3MgdGhlIHZhbHVlIG9mIHRoZSBSZWNvaWxTdGF0ZSB0byBiZSByZWFkIGFuZCB3cml0dGVuLlxuICBTdWJzZXF1ZW50IHVwZGF0ZXMgdG8gdGhlIFJlY29pbFN0YXRlIHdpbGwgY2F1c2UgdGhlIGNvbXBvbmVudCB0byByZS1yZW5kZXIuIElmIHRoZVxuICBSZWNvaWxTdGF0ZSBpcyBwZW5kaW5nLCB0aGlzIHdpbGwgc3VzcGVuZCB0aGUgY29tcG9uZW50IGFuZCBpbml0aWF0ZSB0aGVcbiAgcmV0cmlldmFsIG9mIHRoZSB2YWx1ZS4gSWYgZXZhbHVhdGluZyB0aGUgUmVjb2lsU3RhdGUgcmVzdWx0ZWQgaW4gYW4gZXJyb3IsIHRoaXMgd2lsbFxuICB0aHJvdyB0aGUgZXJyb3Igc28gdGhhdCB0aGUgbmVhcmVzdCBSZWFjdCBlcnJvciBib3VuZGFyeSBjYW4gY2F0Y2ggaXQuXG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0YXRlKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGUnKTtcbiAgfVxuXG4gIHJldHVybiBbdXNlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xufVxuLyoqXG4gIExpa2UgdXNlUmVjb2lsU3RhdGUoKSwgYnV0IGRvZXMgbm90IGNhdXNlIFN1c3BlbnNlIG9yIFJlYWN0IGVycm9yIGhhbmRsaW5nLiBSZXR1cm5zXG4gIGFuIG9iamVjdCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBSZWNvaWxTdGF0ZSBpcyBhdmFpbGFibGUsIHBlbmRpbmcsIG9yXG4gIHVuYXZhaWxhYmxlIGR1ZSB0byBhbiBlcnJvci5cbiovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVMb2FkYWJsZShyZWNvaWxTdGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBbdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcygpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIHJldHVybiAodmFsdWVzLCB0cmFuc2FjdGlvbk1ldGFkYXRhID0ge30pID0+IHtcbiAgICBiYXRjaFVwZGF0ZXMkMigoKSA9PiB7XG4gICAgICBzdG9yZVJlZi5jdXJyZW50LmFkZFRyYW5zYWN0aW9uTWV0YWRhdGEodHJhbnNhY3Rpb25NZXRhZGF0YSk7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfTtcbn1cbi8qKlxuICogRXhwZXJpbWVudGFsIHZhcmlhbnRzIG9mIGhvb2tzIHdpdGggc3VwcG9ydCBmb3IgdXNlVHJhbnNpdGlvbigpXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSwgJ3VzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJyk7XG5cbiAgICBpZiAoIXJlYWN0TW9kZSQzKCkuZWFybHkpIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignQXR0ZXBtdCB0byB1c2UgYSBob29rIHdpdGggVU5TVEFCTEVfVFJBTlNJVElPTl9TVVBQT1JUIGluIGEgcmVuZGVyaW5nIG1vZGUgaW5jb21wYXRpYmxlIHdpdGggY29uY3VycmVudCByZW5kZXJpbmcuICBUcnkgZW5hYmxpbmcgdGhlIHJlY29pbF9zeW5jX2V4dGVybmFsX3N0b3JlIG9yIHJlY29pbF90cmFuc2l0aW9uX3N1cHBvcnQgR0tzLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuICAgIFJlY29pbF91c2VSZXRhaW4ocmVjb2lsVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUKHJlY29pbFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxWYWx1ZSk7XG4gIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFJyk7XG4gIH1cblxuICByZXR1cm4gW3VzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG59XG5cbnZhciBSZWNvaWxfSG9va3MgPSB7XG4gIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcsXG4gIHVzZVJlY29pbEludGVyZmFjZTogdXNlUmVjb2lsSW50ZXJmYWNlX0RFUFJFQ0FURUQsXG4gIHVzZVJlY29pbFN0YXRlLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxuICB1c2VSZWNvaWxWYWx1ZSxcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgdXNlUmVzZXRSZWNvaWxTdGF0ZSxcbiAgdXNlU2V0UmVjb2lsU3RhdGUsXG4gIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyxcbiAgdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsXG4gIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSxcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBrZXlzICsgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIG1hcCB3aGVyZVxuICogdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX2ZpbHRlck1hcCA9IGZpbHRlck1hcDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIHNldCB3aGVyZVxuICogdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyU2V0KHNldCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgaWYgKGNhbGxiYWNrKHZhbHVlKSkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9maWx0ZXJTZXQgPSBmaWx0ZXJTZXQ7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIG1lcmdlTWFwcyguLi5tYXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IG1hcHNbaV0ua2V5cygpO1xuICAgIGxldCBuZXh0S2V5O1xuXG4gICAgd2hpbGUgKCEobmV4dEtleSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtY2FsbF0gLSBtYXAvaXRlcmF0b3Iga25vd3Mgbm90aGluZyBhYm91dCBmbG93IHR5cGVzXG4gICAgICByZXN1bHQuc2V0KG5leHRLZXkudmFsdWUsIG1hcHNbaV0uZ2V0KG5leHRLZXkudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX21lcmdlTWFwcyA9IG1lcmdlTWFwcztcblxuY29uc3Qge1xuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQzXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkMyxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQ0LFxuICBub2Rlczogbm9kZXMkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQzXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQ0LFxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgU1VTUEVOU0VfVElNRU9VVF9NUzogU1VTUEVOU0VfVElNRU9VVF9NUyQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBjbG9uZVNuYXBzaG90OiBjbG9uZVNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcblxuY29uc3Qge1xuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2skMixcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkNCxcbiAgdXNlUmVmOiB1c2VSZWYkNSxcbiAgdXNlU3RhdGU6IHVzZVN0YXRlJDJcbn0gPSByZWFjdDtcblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkM1xufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xuICB1c2VFZmZlY3QkNCgoKSA9PiB7XG4gICAgY29uc3Qgc3ViID0gc3RvcmVSZWYuY3VycmVudC5zdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyhjYWxsYmFjayk7XG4gICAgcmV0dXJuIHN1Yi5yZWxlYXNlO1xuICB9LCBbY2FsbGJhY2ssIHN0b3JlUmVmXSk7XG59XG5cbmZ1bmN0aW9uIGV4dGVybmFsbHlWaXNpYmxlQXRvbVZhbHVlc0luU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgYXRvbVZhbHVlcyA9IHN0YXRlLmF0b21WYWx1ZXMudG9NYXAoKTtcbiAgY29uc3QgcGVyc2lzdGVkQXRvbUNvbnRlbnRzVmFsdWVzID0gUmVjb2lsX21hcE1hcChSZWNvaWxfZmlsdGVyTWFwKGF0b21WYWx1ZXMsICh2LCBrKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGUkNChrKTtcbiAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IG5vZGUucGVyc2lzdGVuY2VfVU5TVEFCTEU7XG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlICE9IG51bGwgJiYgcGVyc2lzdGVuY2UudHlwZSAhPT0gJ25vbmUnICYmIHYuc3RhdGUgPT09ICdoYXNWYWx1ZSc7XG4gIH0pLCB2ID0+IHYuY29udGVudHMpOyAvLyBNZXJnZSBpbiBub252YWxpZGF0ZWQgYXRvbXM7IHdlIG1heSBub3QgaGF2ZSBkZWZzIGZvciB0aGVtIGJ1dCB0aGV5IHdpbGxcbiAgLy8gYWxsIGhhdmUgcGVyc2lzdGVuY2Ugb24gb3IgdGhleSB3b3VsZG4ndCBiZSB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG5cbiAgcmV0dXJuIFJlY29pbF9tZXJnZU1hcHMoc3RhdGUubm9udmFsaWRhdGVkQXRvbXMudG9NYXAoKSwgcGVyc2lzdGVkQXRvbUNvbnRlbnRzVmFsdWVzKTtcbn1cblxuLyoqXG4gIENhbGxzIHRoZSBnaXZlbiBjYWxsYmFjayBhZnRlciBhbnkgYXRvbXMgaGF2ZSBiZWVuIG1vZGlmaWVkIGFuZCB0aGUgY29uc2VxdWVudFxuICBjb21wb25lbnQgcmUtcmVuZGVycyBoYXZlIGJlZW4gY29tbWl0dGVkLiBUaGlzIGlzIGludGVuZGVkIGZvciBwZXJzaXN0aW5nXG4gIHRoZSB2YWx1ZXMgb2YgdGhlIGF0b21zIHRvIHN0b3JhZ2UuIFRoZSBzdG9yZWQgdmFsdWVzIGNhbiB0aGVuIGJlIHJlc3RvcmVkXG4gIHVzaW5nIHRoZSB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXMgaG9vay5cblxuICBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBpbmZvOlxuXG4gIGF0b21WYWx1ZXM6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGV2ZXJ5IGF0b20gdGhhdCBpcyBib3RoIHBlcnNpc3RhYmxlIChwZXJzaXN0ZW5jZVxuICAgICAgICAgICAgICB0eXBlIG5vdCBzZXQgdG8gJ25vbmUnKSBhbmQgd2hvc2UgdmFsdWUgaXMgYXZhaWxhYmxlIChub3QgaW4gYW5cbiAgICAgICAgICAgICAgZXJyb3Igb3IgbG9hZGluZyBzdGF0ZSkuXG5cbiAgcHJldmlvdXNBdG9tVmFsdWVzOiBUaGUgdmFsdWUgb2YgZXZlcnkgcGVyc2lzdGFibGUgYW5kIGF2YWlsYWJsZSBhdG9tIGJlZm9yZVxuICAgICAgICAgICAgICAgdGhlIHRyYW5zYWN0aW9uIGJlZ2FuLlxuXG4gIGF0b21JbmZvOiBBIG1hcCBjb250YWluaW5nIHRoZSBwZXJzaXN0ZW5jZSBzZXR0aW5ncyBmb3IgZWFjaCBhdG9tLiBFdmVyeSBrZXlcbiAgICAgICAgICAgIHRoYXQgZXhpc3RzIGluIGF0b21WYWx1ZXMgd2lsbCBhbHNvIGV4aXN0IGluIGF0b21JbmZvLlxuXG4gIG1vZGlmaWVkQXRvbXM6IFRoZSBzZXQgb2YgYXRvbXMgdGhhdCB3ZXJlIHdyaXR0ZW4gdG8gZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cblxuICB0cmFuc2FjdGlvbk1ldGFkYXRhOiBBcmJpdHJhcnkgaW5mb3JtYXRpb24gdGhhdCB3YXMgYWRkZWQgdmlhIHRoZVxuICAgICAgICAgIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyBob29rLiBVc2VmdWwgZm9yIGlnbm9yaW5nIHRoZSB1c2VTZXRVbnZhbGlkYXRlZEF0b21WYWx1ZXNcbiAgICAgICAgICB0cmFuc2FjdGlvbiwgdG8gYXZvaWQgbG9vcHMuXG4qL1xuZnVuY3Rpb24gdXNlVHJhbnNhY3Rpb25PYnNlcnZhdGlvbl9ERVBSRUNBVEVEKGNhbGxiYWNrKSB7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4ge1xuICAgIGxldCBwcmV2aW91c1RyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLnByZXZpb3VzVHJlZTtcbiAgICBjb25zdCBjdXJyZW50VHJlZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICBpZiAoIXByZXZpb3VzVHJlZSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmFuc2FjdGlvbiBzdWJzY3JpYmVycyBub3RpZmllZCB3aXRob3V0IGEgcHJldmlvdXMgdHJlZSBiZWluZyBwcmVzZW50IC0tIHRoaXMgaXMgYSBidWcgaW4gUmVjb2lsJyk7XG4gICAgICBwcmV2aW91c1RyZWUgPSBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cbiAgICB9XG5cbiAgICBjb25zdCBhdG9tVmFsdWVzID0gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShjdXJyZW50VHJlZSk7XG4gICAgY29uc3QgcHJldmlvdXNBdG9tVmFsdWVzID0gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShwcmV2aW91c1RyZWUpO1xuICAgIGNvbnN0IGF0b21JbmZvID0gUmVjb2lsX21hcE1hcChub2RlcyQxLCBub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMsIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiB7XG4gICAgICAgICAgdHlwZTogKF9ub2RlJHBlcnNpc3RlbmNlX1VOUyA9IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyID0gbm9kZS5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkgPT09IG51bGwgfHwgX25vZGUkcGVyc2lzdGVuY2VfVU5TMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGVyc2lzdGVuY2VfVU5TMi50eXBlKSAhPT0gbnVsbCAmJiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMgIT09IHZvaWQgMCA/IF9ub2RlJHBlcnNpc3RlbmNlX1VOUyA6ICdub25lJyxcbiAgICAgICAgICBiYWNrQnV0dG9uOiAoX25vZGUkcGVyc2lzdGVuY2VfVU5TMyA9IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0ID0gbm9kZS5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkgPT09IG51bGwgfHwgX25vZGUkcGVyc2lzdGVuY2VfVU5TNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGVyc2lzdGVuY2VfVU5TNC5iYWNrQnV0dG9uKSAhPT0gbnVsbCAmJiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzICE9PSB2b2lkIDAgPyBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzIDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTsgLy8gRmlsdGVyIG9uIGV4aXN0YW5jZSBpbiBhdG9tVmFsdWVzIHNvIHRoYXQgZXh0ZXJuYWxseS12aXNpYmxlIHJ1bGVzXG4gICAgLy8gYXJlIGFsc28gYXBwbGllZCB0byBtb2RpZmllZCBhdG9tcyAoc3BlY2lmaWNhbGx5IGV4Y2x1ZGUgc2VsZWN0b3JzKTpcblxuICAgIGNvbnN0IG1vZGlmaWVkQXRvbXMgPSBSZWNvaWxfZmlsdGVyU2V0KGN1cnJlbnRUcmVlLmRpcnR5QXRvbXMsIGsgPT4gYXRvbVZhbHVlcy5oYXMoaykgfHwgcHJldmlvdXNBdG9tVmFsdWVzLmhhcyhrKSk7XG4gICAgY2FsbGJhY2soe1xuICAgICAgYXRvbVZhbHVlcyxcbiAgICAgIHByZXZpb3VzQXRvbVZhbHVlcyxcbiAgICAgIGF0b21JbmZvLFxuICAgICAgbW9kaWZpZWRBdG9tcyxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHsgLi4uY3VycmVudFRyZWUudHJhbnNhY3Rpb25NZXRhZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBbY2FsbGJhY2tdKSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDEoc3RvcmUsICdsYXRlc3QnKTtcbiAgICBjb25zdCBwcmV2aW91c1NuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQxKHN0b3JlLCAncHJldmlvdXMnKTtcbiAgICBjYWxsYmFjayh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIHByZXZpb3VzU25hcHNob3RcbiAgICB9KTtcbiAgfSwgW2NhbGxiYWNrXSkpO1xufSAvLyBSZXR1cm4gYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgc3Vic2NyaWJlIHRvIGFsbCBzdGF0ZSBjaGFuZ2VzXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsU25hcHNob3QoKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMygpO1xuICBjb25zdCBbc25hcHNob3QsIHNldFNuYXBzaG90XSA9IHVzZVN0YXRlJDIoKCkgPT4gY2xvbmVTbmFwc2hvdCQxKHN0b3JlUmVmLmN1cnJlbnQpKTtcbiAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IFJlY29pbF91c2VQcmV2aW91cyhzbmFwc2hvdCk7XG4gIGNvbnN0IHRpbWVvdXRJRCA9IHVzZVJlZiQ1KCk7XG4gIGNvbnN0IHJlbGVhc2VSZWYgPSB1c2VSZWYkNSgpO1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHNldFNuYXBzaG90KGNsb25lU25hcHNob3QkMShzdG9yZSkpLCBbXSkpOyAvLyBSZXRhaW4gc25hcHNob3QgZm9yIGR1cmF0aW9uIGNvbXBvbmVudCBpcyBtb3VudGVkXG5cbiAgdXNlRWZmZWN0JDQoKCkgPT4ge1xuICAgIGNvbnN0IHJlbGVhc2UgPSBzbmFwc2hvdC5yZXRhaW4oKTsgLy8gUmVsZWFzZSB0aGUgcmV0YWluIGZyb20gdGhlIHJlbmRlcmluZyBjYWxsXG5cbiAgICBpZiAodGltZW91dElELmN1cnJlbnQgJiYgIWlzU1NSJDMpIHtcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50O1xuXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50ID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50LmNhbGwocmVsZWFzZVJlZik7XG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBEZWZlciB0aGUgcmVsZWFzZS4gIElmIFwiRmFzdCBSZWZyZXNoXCJcIiBpcyB1c2VkIHRoZW4gdGhlIGNvbXBvbmVudCBtYXlcbiAgICAgIC8vIHJlLXJlbmRlciB3aXRoIHRoZSBzYW1lIHN0YXRlLiAgVGhlIHByZXZpb3VzIGNsZWFudXAgd2lsbCB0aGVuIHJ1biBhbmRcbiAgICAgIC8vIHRoZW4gdGhlIG5ldyBlZmZlY3Qgd2lsbCBydW4uIFdlIGRvbid0IHdhbnQgdGhlIHNuYXBzaG90IHRvIGJlIHJlbGVhc2VkXG4gICAgICAvLyBieSB0aGF0IGNsZWFudXAgYmVmb3JlIHRoZSBuZXcgZWZmZWN0IGhhcyBhIGNoYW5jZSB0byByZXRhaW4gaXQgYWdhaW4uXG4gICAgICAvLyBVc2UgdGltZW91dCBvZiAxMCB0byB3b3JrYXJvdW5kIEZpcmVmb3ggaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzE5MzZcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJlbGVhc2UsIDEwKTtcbiAgICB9O1xuICB9LCBbc25hcHNob3RdKTsgLy8gUmV0YWluIHNuYXBzaG90IHVudGlsIGFib3ZlIGVmZmVjdCBpcyBydW4uXG4gIC8vIFJlbGVhc2UgYWZ0ZXIgYSB0aHJlc2hvbGQgaW4gY2FzZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkLlxuXG4gIGlmIChwcmV2aW91c1NuYXBzaG90ICE9PSBzbmFwc2hvdCAmJiAhaXNTU1IkMykge1xuICAgIC8vIFJlbGVhc2UgdGhlIHByZXZpb3VzIHNuYXBzaG90XG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50KSB7XG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDI7XG5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQyID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudDIuY2FsbChyZWxlYXNlUmVmKTtcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gc25hcHNob3QucmV0YWluKCk7XG4gICAgdGltZW91dElELmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIgX3JlbGVhc2VSZWYkY3VycmVudDM7XG5cbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIChfcmVsZWFzZVJlZiRjdXJyZW50MyA9IHJlbGVhc2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlbGVhc2VSZWYkY3VycmVudDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQzLmNhbGwocmVsZWFzZVJlZik7XG4gICAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sIFNVU1BFTlNFX1RJTUVPVVRfTVMkMik7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIGdvdG9TbmFwc2hvdChzdG9yZSwgc25hcHNob3QpIHtcbiAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCBwcmV2ID0gKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgY29uc3QgbmV4dCA9IHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCkuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcbiAgYmF0Y2hVcGRhdGVzJDMoKCkgPT4ge1xuICAgIGNvbnN0IGtleXNUb1VwZGF0ZSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qga2V5cyBvZiBbcHJldi5hdG9tVmFsdWVzLmtleXMoKSwgbmV4dC5hdG9tVmFsdWVzLmtleXMoKV0pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgdmFyIF9wcmV2JGF0b21WYWx1ZXMkZ2V0LCBfbmV4dCRhdG9tVmFsdWVzJGdldDtcblxuICAgICAgICBpZiAoKChfcHJldiRhdG9tVmFsdWVzJGdldCA9IHByZXYuYXRvbVZhbHVlcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX3ByZXYkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcmV2JGF0b21WYWx1ZXMkZ2V0LmNvbnRlbnRzKSAhPT0gKChfbmV4dCRhdG9tVmFsdWVzJGdldCA9IG5leHQuYXRvbVZhbHVlcy5nZXQoa2V5KSkgPT09IG51bGwgfHwgX25leHQkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uZXh0JGF0b21WYWx1ZXMkZ2V0LmNvbnRlbnRzKSAmJiBnZXROb2RlJDQoa2V5KS5zaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90cykge1xuICAgICAgICAgIGtleXNUb1VwZGF0ZS5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGtleXNUb1VwZGF0ZS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDQoa2V5KSwgbmV4dC5hdG9tVmFsdWVzLmhhcyhrZXkpID8gUmVjb2lsX251bGx0aHJvd3MobmV4dC5hdG9tVmFsdWVzLmdldChrZXkpKSA6IERFRkFVTFRfVkFMVUUkMyk7XG4gICAgfSk7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHN0YXRlID0+ICh7IC4uLnN0YXRlLFxuICAgICAgc3RhdGVJRDogc25hcHNob3QuZ2V0SUQoKVxuICAgIH0pKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCgpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQyKHNuYXBzaG90ID0+IGdvdG9TbmFwc2hvdChzdG9yZVJlZi5jdXJyZW50LCBzbmFwc2hvdCksIFtzdG9yZVJlZl0pO1xufVxuXG52YXIgUmVjb2lsX1NuYXBzaG90SG9va3MgPSB7XG4gIHVzZVJlY29pbFNuYXBzaG90LFxuICBnb3RvU25hcHNob3QsXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCxcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcixcbiAgdXNlVHJhbnNhY3Rpb25PYnNlcnZhdGlvbl9ERVBSRUNBVEVELFxuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbl9ERVBSRUNBVEVEOiB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvblxufTtcblxuY29uc3Qge1xuICBwZWVrTm9kZUluZm86IHBlZWtOb2RlSW5mbyQyXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQ0XG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmZ1bmN0aW9uIHVzZUdldFJlY29pbFZhbHVlSW5mbygpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQ0KCk7XG4gIHJldHVybiAoe1xuICAgIGtleVxuICB9KSA9PiBwZWVrTm9kZUluZm8kMihzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG59XG5cbnZhciBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvID0gdXNlR2V0UmVjb2lsVmFsdWVJbmZvO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDRcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMSxcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDVcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuXG5cbmNvbnN0IHtcbiAgdXNlTWVtbzogdXNlTWVtbyQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMoKSB7XG4gIC8vIFRoZSB0ZXN0IGZhaWxzIHdoZW4gdXNpbmcgdXNlTXV0YWJsZVNvdXJjZSgpLCBidXQgb25seSBpZiBhY3QoKSBpcyB1c2VkXG4gIC8vIGZvciB0aGUgbmVzdGVkIHJvb3QuICBTbywgdGhpcyBtYXkgb25seSBiZSBhIHRlc3RpbmcgZW52aXJvbm1lbnQgaXNzdWUuXG4gIGlmIChyZWFjdE1vZGUkNCgpLm1vZGUgPT09ICdNVVRBQkxFX1NPVVJDRScpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IFRoZXJlIGFyZSBrbm93biBpc3N1ZXMgdXNpbmcgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cygpIGluIHJlY29pbF9tdXRhYmxlX3NvdXJjZSByZW5kZXJpbmcgbW9kZS4gIFBsZWFzZSBjb25zaWRlciB1cGdyYWRpbmcgdG8gcmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUgbW9kZS4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVSZWYkNSgpLmN1cnJlbnQ7XG4gIHJldHVybiB1c2VNZW1vJDIoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBmdW5jdGlvbiBSZWNvaWxCcmlkZ2Uoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdCQxLCB7XG4gICAgICAgIHN0b3JlX0lOVEVSTkFMOiBzdG9yZVxuICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBSZWNvaWxCcmlkZ2U7XG4gIH0sIFtzdG9yZV0pO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMgPSB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzO1xuXG5jb25zdCB7XG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQxXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ0LFxuICBnZXROb2RlOiBnZXROb2RlJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBjb3B5VHJlZVN0YXRlOiBjb3B5VHJlZVN0YXRlJDEsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtczogaW52YWxpZGF0ZURvd25zdHJlYW1zJDEsXG4gIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZTogd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cblxuXG5mdW5jdGlvbiBpc0F0b20ocmVjb2lsVmFsdWUpIHtcbiAgcmV0dXJuIGdldE5vZGUkNShyZWNvaWxWYWx1ZS5rZXkpLm5vZGVUeXBlID09PSAnYXRvbSc7XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlLCB0cmVlU3RhdGUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RvcmVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmVlU3RhdGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGFuZ2VzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NoYW5nZXMuaGFzKHJlY29pbFZhbHVlLmtleSkpIHtcbiAgICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlcy5nZXQocmVjb2lsVmFsdWUua2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0F0b20ocmVjb2lsVmFsdWUpKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1JlYWRpbmcgc2VsZWN0b3JzIHdpdGhpbiBhdG9taWNVcGRhdGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzKHRoaXMuX3N0b3JlLCByZWNvaWxWYWx1ZSwgdGhpcy5fdHJlZVN0YXRlKTtcblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKGBFeHBlY3RlZCBSZWNvaWwgYXRvbSAke3JlY29pbFZhbHVlLmtleX0gdG8gaGF2ZSBhIHZhbHVlLCBidXQgaXQgaXMgaW4gYSBsb2FkaW5nIHN0YXRlLmApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0XCIsIChyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIpID0+IHtcbiAgICAgIGlmICghaXNBdG9tKHJlY29pbFN0YXRlKSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQocmVjb2lsU3RhdGUpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIoY3VycmVudCkpOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdG9tIGFuZCBydW4gZWZmZWN0cyBpZiBub3QgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIGluaXRpYWxpemVOb2RlJDModGhpcy5fc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgJ3NldCcpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzZXRcIiwgcmVjb2lsU3RhdGUgPT4ge1xuICAgICAgdGhpcy5zZXQocmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkNCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuX3RyZWVTdGF0ZSA9IHRyZWVTdGF0ZTtcbiAgICB0aGlzLl9jaGFuZ2VzID0gbmV3IE1hcCgpO1xuICB9IC8vIEFsbG93IGRlc3RydWN0aW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXJcblxuXG4gIG5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJlZVN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZSQxKHRoaXMuX3RyZWVTdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB0aGlzLl9jaGFuZ2VzKSB7XG4gICAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMShuZXdTdGF0ZSwgaywgbG9hZGFibGVXaXRoVmFsdWUkMSh2KSk7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zJDEodGhpcy5fc3RvcmUsIG5ld1N0YXRlKTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBhdG9taWNVcGRhdGVyKHN0b3JlKSB7XG4gIHJldHVybiBmbiA9PiB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRyZWVTdGF0ZSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VzZXQgPSBuZXcgVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsKHN0b3JlLCB0cmVlU3RhdGUpO1xuICAgICAgZm4oY2hhbmdlc2V0KTtcbiAgICAgIHJldHVybiBjaGFuZ2VzZXQubmV3VHJlZVN0YXRlX0lOVEVSTkFMKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyA9IHtcbiAgYXRvbWljVXBkYXRlclxufTtcblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzXzEgPSBSZWNvaWxfQXRvbWljVXBkYXRlcy5hdG9taWNVcGRhdGVyO1xuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhdG9taWNVcGRhdGVyOiBSZWNvaWxfQXRvbWljVXBkYXRlc18xXG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZhcmlhbnRfMSA9IGludmFyaWFudDtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9pbnZhcmlhbnQgPSBpbnZhcmlhbnRfMTtcblxuY29uc3Qge1xuICBhdG9taWNVcGRhdGVyOiBhdG9taWNVcGRhdGVyJDFcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDRcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ1XG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDZcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQxLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkM1xufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICBjbG9uZVNuYXBzaG90OiBjbG9uZVNuYXBzaG90JDJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcblxuY29uc3Qge1xuICBnb3RvU25hcHNob3Q6IGdvdG9TbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90SG9va3M7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDNcbn0gPSByZWFjdDtcblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIFNlbnRpbmVsIHt9XG5cbmNvbnN0IFNFTlRJTkVMID0gbmV3IFNlbnRpbmVsKCk7XG5cbmZ1bmN0aW9uIHJlY29pbENhbGxiYWNrKHN0b3JlLCBmbiwgYXJncywgZXh0cmFJbnRlcmZhY2UpIHtcbiAgbGV0IHJldCA9IFNFTlRJTkVMO1xuICBsZXQgcmVsZWFzZVNuYXBzaG90O1xuICBiYXRjaFVwZGF0ZXMkNCgoKSA9PiB7XG4gICAgY29uc3QgZXJyTXNnID0gJ3VzZVJlY29pbENhbGxiYWNrKCkgZXhwZWN0cyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uOiAnICsgJ2l0IGFjY2VwdHMgYSBmdW5jdGlvbiBvZiB0aGUgdHlwZSAoUmVjb2lsSW50ZXJmYWNlKSA9PiAoQXJncykgPT4gUmV0dXJuVHlwZSAnICsgJ2FuZCByZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gKEFyZ3MpID0+IFJldHVyblR5cGUsIHdoZXJlIFJlY29pbEludGVyZmFjZSBpcyAnICsgJ2FuIG9iamVjdCB7c25hcHNob3QsIHNldCwgLi4ufSBhbmQgQXJncyBhbmQgUmV0dXJuVHlwZSBhcmUgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm4gJyArICd0eXBlcyBvZiB0aGUgY2FsbGJhY2sgeW91IHdhbnQgdG8gY3JlYXRlLiAgUGxlYXNlIHNlZSB0aGUgZG9jcyAnICsgJ2F0IHJlY29pbGpzLm9yZyBmb3IgZGV0YWlscy4nO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH0gLy8gQ2xvbmUgdGhlIHNuYXBzaG90IGxhemlseSB0byBhdm9pZCBvdmVyaGVhZCBpZiB0aGUgY2FsbGJhY2sgZG9lcyBub3QgdXNlIGl0LlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBtYXkgcmVwcmVzZW50IGxhdGVyIHN0YXRlIGZyb20gd2hlblxuICAgIC8vIHRoZSBjYWxsYmFjayB3YXMgY2FsbGVkIGlmIGl0IGZpcnN0IGFjY2Vzc2VzIHRoZSBzbmFwc2hvdCBhc3luY2hyb25vdXNseS5cblxuXG4gICAgY29uc3QgY2FsbGJhY2tJbnRlcmZhY2UgPSBSZWNvaWxfbGF6eVByb3h5KHsgLi4uKGV4dHJhSW50ZXJmYWNlICE9PSBudWxsICYmIGV4dHJhSW50ZXJmYWNlICE9PSB2b2lkIDAgPyBleHRyYUludGVyZmFjZSA6IHt9KSxcbiAgICAgIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgc2V0OiAobm9kZSwgbmV3VmFsdWUpID0+IHNldFJlY29pbFZhbHVlJDMoc3RvcmUsIG5vZGUsIG5ld1ZhbHVlKSxcbiAgICAgIHJlc2V0OiBub2RlID0+IHNldFJlY29pbFZhbHVlJDMoc3RvcmUsIG5vZGUsIERFRkFVTFRfVkFMVUUkNSksXG4gICAgICByZWZyZXNoOiBub2RlID0+IHJlZnJlc2hSZWNvaWxWYWx1ZSQxKHN0b3JlLCBub2RlKSxcbiAgICAgIGdvdG9TbmFwc2hvdDogc25hcHNob3QgPT4gZ290b1NuYXBzaG90JDEoc3RvcmUsIHNuYXBzaG90KSxcbiAgICAgIHRyYW5zYWN0X1VOU1RBQkxFOiB0cmFuc2FjdGlvbiA9PiBhdG9taWNVcGRhdGVyJDEoc3RvcmUpKHRyYW5zYWN0aW9uKVxuICAgIH0sIHtcbiAgICAgIHNuYXBzaG90OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQyKHN0b3JlKTtcbiAgICAgICAgcmVsZWFzZVNuYXBzaG90ID0gc25hcHNob3QucmV0YWluKCk7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZuKGNhbGxiYWNrSW50ZXJmYWNlKTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoZXJyTXNnKTtcbiAgICB9XG5cbiAgICByZXQgPSBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSk7XG4gICEhKHJldCBpbnN0YW5jZW9mIFNlbnRpbmVsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdiYXRjaFVwZGF0ZXMgc2hvdWxkIHJldHVybiBpbW1lZGlhdGVseScpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UocmV0KSkge1xuICAgIHJldC5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfcmVsZWFzZVNuYXBzaG90O1xuXG4gICAgICAoX3JlbGVhc2VTbmFwc2hvdCA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdCgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmVsZWFzZVNuYXBzaG90MjtcblxuICAgIChfcmVsZWFzZVNuYXBzaG90MiA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlU25hcHNob3QyKCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxDYWxsYmFjayhmbiwgZGVwcykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDYoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDMoIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlY29pbENhbGxiYWNrKHN0b3JlUmVmLmN1cnJlbnQsIGZuLCBhcmdzKTtcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gICk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2sgPSB7XG4gIHJlY29pbENhbGxiYWNrLFxuICB1c2VSZWNvaWxDYWxsYmFja1xufTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkN1xufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDRcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsUmVmcmVzaGVyKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNygpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skNCgoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIHJlZnJlc2hSZWNvaWxWYWx1ZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gIH0sIFtyZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxSZWZyZXNoZXIgPSB1c2VSZWNvaWxSZWZyZXNoZXI7XG5cbmNvbnN0IHtcbiAgYXRvbWljVXBkYXRlcjogYXRvbWljVXBkYXRlciQyXG59ID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMkMTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkOFxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHVzZU1lbW86IHVzZU1lbW8kM1xufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbihmbiwgZGVwcykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDgoKTtcbiAgcmV0dXJuIHVzZU1lbW8kMygoKSA9PiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGF0b21pY1VwZGF0ZSA9IGF0b21pY1VwZGF0ZXIkMihzdG9yZVJlZi5jdXJyZW50KTtcbiAgICBhdG9taWNVcGRhdGUodHJhbnNhY3Rpb25JbnRlcmZhY2UgPT4ge1xuICAgICAgZm4odHJhbnNhY3Rpb25JbnRlcmZhY2UpKC4uLmFyZ3MpO1xuICAgIH0pO1xuICB9LCBkZXBzICE9IG51bGwgPyBbLi4uZGVwcywgc3RvcmVSZWZdIDogdW5kZWZpbmVkIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzLWRlcHNcbiAgKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbiA9IHVzZVJlY29pbFRyYW5zYWN0aW9uO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5jbGFzcyBXcmFwcGVkVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX1dyYXBwZXIgPSB7XG4gIFdyYXBwZWRWYWx1ZVxufTtcblxudmFyIFJlY29pbF9XcmFwcGVyXzEgPSBSZWNvaWxfV3JhcHBlci5XcmFwcGVkVmFsdWU7XG5cbnZhciBSZWNvaWxfV3JhcHBlciQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFdyYXBwZWRWYWx1ZTogUmVjb2lsX1dyYXBwZXJfMVxufSk7XG5cbmNvbnN0IHtcbiAgaXNGYXN0UmVmcmVzaEVuYWJsZWQ6IGlzRmFzdFJlZnJlc2hFbmFibGVkJDJcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5cblxuY2xhc3MgQ2hhbmdlZFBhdGhFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbmNsYXNzIFRyZWVDYWNoZSB7XG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJG9uSGl0LCBfb3B0aW9ucyRvblNldCwgX29wdGlvbnMkbWFwTm9kZVZhbHVlO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9udW1MZWFmc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Jvb3RcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vbkhpdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uU2V0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwTm9kZVZhbHVlXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9uYW1lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX29uSGl0ID0gKF9vcHRpb25zJG9uSGl0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uSGl0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRvbkhpdCAhPT0gdm9pZCAwID8gX29wdGlvbnMkb25IaXQgOiAoKSA9PiB7fTtcbiAgICB0aGlzLl9vblNldCA9IChfb3B0aW9ucyRvblNldCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblNldCkgIT09IG51bGwgJiYgX29wdGlvbnMkb25TZXQgIT09IHZvaWQgMCA/IF9vcHRpb25zJG9uU2V0IDogKCkgPT4ge307XG4gICAgdGhpcy5fbWFwTm9kZVZhbHVlID0gKF9vcHRpb25zJG1hcE5vZGVWYWx1ZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBOb2RlVmFsdWUpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcE5vZGVWYWx1ZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwTm9kZVZhbHVlIDogdmFsID0+IHZhbDtcbiAgfVxuXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bUxlYWZzO1xuICB9IC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5cbiAgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfVxuXG4gIGdldChnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSB7XG4gICAgdmFyIF90aGlzJGdldExlYWZOb2RlO1xuXG4gICAgcmV0dXJuIChfdGhpcyRnZXRMZWFmTm9kZSA9IHRoaXMuZ2V0TGVhZk5vZGUoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykpID09PSBudWxsIHx8IF90aGlzJGdldExlYWZOb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRMZWFmTm9kZS52YWx1ZTtcbiAgfVxuXG4gIGdldExlYWZOb2RlKGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpIHtcbiAgICBpZiAodGhpcy5fcm9vdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gSXRlcmF0ZSBkb3duIHRoZSB0cmVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IG5vZGUgdmFsdWVzIHVudGlsIHdlIGhpdCBhIGxlYWZcbiAgICAvLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuXG4gICAgbGV0IG5vZGUgPSB0aGlzLl9yb290O1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGhhbmRsZXJzID09PSBudWxsIHx8IGhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoYW5kbGVycy5vbk5vZGVWaXNpdChub2RlKTtcblxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xlYWYnKSB7XG4gICAgICAgIHRoaXMuX29uSGl0KG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlVmFsdWUgPSB0aGlzLl9tYXBOb2RlVmFsdWUoZ2V0Tm9kZVZhbHVlKG5vZGUubm9kZUtleSkpO1xuXG4gICAgICBub2RlID0gbm9kZS5icmFuY2hlcy5nZXQobm9kZVZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc2V0KHJvdXRlLCB2YWx1ZSwgaGFuZGxlcnMpIHtcbiAgICBjb25zdCBhZGRMZWFmID0gKCkgPT4ge1xuICAgICAgdmFyIF9ub2RlMiwgX25vZGUzLCBfdGhpcyRfcm9vdDIsIF9oYW5kbGVycyRvbk5vZGVWaXNpdDI7XG5cbiAgICAgIC8vIEZpcnN0LCBzZXR1cCB0aGUgYnJhbmNoIG5vZGVzIGZvciB0aGUgcm91dGU6XG4gICAgICAvLyBJdGVyYXRlIGRvd24gdGhlIHRyZWUgdG8gZmluZCBvciBhZGQgYnJhbmNoIG5vZGVzIGZvbGxvd2luZyB0aGUgcm91dGVcbiAgICAgIGxldCBub2RlO1xuICAgICAgbGV0IGJyYW5jaEtleTtcblxuICAgICAgZm9yIChjb25zdCBbbm9kZUtleSwgbm9kZVZhbHVlXSBvZiByb3V0ZSkge1xuICAgICAgICB2YXIgX25vZGUsIF9oYW5kbGVycyRvbk5vZGVWaXNpdCwgX3RoaXMkX3Jvb3Q7XG5cbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHJvb3Qgd2FzIGEgbGVhZiwgd2hpbGUgd2Ugbm90IGhhdmUgYSBnZXQoKSwgaXQgbWVhbnNcbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGhhcyBpbmNvbnNpc3RlbnQgdmFsdWVzIG9yIGltcGxlbWVudGF0aW9uIGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290O1xuXG4gICAgICAgIGlmICgocm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LnR5cGUpID09PSAnbGVhZicpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICAgIH0gLy8gbm9kZSBub3cgcmVmZXJzIHRvIHRoZSBuZXh0IG5vZGUgZG93biBpbiB0aGUgdHJlZVxuXG5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG5cbiAgICAgICAgbm9kZSA9IHBhcmVudCA/IHBhcmVudC5icmFuY2hlcy5nZXQoYnJhbmNoS2V5KSA6IHJvb3Q7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuXG4gICAgICAgIG5vZGUgPSAoX25vZGUgPSBub2RlKSAhPT0gbnVsbCAmJiBfbm9kZSAhPT0gdm9pZCAwID8gX25vZGUgOiB7XG4gICAgICAgICAgdHlwZTogJ2JyYW5jaCcsXG4gICAgICAgICAgbm9kZUtleSxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgYnJhbmNoZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBicmFuY2hLZXlcbiAgICAgICAgfTsgLy8gSWYgd2UgZm91bmQgYW4gZXhpc3Rpbmcgbm9kZSwgY29uZmlybSBpdCBoYXMgYSBjb25zaXN0ZW50IHZhbHVlXG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2JyYW5jaCcgfHwgbm9kZS5ub2RlS2V5ICE9PSBub2RlS2V5KSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgICB9IC8vIEFkZCB0aGUgYnJhbmNoIG5vZGUgdG8gdGhlIHRyZWVcblxuXG4gICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5icmFuY2hlcy5zZXQoYnJhbmNoS2V5LCBub2RlKTtcbiAgICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaGFuZGxlcnMkb25Ob2RlVmlzaXQgPSBoYW5kbGVycy5vbk5vZGVWaXNpdCkgPT09IG51bGwgfHwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaGFuZGxlcnMkb25Ob2RlVmlzaXQuY2FsbChoYW5kbGVycywgbm9kZSk7IC8vIFByZXBhcmUgZm9yIG5leHQgaXRlcmF0aW9uIGFuZCBpbnN0YWxsIHJvb3QgaWYgaXQgaXMgbmV3LlxuXG4gICAgICAgIGJyYW5jaEtleSA9IHRoaXMuX21hcE5vZGVWYWx1ZShub2RlVmFsdWUpO1xuICAgICAgICB0aGlzLl9yb290ID0gKF90aGlzJF9yb290ID0gdGhpcy5fcm9vdCkgIT09IG51bGwgJiYgX3RoaXMkX3Jvb3QgIT09IHZvaWQgMCA/IF90aGlzJF9yb290IDogbm9kZTtcbiAgICAgIH0gLy8gU2Vjb25kLCBzZXR1cCB0aGUgbGVhZiBub2RlOlxuICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgbGVhZiBmb3IgdGhpcyByb3V0ZSBjb25maXJtIGl0IGlzIGNvbnNpc3RlbnRcblxuXG4gICAgICBjb25zdCBvbGRMZWFmID0gbm9kZSA/IChfbm9kZTIgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlMi5icmFuY2hlcy5nZXQoYnJhbmNoS2V5KSA6IHRoaXMuX3Jvb3Q7XG5cbiAgICAgIGlmIChvbGRMZWFmICE9IG51bGwgJiYgKG9sZExlYWYudHlwZSAhPT0gJ2xlYWYnIHx8IG9sZExlYWYuYnJhbmNoS2V5ICE9PSBicmFuY2hLZXkpKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgbmV3IG9yIHJlcGxhY2VtZW50IGxlYWYuXG5cblxuICAgICAgY29uc3QgbGVhZk5vZGUgPSB7XG4gICAgICAgIHR5cGU6ICdsZWFmJyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgYnJhbmNoS2V5XG4gICAgICB9OyAvLyBJbnN0YWxsIHRoZSBsZWFmIGFuZCBjYWxsIGhhbmRsZXJzXG5cbiAgICAgIChfbm9kZTMgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlMy5icmFuY2hlcy5zZXQoYnJhbmNoS2V5LCBsZWFmTm9kZSk7XG4gICAgICB0aGlzLl9yb290ID0gKF90aGlzJF9yb290MiA9IHRoaXMuX3Jvb3QpICE9PSBudWxsICYmIF90aGlzJF9yb290MiAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QyIDogbGVhZk5vZGU7XG4gICAgICB0aGlzLl9udW1MZWFmcysrO1xuXG4gICAgICB0aGlzLl9vblNldChsZWFmTm9kZSk7XG5cbiAgICAgIGhhbmRsZXJzID09PSBudWxsIHx8IGhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2hhbmRsZXJzJG9uTm9kZVZpc2l0MiA9IGhhbmRsZXJzLm9uTm9kZVZpc2l0KSA9PT0gbnVsbCB8fCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaGFuZGxlcnMkb25Ob2RlVmlzaXQyLmNhbGwoaGFuZGxlcnMsIGxlYWZOb2RlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGFkZExlYWYoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhlIGNhY2hlIHdhcyBzdGFsZSBvciBvYnNlcnZlZCBpbmNvbnNpc3RlbnQgdmFsdWVzLCBzdWNoIGFzIHdpdGhcbiAgICAgIC8vIEZhc3QgUmVmcmVzaCwgdGhlbiBjbGVhciBpdCBhbmQgcmVidWlsZCB3aXRoIHRoZSBuZXcgdmFsdWVzLlxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ2hhbmdlZFBhdGhFcnJvcikge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGFkZExlYWYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXR1cm5zIHRydWUgaWYgbGVhZiB3YXMgYWN0dWFsbHkgZGVsZXRlZCBmcm9tIHRoZSB0cmVlXG5cblxuICBkZWxldGUobGVhZikge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3QoKTtcblxuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsZWFmID09PSByb290KSB7XG4gICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gSXRlcmF0ZSB1cCBmcm9tIHRoZSBsZWFmIGRlbGV0ZWluZyBpdCBmcm9tIGl0J3MgcGFyZW50J3MgYnJhbmNoZXMuXG5cblxuICAgIGxldCBub2RlID0gbGVhZi5wYXJlbnQ7XG4gICAgbGV0IGJyYW5jaEtleSA9IGxlYWYuYnJhbmNoS2V5O1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIHZhciBfbm9kZTQ7XG5cbiAgICAgIG5vZGUuYnJhbmNoZXMuZGVsZXRlKGJyYW5jaEtleSk7IC8vIFN0b3AgaXRlcmF0aW5nIGlmIHdlIGhpdCB0aGUgcm9vdC5cblxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgaWYgKG5vZGUuYnJhbmNoZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9udW1MZWFmcy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIFN0b3AgaXRlcmF0aW5nIGlmIHRoZXJlIGFyZSBvdGhlciBicmFuY2hlcyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAvLyByZW1vdmUgYW55IG1vcmUgbm9kZXMuXG5cblxuICAgICAgaWYgKG5vZGUuYnJhbmNoZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIEl0ZXJhdGUgdXAgdG8gb3VyIHBhcmVudFxuXG5cbiAgICAgIGJyYW5jaEtleSA9IChfbm9kZTQgPSBub2RlKSA9PT0gbnVsbCB8fCBfbm9kZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlNC5icmFuY2hLZXk7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfSAvLyBDb25maXJtIHRoYXQgdGhlIGxlYWYgd2UgYXJlIGRlbGV0aW5nIGlzIGFjdHVhbGx5IGF0dGFjaGVkIHRvIG91ciB0cmVlXG5cblxuICAgIGZvciAoOyBub2RlICE9PSByb290OyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX251bUxlYWZzLS07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIH1cblxuICBpbnZhbGlkQ2FjaGVFcnJvcigpIHtcbiAgICBjb25zdCBDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSA9IGlzRmFzdFJlZnJlc2hFbmFibGVkJDIoKSA/ICdQb3NzaWJsZSBGYXN0IFJlZnJlc2ggbW9kdWxlIHJlbG9hZCBkZXRlY3RlZC4gICcgKyAnVGhpcyBtYXkgYWxzbyBiZSBjYXVzZWQgYnkgYW4gc2VsZWN0b3IgcmV0dXJuaW5nIGluY29uc2lzdGVudCB2YWx1ZXMuICcgKyAnUmVzZXR0aW5nIGNhY2hlLicgOiAnSW52YWxpZCBjYWNoZSB2YWx1ZXMuICBUaGlzIGhhcHBlbnMgd2hlbiBzZWxlY3RvcnMgZG8gbm90IHJldHVybiAnICsgJ2NvbnNpc3RlbnQgdmFsdWVzIGZvciB0aGUgc2FtZSBpbnB1dCBkZXBlbmRlbmN5IHZhbHVlcy4gIFRoYXQgbWF5IGFsc28gJyArICdiZSBjYXVzZWQgd2hlbiB1c2luZyBGYXN0IFJlZnJlc2ggdG8gY2hhbmdlIGEgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24uICAnICsgJ1Jlc2V0dGluZyBjYWNoZS4nO1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihDSEFOR0VEX1BBVEhfRVJST1JfTUVTU0FHRSArICh0aGlzLl9uYW1lICE9IG51bGwgPyBgIC0gJHt0aGlzLl9uYW1lfWAgOiAnJykpO1xuICAgIHRocm93IG5ldyBDaGFuZ2VkUGF0aEVycm9yKCk7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX1RyZWVDYWNoZSA9IHtcbiAgVHJlZUNhY2hlXG59O1xuXG52YXIgUmVjb2lsX1RyZWVDYWNoZV8xID0gUmVjb2lsX1RyZWVDYWNoZS5UcmVlQ2FjaGU7XG5cbnZhciBSZWNvaWxfVHJlZUNhY2hlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgVHJlZUNhY2hlOiBSZWNvaWxfVHJlZUNhY2hlXzFcbn0pO1xuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkbWFwS2V5O1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21heFNpemVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGVhZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhaWxcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9rZXlNYXBwZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX21heFNpemUgPSBvcHRpb25zLm1heFNpemU7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zLm1hcEtleSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwS2V5ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBLZXkgOiB2ID0+IHY7XG4gIH1cblxuICBoZWFkKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkO1xuICB9XG5cbiAgdGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBtYXhTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhTaXplO1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCBtYXBwZWRLZXkgPSB0aGlzLl9rZXlNYXBwZXIoa2V5KTtcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSk7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoa2V5LCBub2RlLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHNldChrZXksIHZhbCkge1xuICAgIGNvbnN0IG1hcHBlZEtleSA9IHRoaXMuX2tleU1hcHBlcihrZXkpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gdGhpcy5fbWFwLmdldChtYXBwZWRLZXkpO1xuXG4gICAgaWYgKGV4aXN0aW5nTm9kZSkge1xuICAgICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkID0gdGhpcy5oZWFkKCk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGtleSxcbiAgICAgIHJpZ2h0OiBoZWFkLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHZhbHVlOiB2YWxcbiAgICB9O1xuXG4gICAgaWYgKGhlYWQpIHtcbiAgICAgIGhlYWQubGVmdCA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RhaWwgPSBub2RlO1xuICAgIH1cblxuICAgIHRoaXMuX21hcC5zZXQobWFwcGVkS2V5LCBub2RlKTtcblxuICAgIHRoaXMuX2hlYWQgPSBub2RlO1xuICAgIHRoaXMuX3NpemUrKztcblxuICAgIHRoaXMuX21heWJlRGVsZXRlTFJVKCk7XG4gIH1cblxuICBfbWF5YmVEZWxldGVMUlUoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpID4gdGhpcy5tYXhTaXplKCkpIHtcbiAgICAgIHRoaXMuZGVsZXRlTHJ1KCk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlTHJ1KCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWwoKTtcblxuICAgIGlmICh0YWlsKSB7XG4gICAgICB0aGlzLmRlbGV0ZSh0YWlsLmtleSk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IG1hcHBlZEtleSA9IHRoaXMuX2tleU1hcHBlcihrZXkpO1xuXG4gICAgaWYgKCF0aGlzLl9zaXplIHx8ICF0aGlzLl9tYXAuaGFzKG1hcHBlZEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gUmVjb2lsX251bGx0aHJvd3ModGhpcy5fbWFwLmdldChtYXBwZWRLZXkpKTtcbiAgICBjb25zdCByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgY29uc3QgbGVmdCA9IG5vZGUubGVmdDtcblxuICAgIGlmIChyaWdodCkge1xuICAgICAgcmlnaHQubGVmdCA9IG5vZGUubGVmdDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCkge1xuICAgICAgbGVmdC5yaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCgpKSB7XG4gICAgICB0aGlzLl9oZWFkID0gcmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCgpKSB7XG4gICAgICB0aGlzLl90YWlsID0gbGVmdDtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXAuZGVsZXRlKG1hcHBlZEtleSk7XG5cbiAgICB0aGlzLl9zaXplLS07XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX0xSVUNhY2hlID0ge1xuICBMUlVDYWNoZVxufTtcblxudmFyIFJlY29pbF9MUlVDYWNoZV8xID0gUmVjb2lsX0xSVUNhY2hlLkxSVUNhY2hlO1xuXG52YXIgUmVjb2lsX0xSVUNhY2hlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgTFJVQ2FjaGU6IFJlY29pbF9MUlVDYWNoZV8xXG59KTtcblxuY29uc3Qge1xuICBMUlVDYWNoZTogTFJVQ2FjaGUkMVxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xuXG5jb25zdCB7XG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDFcbn0gPSBSZWNvaWxfVHJlZUNhY2hlJDE7XG5cbmZ1bmN0aW9uIHRyZWVDYWNoZUxSVSh7XG4gIG5hbWUsXG4gIG1heFNpemUsXG4gIG1hcE5vZGVWYWx1ZSA9IHYgPT4gdlxufSkge1xuICBjb25zdCBscnVDYWNoZSA9IG5ldyBMUlVDYWNoZSQxKHtcbiAgICBtYXhTaXplXG4gIH0pO1xuICBjb25zdCBjYWNoZSA9IG5ldyBUcmVlQ2FjaGUkMSh7XG4gICAgbmFtZSxcbiAgICBtYXBOb2RlVmFsdWUsXG4gICAgb25IaXQ6IG5vZGUgPT4ge1xuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xuICAgIH0sXG4gICAgb25TZXQ6IG5vZGUgPT4ge1xuICAgICAgY29uc3QgbHJ1Tm9kZSA9IGxydUNhY2hlLnRhaWwoKTtcbiAgICAgIGxydUNhY2hlLnNldChub2RlLCB0cnVlKTtcblxuICAgICAgaWYgKGxydU5vZGUgJiYgY2FjaGUuc2l6ZSgpID4gbWF4U2l6ZSkge1xuICAgICAgICBjYWNoZS5kZWxldGUobHJ1Tm9kZS5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjYWNoZTtcbn1cblxudmFyIFJlY29pbF90cmVlQ2FjaGVMUlUgPSB0cmVlQ2FjaGVMUlU7XG5cbmNvbnN0IFRJTUVfV0FSTklOR19USFJFU0hPTERfTVMgPSAxNTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHgsIG9wdCwga2V5KSB7XG4gIC8vIEEgb3B0aW1pemF0aW9uIHRvIGF2b2lkIHRoZSBtb3JlIGV4cGVuc2l2ZSBKU09OLnN0cmluZ2lmeSgpIGZvciBzaW1wbGUgc3RyaW5nc1xuICAvLyBUaGlzIG1heSBsb3NlIHByb3RlY3Rpb24gZm9yIHUyMDI4IGFuZCB1MjAyOSwgdGhvdWdoLlxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmICF4LmluY2x1ZGVzKCdcIicpICYmICF4LmluY2x1ZGVzKCdcXFxcJykpIHtcbiAgICByZXR1cm4gYFwiJHt4fVwiYDtcbiAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlIHR5cGVzXG5cblxuICBzd2l0Y2ggKHR5cGVvZiB4KSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiAnJztcbiAgICAvLyBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLCBidXQgd2UgYWx3YXlzIHdhbnQgdG8gcmV0dXJuIGEgc3RyaW5nXG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB4ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGNhc2UgJ2JpZ2ludCc6IC8vIEJpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIGluIHd3d1xuICAgICAgcmV0dXJuIFN0cmluZyh4KTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAvLyBBZGQgc3Vycm91bmRpbmcgcXVvdGVzIGFuZCBlc2NhcGUgaW50ZXJuYWwgcXVvdGVzXG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5hbGxvd0Z1bmN0aW9ucykgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQXR0ZW1wdCB0byBzZXJpYWxpemUgZnVuY3Rpb24gaW4gYSBSZWNvaWwgY2FjaGUga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgX19GVU5DVElPTigke3gubmFtZX0pX19gO1xuICB9XG5cbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IC8vIEZhbGxiYWNrIGNhc2UgZm9yIHVua25vd24gdHlwZXNcblxuXG4gIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICB2YXIgX0pTT04kc3RyaW5naWZ5O1xuXG4gICAgcmV0dXJuIChfSlNPTiRzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeSh4KSkgIT09IG51bGwgJiYgX0pTT04kc3RyaW5naWZ5ICE9PSB2b2lkIDAgPyBfSlNPTiRzdHJpbmdpZnkgOiAnJztcbiAgfSAvLyBEZWFsIHdpdGggYWxsIHByb21pc2VzIGFzIGVxdWl2YWxlbnQgZm9yIG5vdy5cblxuXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHgpKSB7XG4gICAgcmV0dXJuICdfX1BST01JU0VfXyc7XG4gIH0gLy8gQXJyYXlzIGhhbmRsZSByZWN1cnNpdmUgc3RyaW5naWZpY2F0aW9uXG5cblxuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHJldHVybiBgWyR7eC5tYXAoKHYsIGkpID0+IHN0cmluZ2lmeSh2LCBvcHQsIGkudG9TdHJpbmcoKSkpfV1gO1xuICB9IC8vIElmIGFuIG9iamVjdCBkZWZpbmVzIGEgdG9KU09OKCkgbWV0aG9kLCB0aGVuIHVzZSB0aGF0IHRvIG92ZXJyaWRlIHRoZVxuICAvLyBzZXJpYWxpemF0aW9uLiAgVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAvLyBQYXNzIHRoZSBrZXkgZm9yIGNvbXBhdGliaWxpdHkuXG4gIC8vIEltbXV0YWJsZS5qcyBjb2xsZWN0aW9ucyBkZWZpbmUgdGhpcyBtZXRob2QgdG8gYWxsb3cgdXMgdG8gc2VyaWFsaXplIHRoZW0uXG5cblxuICBpZiAodHlwZW9mIHgudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh4LnRvSlNPTihrZXkpLCBvcHQsIGtleSk7XG4gIH0gLy8gRm9yIGJ1aWx0LWluIE1hcHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIgaW5zdGVhZCBvZiB0aGVcbiAgLy8gZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuICBTdXBwb3J0IG5vbi1zdHJpbmcga2V5cy5cblxuXG4gIGlmICh4IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB4KSB7XG4gICAgICAvLyBTdHJpbmdpZnkgd2lsbCBlc2NhcGUgYW55IG5lc3RlZCBxdW90ZXNcbiAgICAgIG9ialt0eXBlb2YgayA9PT0gJ3N0cmluZycgPyBrIDogc3RyaW5naWZ5KGssIG9wdCldID0gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KG9iaiwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBidWlsdC1pbiBTZXRzLCBzb3J0IHRoZSBrZXlzIGluIGEgc3RhYmxlIG9yZGVyIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxuXG5cbiAgaWYgKHggaW5zdGFuY2VvZiBTZXQpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5KEFycmF5LmZyb20oeCkuc29ydCgoYSwgYikgPT4gc3RyaW5naWZ5KGEsIG9wdCkubG9jYWxlQ29tcGFyZShzdHJpbmdpZnkoYiwgb3B0KSkpLCBvcHQsIGtleSk7XG4gIH0gLy8gQW55dGhpbmcgZWxzZSB0aGF0IGlzIGl0ZXJhYmxlIHNlcmlhbGl6ZSBhcyBhbiBBcnJheS5cblxuXG4gIGlmIChTeW1ib2wgIT09IHVuZGVmaW5lZCAmJiB4W1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gICAgcmV0dXJuIHN0cmluZ2lmeShBcnJheS5mcm9tKHgpLCBvcHQsIGtleSk7XG4gIH0gLy8gRm9yIGFsbCBvdGhlciBPYmplY3RzLCBzb3J0IHRoZSBrZXlzIGluIGEgc3RhYmxlIG9yZGVyLlxuXG5cbiAgcmV0dXJuIGB7JHtPYmplY3Qua2V5cyh4KS5maWx0ZXIoayA9PiB4W2tdICE9PSB1bmRlZmluZWQpLnNvcnQoKSAvLyBzdHJpbmdpZnkgdGhlIGtleSB0byBhZGQgcXVvdGVzIGFuZCBlc2NhcGUgYW55IG5lc3RlZCBzbGFzaGVzIG9yIHF1b3Rlcy5cbiAgLm1hcChrID0+IGAke3N0cmluZ2lmeShrLCBvcHQpfToke3N0cmluZ2lmeSh4W2tdLCBvcHQsIGspfWApLmpvaW4oJywnKX19YDtcbn0gLy8gVXRpbGl0eSBzaW1pbGFyIHRvIEpTT04uc3RyaW5naWZ5KCkgZXhjZXB0OlxuLy8gKiBTZXJpYWxpemUgYnVpbHQtaW4gU2V0cyBhcyBhbiBBcnJheVxuLy8gKiBTZXJpYWxpemUgYnVpbHQtaW4gTWFwcyBhcyBhbiBPYmplY3QuICBTdXBwb3J0cyBub24tc3RyaW5nIGtleXMuXG4vLyAqIFNlcmlhbGl6ZSBvdGhlciBpdGVyYWJsZXMgYXMgYXJyYXlzXG4vLyAqIFNvcnQgdGhlIGtleXMgb2YgT2JqZWN0cyBhbmQgTWFwcyB0byBoYXZlIGEgc3RhYmxlIG9yZGVyIGJhc2VkIG9uIHN0cmluZyBjb252ZXJzaW9uLlxuLy8gICAgVGhpcyBvdmVycmlkZXMgdGhlaXIgZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuXG4vLyAqIFN0aWxsIHVzZXMgdG9KU09OKCkgb2YgYW55IG9iamVjdCB0byBvdmVycmlkZSBzZXJpYWxpemF0aW9uXG4vLyAqIFN1cHBvcnQgU3ltYm9scyAodGhvdWdoIGRvbid0IGd1YXJhbnRlZSB1bmlxdWVuZXNzKVxuLy8gKiBXZSBjb3VsZCBzdXBwb3J0IEJpZ0ludCwgYnV0IEZsb3cgZG9lc24ndCBzZWVtIHRvIGxpa2UgaXQuXG4vLyBTZWUgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeS10ZXN0LmpzIGZvciBleGFtcGxlc1xuXG5cbmZ1bmN0aW9uIHN0YWJsZVN0cmluZ2lmeSh4LCBvcHQgPSB7XG4gIGFsbG93RnVuY3Rpb25zOiBmYWxzZVxufSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAwO1xuICAgICAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KHgsIG9wdCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogMDtcblxuICAgICAgaWYgKGVuZFRpbWUgLSBzdGFydFRpbWUgPiBUSU1FX1dBUk5JTkdfVEhSRVNIT0xEX01TKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy9uby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYFJlY29pbDogU3BlbnQgJHtlbmRUaW1lIC0gc3RhcnRUaW1lfW1zIGNvbXB1dGluZyBhIGNhY2hlIGtleWApO1xuICAgICAgICBjb25zb2xlLndhcm4oeCwgc3RyKTtcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGZiLXd3dy9uby1jb25zb2xlICovXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCBvcHQpO1xufVxuXG52YXIgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSA9IHN0YWJsZVN0cmluZ2lmeTtcblxuY29uc3Qge1xuICBUcmVlQ2FjaGU6IFRyZWVDYWNoZSQyXG59ID0gUmVjb2lsX1RyZWVDYWNoZSQxO1xuXG5cblxuXG5cblxuXG5cblxuY29uc3QgZGVmYXVsdFBvbGljeSA9IHtcbiAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnLFxuICBldmljdGlvbjogJ2tlZXAtYWxsJyxcbiAgbWF4U2l6ZTogSW5maW5pdHlcbn07XG5cbmZ1bmN0aW9uIHRyZWVDYWNoZUZyb21Qb2xpY3koe1xuICBlcXVhbGl0eSA9IGRlZmF1bHRQb2xpY3kuZXF1YWxpdHksXG4gIGV2aWN0aW9uID0gZGVmYXVsdFBvbGljeS5ldmljdGlvbixcbiAgbWF4U2l6ZSA9IGRlZmF1bHRQb2xpY3kubWF4U2l6ZVxufSA9IGRlZmF1bHRQb2xpY3ksIG5hbWUpIHtcbiAgY29uc3QgdmFsdWVNYXBwZXIgPSBnZXRWYWx1ZU1hcHBlcihlcXVhbGl0eSk7XG4gIHJldHVybiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIHZhbHVlTWFwcGVyLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIoZXF1YWxpdHkpIHtcbiAgc3dpdGNoIChlcXVhbGl0eSkge1xuICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICByZXR1cm4gdmFsID0+IHZhbDtcblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSh2YWwpO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGVxdWFsaXR5IHBvbGljeSAke2VxdWFsaXR5fWApO1xufVxuXG5mdW5jdGlvbiBnZXRUcmVlQ2FjaGUoZXZpY3Rpb24sIG1heFNpemUsIG1hcE5vZGVWYWx1ZSwgbmFtZSkge1xuICBzd2l0Y2ggKGV2aWN0aW9uKSB7XG4gICAgY2FzZSAna2VlcC1hbGwnOlxuICAgICAgcmV0dXJuIG5ldyBUcmVlQ2FjaGUkMih7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1hcE5vZGVWYWx1ZVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdscnUnOlxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXhTaXplOiBSZWNvaWxfbnVsbHRocm93cyhtYXhTaXplKSxcbiAgICAgICAgbWFwTm9kZVZhbHVlXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ21vc3QtcmVjZW50JzpcbiAgICAgIHJldHVybiBSZWNvaWxfdHJlZUNhY2hlTFJVKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWF4U2l6ZTogMSxcbiAgICAgICAgbWFwTm9kZVZhbHVlXG4gICAgICB9KTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBldmljdGlvbiBwb2xpY3kgJHtldmljdGlvbn1gKTtcbn1cblxudmFyIFJlY29pbF90cmVlQ2FjaGVGcm9tUG9saWN5ID0gdHJlZUNhY2hlRnJvbVBvbGljeTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgX293bmVyRG9jdW1lbnQsIF9kb2MkZGVmYXVsdFZpZXc7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZG9jID0gb2JqZWN0ICE9IG51bGwgPyAoX293bmVyRG9jdW1lbnQgPSBvYmplY3Qub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX293bmVyRG9jdW1lbnQgIT09IHZvaWQgMCA/IF9vd25lckRvY3VtZW50IDogb2JqZWN0IDogZG9jdW1lbnQ7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpICE9PSBudWxsICYmIF9kb2MkZGVmYXVsdFZpZXcgIT09IHZvaWQgMCA/IF9kb2MkZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgIT0gbnVsbCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxudmFyIFJlY29pbF9pc05vZGUgPSBpc05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWFjdE5hdGl2ZTogaXNSZWFjdE5hdGl2ZSQxLFxuICBpc1dpbmRvdzogaXNXaW5kb3ckMVxufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5mdW5jdGlvbiBzaG91bGROb3RCZUZyb3plbih2YWx1ZSkge1xuICAvLyBQcmltaXRpdmVzIGFuZCBmdW5jdGlvbnM6XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gUmVhY3QgZWxlbWVudHM6XG5cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZS4kJHR5cGVvZikge1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbW11dGFibGUgc3RydWN0dXJlczpcblxuXG4gIGlmICh2YWx1ZVsnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIERPTSBub2RlczpcblxuXG4gIGlmIChSZWNvaWxfaXNOb2RlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTb21lIGVudmlyb25tZW50cywganVzdCBhcyBKZXN0LCBkb24ndCB3b3JrIHdpdGggdGhlIGluc3RhbmNlb2YgY2hlY2tcblxuXG4gIGlmICghaXNSZWFjdE5hdGl2ZSQxICYmIGlzV2luZG93JDEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFJlY3Vyc2l2ZWx5IGZyZWV6ZSBhIHZhbHVlIHRvIGVuZm9yY2UgaXQgaXMgcmVhZC1vbmx5LlxuLy8gVGhpcyBtYXkgYWxzbyBoYXZlIG1pbmltYWwgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIGZvciBlbnVtZXJhdGluZ1xuLy8gb2JqZWN0cyAoYmFzZWQgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMsIG9mIGNvdXJzZSlcblxuXG5mdW5jdGlvbiBkZWVwRnJlZXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7IC8vIE1ha2UgYWxsIHByb3BlcnRpZXMgcmVhZC1vbmx5XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAvLyAkRmxvd0lzc3VlW21ldGhvZC11bmJpbmRpbmddIGFkZGVkIHdoZW4gaW1wcm92aW5nIHR5cGluZyBmb3IgdGhpcyBwYXJhbWV0ZXJzXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgY29uc3QgcHJvcCA9IHZhbHVlW2tleV07IC8vIFByZXZlbnQgaW5maW5pdGUgcmVjdXJzc2lvbiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiBwcm9wICE9IG51bGwgJiYgIU9iamVjdC5pc0Zyb3plbihwcm9wKSkge1xuICAgICAgICBkZWVwRnJlZXplVmFsdWUocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LnNlYWwodmFsdWUpOyAvLyBUaGlzIGFsc28gbWFrZXMgZXhpc3RpbmcgcHJvcGVydGllcyBub24tY29uZmlndXJhYmxlLlxufVxuXG52YXIgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSA9IGRlZXBGcmVlemVWYWx1ZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBUaGlzIGlzIGEgc3R1YiBmb3Igc29tZSBpbnRlZ3JhdGlvbiBpbnRvIEZCIGludGVybmFsIHN0dWZmXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5mdW5jdGlvbiBzdGFydFBlcmZCbG9jayhfaWQpIHtcbiAgcmV0dXJuICgpID0+IG51bGw7XG59XG5cbnZhciBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzID0ge1xuICBzdGFydFBlcmZCbG9ja1xufTtcblxuY29uc3Qge1xuICBpc0xvYWRhYmxlOiBpc0xvYWRhYmxlJDEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBsb2FkYWJsZVdpdGhFcnJvciQxLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDEsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQyXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgV3JhcHBlZFZhbHVlOiBXcmFwcGVkVmFsdWUkMVxufSA9IFJlY29pbF9XcmFwcGVyJDE7XG5cblxuXG5jb25zdCB7XG4gIGdldE5vZGVMb2FkYWJsZTogZ2V0Tm9kZUxvYWRhYmxlJDIsXG4gIHBlZWtOb2RlTG9hZGFibGU6IHBlZWtOb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkM1xufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBzYXZlRGVwc1RvU3RvcmU6IHNhdmVEZXBzVG9TdG9yZSQxXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQ2LFxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgcmVjb2lsQ2FsbGJhY2s6IHJlY29pbENhbGxiYWNrJDFcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgc3RhcnRQZXJmQmxvY2s6IHN0YXJ0UGVyZkJsb2NrJDFcbn0gPSBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzO1xuXG5cblxuY2xhc3MgQ2FuY2VsZWQge31cblxuY29uc3QgQ0FOQ0VMRUQgPSBuZXcgQ2FuY2VsZWQoKTtcbi8qKlxuICogQW4gRXhlY3V0aW9uSUQgaXMgYW4gYXJiaXRyYXJ5IElEIHRoYXQgbGV0cyB1cyBkaXN0aW5ndWlzaCBleGVjdXRpb25zIGZyb21cbiAqIGVhY2ggb3RoZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdlIG5lZWQgYSB3YXkgb2Ygc29sdmluZyB0aGlzIHByb2JsZW06XG4gKiBcImdpdmVuIDMgYXN5bmMgZXhlY3V0aW9ucywgb25seSB1cGRhdGUgc3RhdGUgZm9yIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24gd2hlblxuICogaXQgZmluaXNoZXMgcnVubmluZyByZWdhcmRsZXNzIG9mIHdoZW4gdGhlIG90aGVyIDIgZmluaXNoXCIuIEV4ZWN1dGlvbklEc1xuICogcHJvdmlkZSBhIGNvbnZlbmllbnQgd2F5IG9mIGlkZW50aWZ5aW5nIGV4ZWN1dGlvbnMgc28gdGhhdCB3ZSBjYW4gdHJhY2sgYW5kXG4gKiBtYW5hZ2UgdGhlbSBvdmVyIHRpbWUuXG4gKi9cblxuY29uc3QgZGVwZW5kZW5jeVN0YWNrID0gW107IC8vIGZvciBkZXRlY3RpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuXG5jb25zdCB3YWl0aW5nU3RvcmVzID0gbmV3IE1hcCgpO1xuXG5jb25zdCBnZXROZXdFeGVjdXRpb25JRCA9ICgoKSA9PiB7XG4gIGxldCBleGVjdXRpb25JRCA9IDA7XG4gIHJldHVybiAoKSA9PiBleGVjdXRpb25JRCsrO1xufSkoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5cbmZ1bmN0aW9uIHNlbGVjdG9yKG9wdGlvbnMpIHtcbiAgbGV0IHJlY29pbFZhbHVlID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBnZXQsXG4gICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IGNhY2hlUG9saWN5XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZXQgPSBvcHRpb25zLnNldCAhPSBudWxsID8gb3B0aW9ucy5zZXQgOiB1bmRlZmluZWQ7IC8vIGZsb3dcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdBIGtleSBvcHRpb24gd2l0aCBhIHVuaXF1ZSBzdHJpbmcgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIGEgc2VsZWN0b3IuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NlbGVjdG9ycyBtdXN0IHNwZWNpZnkgYSBnZXQgY2FsbGJhY2sgb3B0aW9uIHRvIGdldCB0aGUgc2VsZWN0b3IgdmFsdWUuJyk7XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgZXZlcnkgZGlzY292ZXJlZCBkZXBlbmRlbmN5IGFjcm9zcyBhbGwgZXhlY3V0aW9uc1xuXG5cbiAgY29uc3QgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgY2FjaGUgPSBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeShjYWNoZVBvbGljeSAhPT0gbnVsbCAmJiBjYWNoZVBvbGljeSAhPT0gdm9pZCAwID8gY2FjaGVQb2xpY3kgOiB7XG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0sIGtleSk7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMShvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUpO1xuICBjb25zdCBleGVjdXRpb25JbmZvTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcblxuICBmdW5jdGlvbiBzZWxlY3RvcklzTGl2ZSgpIHtcbiAgICByZXR1cm4gIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgfHwgbGl2ZVN0b3Jlc0NvdW50ID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySW5pdChzdG9yZSkge1xuICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuYWRkKGtleSk7XG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpdmVTdG9yZXNDb3VudC0tO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSgpIHtcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoa2V5KSAhPT0gdW5kZWZpbmVkICYmICFzZWxlY3RvcklzTGl2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcbiAgICBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgfVxuXG4gICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBzdG9yZXMgdG8gcHVsbCB0aGUgc2VsZWN0b3IgYWdhaW4gaWYgYSBuZXcgYXN5bmMgZGVwIHdhcyBkaXNjb3ZlcmVkLlxuICAgKiAxKSBBc3luYyBzZWxlY3RvciBhZGRzIGEgbmV3IGRlcCBidXQgZG9lc24ndCByZXNvbHZlIHlldC5cbiAgICogICAgTm90ZSB0aGF0IGRlcHMgZm9yIGFuIGFzeW5jIHNlbGVjdG9yIGFyZSBiYXNlZCBvbiB0aGUgc3RhdGUgd2hlbiB0aGVcbiAgICogICAgZXZhbHVhdGlvbiBzdGFydGVkLCBpbiBvcmRlciB0byBwcm92aWRlIGEgY29uc2lzdGVudCBwaWN0dXJlIG9mIHN0YXRlLlxuICAgKiAyKSBCdXQsIG5ldyB2YWx1ZSBvZiBkZXAgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgbWlnaHQgY2F1c2UgdGhlIHNlbGVjdG9yXG4gICAqICAgIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBkaWZmZXJlbnRseS5cbiAgICogMykgVGhlcmVmb3JlLCB0aGlzIG5vdGlmaWNhdGlvbiB3aWxsIHB1bGwgdGhlIHNlbGVjdG9yIGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAqICAgIHN0YXRlIGZvciB0aGUgY29tcG9uZW50c1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBSZWNvaWxfbnVsbHRocm93cyhnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSk7XG4gICAgICBleGVjdXRpb25JbmZvLnN0YXRlVmVyc2lvbnMuY2xlYXIoKTtcbiAgICAgIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCBjbGVhcldhaXRsaXN0KSB7XG4gICAgY29uc3Qgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xuXG4gICAgaWYgKHN0b3JlcyAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IHdhaXRpbmdTdG9yZSBvZiBzdG9yZXMpIHtcbiAgICAgICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMSh3YWl0aW5nU3RvcmUsIFJlY29pbF9udWxsdGhyb3dzKHJlY29pbFZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGVhcldhaXRsaXN0KSB7XG4gICAgICAgIHdhaXRpbmdTdG9yZXMuZGVsZXRlKGV4ZWN1dGlvbklEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBsZXQgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xuXG4gICAgaWYgKHN0b3JlcyA9PSBudWxsKSB7XG4gICAgICB3YWl0aW5nU3RvcmVzLnNldChleGVjdXRpb25JRCwgc3RvcmVzID0gbmV3IFNldCgpKTtcbiAgICB9XG5cbiAgICBzdG9yZXMuYWRkKHN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiByZXR1cm5lZCBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKSAoZWl0aGVyIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBieVxuICAgKiBydW5uaW5nIGEgZnVuY3Rpb24gdGhhdCB1c2VzIHRoZSBcImFzeW5jXCIga2V5d29yZCkuIElmIGEgc2VsZWN0b3IncyBnZXQoKVxuICAgKiByZXR1cm5zIGEgcHJvbWlzZSwgd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcbiAgICpcbiAgICogMS4gVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgaGF2ZSBjb21wbGV0ZWx5IGZpbmlzaGVkXG4gICAqICAgIGV4ZWN1dGluZyB3aXRob3V0IGFueSByZW1haW5pbmcgcGVuZGluZyBkZXBlbmRlbmNpZXMuIE5vIG1vcmUgcmV0cmllc1xuICAgKiAgICBhcmUgbmVlZGVkIGFuZCB3ZSBjYW4gcHJvY2VlZCB3aXRoIHVwZGF0aW5nIHRoZSBjYWNoZSBhbmQgbm90aWZ5aW5nXG4gICAqICAgIHN1YnNjcmliZXJzIChpZiBpdCBpcyB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiwgb3RoZXJ3aXNlIG9ubHkgdGhlIGNhY2hlXG4gICAqICAgIHdpbGwgYmUgdXBkYXRlZCBhbmQgc3Vic2NyaXB0aW9ucyB3aWxsIG5vdCBiZSBmaXJlZCkuIFRoaXMgaXMgdGhlIGNhc2VcbiAgICogICAgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXG4gICAqXG4gICAqIDIuIFRoZSBwcm9taXNlIHdpbGwgdGhyb3cgYmVjYXVzZSBpdCBlaXRoZXIgaGFzIGFuIGVycm9yIG9yIGl0IGNhbWUgYWNyb3NzXG4gICAqICAgIGFuIGFzeW5jIGRlcGVuZGVuY3kgdGhhdCBoYXMgbm90IHlldCByZXNvbHZlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsXG4gICAqICAgIGNhbGwgd3JhcERlcGRlbmN5UHJvbWlzZSgpLCB3aG9zZSByZXNwb25zaWJpbGl0eSBpcyB0byBoYW5kbGUgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlcy4gVGhpcyBjYXNlIGlzIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIGNhdGNoKCkgaGFuZGxlci5cbiAgICpcbiAgICogQm90aCBicmFuY2hlcyB3aWxsIGV2ZW50dWFsbHkgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZSBzZWxlY3RvclxuICAgKiAob3IgYW4gZXJyb3IgaWYgYSByZWFsIGVycm9yIG9jY3VycmVkKS5cbiAgICpcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcbiAgICogd2lsbCBiZSBjYWNoZWQuIEJ1dCBzdGFsZSBleGVjdXRpb25zIHdpbGwgbm90IHVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgdXBkYXRlXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgcGFzc2VkIGEgcHJvbWlzZSB0aGF0IHdhcyB0aHJvd24tLUFLQSBhXG4gICAqIGRlcGVuZGVuY3kgcHJvbWlzZS4gRGVwZW5kZW5jeSBwcm9taXNlcyBzaG91bGQgYmUgcGFzc2VkIHRvXG4gICAqIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2UoKSkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcFJlc3VsdFByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMih2YWx1ZSk7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3JPclByb21pc2UgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShlcnJvck9yUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIGVycm9yT3JQcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvck9yUHJvbWlzZSk7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICB0aHJvdyBlcnJvck9yUHJvbWlzZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiB0aHJvd24gZnJvbSBhIHNlbGVjdG9yJ3MgZ2V0KCkuIElmIGEgc2VsZWN0b3IncyBnZXQoKSB0aHJvd3MgYSBwcm9taXNlLFxuICAgKiB3ZSBoYXZlIHR3byBwb3NzaWJpbGl0aWVzOlxuICAgKlxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIG1lYW5pbmcgb25lIG9mIG91ciBzZWxlY3RvcidzIGRlcGVuZGVuY2llcyBpc1xuICAgKiAgICBub3cgYXZhaWxhYmxlIGFuZCB3ZSBzaG91bGQgXCJyZXRyeVwiIG91ciBnZXQoKSBieSBydW5uaW5nIGl0IGFnYWluLiBUaGlzXG4gICAqICAgIGlzIHRoZSBjYXNlIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxuICAgKlxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2Ugc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlIChpbiBvdGhlciB3b3JkcyBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieVxuICAgKiAgICB0aGUgYXR0YWNoZWQgY2F0Y2goKSBoYW5kbGVyLiBJZiB0aGUgZGVwZW5kZW5jeSBwcm9taXNlIHRocm93cywgaXQgaXNcbiAgICogICAgX2Fsd2F5c18gYSByZWFsIGVycm9yIGFuZCBub3QgYW5vdGhlciBkZXBlbmRlbmN5IHByb21pc2UgKGFueSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2VzIHdvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIHVwc3RyZWFtKS5cbiAgICpcbiAgICogVGhlIHRoZW4oKSBicmFuY2ggd2lsbCBldmVudHVhbGx5IHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGVcbiAgICogc2VsZWN0b3IgKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnMpLCBhbmQgdGhlIGNhdGNoKCkgd2lsbCBhbHdheXNcbiAgICogcmVzb2x2ZSB0byBhbiBlcnJvciBiZWNhdXNlIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgaXMgYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHdyYXBwZWQgdXBzdHJlYW0sIG1lYW5pbmcgaXQgd2lsbCBvbmx5IHJlc29sdmUgdG8gaXRzIHJlYWwgdmFsdWUgb3IgdG8gYVxuICAgKiByZWFsIGVycm9yLlxuICAgKlxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcbiAgICogZXhlY3V0aW9uSW5mbyBhcyB0aGF0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb21cbiAgICogZ2V0KCkuIFRoZSBpbnRlbnRpb24gaXMgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgcGFzc2VkIHByb21pc2VzIHRoYXRcbiAgICogd2VyZSB0aHJvd24gZHVlIHRvIGEgcGVuZGluZyBkZXBlbmRlbmN5LiBQcm9taXNlcyByZXR1cm5lZCBieSBnZXQoKSBzaG91bGRcbiAgICogYmUgcGFzc2VkIHRvIHdyYXBSZXN1bHRQcm9taXNlKCkgaW5zdGVhZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZXhpc3RpbmdEZXBzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVzb2x2ZWREZXAgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgaGFuZGxpbmcgYSBwZW5kaW5nIFJlY29pbCBkZXBlbmRlbmN5IG9yIGlmIHRoZSB1c2VyXG4gICAgICAvLyB0aHJldyB0aGVpciBvd24gUHJvbWlzZSB0byBcInN1c3BlbmRcIiBhIHNlbGVjdG9yIGV2YWx1YXRpb24uICBXZSBuZWVkXG4gICAgICAvLyB0byBjaGVjayB0aGF0IHRoZSBsb2FkaW5nRGVwUHJvbWlzZSBhY3R1YWxseSBtYXRjaGVzIHRoZSBwcm9taXNlIHRoYXRcbiAgICAgIC8vIHdlIGNhdWdodCBpbiBjYXNlIHRoZSBzZWxlY3RvciBoYXBwZW5lZCB0byBjYXRjaCB0aGUgcHJvbWlzZSB3ZSB0aHJld1xuICAgICAgLy8gZm9yIGEgcGVuZGluZyBSZWNvaWwgZGVwZW5kZW5jeSBmcm9tIGBnZXRSZWNvaWxWYWx1ZSgpYCBhbmQgdGhyZXdcbiAgICAgIC8vIHRoZWlyIG93biBwcm9taXNlIGluc3RlYWQuXG5cblxuICAgICAgaWYgKGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSAhPSBudWxsICYmIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPT09IHByb21pc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGUgZm9yIGFzeW5jIGF0b21zLCB0aGlzIG1lYW5zIHdlIGFyZSBjaGFuZ2luZyB0aGUgYXRvbSdzIHZhbHVlXG4gICAgICAgICAqIGluIHRoZSBzdG9yZSBmb3IgdGhlIGdpdmVuIHZlcnNpb24uIFRoaXMgc2hvdWxkIGJlIGFscmlnaHQgYmVjYXVzZVxuICAgICAgICAgKiB0aGUgdmVyc2lvbiBvZiBzdGF0ZSBpcyBub3cgc3RhbGUgYW5kIGEgbmV3IHZlcnNpb24gd2lsbCBoYXZlXG4gICAgICAgICAqIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQgYnkgdGhlIGF0b20gYmVpbmcgcmVzb2x2ZWQgKHNlZSB0aGlzIGxvZ2ljXG4gICAgICAgICAqIGluIFJlY29pbF9hdG9tLmpzKVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQobG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5LCBsb2FkYWJsZVdpdGhWYWx1ZSQyKHJlc29sdmVkRGVwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcmVzb2x2ZWREZXBLZXkgaXMgbm90IGRlZmluZWQsIHRoZSBwcm9taXNlIHdhcyBhIHVzZXItdGhyb3duXG4gICAgICAgICAqIHByb21pc2UuIFVzZXItdGhyb3duIHByb21pc2VzIGFyZSBhbiBhZHZhbmNlZCBmZWF0dXJlIGFuZCB0aGV5XG4gICAgICAgICAqIHNob3VsZCBiZSBhdm9pZGVkIGluIGFsbW9zdCBhbGwgY2FzZXMuIFVzaW5nIGBsb2FkYWJsZS5tYXAoKWAgaW5zaWRlXG4gICAgICAgICAqIG9mIHNlbGVjdG9ycyBmb3IgbG9hZGluZyBsb2FkYWJsZXMgYW5kIHRoZW4gdGhyb3dpbmcgdGhhdCBtYXBwZWRcbiAgICAgICAgICogbG9hZGFibGUncyBwcm9taXNlIGlzIGFuIGV4YW1wbGUgb2YgYSB1c2VyLXRocm93biBwcm9taXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHdlIGhpdCBhIHVzZXItdGhyb3duIHByb21pc2UsIHdlIGhhdmUgdG8gYmFpbCBvdXQgb2YgYW4gb3B0aW1pemF0aW9uXG4gICAgICAgICAqIHdoZXJlIHdlIGJ5cGFzcyBjYWxjdWxhdGluZyBzZWxlY3RvciBjYWNoZSBrZXlzIGZvciBzZWxlY3RvcnMgdGhhdFxuICAgICAgICAgKiBoYXZlIGJlZW4gcHJldmlvdXNseSBzZWVuIGZvciBhIGdpdmVuIHN0YXRlICh0aGVzZSBzZWxlY3RvcnMgYXJlIHNhdmVkIGluXG4gICAgICAgICAqIHN0YXRlLmF0b21WYWx1ZXMpIHRvIGF2b2lkIHN0YWxlIHN0YXRlIGFzIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmdcbiAgICAgICAgICogd2hhdCBzdGF0ZSBjaGFuZ2VzIGhhcHBlbmVkIChpZiBhbnkpIGluIHJlc3VsdCB0byB0aGUgcHJvbWlzZSByZXNvbHZpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElkZWFsbHkgd2Ugd291bGQgb25seSBiYWlsIG91dCBzZWxlY3RvcnMgdGhhdCBhcmUgaW4gdGhlIGNoYWluIG9mXG4gICAgICAgICAqIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBzZWxlY3RvciwgYnV0IHRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBnZXRcbiAgICAgICAgICogYSBmdWxsIGxpc3Qgb2YgYSBzZWxlY3RvcidzIGRvd25zdHJlYW0gbm9kZXMgYmVjYXVzZSB0aGUgc3RhdGUgdGhhdFxuICAgICAgICAgKiBpcyBleGVjdXRpbmcgbWF5IGJlIGEgZGlzY2FyZGVkIHRyZWUgKHNvIHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pXG4gICAgICAgICAqIHdpbGwgYmUgZW1wdHkpLCBhbmQgdGhlIGZ1bGwgZGVwIHRyZWUgbWF5IG5vdCBiZSBpbiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICogY2FjaGVzIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3RvcidzIGNhY2hlIHdhcyBjbGVhcmVkLiBUbyBzb2x2ZVxuICAgICAgICAgKiBmb3IgdGhpcyB3ZSB3b3VsZCBoYXZlIHRvIGtlZXAgdHJhY2sgb2YgYWxsIHJ1bm5pbmcgc2VsZWN0b3JcbiAgICAgICAgICogZXhlY3V0aW9ucyBhbmQgdGhlaXIgZG93bnN0cmVhbSBkZXBzLiBCZWNhdXNlIHRoaXMgb25seSBjb3ZlcnMgZWRnZVxuICAgICAgICAgKiBjYXNlcywgdGhhdCBjb21wbGV4aXR5IG1pZ2h0IG5vdCBiZSBqdXN0aWZ5YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuZm9yRWFjaChub2RlS2V5ID0+IHtcbiAgICAgICAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9wdGltaXphdGlvbjogTm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkLCBsZXQncyB0cnkgaGl0dGluZ1xuICAgICAgICogdGhlIGNhY2hlIGluIGNhc2UgdGhlIGRlcCByZXNvbHZlZCB0byBhIHZhbHVlIHdlIGhhdmUgcHJldmlvdXNseSBzZWVuLlxuICAgICAgICpcbiAgICAgICAqIFRPRE86XG4gICAgICAgKiBOb3RlIHRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBwZXJmZWN0IGJlY2F1c2UgaXQgb25seSBwcmV2ZW50cyByZS1leGVjdXRpb25zXG4gICAgICAgKiBfYWZ0ZXJfIHRoZSBwb2ludCB3aGVyZSBhbiBhc3luYyBkZXBlbmRlbmN5IGlzIGZvdW5kLiBBbnkgY29kZSBsZWFkaW5nXG4gICAgICAgKiB1cCB0byB0aGUgYXN5bmMgZGVwZW5kZW5jeSBtYXkgaGF2ZSBydW4gdW5uZWNlc3NhcmlseS4gVGhlIGlkZWFsIGNhc2VcbiAgICAgICAqIHdvdWxkIGJlIHRvIHdhaXQgZm9yIHRoZSBhc3luYyBkZXBlbmRlbmN5IHRvIHJlc29sdmUgZmlyc3QsIGNoZWNrIHRoZVxuICAgICAgICogY2FjaGUsIGFuZCBwcmV2ZW50IF9hbnlfIGV4ZWN1dGlvbiBvZiB0aGUgc2VsZWN0b3IgaWYgdGhlIHJlc3VsdGluZ1xuICAgICAgICogdmFsdWUgb2YgdGhlIGRlcGVuZGVuY3kgbGVhZHMgdG8gYSBwYXRoIHRoYXQgaXMgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgICAgICogVGhlIGlkZWFsIGNhc2UgaXMgbW9yZSBkaWZmaWN1bHQgdG8gaW1wbGVtZW50IGFzIGl0IHdvdWxkIHJlcXVpcmUgdGhhdFxuICAgICAgICogd2UgY2FwdHVyZSBhbmQgd2FpdCBmb3IgdGhlIHRoZSBhc3luYyBkZXBlbmRlbmN5IHJpZ2h0IGFmdGVyIGNoZWNraW5nXG4gICAgICAgKiB0aGUgY2FjaGUuIFRoZSBjdXJyZW50IGFwcHJvYWNoIHRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHJ1bm5pbmdcbiAgICAgICAqIHRoZSBzZWxlY3RvciBhbHJlYWR5IGhhcyBhIGNvZGUgcGF0aCB0aGF0IGxldHMgdXMgZXhpdCBlYXJseSB3aGVuXG4gICAgICAgKiBhbiBhc3luYyBkZXAgcmVzb2x2ZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBjYWNoZWRMb2FkYWJsZSA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgICBpZiAoY2FjaGVkTG9hZGFibGUgJiYgY2FjaGVkTG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBoYXMgdG8gbm90aWZ5IHN0b3JlcyBvZiBhIHJlc29sdmVkIGFzeW5jLCBldmVuIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgICAqIGN1cnJlbnQgcGVuZGluZyBleGVjdXRpb24gZm9yIHRoZSBmb2xsb3dpbmcgY2FzZTpcbiAgICAgICAgICogMSkgQSBjb21wb25lbnQgcmVuZGVycyB3aXRoIHRoaXMgcGVuZGluZyBsb2FkYWJsZS5cbiAgICAgICAgICogMikgVGhlIHVwc3RyZWFtIGRlcGVuZGVuY3kgcmVzb2x2ZXMuXG4gICAgICAgICAqIDMpIFdoaWxlIHByb2Nlc3Npbmcgc29tZSBvdGhlciBzZWxlY3RvciBpdCByZWFkcyB0aGlzIG9uZSwgc3VjaCBhc1xuICAgICAgICAgKiAgICB3aGlsZSB0cmF2ZXJzaW5nIGl0cyBkZXBlbmRlbmNpZXMuICBBdCB0aGlzIHBvaW50IGl0IGdldHMgdGhlXG4gICAgICAgICAqICAgIG5ldyByZXNvbHZlZCB2YWx1ZSBzeW5jaHJvbm91c2x5IGFuZCBjbGVhcnMgdGhlIGN1cnJlbnRcbiAgICAgICAgICogICAgZXhlY3V0aW9uIElELiAgVGhlIGNvbXBvbmVudCB3YXNuJ3QgZ2V0dGluZyB0aGUgdmFsdWUgaXRzZWxmLFxuICAgICAgICAgKiAgICB0aG91Z2gsIHNvIGl0IHN0aWxsIGhhcyB0aGUgcGVuZGluZyBsb2FkYWJsZS5cbiAgICAgICAgICogNCkgV2hlbiB0aGlzIGNvZGUgZXhlY3V0ZXMgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGlkIHdhcyBjbGVhcmVkXG4gICAgICAgICAqICAgIGFuZCBpdCB3b3VsZG4ndCBub3RpZnkgdGhlIGNvbXBvbmVudCBvZiB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJIHRoaW5rIHRoaXMgaXMgb25seSBhbiBpc3N1ZSB3aXRoIFwiZWFybHlcIiByZW5kZXJpbmcgc2luY2UgdGhlXG4gICAgICAgICAqIGNvbXBvbmVudHMgZ290IHRoZWlyIHZhbHVlIHVzaW5nIHRoZSBpbi1wcm9ncmVzcyBleGVjdXRpb24uXG4gICAgICAgICAqIFdlIGRvbid0IGhhdmUgYSB1bml0IHRlc3QgZm9yIHRoaXMgY2FzZSB5ZXQuICBJJ20gbm90IHN1cmUgaXQgaXNcbiAgICAgICAgICogbmVjZXNzYXJ5IHdpdGggcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkgfHwgZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkgPT0gbnVsbCkge1xuICAgICAgICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoaXMgZXhlY3V0aW9uIGlzIHN0YWxlLCBsZXQncyBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgc29tZSBpblxuICAgICAgICogcHJvZ3Jlc3MgZXhlY3V0aW9uIHdpdGggYSBtYXRjaGluZyBzdGF0ZS4gSWYgd2UgZmluZCBhIG1hdGNoLCB0aGVuXG4gICAgICAgKiB3ZSBjYW4gdGFrZSB0aGUgdmFsdWUgZnJvbSB0aGF0IGluLXByb2dyZXNzIGV4ZWN1dGlvbi4gTm90ZSB0aGlzIG1heVxuICAgICAgICogc291bmQgbGlrZSBhbiBlZGdlIGNhc2UsIGJ1dCBtYXkgYmUgdmVyeSBjb21tb24gaW4gY2FzZXMgd2hlcmUgYVxuICAgICAgICogbG9hZGluZyBkZXBlbmRlbmN5IHJlc29sdmVzIGZyb20gbG9hZGluZyB0byBoYXZpbmcgYSB2YWx1ZSAodGh1c1xuICAgICAgICogcG9zc2libHkgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciksIGFuZCBSZWFjdCByZS1yZW5kZXJzIGJlZm9yZSB0aGVcbiAgICAgICAqIGNoYWluZWQgLnRoZW4oKSBmdW5jdGlvbnMgcnVuLCB0aHVzIHN0YXJ0aW5nIGEgbmV3IGV4ZWN1dGlvbiBhcyB0aGVcbiAgICAgICAqIGRlcCBoYXMgY2hhbmdlZCB2YWx1ZS4gV2l0aG91dCB0aGlzIGNoZWNrIHdlIHdpbGwgcnVuIHRoZSBzZWxlY3RvclxuICAgICAgICogdHdpY2UgKG9uY2UgaW4gdGhlIG5ldyBleGVjdXRpb24gYW5kIG9uY2UgYWdhaW4gaW4gdGhpcyAudGhlbigpLCBzb1xuICAgICAgICogdGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8ga2VlcCB1bm5lY2Vzc2FyeSByZS1leGVjdXRpb25zIHRvIGFcbiAgICAgICAqIG1pbmltdW0pLlxuICAgICAgICpcbiAgICAgICAqIEFsc28gbm90ZSB0aGlzIGNvZGUgZG9lcyBub3QgY2hlY2sgYWNyb3NzIGFsbCBleGVjdXRpb25zIHRoYXQgbWF5IGJlXG4gICAgICAgKiBydW5uaW5nLiBJdCBvbmx5IG9wdGltaXplcyBmb3IgdGhlIF9sYXRlc3RfIGV4ZWN1dGlvbiBwZXIgc3RvcmUgYXNcbiAgICAgICAqIHdlIGN1cnJlbnRseSBkbyBub3QgbWFpbnRhaW4gYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgcnVubmluZyBleGVjdXRpb25zLlxuICAgICAgICogVGhpcyBtZWFucyBpbiBzb21lIGNhc2VzIHdlIG1heSBydW4gc2VsZWN0b3JzIG1vcmUgdGhhbiBzdHJpY3RseVxuICAgICAgICogbmVjZXNzYXJ5IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGV4ZWN1dGlvbnMgcnVubmluZyBmb3IgdGhlIHNhbWVcbiAgICAgICAqIHNlbGVjdG9yLiBUaGlzIG1heSBiZSBhIHZhbGlkIHRyYWRlb2ZmIGFzIGNoZWNraW5nIGZvciBkZXAgY2hhbmdlc1xuICAgICAgICogYWNyb3NzIGFsbCBpbi1wcm9ncmVzcyBleGVjdXRpb25zIG1heSB0YWtlIGxvbmdlciB0aGFuIGp1c3RcbiAgICAgICAqIHJlLXJ1bm5pbmcgdGhlIHNlbGVjdG9yLiBUaGlzIHdpbGwgYmUgYXBwLWRlcGVuZGVudCwgYW5kIG1heWJlIGluIHRoZVxuICAgICAgICogZnV0dXJlIHdlIGNhbiBtYWtlIHRoZSBiZWhhdmlvciBjb25maWd1cmFibGUuIEFuIGlkZWFsIGZpeCBtYXkgYmVcbiAgICAgICAqIHRvIGV4dGVuZCB0aGUgdHJlZSBjYWNoZSB0byBzdXBwb3J0IGNhY2hpbmcgbG9hZGluZyBzdGF0ZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoIWlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJldHVybmluZyBwcm9taXNlIGhlcmUgd2l0aG91dCB3cmFwcGluZyBhcyB0aGUgd3JhcHBlciBsb2dpYyB3YXNcbiAgICAgICAgICAgKiBhbHJlYWR5IGRvbmUgdXBzdHJlYW0gd2hlbiB0aGlzIHByb21pc2Ugd2FzIGdlbmVyYXRlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZXR1cm4gZXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0cnkgdGhlIHNlbGVjdG9yIGV2YWx1YXRpb24gbm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkXG5cblxuICAgICAgY29uc3QgW2xvYWRhYmxlLCBkZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKTtcblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ2FuY2VsZWQpIHtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKGVycm9yKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZXhpc3RpbmdEZXBzKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIGRlcHMsIGV4ZWN1dGlvbklEKSB7XG4gICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSwgX3N0b3JlJGdldFN0YXRlJGN1cnJlLCBfc3RvcmUkZ2V0U3RhdGUyLCBfc3RvcmUkZ2V0U3RhdGUyJG5leHQ7XG5cbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSA9IF9zdG9yZSRnZXRTdGF0ZS5jdXJyZW50VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJGN1cnJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkY3VycmUudmVyc2lvbikgfHwgc3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmUkZ2V0U3RhdGUyID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTIkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTIubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTIkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMiRuZXh0LnZlcnNpb24pKSB7XG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUzLCBfc3RvcmUkZ2V0U3RhdGUzJG5leHQ7XG5cbiAgICAgIHNhdmVEZXBzVG9TdG9yZSQxKGtleSwgZGVwcywgc3RvcmUsIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSAoX3N0b3JlJGdldFN0YXRlMyA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUzJG5leHQgPSBfc3RvcmUkZ2V0U3RhdGUzLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUzJG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dC52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUudmVyc2lvbik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRlcHMpIHtcbiAgICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuYWRkKG5vZGVLZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCkge1xuICAgIGNvbnN0IGVuZFBlcmZCbG9jayA9IHN0YXJ0UGVyZkJsb2NrJDEoa2V5KTsgLy8gVE9ETyBUNjM5NjU4NjY6IHVzZSBleGVjdXRpb24gSUQgaGVyZVxuXG4gICAgbGV0IGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcbiAgICBsZXQgZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZpbmlzaEV2YWx1YXRpb24gPSAoKSA9PiB7XG4gICAgICBlbmRQZXJmQmxvY2soKTtcbiAgICAgIGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCByZXN1bHRJc0Vycm9yID0gZmFsc2U7XG4gICAgbGV0IGxvYWRhYmxlO1xuICAgIGNvbnN0IGxvYWRpbmdEZXBzU3RhdGUgPSB7XG4gICAgICBsb2FkaW5nRGVwS2V5OiBudWxsLFxuICAgICAgbG9hZGluZ0RlcFByb21pc2U6IG51bGxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIGEgZnJlc2ggc2V0IG9mIGRlcHMgdGhhdCB3ZSdsbCBiZSB1c2luZyB0byB1cGRhdGUgc3RhdGUuIFdlJ3JlXG4gICAgICogc3RhcnRpbmcgYSBuZXcgc2V0IHZlcnN1cyBhZGRpbmcgaXQgaW4gZXhpc3Rpbmcgc3RhdGUgZGVwcyBiZWNhdXNlXG4gICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgdGhhdCB3ZSB1cGRhdGUgZGVwcyBmb3IgbWF5IGJlIGEgbW9yZSByZWNlbnQgdmVyc2lvblxuICAgICAqIHRoYW4gdGhlIHZlcnNpb24gdGhlIHNlbGVjdG9yIHdhcyBjYWxsZWQgd2l0aC4gVGhpcyBpcyBiZWNhdXNlIHRoZSBsYXRlc3RcbiAgICAgKiBleGVjdXRpb24gd2lsbCB1cGRhdGUgdGhlIGRlcHMgb2YgdGhlIGN1cnJlbnQvbGF0ZXN0IHZlcnNpb24gb2Ygc3RhdGVcbiAgICAgKiAoVGhpcyBpcyBzYWZlIHRvIGRvIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCB0aGUgc2VsZWN0b3IgaXMgdGhlIGxhdGVzdFxuICAgICAqIGV4ZWN1dGlvbiBtZWFucyB0aGUgZGVwcyB3ZSBkaXNjb3ZlciBiZWxvdyBhcmUgb3VyIGJlc3QgZ3Vlc3MgYXQgdGhlXG4gICAgICogZGVwcyBmb3IgdGhlIGN1cnJlbnQvbGF0ZXN0IHN0YXRlIGluIHRoZSBzdG9yZSlcbiAgICAgKi9cblxuICAgIGNvbnN0IGRlcFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcbiAgICAgIGtleTogZGVwS2V5XG4gICAgfSkge1xuICAgICAgY29uc3QgZGVwTG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XG4gICAgICBkZXBWYWx1ZXMuc2V0KGRlcEtleSwgZGVwTG9hZGFibGUpOyAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBhc3luY2hyb25vdXMgZGVwZW5kZW5jaWVzIGFzIHdlIGdvIHNvIHRoZSBzZWxlY3RvclxuICAgICAgLy8ga25vd3MgaWYgaXQgaGFzIHRvIHJlc3RhcnQgZXZhbHVhdGlvbiBpZiBvbmUgb2YgdGhlbSBpcyB1cGRhdGVkIGJlZm9yZVxuICAgICAgLy8gdGhlIGFzeW5jaHJvbm91cyBzZWxlY3RvciBjb21wbGV0ZWx5IHJlc29sdmVzLlxuXG4gICAgICBpZiAoIWR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uKSB7XG4gICAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XG4gICAgICAgIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChkZXBMb2FkYWJsZS5zdGF0ZSkge1xuICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XG4gICAgICAgICAgcmV0dXJuIGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcbiAgICAgICAgICB0aHJvdyBkZXBMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICBjYXNlICdsb2FkaW5nJzpcbiAgICAgICAgICBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXkgPSBkZXBLZXk7XG4gICAgICAgICAgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwUHJvbWlzZSA9IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdJbnZhbGlkIExvYWRhYmxlIHN0YXRlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q2FsbGJhY2sgPSBmbiA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbikge1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0NhbGxiYWNrcyBmcm9tIGdldENhbGxiYWNrKCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBzZWxlY3RvciBpcyBldmFsdXRhdGVkLiAgSXQgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdG9ycyB0byByZXR1cm4gb2JqZWN0cyB3aXRoIGNhbGxiYWNrcyB0aGF0IGNhbiB3b3JrIHdpdGggUmVjb2lsIHN0YXRlIHdpdGhvdXQgYSBzdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiByZWNvaWxDYWxsYmFjayQxKHN0b3JlLCBmbiwgYXJncywge1xuICAgICAgICAgIG5vZGU6IHJlY29pbFZhbHVlXG4gICAgICAgIH0gLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZ2V0KHtcbiAgICAgICAgZ2V0OiBnZXRSZWNvaWxWYWx1ZSxcbiAgICAgICAgZ2V0Q2FsbGJhY2tcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0ID0gaXNSZWNvaWxWYWx1ZSQzKHJlc3VsdCkgPyBnZXRSZWNvaWxWYWx1ZShyZXN1bHQpIDogcmVzdWx0O1xuXG4gICAgICBpZiAoaXNMb2FkYWJsZSQxKHJlc3VsdCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoRXZhbHVhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSByZXN1bHQgaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUkMSA/IHJlc3VsdC52YWx1ZSA6IHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvck9yRGVwUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0gZXJyb3JPckRlcFByb21pc2U7XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgcmVzdWx0LCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkuZmluYWxseShmaW5pc2hFdmFsdWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xuICAgICAgICBmaW5pc2hFdmFsdWF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdElzRXJyb3IpIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFByb21pc2UkMShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDIocmVzdWx0KTtcbiAgICB9XG5cbiAgICBkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgIHVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMoc3RvcmUsIGV4ZWN1dGlvbklELCBkZXBWYWx1ZXMpO1xuICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XG4gICAgcmV0dXJuIFtsb2FkYWJsZSwgZGVwVmFsdWVzXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBGaXJzdCwgbG9vayB1cCBpbiB0aGUgc3RhdGUgY2FjaGVcbiAgICAvLyBJZiBpdCdzIGhlcmUsIHRoZW4gdGhlIGRlcHMgaW4gdGhlIHN0b3JlIHNob3VsZCBhbHJlYWR5IGJlIHZhbGlkLlxuICAgIGxldCBjYWNoZWRMb2FkYWJsZSA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICAgIH0gLy8gU2Vjb25kLCBsb29rIHVwIGluIHRoZSBzZWxlY3RvciBjYWNoZSBhbmQgdXBkYXRlIHRoZSBkZXBzIGluIHRoZSBzdG9yZVxuXG5cbiAgICBjb25zdCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCA9IG5ldyBTZXQoKTtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZWRMb2FkYWJsZSA9IGNhY2hlLmdldChub2RlS2V5ID0+IHtcbiAgICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBub2RlS2V5KS5jb250ZW50cztcbiAgICAgIH0sIHtcbiAgICAgICAgb25Ob2RlVmlzaXQ6IG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdicmFuY2gnICYmIG5vZGUubm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBkZXBzQWZ0ZXJDYWNoZUxvb2t1cC5hZGQobm9kZS5ub2RlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciBcIiR7a2V5fVwiOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlKSB7XG4gICAgICB2YXIgX2dldEV4ZWN1dGlvbkluZm87XG5cbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzIGluIHRoZSBzdGF0ZSB0byBhbGxvdyBmb3IgY2hlYXBlciBsb29rdXAgdGhhblxuICAgICAgLy8gaXRlcmF0aW5nIHRoZSB0cmVlIGNhY2hlIG9mIGRlcGVuZGVuY2llcy5cbiAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgY2FjaGVkTG9hZGFibGUpO1xuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmUgc3RvcmUgY29udGFpbnMgY29ycmVjdCBkZXBlbmRlbmNpZXMgaWYgd2UgaGl0IHRoZSBjYWNoZSBzbyB0aGF0XG4gICAgICAgKiB0aGUgc3RvcmUgZGVwcyBhbmQgY2FjaGUgYXJlIGluIHN5bmMgZm9yIGEgZ2l2ZW4gc3RhdGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gICAgICAgKiBiZWNhdXNlIHN0b3JlIGRlcHMgYXJlIG5vcm1hbGx5IHVwZGF0ZWQgd2hlbiBuZXcgZXhlY3V0aW9ucyBhcmUgY3JlYXRlZCxcbiAgICAgICAqIGJ1dCBjYWNoZSBoaXRzIGRvbid0IHRyaWdnZXIgbmV3IGV4ZWN1dGlvbnMgYnV0IHRoZXkgc3RpbGwgX21heV8gc2lnbmlmeVxuICAgICAgICogYSBjaGFuZ2UgaW4gZGVwcyBpbiB0aGUgc3RvcmUgaWYgdGhlIHN0b3JlIGRlcHMgZm9yIHRoaXMgc3RhdGUgYXJlIGVtcHR5XG4gICAgICAgKiBvciBzdGFsZS5cbiAgICAgICAqL1xuXG4gICAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwc0FmdGVyQ2FjaGVMb29rdXAsIChfZ2V0RXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEV4ZWN1dGlvbkluZm8uZXhlY3V0aW9uSUQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gYSB0cmVlIHN0YXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBMb2FkYWJsZSBvZiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHNlbGVjdG9yJ3MgZ2V0KCkgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIHJlLWV2YWx1YXRlZCBpZiBfYm90aF8gb2YgdGhlXG4gICAqIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGFyZSB0cnVlOlxuICAgKlxuICAgKiAxLiBUaGUgY3VycmVudCBkZXAgdmFsdWVzIGZyb20gdGhlIGdpdmVuIHN0YXRlIHByb2R1Y2VkIGEgY2FjaGUga2V5IHRoYXRcbiAgICogICAgd2FzIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUuXG4gICAqIDIuIFRoZXJlIGlzIG5vIGN1cnJlbnRseSBydW5uaW5nIGFzeW5jIGV4ZWN1dGlvbiBPUiB0aGVyZSBpcyBhblxuICAgKiAgICBhc3luYyBleGVjdXRpb24gdGhhdCBpcyBydW5uaW5nLCBidXQgYWZ0ZXIgY29tcGFyaW5nIHRoZSBkZXAgdmFsdWVzIGluXG4gICAqICAgIHRoZSBnaXZlbiBzdGF0ZSB3aXRoIHRoZSBkZXAgdmFsdWVzIHRoYXQgdGhlIGV4ZWN1dGlvbiBoYXMgZGlzY292ZXJlZCBzb1xuICAgKiAgICBmYXIgd2UgZmluZCB0aGF0IGF0IGxlYXN0IG9uZSBkZXAgdmFsdWUgaGFzIGNoYW5nZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICogICAgc3RhcnQgYSBuZXcgZXhlY3V0aW9uICh0aGUgcHJldmlvdXNseSBydW5uaW5nIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHRvXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uLCBidXQgb25seSB0aGUgbmV3IGV4ZWN1dGlvbiB3aWxsIGJlIGRlZW1lZCB0aGVcbiAgICogICAgJ2xhdGVzdCcgZXhlY3V0aW9uLCBtZWFuaW5nIGl0IHdpbGwgYmUgdGhlIG9ubHkgZXhlY3V0aW9uIHRoYXQgd2lsbFxuICAgKiAgICB1cGRhdGUgZ2xvYmFsIHN0YXRlIHdoZW4gaXQgaXMgZmluaXNoZWQuIEFueSBub24tbGF0ZXN0IGV4ZWN1dGlvbnMgd2lsbFxuICAgKiAgICBydW4gdG8gY29tcGxldGlvbiBhbmQgdXBkYXRlIHRoZSBzZWxlY3RvciBjYWNoZSBidXQgbm90IGdsb2JhbCBzdGF0ZSkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gRmlyc3QsIHNlZSBpZiBvdXIgY3VycmVudCBzdGF0ZSBpcyBjYWNoZWRcbiAgICBjb25zdCBjYWNoZWRWYWwgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcblxuICAgIGlmIChjYWNoZWRWYWwgIT0gbnVsbCkge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfSAvLyBTZWNvbmQsIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gb25nb2luZyBleGVjdXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGVcblxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgaWYgKGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgIHZhciBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkk7XG5cbiAgICAgIGlmICgoKF9pblByb2dyZXNzRXhlY3V0aW9uSSA9IGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZSkgPT09IG51bGwgfHwgX2luUHJvZ3Jlc3NFeGVjdXRpb25JID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkuc3RhdGUpID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcbiAgICAgIH0gLy8gRklYTUU6IGNoZWNrIGFmdGVyIHRoZSBmYWN0IHRvIHNlZSBpZiB3ZSBtYWRlIHRoZSByaWdodCBjaG9pY2UgYnkgd2FpdGluZ1xuXG5cbiAgICAgIHJldHVybiBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGU7XG4gICAgfSAvLyBUaGlyZCwgc3RhcnQgYSBuZXcgZXZhbHVhdGlvbiBvZiB0aGUgc2VsZWN0b3JcblxuXG4gICAgY29uc3QgbmV3RXhlY3V0aW9uSUQgPSBnZXROZXdFeGVjdXRpb25JRCgpO1xuICAgIGNvbnN0IFtsb2FkYWJsZSwgbmV3RGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBuZXdFeGVjdXRpb25JRCk7XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSB1cGRhdGVzIHRoZSBjYWNoZSB3aXRoIGEgZ2l2ZW4gbG9hZGFibGUuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IGNhY2hlIGxvYWRhYmxlcyB0aGF0IGFyZSBub3QgbG9hZGluZyBiZWNhdXNlIG91ciBjYWNoZSBrZXlzIGFyZVxuICAgICAqIGJhc2VkIG9uIGRlcCB2YWx1ZXMsIHdoaWNoIGFyZSBpbiBhbiB1bmZpbmlzaGVkIHN0YXRlIGZvciBsb2FkYWJsZXMgdGhhdFxuICAgICAqIGhhdmUgYSAnbG9hZGluZycgc3RhdGUgKG5ldyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIHdoaWxlIHRoZSBzZWxlY3RvclxuICAgICAqIHJ1bnMgaXRzIGFzeW5jIGNvZGUpLiBXZSBuZXZlciB3YW50IHRvIGNhY2hlIHBhcnRpYWwgZGVwZW5kZW5jaWVzIGIvYyBpdFxuICAgICAqIGNvdWxkIGxlYWQgdG8gZXJyb3JzLCBzdWNoIGFzIHByZW1hdHVyZWx5IHJldHVybmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIGFcbiAgICAgKiBwYXJ0aWFsIGxpc3Qgb2YgZGVwcy0tIHdlIG5lZWQgdGhlIGZ1bGwgbGlzdCBvZiBkZXBzIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICogYXJlIHJldHVybmluZyB0aGUgY29ycmVjdCByZXN1bHQgZnJvbSBjYWNoZS5cbiAgICAgKi9cblxuICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBzZXRFeGVjdXRpb25JbmZvKHN0b3JlLCBuZXdFeGVjdXRpb25JRCwgbG9hZGFibGUsIG5ld0RlcFZhbHVlcywgc3RhdGUpO1xuICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIG5ld0V4ZWN1dGlvbklEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9hZGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGV4ZWN1dGlvbiBpbmZvIGFjcm9zcyBhbGwgc3RvcmVzIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBpbi1wcm9ncmVzc1xuICAgKiBleGVjdXRpb24gd2hvc2UgZGVwZW5kZW5jeSB2YWx1ZXMgbWF0Y2ggdGhlIHZhbHVlcyBvZiB0aGUgcmVxdWVzdGluZyBzdG9yZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBTb3J0IHRoZSBwZW5kaW5nIGV4ZWN1dGlvbnMgc28gdGhhdCBvdXIgY3VycmVudCBzdG9yZSBpcyBjaGVja2VkIGZpcnN0LlxuICAgIGNvbnN0IHBlbmRpbmdFeGVjdXRpb25zID0gUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyhbZXhlY3V0aW9uSW5mb01hcC5oYXMoc3RvcmUpID8gW1JlY29pbF9udWxsdGhyb3dzKGV4ZWN1dGlvbkluZm9NYXAuZ2V0KHN0b3JlKSldIDogW10sIFJlY29pbF9tYXBJdGVyYWJsZShSZWNvaWxfZmlsdGVySXRlcmFibGUoZXhlY3V0aW9uSW5mb01hcCwgKFtzXSkgPT4gcyAhPT0gc3RvcmUpLCAoWywgZXhlY0luZm9dKSA9PiBleGVjSW5mbyldKTtcblxuICAgIGZ1bmN0aW9uIGFueURlcENoYW5nZWQoZXhlY0RlcFZhbHVlcykge1xuICAgICAgZm9yIChjb25zdCBbZGVwS2V5LCBleGVjTG9hZGFibGVdIG9mIGV4ZWNEZXBWYWx1ZXMpIHtcbiAgICAgICAgaWYgKCFnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSkuaXMoZXhlY0xvYWRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGV4ZWNJbmZvIG9mIHBlbmRpbmdFeGVjdXRpb25zKSB7XG4gICAgICBpZiAoIC8vIElmIHRoaXMgZXhlY3V0aW9uIHdhcyBhbHJlYWR5IGNoZWNrZWQgdG8gYmUgdmFsaWQgd2l0aCB0aGlzIHZlcnNpb25cbiAgICAgIC8vIG9mIHN0YXRlLCB0aGVuIGxldCdzIHVzZSBpdCFcbiAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuZ2V0KHN0YXRlLnZlcnNpb24pIHx8IC8vIElmIHRoZSBkZXBzIGZvciB0aGUgZXhlY3V0aW9uIG1hdGNoIG91ciBjdXJyZW50IHN0YXRlLCB0aGVuIGl0J3MgdmFsaWRcbiAgICAgICFhbnlEZXBDaGFuZ2VkKGV4ZWNJbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yaykpIHtcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBleGVjSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkge1xuICAgIHJldHVybiBleGVjdXRpb25JbmZvTWFwLmdldChzdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgdGhlIHNlbGVjdG9yJ3MgZXhlY3V0aW9uIGluZm8gd2hlbiB0aGUgc2VsZWN0b3JcbiAgICogaGFzIGVpdGhlciBmaW5pc2hlZCBydW5uaW5nIGFuIGV4ZWN1dGlvbiBvciBoYXMgc3RhcnRlZCBhIG5ldyBleGVjdXRpb24uIElmXG4gICAqIHRoZSBnaXZlbiBsb2FkYWJsZSBpcyBpbiBhICdsb2FkaW5nJyBzdGF0ZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGEgbmV3XG4gICAqIGV4ZWN1dGlvbiBoYXMgc3RhcnRlZC4gT3RoZXJ3aXNlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYW4gZXhlY3V0aW9uIGhhc1xuICAgKiBqdXN0IGZpbmlzaGVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldEV4ZWN1dGlvbkluZm8oc3RvcmUsIG5ld0V4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzLCBzdGF0ZSkge1xuICAgIGV4ZWN1dGlvbkluZm9NYXAuc2V0KHN0b3JlLCB7XG4gICAgICBkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcms6IGRlcFZhbHVlcyxcbiAgICAgIGV4ZWN1dGlvbklEOiBuZXdFeGVjdXRpb25JRCxcbiAgICAgIGxvYWRpbmdMb2FkYWJsZTogbG9hZGFibGUsXG4gICAgICBzdGF0ZVZlcnNpb25zOiBuZXcgTWFwKFtbc3RhdGUudmVyc2lvbiwgdHJ1ZV1dKVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyhzdG9yZSwgZXhlY3V0aW9uSUQsIGRlcFZhbHVlcykge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBib3RoZXIgdXBkYXRpbmcgdGhlIGRlcHMgZm9yIHRoZSBsYXRlc3QgZXhlY3V0aW9uIGJlY2F1c2VcbiAgICAvLyB0aGF0J3MgYWxsIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKCkgd2lsbCBiZSBsb29raW5nIGZvci5cbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIGV4ZWN1dGlvbkluZm8uZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrID0gZGVwVmFsdWVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSkge1xuICAgIGV4ZWN1dGlvbkluZm9NYXAuZGVsZXRlKHN0b3JlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbzI7XG5cbiAgICByZXR1cm4gZXhlY3V0aW9uSUQgPT09ICgoX2dldEV4ZWN1dGlvbkluZm8yID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEV4ZWN1dGlvbkluZm8yLmV4ZWN1dGlvbklEKTtcbiAgfVxuICAvKipcbiAgICogRklYTUU6IGRlcCBrZXlzIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCB0aGUgc3RhdGUgb2YgdGhlIGxvYWRhYmxlIHRvXG4gICAqIHByZXZlbnQgdGhlIGVkZ2UgY2FzZSB3aGVyZSBhIGxvYWRhYmxlIHdpdGggYW4gZXJyb3IgYW5kIGEgbG9hZGFibGUgd2l0aFxuICAgKiBhbiBlcnJvciBhcyBhIHZhbHVlIGFyZSB0cmVhdGVkIGFzIHRoZSBzYW1lIHRoaW5nIGluY29ycmVjdGx5LiBGb3IgZXhhbXBsZVxuICAgKiB0aGVzZSB0d28gc2hvdWxkIGJlIHRyZWF0ZWQgZGlmZmVyZW50bHk6XG4gICAqXG4gICAqIHNlbGVjdG9yKHtrZXk6ICcnLCBnZXQ6ICgpID0+IG5ldyBFcnJvcignaGknKX0pO1xuICAgKiBzZWxlY3Rvcih7a2V5OiAnJywgZ2V0ICgpID0+IHt0aHJvdyBuZXcgRXJyb3IoJ2hpJyl9fSk7XG4gICAqXG4gICAqIFdpdGggY3VycmVudCBpbXBsZW1lbnRhdGlvbiB0aGV5IGFyZSB0cmVhdGVkIHRoZSBzYW1lXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkZXBWYWx1ZXMuZW50cmllcygpKS5tYXAoKFtkZXBLZXksIHZhbExvYWRhYmxlXSkgPT4gW2RlcEtleSwgdmFsTG9hZGFibGUuY29udGVudHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycgJiYgQm9vbGVhbihvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZShsb2FkYWJsZS5jb250ZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGUuc2V0KGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSwgbG9hZGFibGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggc2V0dGluZyBjYWNoZSBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzKGZuKSB7XG4gICAgaWYgKGRlcGVuZGVuY3lTdGFjay5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFJlY29pbCBzZWxlY3RvciBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzOiAke2RlcGVuZGVuY3lTdGFjay5zbGljZShkZXBlbmRlbmN5U3RhY2suaW5kZXhPZihrZXkpKS5qb2luKCcgXFx1MjE5MiAnKX1gO1xuICAgICAgcmV0dXJuIGxvYWRhYmxlV2l0aEVycm9yJDEoUmVjb2lsX2VycihtZXNzYWdlKSk7XG4gICAgfVxuXG4gICAgZGVwZW5kZW5jeVN0YWNrLnB1c2goa2V5KTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVwZW5kZW5jeVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yUGVlayhzdG9yZSwgc3RhdGUpIHtcbiAgICBjb25zdCBjYWNoZWRMb2FkYWJsZSA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5nZXQobm9kZUtleSA9PiB7XG4gICAgICB2YXIgX3BlZWtOb2RlTG9hZGFibGU7XG5cbiAgICAgICEodHlwZW9mIG5vZGVLZXkgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdDYWNoZSBub2RlS2V5IGlzIHR5cGUgc3RyaW5nJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiAoX3BlZWtOb2RlTG9hZGFibGUgPSBwZWVrTm9kZUxvYWRhYmxlJDEoc3RvcmUsIHN0YXRlLCBub2RlS2V5KSkgPT09IG51bGwgfHwgX3BlZWtOb2RlTG9hZGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZWVrTm9kZUxvYWRhYmxlLmNvbnRlbnRzO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JHZXQoc3RvcmUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzKCgpID0+IGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVNlbGVjdG9yKHN0YXRlKSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0b3JDYWNoZShzdG9yZSwgdHJlZVN0YXRlKSB7XG4gICAgIShyZWNvaWxWYWx1ZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdSZWNvaWwgVmFsdWUgY2FuIG5ldmVyIGJlIG51bGwnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMpIHtcbiAgICAgIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ2KG5vZGVLZXkpO1xuICAgICAgKF9ub2RlJGNsZWFyQ2FjaGUgPSBub2RlLmNsZWFyQ2FjaGUpID09PSBudWxsIHx8IF9ub2RlJGNsZWFyQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGNsZWFyQ2FjaGUuY2FsbChub2RlLCBzdG9yZSwgdHJlZVN0YXRlKTtcbiAgICB9XG5cbiAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmNsZWFyKCk7XG4gICAgaW52YWxpZGF0ZVNlbGVjdG9yKHRyZWVTdGF0ZSk7XG4gICAgY2FjaGUuY2xlYXIoKTtcbiAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gIH1cblxuICBpZiAoc2V0ICE9IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiBFUzUgc3RyaWN0IG1vZGUgcHJvaGliaXRzIGRlZmluaW5nIG5vbi10b3AtbGV2ZWwgZnVuY3Rpb24gZGVjbGFyYXRpb25zLFxuICAgICAqIHNvIGRvbid0IHVzZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBzeW50YXggaGVyZVxuICAgICAqL1xuICAgIGNvbnN0IHNlbGVjdG9yU2V0ID0gKHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpID0+IHtcbiAgICAgIGxldCBzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgd3JpdGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRSZWNvaWxWYWx1ZSh7XG4gICAgICAgIGtleTogZGVwS2V5XG4gICAgICB9KSB7XG4gICAgICAgIGlmIChzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCkge1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcblxuICAgICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBHZXR0aW5nIHZhbHVlIG9mIGFzeW5jaHJvbm91cyBhdG9tIG9yIHNlbGVjdG9yIFwiJHtkZXBLZXl9XCIgaW4gYSBwZW5kaW5nIHN0YXRlIHdoaWxlIHNldHRpbmcgc2VsZWN0b3IgXCIke2tleX1cIiBpcyBub3QgeWV0IHN1cHBvcnRlZC5gO1xuICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihtc2cpO1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIpIHtcbiAgICAgICAgaWYgKHN5bmNTZWxlY3RvclNldEZpbmlzaGVkKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJztcbiAgICAgICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24obXNnKTtcbiAgICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXRWYWx1ZSA9IHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgdHlwZSBTIGZyb20gYmVpbmcgYSBmdW5jdGlvbiBpdHNlbGYgd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgIHZhbHVlT3JVcGRhdGVyKGdldFJlY29pbFZhbHVlKHJlY29pbFN0YXRlKSkgOiB2YWx1ZU9yVXBkYXRlcjtcbiAgICAgICAgY29uc3QgdXBzdHJlYW1Xcml0ZXMgPSBzZXROb2RlVmFsdWUkMyhzdG9yZSwgc3RhdGUsIHJlY29pbFN0YXRlLmtleSwgc2V0VmFsdWUpO1xuICAgICAgICB1cHN0cmVhbVdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB3cml0ZXMuc2V0KGssIHYpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgICBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQ2KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmV0ID0gc2V0KHtcbiAgICAgICAgc2V0OiBzZXRSZWNvaWxTdGF0ZSxcbiAgICAgICAgZ2V0OiBnZXRSZWNvaWxWYWx1ZSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0UmVjb2lsU3RhdGVcbiAgICAgIH0sIG5ld1ZhbHVlKTsgLy8gc2V0IHNob3VsZCBiZSBhIHZvaWQgbWV0aG9kLCBidXQgaWYgdGhlIHVzZXIgbWFrZXMgaXQgYGFzeW5jYCwgdGhlbiBpdFxuICAgICAgLy8gd2lsbCByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3ZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydC5cblxuICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9pc1Byb21pc2UocmV0KSA/IFJlY29pbF9lcnIoJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJykgOiBSZWNvaWxfZXJyKCdSZWNvaWw6IHNlbGVjdG9yIHNldCBzaG91bGQgYmUgYSB2b2lkIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICBzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCA9IHRydWU7XG4gICAgICByZXR1cm4gd3JpdGVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XG4gICAgICBrZXksXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcbiAgICAgIGdldDogc2VsZWN0b3JHZXQsXG4gICAgICBzZXQ6IHNlbGVjdG9yU2V0LFxuICAgICAgaW5pdDogc2VsZWN0b3JJbml0LFxuICAgICAgaW52YWxpZGF0ZTogaW52YWxpZGF0ZVNlbGVjdG9yLFxuICAgICAgY2xlYXJDYWNoZTogY2xlYXJTZWxlY3RvckNhY2hlLFxuICAgICAgc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlOiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSxcbiAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IGZhbHNlLFxuICAgICAgcmV0YWluZWRCeVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWNvaWxWYWx1ZSA9IHJlZ2lzdGVyTm9kZSQxKHtcbiAgICAgIGtleSxcbiAgICAgIG5vZGVUeXBlOiAnc2VsZWN0b3InLFxuICAgICAgcGVlazogc2VsZWN0b3JQZWVrLFxuICAgICAgZ2V0OiBzZWxlY3RvckdldCxcbiAgICAgIGluaXQ6IHNlbGVjdG9ySW5pdCxcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcbiAgICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UsXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcbiAgICAgIHJldGFpbmVkQnlcbiAgICB9KTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1yZWRlY2xhcmUgKi9cbi8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXVzZV1cbi8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuXG5zZWxlY3Rvci52YWx1ZSA9IHZhbHVlID0+IG5ldyBXcmFwcGVkVmFsdWUkMSh2YWx1ZSk7XG5cbnZhciBSZWNvaWxfc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuLy8gQGZiLW9ubHk6IGltcG9ydCB0eXBlIHtTY29wZVJ1bGVzfSBmcm9tICdSZWNvaWxfU2NvcGVkQXRvbSc7XG4vLyBAZmItb25seTogY29uc3Qge3Njb3BlZEF0b219ID0gcmVxdWlyZSgnUmVjb2lsX1Njb3BlZEF0b20nKTtcbmNvbnN0IHtcbiAgaXNMb2FkYWJsZTogaXNMb2FkYWJsZSQyLFxuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMixcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQyLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkM1xufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIFdyYXBwZWRWYWx1ZTogV3JhcHBlZFZhbHVlJDJcbn0gPSBSZWNvaWxfV3JhcHBlciQxO1xuXG5jb25zdCB7XG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ3LFxuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyLFxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQyLFxuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQ0XG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlOiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNCxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDIsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQ0LFxuICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlOiBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMlxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB1bndyYXAgPSB4ID0+IHggaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUkMiA/IHgudmFsdWUgOiB4O1xuXG5mdW5jdGlvbiBiYXNlQXRvbShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IHBlcnNpc3RlbmNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXRhaW5lZEJ5ID0gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDIob3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKTtcbiAgbGV0IGxpdmVTdG9yZXNDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gdW53cmFwUHJvbWlzZShwcm9taXNlKSB7XG4gICAgcmV0dXJuIGxvYWRhYmxlV2l0aFByb21pc2UkMihwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgZGVmYXVsdExvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgZGVmYXVsdExvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KSk7XG4gIH1cblxuICBsZXQgZGVmYXVsdExvYWRhYmxlID0gUmVjb2lsX2lzUHJvbWlzZShvcHRpb25zLmRlZmF1bHQpID8gdW53cmFwUHJvbWlzZShvcHRpb25zLmRlZmF1bHQpIDogaXNMb2FkYWJsZSQyKG9wdGlvbnMuZGVmYXVsdCkgPyBvcHRpb25zLmRlZmF1bHQuc3RhdGUgPT09ICdsb2FkaW5nJyA/IHVud3JhcFByb21pc2Uob3B0aW9ucy5kZWZhdWx0LmNvbnRlbnRzKSA6IG9wdGlvbnMuZGVmYXVsdCA6IGxvYWRhYmxlV2l0aFZhbHVlJDModW53cmFwKG9wdGlvbnMuZGVmYXVsdCkpO1xuICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cyk7XG4gIGxldCBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBDbGVhbnVwIGhhbmRsZXJzIGZvciB0aGlzIGF0b21cbiAgLy8gUmVseSBvbiBzdGFibGUgcmVmZXJlbmNlIGVxdWFsaXR5IG9mIHRoZSBzdG9yZSB0byB1c2UgaXQgYXMgYSBrZXkgcGVyIDxSZWNvaWxSb290PlxuXG4gIGNvbnN0IGNsZWFudXBFZmZlY3RzQnlTdG9yZSA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKHZhbHVlT3JQcm9taXNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHkgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZSh2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlT3JQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcFBlbmRpbmdQcm9taXNlKHN0b3JlLCBwcm9taXNlKSB7XG4gICAgY29uc3Qgd3JhcHBlZFByb21pc2UgPSBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0O1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgIGlmICgoKF9zdGF0ZSRhdG9tVmFsdWVzJGdldCA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJGF0b21WYWx1ZXMkZ2V0LmNvbnRlbnRzKSA9PT0gd3JhcHBlZFByb21pc2UpIHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkNChzdG9yZSwgbm9kZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDI7XG5cbiAgICAgIGNvbnN0IHN0YXRlID0gKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDIgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgaWYgKCgoX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MiA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIuY29udGVudHMpID09PSB3cmFwcGVkUHJvbWlzZSkge1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZUxvYWRhYmxlJDIoc3RvcmUsIG5vZGUsIGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEF0b20oc3RvcmUsIGluaXRTdGF0ZSwgdHJpZ2dlcikge1xuICAgIHZhciBfb3B0aW9ucyRlZmZlY3RzO1xuXG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XG5cbiAgICBjb25zdCBjbGVhbnVwQXRvbSA9ICgpID0+IHtcbiAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3I7XG5cbiAgICAgIGxpdmVTdG9yZXNDb3VudC0tO1xuICAgICAgKF9jbGVhbnVwRWZmZWN0c0J5U3RvciA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSA9PT0gbnVsbCB8fCBfY2xlYW51cEVmZmVjdHNCeVN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbGVhbnVwRWZmZWN0c0J5U3Rvci5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5kZWxldGUoc3RvcmUpO1xuICAgIH07XG5cbiAgICBzdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXMuYWRkKGtleSk7IC8vIFNldHVwIGFzeW5jIGRlZmF1bHRzIHRvIG5vdGlmeSBzdWJzY3JpYmVycyB3aGVuIHRoZXkgcmVzb2x2ZVxuXG4gICAgaWYgKGRlZmF1bHRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBjb25zdCBub3RpZnlEZWZhdWx0U3Vic2NyaWJlcnMgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gKF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzIDogc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgICAgICBpZiAoIXN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyKHN0b3JlLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZGVmYXVsdExvYWRhYmxlLmNvbnRlbnRzLmZpbmFsbHkobm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzKTtcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSdW4gQXRvbSBFZmZlY3RzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICBjb25zdCBlZmZlY3RzID0gKF9vcHRpb25zJGVmZmVjdHMgPSBvcHRpb25zLmVmZmVjdHMpICE9PSBudWxsICYmIF9vcHRpb25zJGVmZmVjdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJGVmZmVjdHMgOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEU7XG5cbiAgICBpZiAoZWZmZWN0cyAhPSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHN0YXRlIGlzIHNjb3BlZCBieSBTdG9yZSwgc2luY2UgdGhpcyBpcyBpbiB0aGUgaW5pdEF0b20oKSBjbG9zdXJlXG4gICAgICBsZXQgaW5pdFZhbHVlID0gREVGQVVMVF9WQUxVRSQ3O1xuICAgICAgbGV0IGlzRHVyaW5nSW5pdCA9IHRydWU7XG4gICAgICBsZXQgaXNJbml0RXJyb3IgPSBmYWxzZTtcbiAgICAgIGxldCBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGdldExvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBqdXN0IGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbm90aGVyIGF0b20uXG4gICAgICAgIC8vIEJ1dCBmb3Igb3VyIG93biB2YWx1ZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZ1xuICAgICAgICAvLyBpbml0aWFsaXplZCB2YWx1ZSBvciBnZXQgdGhlIGZhbGxiYWNrIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgIGlmIChpc0R1cmluZ0luaXQgJiYgcmVjb2lsVmFsdWUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAvLyBDYXN0IFQgdG8gU1xuICAgICAgICAgIGNvbnN0IHJldFZhbHVlID0gaW5pdFZhbHVlOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuICAgICAgICAgIHJldHVybiByZXRWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gcGVla0F0b20oc3RvcmUsIGluaXRTdGF0ZSkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiBSZWNvaWxfaXNQcm9taXNlKHJldFZhbHVlKSA/IGxvYWRhYmxlV2l0aFByb21pc2UkMihyZXRWYWx1ZS50aGVuKHYgPT4gdiBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gLy8gQ2FzdCBUIHRvIFNcbiAgICAgICAgICBkZWZhdWx0TG9hZGFibGUudG9Qcm9taXNlKCkgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICAgOiB2KSkgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHJldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNChzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9taXNlKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEluZm9fVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQ7XG5cbiAgICAgICAgY29uc3QgaW5mbyA9IHBlZWtOb2RlSW5mbyQzKHN0b3JlLCAoX3N0b3JlJGdldFN0YXRlJG5leHRUNCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCByZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgICByZXR1cm4gaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5ICYmICEoaW5pdFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpID8geyAuLi5pbmZvLFxuICAgICAgICAgIGlzU2V0OiB0cnVlLFxuICAgICAgICAgIGxvYWRhYmxlOiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSlcbiAgICAgICAgfSA6IGluZm87XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNldFNlbGYgPSBlZmZlY3QgPT4gdmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgICAgICBpZiAoaXNEdXJpbmdJbml0KSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudExvYWRhYmxlID0gZ2V0TG9hZGFibGUobm9kZSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gY3VycmVudExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3O1xuICAgICAgICAgIGluaXRWYWx1ZSA9IHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgVCBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICA6IHZhbHVlT3JVcGRhdGVyO1xuXG4gICAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSkge1xuICAgICAgICAgICAgaW5pdFZhbHVlID0gaW5pdFZhbHVlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBjYWxsaW5nIG9uU2V0KCkgd2hlbiBzZXRTZWxmKCkgaW5pdGlhbGl6ZXMgd2l0aCBhIFByb21pc2VcbiAgICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh2YWx1ZU9yVXBkYXRlcikpIHtcbiAgICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NldHRpbmcgYXRvbXMgdG8gYXN5bmMgdmFsdWVzIGlzIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlT3JVcGRhdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICB2YWx1ZTogdW53cmFwKHZhbHVlT3JVcGRhdGVyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRSZWNvaWxWYWx1ZSQ0KHN0b3JlLCBub2RlLCB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50VmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB1bndyYXAoIC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgVCBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgICAgICB2YWx1ZU9yVXBkYXRlcihjdXJyZW50VmFsdWUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBlbmRpbmdTZXRTZWxmID0ge1xuICAgICAgICAgICAgICBlZmZlY3QsXG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICAgICAgICB9IDogdW53cmFwKHZhbHVlT3JVcGRhdGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc2V0U2VsZiA9IGVmZmVjdCA9PiAoKSA9PiBzZXRTZWxmKGVmZmVjdCkoREVGQVVMVF9WQUxVRSQ3KTtcblxuICAgICAgY29uc3Qgb25TZXQgPSBlZmZlY3QgPT4gaGFuZGxlciA9PiB7XG4gICAgICAgIHZhciBfY2xlYW51cEVmZmVjdHNCeVN0b3IyO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZWxlYXNlXG4gICAgICAgIH0gPSBzdG9yZS5zdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyhjdXJyZW50U3RvcmUgPT4ge1xuICAgICAgICAgIHZhciBfY3VycmVudFRyZWUkYXRvbVZhbHU7XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgICAgcHJldmlvdXNUcmVlXG4gICAgICAgICAgfSA9IGN1cnJlbnRTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKCFwcmV2aW91c1RyZWUpIHtcbiAgICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgbm90aWZpZWQgd2l0aG91dCBhIG5leHQgdHJlZSBiZWluZyBwcmVzZW50IC0tIHRoaXMgaXMgYSBidWcgaW4gUmVjb2lsJyk7XG4gICAgICAgICAgICBwcmV2aW91c1RyZWUgPSBjdXJyZW50VHJlZTsgLy8gYXR0ZW1wdCB0byB0cnVuZGxlIG9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3TG9hZGFibGUgPSAoX2N1cnJlbnRUcmVlJGF0b21WYWx1ID0gY3VycmVudFRyZWUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2N1cnJlbnRUcmVlJGF0b21WYWx1ICE9PSB2b2lkIDAgPyBfY3VycmVudFRyZWUkYXRvbVZhbHUgOiBkZWZhdWx0TG9hZGFibGU7XG5cbiAgICAgICAgICBpZiAobmV3TG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgICAgIHZhciBfcHJldmlvdXNUcmVlJGF0b21WYWwsIF9wZW5kaW5nU2V0U2VsZiwgX3BlbmRpbmdTZXRTZWxmMiwgX3BlbmRpbmdTZXRTZWxmMztcblxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXdMb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgICAgIGNvbnN0IG9sZExvYWRhYmxlID0gKF9wcmV2aW91c1RyZWUkYXRvbVZhbCA9IHByZXZpb3VzVHJlZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfcHJldmlvdXNUcmVlJGF0b21WYWwgIT09IHZvaWQgMCA/IF9wcmV2aW91c1RyZWUkYXRvbVZhbCA6IGRlZmF1bHRMb2FkYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb2xkTG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgPyBvbGRMb2FkYWJsZS5jb250ZW50cyA6IERFRkFVTFRfVkFMVUUkNzsgLy8gVE9ETyBUaGlzIGlzbid0IGFjdHVhbGx5IHZhbGlkLCB1c2UgYXMgYSBwbGFjZWhvbGRlciBmb3Igbm93LlxuICAgICAgICAgICAgLy8gSWdub3JlIGF0b20gdmFsdWUgY2hhbmdlcyB0aGF0IHdlcmUgc2V0IHZpYSBzZXRTZWxmKCkgaW4gdGhlIHNhbWUgZWZmZWN0LlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBzdGlsbCBwcm9wZXJseSBjYWxsIHRoZSBoYW5kbGVyIGlmIHRoZXJlIHdhcyBhIHN1YnNlcXVlbnRcbiAgICAgICAgICAgIC8vIHNldCBmcm9tIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIGF0b20gZWZmZWN0IHdoaWNoIHdhcyBiYXRjaGVkXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBgc2V0U2VsZigpYCBjYWxsLiAgSG93ZXZlciwgd2UgbWF5IGluY29ycmVjdGx5IGlnbm9yZVxuICAgICAgICAgICAgLy8gdGhlIGhhbmRsZXIgaWYgdGhlIHN1YnNlcXVlbnQgYmF0Y2hlZCBjYWxsIGhhcHBlbnMgdG8gc2V0IHRoZVxuICAgICAgICAgICAgLy8gYXRvbSB0byB0aGUgZXhhY3Qgc2FtZSB2YWx1ZSBhcyB0aGUgYHNldFNlbGYoKWAuICAgQnV0LCBpbiB0aGF0XG4gICAgICAgICAgICAvLyBjYXNlLCBpdCB3YXMga2luZCBvZiBhIG5vb3AsIHNvIHRoZSBzZW1hbnRpY3MgYXJlIGRlYmF0YWJsZS4uXG5cbiAgICAgICAgICAgIGlmICgoKF9wZW5kaW5nU2V0U2VsZiA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nU2V0U2VsZi5lZmZlY3QpICE9PSBlZmZlY3QgfHwgKChfcGVuZGluZ1NldFNlbGYyID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nU2V0U2VsZjIudmFsdWUpICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICBoYW5kbGVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgIWN1cnJlbnRUcmVlLmF0b21WYWx1ZXMuaGFzKGtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKF9wZW5kaW5nU2V0U2VsZjMgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdTZXRTZWxmMy5lZmZlY3QpID09PSBlZmZlY3QpIHtcbiAgICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwga2V5KTtcbiAgICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLnNldChzdG9yZSwgWy4uLigoX2NsZWFudXBFZmZlY3RzQnlTdG9yMiA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSAhPT0gbnVsbCAmJiBfY2xlYW51cEVmZmVjdHNCeVN0b3IyICE9PSB2b2lkIDAgPyBfY2xlYW51cEVmZmVjdHNCeVN0b3IyIDogW10pLCByZWxlYXNlXSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9IGVmZmVjdCh7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc3RvcmVJRDogc3RvcmUuc3RvcmVJRCxcbiAgICAgICAgICAgIHBhcmVudFN0b3JlSURfVU5TVEFCTEU6IHN0b3JlLnBhcmVudFN0b3JlSUQsXG4gICAgICAgICAgICB0cmlnZ2VyLFxuICAgICAgICAgICAgc2V0U2VsZjogc2V0U2VsZihlZmZlY3QpLFxuICAgICAgICAgICAgcmVzZXRTZWxmOiByZXNldFNlbGYoZWZmZWN0KSxcbiAgICAgICAgICAgIG9uU2V0OiBvblNldChlZmZlY3QpLFxuICAgICAgICAgICAgZ2V0UHJvbWlzZSxcbiAgICAgICAgICAgIGdldExvYWRhYmxlLFxuICAgICAgICAgICAgZ2V0SW5mb19VTlNUQUJMRVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNsZWFudXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjM7XG5cbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3RzQnlTdG9yZS5zZXQoc3RvcmUsIFsuLi4oKF9jbGVhbnVwRWZmZWN0c0J5U3RvcjMgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgIT09IG51bGwgJiYgX2NsZWFudXBFZmZlY3RzQnlTdG9yMyAhPT0gdm9pZCAwID8gX2NsZWFudXBFZmZlY3RzQnlTdG9yMyA6IFtdKSwgY2xlYW51cF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbml0VmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICBpc0luaXRFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNEdXJpbmdJbml0ID0gZmFsc2U7IC8vIE11dGF0ZSBpbml0aWFsIHN0YXRlIGluIHBsYWNlIHNpbmNlIHdlIGtub3cgdGhlcmUgYXJlIG5vIG90aGVyIHN1YnNjcmliZXJzXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgdGhlIG9uZXMgaW5pdGlhbGl6aW5nIG9uIGZpcnN0IHVzZS5cblxuICAgICAgaWYgKCEoaW5pdFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpKSB7XG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1O1xuXG4gICAgICAgIGNvbnN0IGluaXRMb2FkYWJsZSA9IGlzSW5pdEVycm9yID8gbG9hZGFibGVXaXRoRXJyb3IkMihpbml0VmFsdWUpIDogUmVjb2lsX2lzUHJvbWlzZShpbml0VmFsdWUpID8gbG9hZGFibGVXaXRoUHJvbWlzZSQyKHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgaW5pdFZhbHVlKSkgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHVud3JhcChpbml0VmFsdWUpKTtcbiAgICAgICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShpbml0TG9hZGFibGUuY29udGVudHMpO1xuICAgICAgICBpbml0U3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBpbml0TG9hZGFibGUpOyAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgdHJhbnNhY3Rpb24sIHRoZW4gYWxzbyBtdXRhdGUgdGhlIG5leHQgc3RhdGUgdHJlZS5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdGhlIGF0b20gd2FzIGZpcnN0IGluaXRpYWxpemVkIGluIGFuIGFjdGlvbiB0aGF0XG4gICAgICAgIC8vIGFsc28gdXBkYXRlZCBzb21lIG90aGVyIGF0b20ncyBzdGF0ZS5cblxuICAgICAgICAoX3N0b3JlJGdldFN0YXRlJG5leHRUNSA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDUuYXRvbVZhbHVlcy5zZXQoa2V5LCBpbml0TG9hZGFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGVhbnVwQXRvbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWtBdG9tKF9zdG9yZSwgc3RhdGUpIHtcbiAgICB2YXIgX3JlZiwgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MztcblxuICAgIHJldHVybiAoX3JlZiA9IChfc3RhdGUkYXRvbVZhbHVlcyRnZXQzID0gc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyAhPT0gdm9pZCAwID8gX3N0YXRlJGF0b21WYWx1ZXMkZ2V0MyA6IGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBkZWZhdWx0TG9hZGFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdG9tKF9zdG9yZSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgLy8gQXRvbSB2YWx1ZSBpcyBzdG9yZWQgaW4gc3RhdGU6XG4gICAgICByZXR1cm4gUmVjb2lsX251bGx0aHJvd3Moc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5oYXMoa2V5KSkge1xuICAgICAgLy8gQXRvbSB2YWx1ZSBpcyBzdG9yZWQgYnV0IG5lZWRzIHZhbGlkYXRpb24gYmVmb3JlIHVzZS5cbiAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgaXQgYW5kIGhhdmUgYSBjYWNoZWQgdmFsaWRhdGVkIHZhbHVlOlxuICAgICAgaWYgKGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBlcnNpc3RlbmNlID09IG51bGwpIHtcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKGBUcmllZCB0byByZXN0b3JlIGEgcGVyc2lzdGVkIHZhbHVlIGZvciBhdG9tICR7a2V5fSBidXQgaXQgaGFzIG5vIHBlcnNpc3RlbmNlIHNldHRpbmdzLmApO1xuICAgICAgICByZXR1cm4gZGVmYXVsdExvYWRhYmxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub252YWxpZGF0ZWRWYWx1ZSA9IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmdldChrZXkpO1xuICAgICAgY29uc3QgdmFsaWRhdG9yUmVzdWx0ID0gcGVyc2lzdGVuY2UudmFsaWRhdG9yKG5vbnZhbGlkYXRlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpO1xuICAgICAgY29uc3QgdmFsaWRhdGVkVmFsdWVMb2FkYWJsZSA9IHZhbGlkYXRvclJlc3VsdCBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyID8gZGVmYXVsdExvYWRhYmxlIDogbG9hZGFibGVXaXRoVmFsdWUkMyh2YWxpZGF0b3JSZXN1bHQpO1xuICAgICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHZhbGlkYXRlZFZhbHVlTG9hZGFibGU7XG4gICAgICByZXR1cm4gY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmF1bHRMb2FkYWJsZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkYXRlQXRvbSgpIHtcbiAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXRvbShfc3RvcmUsIHN0YXRlLCBuZXdWYWx1ZSkge1xuICAgIC8vIEJhaWwgb3V0IGlmIHdlJ3JlIGJlaW5nIHNldCB0byB0aGUgZXhpc3RpbmcgdmFsdWUsIG9yIGlmIHdlJ3JlIGJlaW5nXG4gICAgLy8gcmVzZXQgYnV0IGhhdmUgbm8gc3RvcmVkIHZhbHVlICh2YWxpZGF0ZWQgb3IgdW52YWxpZGF0ZWQpIHRvIHJlc2V0IGZyb206XG4gICAgaWYgKHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gUmVjb2lsX251bGx0aHJvd3Moc3RhdGUuYXRvbVZhbHVlcy5nZXQoa2V5KSk7XG5cbiAgICAgIGlmIChleGlzdGluZy5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyAmJiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmcuY29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5oYXMoa2V5KSAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQyKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIG1heWJlRnJlZXplVmFsdWVPclByb21pc2UobmV3VmFsdWUpO1xuICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB1bmRlZmluZWQ7IC8vIGNhbiBiZSByZWxlYXNlZCBub3cgaWYgaXQgd2FzIHByZXZpb3VzbHkgaW4gdXNlXG5cbiAgICByZXR1cm4gbmV3IE1hcCgpLnNldChrZXksIGxvYWRhYmxlV2l0aFZhbHVlJDMobmV3VmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZUF0b20oKSB7XG4gICAgcmV0dXJuIGdldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyKGtleSkgIT09IHVuZGVmaW5lZCAmJiBsaXZlU3RvcmVzQ291bnQgPD0gMDtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSByZWdpc3Rlck5vZGUkMih7XG4gICAga2V5LFxuICAgIG5vZGVUeXBlOiAnYXRvbScsXG4gICAgcGVlazogcGVla0F0b20sXG4gICAgZ2V0OiBnZXRBdG9tLFxuICAgIHNldDogc2V0QXRvbSxcbiAgICBpbml0OiBpbml0QXRvbSxcbiAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlQXRvbSxcbiAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZUF0b20sXG4gICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPyB7XG4gICAgICB0eXBlOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFLnR5cGUsXG4gICAgICBiYWNrQnV0dG9uOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFLmJhY2tCdXR0b25cbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiB0cnVlLFxuICAgIHJldGFpbmVkQnlcbiAgfSk7XG4gIHJldHVybiBub2RlO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG5mdW5jdGlvbiBhdG9tKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5rZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdBIGtleSBvcHRpb24gd2l0aCBhIHVuaXF1ZSBzdHJpbmcgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIGFuIGF0b20uJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgIC4uLnJlc3RPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvcHRpb25zRGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBvcHRpb25zID8gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcbiAgb3B0aW9ucy5kZWZhdWx0IDogbmV3IFByb21pc2UoKCkgPT4ge30pO1xuXG4gIGlmIChpc1JlY29pbFZhbHVlJDQob3B0aW9uc0RlZmF1bHQpIC8vIENvbnRpbnVlIHRvIHVzZSBhdG9tV2l0aEZhbGxiYWNrIGZvciBwcm9taXNlIGRlZmF1bHRzIGZvciBzY29wZWQgYXRvbXNcbiAgLy8gZm9yIG5vdywgc2luY2Ugc2NvcGVkIGF0b21zIGRvbid0IHN1cHBvcnQgYXN5bmMgZGVmYXVsdHNcbiAgLy8gQGZiLW9ubHk6IHx8IChpc1Byb21pc2Uob3B0aW9uc0RlZmF1bHQpICYmIHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUylcbiAgLy8gQGZiLW9ubHk6IHx8IChpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KSAmJiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MpXG4gICkge1xuICAgIHJldHVybiBhdG9tV2l0aEZhbGxiYWNrKHsgLi4ucmVzdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0OiBvcHRpb25zRGVmYXVsdCAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuXG4gICAgfSk7IC8vIEBmYi1vbmx5OiB9IGVsc2UgaWYgKHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DU1xuICAgIC8vIEBmYi1vbmx5OiAmJiAhaXNQcm9taXNlKG9wdGlvbnNEZWZhdWx0KVxuICAgIC8vIEBmYi1vbmx5OiAmJiAhaXNMb2FkYWJsZShvcHRpb25zRGVmYXVsdClcbiAgICAvLyBAZmItb25seTogKSB7XG4gICAgLy8gQGZiLW9ubHk6IHJldHVybiBzY29wZWRBdG9tPFQ+KHtcbiAgICAvLyBAZmItb25seTogLi4ucmVzdE9wdGlvbnMsXG4gICAgLy8gQGZiLW9ubHk6IGRlZmF1bHQ6IHVud3JhcDxUPihvcHRpb25zRGVmYXVsdCksXG4gICAgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAvLyBAZmItb25seTogfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2VBdG9tKHsgLi4ucmVzdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0OiBvcHRpb25zRGVmYXVsdFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoRmFsbGJhY2sob3B0aW9ucykge1xuICBjb25zdCBiYXNlID0gYXRvbSh7IC4uLm9wdGlvbnMsXG4gICAgZGVmYXVsdDogREVGQVVMVF9WQUxVRSQ3LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBvcHRpb25zLnBlcnNpc3RlbmNlX1VOU1RBQkxFID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB7IC4uLm9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUsXG4gICAgICB2YWxpZGF0b3I6IHN0b3JlZFZhbHVlID0+IHN0b3JlZFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBzdG9yZWRWYWx1ZSA6IFJlY29pbF9udWxsdGhyb3dzKG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUpLnZhbGlkYXRvcihzdG9yZWRWYWx1ZSwgREVGQVVMVF9WQUxVRSQ3KVxuICAgIH0sXG4gICAgLy8gVE9ETyBIYWNrIGZvciBub3cuXG4gICAgZWZmZWN0czogb3B0aW9ucy5lZmZlY3RzLFxuICAgIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgICBlZmZlY3RzX1VOU1RBQkxFOiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuXG4gIH0pO1xuICBjb25zdCBzZWwgPSBSZWNvaWxfc2VsZWN0b3Ioe1xuICAgIGtleTogYCR7b3B0aW9ucy5rZXl9X193aXRoRmFsbGJhY2tgLFxuICAgIGdldDogKHtcbiAgICAgIGdldFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGdldChiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IG9wdGlvbnMuZGVmYXVsdCA6IGJhc2VWYWx1ZTtcbiAgICB9LFxuICAgIHNldDogKHtcbiAgICAgIHNldFxuICAgIH0sIG5ld1ZhbHVlKSA9PiBzZXQoYmFzZSwgbmV3VmFsdWUpLFxuICAgIC8vIFRoaXMgc2VsZWN0b3IgZG9lcyBub3QgbmVlZCB0byBjYWNoZSBhcyBpdCBpcyBhIHdyYXBwZXIgc2VsZWN0b3JcbiAgICAvLyBhbmQgdGhlIHNlbGVjdG9yIHdpdGhpbiB0aGUgd3JhcHBlciBzZWxlY3RvciB3aWxsIGhhdmUgYSBjYWNoZVxuICAgIC8vIG9wdGlvbiBieSBkZWZhdWx0XG4gICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IHtcbiAgICAgIGV2aWN0aW9uOiAnbW9zdC1yZWNlbnQnXG4gICAgfSxcbiAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eVxuICB9KTtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoc2VsLmtleSwgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIob3B0aW9ucy5rZXkpKTtcbiAgcmV0dXJuIHNlbDtcbn0gLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG5cbmF0b20udmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDIodmFsdWUpO1xuXG52YXIgUmVjb2lsX2F0b20gPSBhdG9tO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5jbGFzcyBNYXBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkbWFwS2V5O1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleU1hcHBlclwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2tleU1hcHBlciA9IChfb3B0aW9ucyRtYXBLZXkgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwS2V5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBLZXkgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcEtleSA6IHYgPT4gdjtcbiAgfVxuXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldCh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBzZXQoa2V5LCB2YWwpIHtcbiAgICB0aGlzLl9tYXAuc2V0KHRoaXMuX2tleU1hcHBlcihrZXkpLCB2YWwpO1xuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX21hcC5kZWxldGUodGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gIH1cblxufVxuXG52YXIgUmVjb2lsX01hcENhY2hlID0ge1xuICBNYXBDYWNoZVxufTtcblxudmFyIFJlY29pbF9NYXBDYWNoZV8xID0gUmVjb2lsX01hcENhY2hlLk1hcENhY2hlO1xuXG52YXIgUmVjb2lsX01hcENhY2hlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgTWFwQ2FjaGU6IFJlY29pbF9NYXBDYWNoZV8xXG59KTtcblxuY29uc3Qge1xuICBMUlVDYWNoZTogTFJVQ2FjaGUkMlxufSA9IFJlY29pbF9MUlVDYWNoZSQxO1xuXG5jb25zdCB7XG4gIE1hcENhY2hlOiBNYXBDYWNoZSQxXG59ID0gUmVjb2lsX01hcENhY2hlJDE7XG5cblxuXG5cblxuXG5cbmNvbnN0IGRlZmF1bHRQb2xpY3kkMSA9IHtcbiAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnLFxuICBldmljdGlvbjogJ25vbmUnLFxuICBtYXhTaXplOiBJbmZpbml0eVxufTtcblxuZnVuY3Rpb24gY2FjaGVGcm9tUG9saWN5KHtcbiAgZXF1YWxpdHkgPSBkZWZhdWx0UG9saWN5JDEuZXF1YWxpdHksXG4gIGV2aWN0aW9uID0gZGVmYXVsdFBvbGljeSQxLmV2aWN0aW9uLFxuICBtYXhTaXplID0gZGVmYXVsdFBvbGljeSQxLm1heFNpemVcbn0gPSBkZWZhdWx0UG9saWN5JDEpIHtcbiAgY29uc3QgdmFsdWVNYXBwZXIgPSBnZXRWYWx1ZU1hcHBlciQxKGVxdWFsaXR5KTtcbiAgY29uc3QgY2FjaGUgPSBnZXRDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgdmFsdWVNYXBwZXIpO1xuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlTWFwcGVyJDEoZXF1YWxpdHkpIHtcbiAgc3dpdGNoIChlcXVhbGl0eSkge1xuICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICByZXR1cm4gdmFsID0+IHZhbDtcblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeSh2YWwpO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGVxdWFsaXR5IHBvbGljeSAke2VxdWFsaXR5fWApO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgbWFwS2V5KSB7XG4gIHN3aXRjaCAoZXZpY3Rpb24pIHtcbiAgICBjYXNlICdrZWVwLWFsbCc6XG4gICAgICByZXR1cm4gbmV3IE1hcENhY2hlJDEoe1xuICAgICAgICBtYXBLZXlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbHJ1JzpcbiAgICAgIHJldHVybiBuZXcgTFJVQ2FjaGUkMih7XG4gICAgICAgIG1hcEtleSxcbiAgICAgICAgbWF4U2l6ZTogUmVjb2lsX251bGx0aHJvd3MobWF4U2l6ZSlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbW9zdC1yZWNlbnQnOlxuICAgICAgcmV0dXJuIG5ldyBMUlVDYWNoZSQyKHtcbiAgICAgICAgbWFwS2V5LFxuICAgICAgICBtYXhTaXplOiAxXG4gICAgICB9KTtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIoYFVucmVjb2duaXplZCBldmljdGlvbiBwb2xpY3kgJHtldmljdGlvbn1gKTtcbn1cblxudmFyIFJlY29pbF9jYWNoZUZyb21Qb2xpY3kgPSBjYWNoZUZyb21Qb2xpY3k7XG5cbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xuXG5cbmNvbnN0IHtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMlxufSA9IFJlY29pbF9Ob2RlO1xuXG5cblxuXG5cbi8vIFByb2Nlc3Mgc2NvcGVSdWxlcyB0byBoYW5kbGUgYW55IGVudHJpZXMgd2hpY2ggYXJlIGZ1bmN0aW9ucyB0YWtpbmcgcGFyYW1ldGVyc1xuLy8gcHJldHRpZXItaWdub3JlXG4vLyBAZmItb25seTogZnVuY3Rpb24gbWFwU2NvcGVSdWxlczxQPihcbi8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzPzogUGFyYW1ldGVyaXplZFNjb3BlUnVsZXM8UD4sXG4vLyBAZmItb25seTogcGFyYW06IFAsXG4vLyBAZmItb25seTogKTogU2NvcGVSdWxlcyB8IHZvaWQge1xuLy8gQGZiLW9ubHk6IHJldHVybiBzY29wZVJ1bGVzPy5tYXAocnVsZSA9PlxuLy8gQGZiLW9ubHk6IEFycmF5LmlzQXJyYXkocnVsZSlcbi8vIEBmYi1vbmx5OiA/IHJ1bGUubWFwKGVudHJ5ID0+ICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicgPyBlbnRyeShwYXJhbSkgOiBlbnRyeSkpXG4vLyBAZmItb25seTogOiBydWxlLFxuLy8gQGZiLW9ubHk6ICk7XG4vLyBAZmItb25seTogfVxuXG4vKlxuQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIGF0b20gYmFzZWQgb24gdGhlIGlucHV0IHBhcmFtZXRlci5cblxuRWFjaCB1bmlxdWUgcGFyYW1ldGVyIHJldHVybnMgYSB1bmlxdWUgYXRvbS4gRS5nLixcblxuICBjb25zdCBmID0gYXRvbUZhbWlseSguLi4pO1xuICBmKHthOiAxfSkgPT4gYW4gYXRvbVxuICBmKHthOiAyfSkgPT4gYSBkaWZmZXJlbnQgYXRvbVxuXG5UaGlzIGFsbG93cyBjb21wb25lbnRzIHRvIHBlcnNpc3QgbG9jYWwsIHByaXZhdGUgc3RhdGUgdXNpbmcgYXRvbXMuICBFYWNoXG5pbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IG1heSBoYXZlIGEgZGlmZmVyZW50IGtleSwgd2hpY2ggaXQgdXNlcyBhcyB0aGVcbnBhcmFtZXRlciBmb3IgYSBmYW1pbHkgb2YgYXRvbXM7IGluIHRoaXMgd2F5LCBlYWNoIGNvbXBvbmVudCB3aWxsIGhhdmVcbml0cyBvd24gYXRvbSBub3Qgc2hhcmVkIGJ5IG90aGVyIGluc3RhbmNlcy4gIFRoZXNlIHN0YXRlIGtleXMgbWF5IGJlIGNvbXBvc2VkXG5pbnRvIGNoaWxkcmVuJ3Mgc3RhdGUga2V5cyBhcyB3ZWxsLlxuKi9cbmZ1bmN0aW9uIGF0b21GYW1pbHkob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xuXG4gIGNvbnN0IGF0b21DYWNoZSA9IFJlY29pbF9jYWNoZUZyb21Qb2xpY3koe1xuICAgIGVxdWFsaXR5OiAoX29wdGlvbnMkY2FjaGVQb2xpY3lGID0gKF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPSBvcHRpb25zLmNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRjYWNoZVBvbGljeUYyLmVxdWFsaXR5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYWNoZVBvbGljeUYgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhY2hlUG9saWN5RiA6ICd2YWx1ZScsXG4gICAgZXZpY3Rpb246ICdrZWVwLWFsbCdcbiAgfSk7IC8vIFNpbXBsZSBhdG9tRmFtaWx5IGltcGxlbWVudGF0aW9uIHRvIGNhY2hlIGluZGl2aWR1YWwgYXRvbXMgYmFzZWRcbiAgLy8gb24gdGhlIHBhcmFtZXRlciB2YWx1ZSBlcXVhbGl0eS5cblxuICByZXR1cm4gcGFyYW1zID0+IHtcbiAgICB2YXIgX3N0YWJsZVN0cmluZ2lmeSwgX29wdGlvbnMkZWZmZWN0cztcblxuICAgIGNvbnN0IGNhY2hlZEF0b20gPSBhdG9tQ2FjaGUuZ2V0KHBhcmFtcyk7XG5cbiAgICBpZiAoY2FjaGVkQXRvbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQXRvbTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSxcbiAgICAgIC4uLmF0b21PcHRpb25zXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9uc0RlZmF1bHQgPSAnZGVmYXVsdCcgaW4gb3B0aW9ucyA/IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXR5cGVdIE5vIHdheSB0byByZWZpbmUgaW4gRmxvdyB0aGF0IHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkXG4gICAgb3B0aW9ucy5kZWZhdWx0IDogbmV3IFByb21pc2UoKCkgPT4ge30pO1xuICAgIGNvbnN0IG5ld0F0b20gPSBSZWNvaWxfYXRvbSh7IC4uLmF0b21PcHRpb25zLFxuICAgICAga2V5OiBgJHtvcHRpb25zLmtleX1fXyR7KF9zdGFibGVTdHJpbmdpZnkgPSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHBhcmFtcykpICE9PSBudWxsICYmIF9zdGFibGVTdHJpbmdpZnkgIT09IHZvaWQgMCA/IF9zdGFibGVTdHJpbmdpZnkgOiAndm9pZCd9YCxcbiAgICAgIGRlZmF1bHQ6IHR5cGVvZiBvcHRpb25zRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyA/IC8vIFRoZSBkZWZhdWx0IHdhcyBwYXJhbWV0ZXJpemVkXG4gICAgICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGF0IFQgaXNuJ3QgYSBmdW5jdGlvbiwgc28gd2UgbmVlZCB0byBjYXNlIHRvIGFueVxuICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdXNlXVxuICAgICAgb3B0aW9uc0RlZmF1bHQocGFyYW1zKSA6IC8vIERlZmF1bHQgbWF5IGJlIGEgc3RhdGljIHZhbHVlLCBwcm9taXNlLCBvciBSZWNvaWxWYWx1ZVxuICAgICAgb3B0aW9uc0RlZmF1bHQsXG4gICAgICByZXRhaW5lZEJ5X1VOU1RBQkxFOiB0eXBlb2Ygb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKHBhcmFtcykgOiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUsXG4gICAgICBlZmZlY3RzOiB0eXBlb2Ygb3B0aW9ucy5lZmZlY3RzID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5lZmZlY3RzKHBhcmFtcykgOiB0eXBlb2Ygb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFKHBhcmFtcykgOiAoX29wdGlvbnMkZWZmZWN0cyA9IG9wdGlvbnMuZWZmZWN0cykgIT09IG51bGwgJiYgX29wdGlvbnMkZWZmZWN0cyAhPT0gdm9pZCAwID8gX29wdGlvbnMkZWZmZWN0cyA6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1M6IG1hcFNjb3BlUnVsZXMoXG4gICAgICAvLyBAZmItb25seTogb3B0aW9ucy5zY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG4gICAgICAvLyBAZmItb25seTogcGFyYW1zLFxuICAgICAgLy8gQGZiLW9ubHk6ICksXG5cbiAgICB9KTtcbiAgICBhdG9tQ2FjaGUuc2V0KHBhcmFtcywgbmV3QXRvbSk7XG4gICAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIobmV3QXRvbS5rZXksICgpID0+IHtcbiAgICAgIGF0b21DYWNoZS5kZWxldGUocGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3QXRvbTtcbiAgfTtcbn1cblxudmFyIFJlY29pbF9hdG9tRmFtaWx5ID0gYXRvbUZhbWlseTtcblxuY29uc3Qge1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzXG59ID0gUmVjb2lsX05vZGU7XG5cblxuXG5cblxuIC8vIEtlZXAgaW4gbWluZCB0aGUgcGFyYW1ldGVyIG5lZWRzIHRvIGJlIHNlcmlhbGl6YWJsZSBhcyBhIGNhaGNoZSBrZXlcbi8vIHVzaW5nIFJlY29pbF9zdGFibGVTdHJpbmdpZnlcblxuXG4vLyBBZGQgYSB1bmlxdWUgaW5kZXggdG8gZWFjaCBzZWxlY3RvciBpbiBjYXNlIHRoZSBjYWNoZSBpbXBsZW1lbnRhdGlvbiBhbGxvd3Ncbi8vIGR1cGxpY2F0ZSBrZXlzIGJhc2VkIG9uIGVxdWl2YWxlbnQgc3RyaW5naWZpZWQgcGFyYW1ldGVyc1xubGV0IG5leHRJbmRleCA9IDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lbWJlcnMgb2YgYSBmYW1pbHkgb2Ygc2VsZWN0b3JzIG9mIHRoZSBzYW1lIHR5cGVcbi8vIEUuZy4sXG4vL1xuLy8gY29uc3QgcyA9IHNlbGVjdG9yRmFtaWx5KC4uLik7XG4vLyBzKHthOiAxfSkgPT4gYSBzZWxlY3RvclxuLy8gcyh7YTogMn0pID0+IGEgZGlmZmVyZW50IHNlbGVjdG9yXG4vL1xuLy8gQnkgZGVmYXVsdCwgdGhlIHNlbGVjdG9ycyBhcmUgZGlzdGluZ3Vpc2hlZCBieSBkaXN0aW5jdCB2YWx1ZXMgb2YgdGhlXG4vLyBwYXJhbWV0ZXIgYmFzZWQgb24gdmFsdWUgZXF1YWxpdHksIG5vdCByZWZlcmVuY2UgZXF1YWxpdHkuICBUaGlzIGFsbG93cyB1c2luZ1xuLy8gb2JqZWN0IGxpdGVyYWxzIG9yIG90aGVyIGVxdWl2YWxlbnQgb2JqZWN0cyBhdCBjYWxsc2l0ZXMgdG8gbm90IGNyZWF0ZVxuLy8gZHVwbGljYXRlIGNhY2hlIGVudHJpZXMuICBUaGlzIGJlaGF2aW9yIG1heSBiZSBvdmVycmlkZGVuIHdpdGggdGhlXG4vLyBjYWNoZUltcGxlbWVudGF0aW9uRm9yUGFyYW1zIG9wdGlvbi5cbmZ1bmN0aW9uIHNlbGVjdG9yRmFtaWx5KG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGNhY2hlUG9saWN5RiwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMjtcblxuICBjb25zdCBzZWxlY3RvckNhY2hlID0gUmVjb2lsX2NhY2hlRnJvbVBvbGljeSh7XG4gICAgZXF1YWxpdHk6IChfb3B0aW9ucyRjYWNoZVBvbGljeUYgPSAoX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9IG9wdGlvbnMuY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUpID09PSBudWxsIHx8IF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGNhY2hlUG9saWN5RjIuZXF1YWxpdHkpICE9PSBudWxsICYmIF9vcHRpb25zJGNhY2hlUG9saWN5RiAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FjaGVQb2xpY3lGIDogJ3ZhbHVlJyxcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xuICB9KTtcbiAgcmV0dXJuIHBhcmFtcyA9PiB7XG4gICAgdmFyIF9zdGFibGVTdHJpbmdpZnk7XG5cbiAgICAvLyBUaHJvdyBhbiBlcnJvciB3aXRoIHNlbGVjdG9yIGtleSBzbyB0aGF0IGl0IGlzIGNsZWFyIHdoaWNoXG4gICAgLy8gc2VsZWN0b3IgaXMgY2F1c2luZyBhbiBlcnJvclxuICAgIGxldCBjYWNoZWRTZWxlY3RvcjtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZWRTZWxlY3RvciA9IHNlbGVjdG9yQ2FjaGUuZ2V0KHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoYFByb2JsZW0gd2l0aCBjYWNoZSBsb29rdXAgZm9yIHNlbGVjdG9yICR7b3B0aW9ucy5rZXl9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlZFNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRTZWxlY3RvcjtcbiAgICB9XG5cbiAgICBjb25zdCBteUtleSA9IGAke29wdGlvbnMua2V5fV9fc2VsZWN0b3JGYW1pbHkvJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zLCB7XG4gICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byB1c2UgZnVuY3Rpb25zIGluIHBhcmFtZXRlcnMgaWYgdGhlIHVzZXIgdXNlc1xuICAgICAgLy8gYSBjYWNoZSB3aXRoIHJlZmVyZW5jZSBlcXVhbGl0eSB0aGFua3MgdG8gdGhlIGluY3JlbWVudGluZyBpbmRleC5cbiAgICAgIGFsbG93RnVuY3Rpb25zOiB0cnVlXG4gICAgfSkpICE9PSBudWxsICYmIF9zdGFibGVTdHJpbmdpZnkgIT09IHZvaWQgMCA/IF9zdGFibGVTdHJpbmdpZnkgOiAndm9pZCd9LyR7bmV4dEluZGV4Kyt9YDsgLy8gQXBwZW5kIGluZGV4IGluIGNhc2UgdmFsdWVzIHNlcmlhbGl6ZSB0byB0aGUgc2FtZSBrZXkgc3RyaW5nXG5cbiAgICBjb25zdCBteUdldCA9IGNhbGxiYWNrcyA9PiBvcHRpb25zLmdldChwYXJhbXMpKGNhbGxiYWNrcyk7XG5cbiAgICBjb25zdCBteUNhY2hlUG9saWN5ID0gb3B0aW9ucy5jYWNoZVBvbGljeV9VTlNUQUJMRTtcbiAgICBjb25zdCByZXRhaW5lZEJ5ID0gdHlwZW9mIG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRShwYXJhbXMpIDogb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFO1xuICAgIGxldCBuZXdTZWxlY3RvcjtcblxuICAgIGlmIChvcHRpb25zLnNldCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzZXQgPSBvcHRpb25zLnNldDtcblxuICAgICAgY29uc3QgbXlTZXQgPSAoY2FsbGJhY2tzLCBuZXdWYWx1ZSkgPT4gc2V0KHBhcmFtcykoY2FsbGJhY2tzLCBuZXdWYWx1ZSk7XG5cbiAgICAgIG5ld1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yKHtcbiAgICAgICAga2V5OiBteUtleSxcbiAgICAgICAgZ2V0OiBteUdldCxcbiAgICAgICAgc2V0OiBteVNldCxcbiAgICAgICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IG15Q2FjaGVQb2xpY3ksXG4gICAgICAgIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiBvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5LFxuICAgICAgICByZXRhaW5lZEJ5X1VOU1RBQkxFOiByZXRhaW5lZEJ5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3Ioe1xuICAgICAgICBrZXk6IG15S2V5LFxuICAgICAgICBnZXQ6IG15R2V0LFxuICAgICAgICBjYWNoZVBvbGljeV9VTlNUQUJMRTogbXlDYWNoZVBvbGljeSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHJldGFpbmVkQnlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdG9yQ2FjaGUuc2V0KHBhcmFtcywgbmV3U2VsZWN0b3IpO1xuICAgIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQzKG5ld1NlbGVjdG9yLmtleSwgKCkgPT4ge1xuICAgICAgc2VsZWN0b3JDYWNoZS5kZWxldGUocGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3U2VsZWN0b3I7XG4gIH07XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5cbnZhciBSZWNvaWxfc2VsZWN0b3JGYW1pbHkgPSBzZWxlY3RvckZhbWlseTtcblxuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5jb25zdCBjb25zdGFudFNlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX19jb25zdGFudCcsXG4gIGdldDogY29uc3RhbnQgPT4gKCkgPT4gY29uc3RhbnQsXG4gIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFOiB7XG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnXG4gIH1cbn0pOyAvLyBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZWxlY3RvciB3aGljaCBhbHdheXMgcHJvZHVjZXMgdGhlXG4vLyBzYW1lIGNvbnN0YW50IHZhbHVlLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZVxuLy8gc2FtZSB2YWx1ZSwgYmFzZWQgb24gcmVmZXJlbmNlIGVxdWFsaXR5LCBhbmQgd2lsbCBwcm92aWRlIHRoZVxuLy8gc2FtZSBzZWxlY3Rvci5cblxuZnVuY3Rpb24gY29uc3RTZWxlY3Rvcihjb25zdGFudCkge1xuICByZXR1cm4gY29uc3RhbnRTZWxlY3Rvcihjb25zdGFudCk7XG59XG5cbnZhciBSZWNvaWxfY29uc3RTZWxlY3RvciA9IGNvbnN0U2VsZWN0b3I7XG5cbi8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuY29uc3QgdGhyb3dpbmdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fZXJyb3InLFxuICBnZXQ6IG1lc3NhZ2UgPT4gKCkgPT4ge1xuICAgIHRocm93IFJlY29pbF9lcnIobWVzc2FnZSk7XG4gIH0sXG4gIC8vIFRPRE8gV2h5P1xuICBjYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRToge1xuICAgIGVxdWFsaXR5OiAncmVmZXJlbmNlJ1xuICB9XG59KTsgLy8gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2VsZWN0b3Igd2hpY2ggYWx3YXlzIHRocm93cyBhbiBlcnJvclxuLy8gd2l0aCB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cblxuZnVuY3Rpb24gZXJyb3JTZWxlY3RvcihtZXNzYWdlKSB7XG4gIHJldHVybiB0aHJvd2luZ1NlbGVjdG9yKG1lc3NhZ2UpO1xufVxuXG52YXIgUmVjb2lsX2Vycm9yU2VsZWN0b3IgPSBlcnJvclNlbGVjdG9yO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFdyYXBzIGFub3RoZXIgcmVjb2lsIHZhbHVlIGFuZCBwcmV2ZW50cyB3cml0aW5nIHRvIGl0LlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiByZWFkT25seVNlbGVjdG9yKGF0b20pIHtcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gIHJldHVybiBhdG9tO1xufVxuXG52YXIgUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IgPSByZWFkT25seVNlbGVjdG9yO1xuXG5jb25zdCB7XG4gIGxvYWRhYmxlV2l0aEVycm9yOiBsb2FkYWJsZVdpdGhFcnJvciQzLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDMsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQ0XG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cblxuXG5cblxuIC8vLy8vLy8vLy8vLy8vLy8vXG4vLyAgVFJVVEggVEFCTEVcbi8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEZXBlbmRlbmNpZXMgICAgICAgIHdhaXRGb3JOb25lICAgICAgICAgd2FpdEZvckFueSAgICAgICAgd2FpdEZvckFsbCAgICAgICB3YWl0Rm9yQWxsU2V0dGxlZFxuLy8gIFtsb2FkaW5nLCBsb2FkaW5nXSAgW1Byb21pc2UsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxuLy8gIFt2YWx1ZSwgbG9hZGluZ10gICAgW3ZhbHVlLCBQcm9taXNlXSAgICBbdmFsdWUsIFByb21pc2VdICBQcm9taXNlICAgICAgICAgUHJvbWlzZVxuLy8gIFt2YWx1ZSwgdmFsdWVdICAgICAgW3ZhbHVlLCB2YWx1ZV0gICAgICBbdmFsdWUsIHZhbHVlXSAgICBbdmFsdWUsIHZhbHVlXSAgW3ZhbHVlLCB2YWx1ZV1cbi8vXG4vLyAgW2Vycm9yLCBsb2FkaW5nXSAgICBbRXJyb3IsIFByb21pc2VdICAgIFtFcnJvciwgUHJvbWlzZV0gIEVycm9yICAgICAgICAgICBQcm9taXNlXG4vLyAgW2Vycm9yLCBlcnJvcl0gICAgICBbRXJyb3IsIEVycm9yXSAgICAgIFtFcnJvciwgRXJyb3JdICAgIEVycm9yICAgICAgICAgICBbZXJyb3IsIGVycm9yXVxuLy8gIFt2YWx1ZSwgZXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgICBbdmFsdWUsIEVycm9yXSAgICBFcnJvciAgICAgICAgICAgW3ZhbHVlLCBlcnJvcl1cbi8vIElzc3VlIHBhcmFsbGVsIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm4gdGhlIGN1cnJlbnRcbi8vIHN0YXR1cyBpZiB0aGV5IGhhdmUgcmVzdWx0cywgaGF2ZSBzb21lIGVycm9yLCBvciBhcmUgc3RpbGwgcGVuZGluZy5cblxuXG5mdW5jdGlvbiBjb25jdXJyZW50UmVxdWVzdHMoZ2V0UmVjb2lsVmFsdWUsIGRlcHMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IEFycmF5KGRlcHMubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG4gIGNvbnN0IGV4Y2VwdGlvbnMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuXG4gIGZvciAoY29uc3QgW2ksIGRlcF0gb2YgZGVwcy5lbnRyaWVzKCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0c1tpXSA9IGdldFJlY29pbFZhbHVlKGRlcCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHRzLCBleGNlcHRpb25zXTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihleHApIHtcbiAgcmV0dXJuIGV4cCAhPSBudWxsICYmICFSZWNvaWxfaXNQcm9taXNlKGV4cCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IGRlcGVuZGVuY2llcyA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlcGVuZGVuY2llcykubWFwKGtleSA9PiBkZXBlbmRlbmNpZXNba2V5XSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcyxcbi8qICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF0gVGhlIHR5cGUgYW5ub3RhdGlvbihzKSByZXF1aXJlZCBieSBGbG93J3NcbiAqIExUSSB1cGRhdGUgY291bGQgbm90IGJlIGFkZGVkIHZpYSBjb2RlbW9kICovXG5yZXN1bHRzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyByZXN1bHRzIDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVwZW5kZW5jaWVzKS5yZWR1Y2UoKG91dCwga2V5LCBpZHgpID0+ICh7IC4uLm91dCxcbiAgICBba2V5XTogcmVzdWx0c1tpZHhdXG4gIH0pLCB7fSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSB7XG4gIGNvbnN0IG91dHB1dCA9IGV4Y2VwdGlvbnMubWFwKChleGNlcHRpb24sIGlkeCkgPT4gZXhjZXB0aW9uID09IG51bGwgPyBsb2FkYWJsZVdpdGhWYWx1ZSQ0KHJlc3VsdHNbaWR4XSkgOiBSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XG4gIHJldHVybiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMoc3luY1Jlc3VsdHMsIGFzeW5jUmVzdWx0cykge1xuICByZXR1cm4gYXN5bmNSZXN1bHRzLm1hcCgocmVzdWx0LCBpZHgpID0+XG4gIC8qKlxuICAgKiBpdCdzIGltcG9ydGFudCB3ZSB1c2UgPT09IHVuZGVmaW5lZCBhcyBvcHBvc2VkIHRvID09IG51bGwsIGJlY2F1c2UgdGhlXG4gICAqIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBhc3luYyBwcm9taXNlIGNvdWxkIGJlIGBudWxsYCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgKiBkb24ndCB3YW50IHRvIHVzZSBzeW5jUmVzdWx0c1tpZHhdLCB3aGljaCB3b3VsZCBiZSB1bmRlZmluZWQuIElmIGFzeW5jXG4gICAqIHByb21pc2UgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAsIHRoYXQncyBvayBiZWNhdXNlIGBzeW5jUmVzdWx0c1tpZHhdYFxuICAgKiB3aWxsIGFsc28gYmUgYHVuZGVmaW5lZGAuIFRoYXQncyBhIGxpdHRsZSBoYWNreSwgYnV0IGl0IHdvcmtzLlxuICAgKi9cbiAgcmVzdWx0ID09PSB1bmRlZmluZWQgPyBzeW5jUmVzdWx0c1tpZHhdIDogcmVzdWx0KTtcbn0gLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCBpbW1lZGlhdGVseSByZXR1cm5zXG4vLyBjdXJyZW50IHJlc3VsdHMgd2l0aG91dCB3YWl0aW5nLlxuXG5cbmNvbnN0IHdhaXRGb3JOb25lID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yTm9uZScsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIEFsd2F5cyByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSByZXN1bHRzOyBuZXZlciBibG9jay5cblxuICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYXQgbGVhc3Rcbi8vIG9uZSB0byBiZSBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLiAgSXQgd2lsbCBvbmx5IGVycm9yIGlmIGFsbFxuLy8gZGVwZW5kZW5jaWVzIGhhdmUgZXJyb3JzLlxuXG5jb25zdCB3YWl0Rm9yQW55ID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQW55JyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFueSByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHZhbHVlIG9yIGVycm9yLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5zb21lKGV4cCA9PiAhUmVjb2lsX2lzUHJvbWlzZShleHApKSkge1xuICAgICAgcmV0dXJuIHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBuZXh0IHJlc3VsdCBpc1xuICAgIC8vIGF2YWlsYWJsZSwgd2hpY2hldmVyIG9uZSBoYXBwZW5zIHRvIGJlIG5leHQuICBCdXQsIGlmIGFsbCBwZW5kaW5nXG4gICAgLy8gZGVwZW5kZW5jaWVzIGVuZCB1cCB3aXRoIGVycm9ycywgdGhlbiByZWplY3QgdGhlIHByb21pc2UuXG5cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2ksIGV4cF0gb2YgZXhjZXB0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZXhwKSkge1xuICAgICAgICAgIGV4cC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpKTtcbiAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBleGNlcHRpb25zW2ldID0gZXJyb3I7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pOyAvLyBTZWxlY3RvciB0aGF0IHJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwgYW5kIHdhaXRzIGZvciBhbGwgdG8gYmVcbi8vIGF2YWlsYWJsZSBiZWZvcmUgcmV0dXJuaW5nIGEgdmFsdWUuICBJdCB3aWxsIGVycm9yIGlmIGFueSBkZXBlbmRlbmNpZXMgZXJyb3IuXG5cbmNvbnN0IHdhaXRGb3JBbGwgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbGwnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5ldmVyeShleHAgPT4gZXhwID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCByZXN1bHRzKTtcbiAgICB9IC8vIElmIHdlIGhhdmUgYW55IGVycm9ycywgdGhyb3cgdGhlIGZpcnN0IGVycm9yXG5cblxuICAgIGNvbnN0IGVycm9yID0gZXhjZXB0aW9ucy5maW5kKGlzRXJyb3IpO1xuXG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZVxuXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZXhjZXB0aW9ucykudGhlbihleGNlcHRpb25SZXN1bHRzID0+IHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgY29tYmluZUFzeW5jUmVzdWx0c1dpdGhTeW5jUmVzdWx0cyhyZXN1bHRzLCBleGNlcHRpb25SZXN1bHRzKSkpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG5jb25zdCB3YWl0Rm9yQWxsU2V0dGxlZCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFsbFNldHRsZWQnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgLy8gRXhjZXB0aW9ucyBjYW4gZWl0aGVyIGJlIFByb21pc2VzIG9mIHBlbmRpbmcgcmVzdWx0cyBvciByZWFsIGVycm9yc1xuICAgIGNvbnN0IGRlcHMgPSB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBbcmVzdWx0cywgZXhjZXB0aW9uc10gPSBjb25jdXJyZW50UmVxdWVzdHMoZ2V0LCBkZXBzKTsgLy8gSWYgYWxsIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSwgcmV0dXJuIHRoZSByZXN1bHRzXG5cbiAgICBpZiAoZXhjZXB0aW9ucy5ldmVyeShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcbiAgICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gICAgfSAvLyBXYWl0IGZvciBhbGwgcmVzdWx0cyB0byBzZXR0bGVcblxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMubWFwKChleHAsIGkpID0+IFJlY29pbF9pc1Byb21pc2UoZXhwKSA/IGV4cC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICByZXN1bHRzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xuICAgIH0pIDogbnVsbCkpIC8vIFRoZW4gd3JhcCB0aGVtIGFzIGxvYWRhYmxlc1xuICAgIC50aGVuKCgpID0+IHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTtcbmNvbnN0IG5vV2FpdCA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fbm9XYWl0JyxcbiAgZ2V0OiBkZXBlbmRlbmN5ID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFJlY29pbF9zZWxlY3Rvci52YWx1ZShsb2FkYWJsZVdpdGhWYWx1ZSQ0KGdldChkZXBlbmRlbmN5KSkpO1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIFJlY29pbF9zZWxlY3Rvci52YWx1ZShSZWNvaWxfaXNQcm9taXNlKGV4Y2VwdGlvbikgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDMoZXhjZXB0aW9uKSA6IGxvYWRhYmxlV2l0aEVycm9yJDMoZXhjZXB0aW9uKSk7XG4gICAgfVxuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG52YXIgUmVjb2lsX1dhaXRGb3IgPSB7XG4gIHdhaXRGb3JOb25lLFxuICB3YWl0Rm9yQW55LFxuICB3YWl0Rm9yQWxsLFxuICB3YWl0Rm9yQWxsU2V0dGxlZCxcbiAgbm9XYWl0XG59O1xuXG5jb25zdCB7XG4gIFJlY29pbExvYWRhYmxlXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkM1xufSA9IFJlY29pbF9Ob2RlO1xuXG5cblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxXG59ID0gUmVjb2lsX0hvb2tzO1xuXG5jb25zdCB7XG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuXG5cblxuXG5jb25zdCB7XG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxXG59ID0gUmVjb2lsX1dhaXRGb3I7XG5cbnZhciBSZWNvaWxfaW5kZXggPSB7XG4gIC8vIFR5cGVzXG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDMsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNSxcbiAgUmVjb2lsTG9hZGFibGUsXG4gIC8vIEdsb2JhbCBSZWNvaWwgZW52aXJvbm1lbnQgc2V0dGlvbmdzXG4gIFJlY29pbEVudjogUmVjb2lsX1JlY29pbEVudixcbiAgLy8gUmVjb2lsIFJvb3RcbiAgUmVjb2lsUm9vdDogUmVjb2lsUm9vdCQyLFxuICB1c2VSZWNvaWxTdG9yZUlEOiB1c2VSZWNvaWxTdG9yZUlEJDEsXG4gIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHNfVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzLFxuICAvLyBBdG9tcy9TZWxlY3RvcnNcbiAgYXRvbTogUmVjb2lsX2F0b20sXG4gIHNlbGVjdG9yOiBSZWNvaWxfc2VsZWN0b3IsXG4gIC8vIENvbnZlbmllbmNlIEF0b21zL1NlbGVjdG9yc1xuICBhdG9tRmFtaWx5OiBSZWNvaWxfYXRvbUZhbWlseSxcbiAgc2VsZWN0b3JGYW1pbHk6IFJlY29pbF9zZWxlY3RvckZhbWlseSxcbiAgY29uc3RTZWxlY3RvcjogUmVjb2lsX2NvbnN0U2VsZWN0b3IsXG4gIGVycm9yU2VsZWN0b3I6IFJlY29pbF9lcnJvclNlbGVjdG9yLFxuICByZWFkT25seVNlbGVjdG9yOiBSZWNvaWxfcmVhZE9ubHlTZWxlY3RvcixcbiAgLy8gQ29uY3VycmVuY3kgSGVscGVycyBmb3IgQXRvbXMvU2VsZWN0b3JzXG4gIG5vV2FpdDogbm9XYWl0JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JBbGw6IHdhaXRGb3JBbGwkMSxcbiAgd2FpdEZvckFsbFNldHRsZWQ6IHdhaXRGb3JBbGxTZXR0bGVkJDEsXG4gIC8vIEhvb2tzIGZvciBBdG9tcy9TZWxlY3RvcnNcbiAgdXNlUmVjb2lsVmFsdWU6IHVzZVJlY29pbFZhbHVlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUkMSxcbiAgdXNlUmVjb2lsU3RhdGU6IHVzZVJlY29pbFN0YXRlJDEsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGU6IHVzZVJlY29pbFN0YXRlTG9hZGFibGUkMSxcbiAgdXNlU2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVJlc2V0UmVjb2lsU3RhdGU6IHVzZVJlc2V0UmVjb2lsU3RhdGUkMSxcbiAgdXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFOiBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvLFxuICB1c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxSZWZyZXNoZXIsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICAvLyBIb29rcyBmb3IgY29tcGxleCBvcGVyYXRpb25zXG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRTogUmVjb2lsX3VzZVJlY29pbFRyYW5zYWN0aW9uLFxuICAvLyBTbmFwc2hvdHNcbiAgdXNlR290b1JlY29pbFNuYXBzaG90OiB1c2VHb3RvUmVjb2lsU25hcHNob3QkMSxcbiAgdXNlUmVjb2lsU25hcHNob3Q6IHVzZVJlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEU6IHVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXIkMSxcbiAgc25hcHNob3RfVU5TVEFCTEU6IGZyZXNoU25hcHNob3QkMixcbiAgLy8gTWVtb3J5IE1hbmFnZW1lbnRcbiAgdXNlUmV0YWluOiBSZWNvaWxfdXNlUmV0YWluLFxuICByZXRlbnRpb25ab25lOiByZXRlbnRpb25ab25lJDFcbn07XG52YXIgUmVjb2lsX2luZGV4XzEgPSBSZWNvaWxfaW5kZXguRGVmYXVsdFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8yID0gUmVjb2lsX2luZGV4LmlzUmVjb2lsVmFsdWU7XG52YXIgUmVjb2lsX2luZGV4XzMgPSBSZWNvaWxfaW5kZXguUmVjb2lsTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzQgPSBSZWNvaWxfaW5kZXguUmVjb2lsRW52O1xudmFyIFJlY29pbF9pbmRleF81ID0gUmVjb2lsX2luZGV4LlJlY29pbFJvb3Q7XG52YXIgUmVjb2lsX2luZGV4XzYgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RvcmVJRDtcbnZhciBSZWNvaWxfaW5kZXhfNyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF84ID0gUmVjb2lsX2luZGV4LmF0b207XG52YXIgUmVjb2lsX2luZGV4XzkgPSBSZWNvaWxfaW5kZXguc2VsZWN0b3I7XG52YXIgUmVjb2lsX2luZGV4XzEwID0gUmVjb2lsX2luZGV4LmF0b21GYW1pbHk7XG52YXIgUmVjb2lsX2luZGV4XzExID0gUmVjb2lsX2luZGV4LnNlbGVjdG9yRmFtaWx5O1xudmFyIFJlY29pbF9pbmRleF8xMiA9IFJlY29pbF9pbmRleC5jb25zdFNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xMyA9IFJlY29pbF9pbmRleC5lcnJvclNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xNCA9IFJlY29pbF9pbmRleC5yZWFkT25seVNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xNSA9IFJlY29pbF9pbmRleC5ub1dhaXQ7XG52YXIgUmVjb2lsX2luZGV4XzE2ID0gUmVjb2lsX2luZGV4LndhaXRGb3JOb25lO1xudmFyIFJlY29pbF9pbmRleF8xNyA9IFJlY29pbF9pbmRleC53YWl0Rm9yQW55O1xudmFyIFJlY29pbF9pbmRleF8xOCA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsO1xudmFyIFJlY29pbF9pbmRleF8xOSA9IFJlY29pbF9pbmRleC53YWl0Rm9yQWxsU2V0dGxlZDtcbnZhciBSZWNvaWxfaW5kZXhfMjAgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWU7XG52YXIgUmVjb2lsX2luZGV4XzIxID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGU7XG52YXIgUmVjb2lsX2luZGV4XzIyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlO1xudmFyIFJlY29pbF9pbmRleF8yMyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTdGF0ZUxvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF8yNCA9IFJlY29pbF9pbmRleC51c2VTZXRSZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjUgPSBSZWNvaWxfaW5kZXgudXNlUmVzZXRSZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjYgPSBSZWNvaWxfaW5kZXgudXNlR2V0UmVjb2lsVmFsdWVJbmZvX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8yNyA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzI4ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8yOSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMwID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzEgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsQ2FsbGJhY2s7XG52YXIgUmVjb2lsX2luZGV4XzMyID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMyA9IFJlY29pbF9pbmRleC51c2VHb3RvUmVjb2lsU25hcHNob3Q7XG52YXIgUmVjb2lsX2luZGV4XzM0ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFNuYXBzaG90O1xudmFyIFJlY29pbF9pbmRleF8zNSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zNiA9IFJlY29pbF9pbmRleC5zbmFwc2hvdF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzcgPSBSZWNvaWxfaW5kZXgudXNlUmV0YWluO1xudmFyIFJlY29pbF9pbmRleF8zOCA9IFJlY29pbF9pbmRleC5yZXRlbnRpb25ab25lO1xuXG5leHBvcnRzLkRlZmF1bHRWYWx1ZSA9IFJlY29pbF9pbmRleF8xO1xuZXhwb3J0cy5SZWNvaWxFbnYgPSBSZWNvaWxfaW5kZXhfNDtcbmV4cG9ydHMuUmVjb2lsTG9hZGFibGUgPSBSZWNvaWxfaW5kZXhfMztcbmV4cG9ydHMuUmVjb2lsUm9vdCA9IFJlY29pbF9pbmRleF81O1xuZXhwb3J0cy5hdG9tID0gUmVjb2lsX2luZGV4Xzg7XG5leHBvcnRzLmF0b21GYW1pbHkgPSBSZWNvaWxfaW5kZXhfMTA7XG5leHBvcnRzLmNvbnN0U2VsZWN0b3IgPSBSZWNvaWxfaW5kZXhfMTI7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWNvaWxfaW5kZXg7XG5leHBvcnRzLmVycm9yU2VsZWN0b3IgPSBSZWNvaWxfaW5kZXhfMTM7XG5leHBvcnRzLmlzUmVjb2lsVmFsdWUgPSBSZWNvaWxfaW5kZXhfMjtcbmV4cG9ydHMubm9XYWl0ID0gUmVjb2lsX2luZGV4XzE1O1xuZXhwb3J0cy5yZWFkT25seVNlbGVjdG9yID0gUmVjb2lsX2luZGV4XzE0O1xuZXhwb3J0cy5yZXRlbnRpb25ab25lID0gUmVjb2lsX2luZGV4XzM4O1xuZXhwb3J0cy5zZWxlY3RvciA9IFJlY29pbF9pbmRleF85O1xuZXhwb3J0cy5zZWxlY3RvckZhbWlseSA9IFJlY29pbF9pbmRleF8xMTtcbmV4cG9ydHMuc25hcHNob3RfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMzY7XG5leHBvcnRzLnVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8yNjtcbmV4cG9ydHMudXNlR290b1JlY29pbFNuYXBzaG90ID0gUmVjb2lsX2luZGV4XzMzO1xuZXhwb3J0cy51c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFID0gUmVjb2lsX2luZGV4Xzc7XG5leHBvcnRzLnVzZVJlY29pbENhbGxiYWNrID0gUmVjb2lsX2luZGV4XzMxO1xuZXhwb3J0cy51c2VSZWNvaWxSZWZyZXNoZXJfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMjc7XG5leHBvcnRzLnVzZVJlY29pbFNuYXBzaG90ID0gUmVjb2lsX2luZGV4XzM0O1xuZXhwb3J0cy51c2VSZWNvaWxTdGF0ZSA9IFJlY29pbF9pbmRleF8yMjtcbmV4cG9ydHMudXNlUmVjb2lsU3RhdGVMb2FkYWJsZSA9IFJlY29pbF9pbmRleF8yMztcbmV4cG9ydHMudXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFID0gUmVjb2lsX2luZGV4XzMwO1xuZXhwb3J0cy51c2VSZWNvaWxTdG9yZUlEID0gUmVjb2lsX2luZGV4XzY7XG5leHBvcnRzLnVzZVJlY29pbFRyYW5zYWN0aW9uT2JzZXJ2ZXJfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMzU7XG5leHBvcnRzLnVzZVJlY29pbFRyYW5zYWN0aW9uX1VOU1RBQkxFID0gUmVjb2lsX2luZGV4XzMyO1xuZXhwb3J0cy51c2VSZWNvaWxWYWx1ZSA9IFJlY29pbF9pbmRleF8yMDtcbmV4cG9ydHMudXNlUmVjb2lsVmFsdWVMb2FkYWJsZSA9IFJlY29pbF9pbmRleF8yMTtcbmV4cG9ydHMudXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUgPSBSZWNvaWxfaW5kZXhfMjg7XG5leHBvcnRzLnVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSA9IFJlY29pbF9pbmRleF8yOTtcbmV4cG9ydHMudXNlUmVzZXRSZWNvaWxTdGF0ZSA9IFJlY29pbF9pbmRleF8yNTtcbmV4cG9ydHMudXNlUmV0YWluID0gUmVjb2lsX2luZGV4XzM3O1xuZXhwb3J0cy51c2VTZXRSZWNvaWxTdGF0ZSA9IFJlY29pbF9pbmRleF8yNDtcbmV4cG9ydHMud2FpdEZvckFsbCA9IFJlY29pbF9pbmRleF8xODtcbmV4cG9ydHMud2FpdEZvckFsbFNldHRsZWQgPSBSZWNvaWxfaW5kZXhfMTk7XG5leHBvcnRzLndhaXRGb3JBbnkgPSBSZWNvaWxfaW5kZXhfMTc7XG5leHBvcnRzLndhaXRGb3JOb25lID0gUmVjb2lsX2luZGV4XzE2O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/recoil/cjs/index.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(sc_server)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fpage&appPaths=%2Fpage&pagePath=private-next-app-dir%2Fpage.jsx&appDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fanamdiazs%2FDocuments%2FGitHub%2Fcatstagram&isDev=true&tsconfigPath=tsconfig.json&assetPrefix=!"));
module.exports = __webpack_exports__;

})();